(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/@wonderlandengine/components/8thwall-camera.js
  var require_thwall_camera = __commonJS({
    "node_modules/@wonderlandengine/components/8thwall-camera.js"() {
      WL.registerComponent("8thwall-camera", {
        /** Choose front/back camera */
        camera: { type: WL.Type.Enum, values: ["auto", "back", "front"], default: "auto" }
      }, {
        name: "wonderland-engine",
        init: function() {
          this.position = [0, 0, 0, 0];
          this.rotation = [0, 0, 0, 0];
          this.started = false;
          const vals = ["auto", "back", "front"];
          this.camera = vals[this.camera];
          if (this.camera == "auto") {
            this.camera = "back";
          }
          this.onStart = this.onStart.bind(this);
          this.onUpdate = this.onUpdate.bind(this);
          XR8.addCameraPipelineModules([
            /* Draw the camera feed */
            XR8.GlTextureRenderer.pipelineModule(),
            XR8.XrController.pipelineModule(),
            this
          ]);
          if (this.camera == "back") {
            XR8.run({ canvas: Module["canvas"], ownRunLoop: false });
          } else if (this.camera == "back") {
            XR8.XrController.configure({ disableWorldTracking: true });
            XR8.run({ canvas: Module["canvas"], ownRunLoop: false, cameraConfig: {
              direction: XR8.XrConfig.camera().FRONT
            } });
          } else {
            console.error("[8thwall-camera] Invalid camera setting:", this.camera);
          }
        },
        update: function() {
          if (this.started) {
            if (WL.scene.onPostRender.length == 0) {
              WL.scene.onPreRender.push(function() {
                XR8.runPreRender(Date.now());
                _wl_reset_context();
              });
              WL.scene.onPostRender.push(function() {
                XR8.runPostRender(Date.now());
              });
            }
            if (this.rotation[0] == 0 && this.rotation[1] == 0 && this.rotation[2] == 0 && this.rotation[3] == 0) {
              return;
            }
            this.object.resetTransform();
            this.object.rotate(this.rotation);
            this.object.translate(this.position);
          }
        },
        /* XR8 CameraPipelineModule functions
         * See: https://www.8thwall.com/docs/web/#camerapipelinemodule */
        onUpdate: function(data) {
          if (!data.processCpuResult.reality)
            return;
          let r = data.processCpuResult.reality.rotation;
          this.rotation[0] = r.x;
          this.rotation[1] = r.y;
          this.rotation[2] = r.z;
          this.rotation[3] = r.w;
          let p = data.processCpuResult.reality.position;
          this.position[0] = p.x;
          this.position[1] = p.y;
          this.position[2] = p.z;
        },
        onStart: function() {
          this.started = true;
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/cursor-target.js
  var require_cursor_target = __commonJS({
    "node_modules/@wonderlandengine/components/cursor-target.js"() {
      WL.registerComponent("cursor-target", {}, {
        init: function() {
          this.hoverFunctions = [];
          this.unHoverFunctions = [];
          this.clickFunctions = [];
          this.moveFunctions = [];
          this.downFunctions = [];
          this.upFunctions = [];
        },
        onHover: function(object, cursor) {
          for (let f of this.hoverFunctions)
            f(object, cursor);
        },
        onUnhover: function(object, cursor) {
          for (let f of this.unHoverFunctions)
            f(object, cursor);
        },
        onClick: function(object, cursor) {
          for (let f of this.clickFunctions)
            f(object, cursor);
        },
        onMove: function(object, cursor) {
          for (let f of this.moveFunctions)
            f(object, cursor);
        },
        onDown: function(object, cursor) {
          for (let f of this.downFunctions)
            f(object, cursor);
        },
        onUp: function(object, cursor) {
          for (let f of this.upFunctions)
            f(object, cursor);
        },
        addHoverFunction: function(f) {
          this._validateCallback(f);
          this.hoverFunctions.push(f);
        },
        removeHoverFunction: function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.hoverFunctions, f);
        },
        addUnHoverFunction: function(f) {
          this._validateCallback(f);
          this.unHoverFunctions.push(f);
        },
        removeUnHoverFunction: function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.unHoverFunctions, f);
        },
        addClickFunction: function(f) {
          this._validateCallback(f);
          this.clickFunctions.push(f);
        },
        removeClickFunction: function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.clickFunctions, f);
        },
        addMoveFunction: function(f) {
          this._validateCallback(f);
          this.moveFunctions.push(f);
        },
        removeMoveFunction: function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.moveFunctions, f);
        },
        addDownFunction: function(f) {
          this._validateCallback(f);
          this.downFunctions.push(f);
        },
        removeDownFunction: function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.downFunctions, f);
        },
        addUpFunction: function(f) {
          this._validateCallback(f);
          this.upFunctions.push(f);
        },
        removeUpFunction: function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.upFunctions, f);
        },
        _removeItemOnce: function(arr, value) {
          var index = arr.indexOf(value);
          if (index > -1)
            arr.splice(index, 1);
          return arr;
        },
        _validateCallback: function(f) {
          if (typeof f !== "function") {
            throw new TypeError(this.object.name + ".cursor-target: Argument needs to be a function");
          }
        }
      });
    }
  });

  // node_modules/gl-matrix/esm/common.js
  var common_exports = {};
  __export(common_exports, {
    ARRAY_TYPE: () => ARRAY_TYPE,
    EPSILON: () => EPSILON,
    RANDOM: () => RANDOM,
    equals: () => equals,
    setMatrixArrayType: () => setMatrixArrayType,
    toRadian: () => toRadian
  });
  function setMatrixArrayType(type) {
    ARRAY_TYPE = type;
  }
  function toRadian(a) {
    return a * degree;
  }
  function equals(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
  }
  var EPSILON, ARRAY_TYPE, RANDOM, degree;
  var init_common = __esm({
    "node_modules/gl-matrix/esm/common.js"() {
      EPSILON = 1e-6;
      ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
      RANDOM = Math.random;
      degree = Math.PI / 180;
      if (!Math.hypot)
        Math.hypot = function() {
          var y = 0, i = arguments.length;
          while (i--) {
            y += arguments[i] * arguments[i];
          }
          return Math.sqrt(y);
        };
    }
  });

  // node_modules/gl-matrix/esm/mat3.js
  var mat3_exports = {};
  __export(mat3_exports, {
    add: () => add,
    adjoint: () => adjoint,
    clone: () => clone,
    copy: () => copy,
    create: () => create,
    determinant: () => determinant,
    equals: () => equals2,
    exactEquals: () => exactEquals,
    frob: () => frob,
    fromMat2d: () => fromMat2d,
    fromMat4: () => fromMat4,
    fromQuat: () => fromQuat,
    fromRotation: () => fromRotation,
    fromScaling: () => fromScaling,
    fromTranslation: () => fromTranslation,
    fromValues: () => fromValues,
    identity: () => identity,
    invert: () => invert,
    mul: () => mul,
    multiply: () => multiply,
    multiplyScalar: () => multiplyScalar,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd,
    normalFromMat4: () => normalFromMat4,
    projection: () => projection,
    rotate: () => rotate,
    scale: () => scale,
    set: () => set,
    str: () => str,
    sub: () => sub,
    subtract: () => subtract,
    translate: () => translate,
    transpose: () => transpose
  });
  function create() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  function clone(a) {
    var out = new ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function transpose(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }
    return out;
  }
  function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  function rotate(out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale(out, a, v) {
    var x = v[0], y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
  }
  function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  function normalFromMat4(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  function str(a) {
    return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
  }
  function frob(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
  }
  function multiplyScalarAndAdd(out, a, b, scale8) {
    out[0] = a[0] + b[0] * scale8;
    out[1] = a[1] + b[1] * scale8;
    out[2] = a[2] + b[2] * scale8;
    out[3] = a[3] + b[3] * scale8;
    out[4] = a[4] + b[4] * scale8;
    out[5] = a[5] + b[5] * scale8;
    out[6] = a[6] + b[6] * scale8;
    out[7] = a[7] + b[7] * scale8;
    out[8] = a[8] + b[8] * scale8;
    return out;
  }
  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  function equals2(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
  }
  var mul, sub;
  var init_mat3 = __esm({
    "node_modules/gl-matrix/esm/mat3.js"() {
      init_common();
      mul = multiply;
      sub = subtract;
    }
  });

  // node_modules/gl-matrix/esm/mat4.js
  var mat4_exports = {};
  __export(mat4_exports, {
    add: () => add2,
    adjoint: () => adjoint2,
    clone: () => clone2,
    copy: () => copy2,
    create: () => create2,
    determinant: () => determinant2,
    equals: () => equals3,
    exactEquals: () => exactEquals2,
    frob: () => frob2,
    fromQuat: () => fromQuat3,
    fromQuat2: () => fromQuat2,
    fromRotation: () => fromRotation2,
    fromRotationTranslation: () => fromRotationTranslation,
    fromRotationTranslationScale: () => fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
    fromScaling: () => fromScaling2,
    fromTranslation: () => fromTranslation2,
    fromValues: () => fromValues2,
    fromXRotation: () => fromXRotation,
    fromYRotation: () => fromYRotation,
    fromZRotation: () => fromZRotation,
    frustum: () => frustum,
    getRotation: () => getRotation,
    getScaling: () => getScaling,
    getTranslation: () => getTranslation,
    identity: () => identity2,
    invert: () => invert2,
    lookAt: () => lookAt,
    mul: () => mul2,
    multiply: () => multiply2,
    multiplyScalar: () => multiplyScalar2,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
    ortho: () => ortho,
    orthoNO: () => orthoNO,
    orthoZO: () => orthoZO,
    perspective: () => perspective,
    perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
    perspectiveNO: () => perspectiveNO,
    perspectiveZO: () => perspectiveZO,
    rotate: () => rotate2,
    rotateX: () => rotateX,
    rotateY: () => rotateY,
    rotateZ: () => rotateZ,
    scale: () => scale2,
    set: () => set2,
    str: () => str2,
    sub: () => sub2,
    subtract: () => subtract2,
    targetTo: () => targetTo,
    translate: () => translate2,
    transpose: () => transpose2
  });
  function create2() {
    var out = new ARRAY_TYPE(16);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  function clone2(a) {
    var out = new ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function copy2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function identity2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose2(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a03 = a[3];
      var a12 = a[6], a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }
    return out;
  }
  function invert2(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function adjoint2(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  function determinant2(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply2(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate2(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  function scale2(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function rotate2(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len6 = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len6 < EPSILON) {
      return null;
    }
    len6 = 1 / len6;
    x *= len6;
    y *= len6;
    z *= len6;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    return out;
  }
  function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  function fromTranslation2(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromScaling2(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotation2(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len6 = Math.hypot(x, y, z);
    var s, c, t;
    if (len6 < EPSILON) {
      return null;
    }
    len6 = 1 / len6;
    x *= len6;
    y *= len6;
    z *= len6;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotationTranslation(out, q, v) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromQuat2(out, a) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation(out, a, translation);
    return out;
  }
  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;
    if (trace > 0) {
      S = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }
    return out;
  }
  function fromRotationTranslationScale(out, q, v, s) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  function fromQuat3(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  function perspectiveZO(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }
    return out;
  }
  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
  }
  function orthoNO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  function orthoZO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len6;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity2(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len6 = 1 / Math.hypot(z0, z1, z2);
    z0 *= len6;
    z1 *= len6;
    z2 *= len6;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len6 = Math.hypot(x0, x1, x2);
    if (!len6) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len6 = 1 / len6;
      x0 *= len6;
      x1 *= len6;
      x2 *= len6;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len6 = Math.hypot(y0, y1, y2);
    if (!len6) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len6 = 1 / len6;
      y0 *= len6;
      y1 *= len6;
      y2 *= len6;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  function targetTo(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len6 = z0 * z0 + z1 * z1 + z2 * z2;
    if (len6 > 0) {
      len6 = 1 / Math.sqrt(len6);
      z0 *= len6;
      z1 *= len6;
      z2 *= len6;
    }
    var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
    len6 = x0 * x0 + x1 * x1 + x2 * x2;
    if (len6 > 0) {
      len6 = 1 / Math.sqrt(len6);
      x0 *= len6;
      x1 *= len6;
      x2 *= len6;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  function str2(a) {
    return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
  }
  function frob2(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
  }
  function add2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  function subtract2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  function multiplyScalar2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  function multiplyScalarAndAdd2(out, a, b, scale8) {
    out[0] = a[0] + b[0] * scale8;
    out[1] = a[1] + b[1] * scale8;
    out[2] = a[2] + b[2] * scale8;
    out[3] = a[3] + b[3] * scale8;
    out[4] = a[4] + b[4] * scale8;
    out[5] = a[5] + b[5] * scale8;
    out[6] = a[6] + b[6] * scale8;
    out[7] = a[7] + b[7] * scale8;
    out[8] = a[8] + b[8] * scale8;
    out[9] = a[9] + b[9] * scale8;
    out[10] = a[10] + b[10] * scale8;
    out[11] = a[11] + b[11] * scale8;
    out[12] = a[12] + b[12] * scale8;
    out[13] = a[13] + b[13] * scale8;
    out[14] = a[14] + b[14] * scale8;
    out[15] = a[15] + b[15] * scale8;
    return out;
  }
  function exactEquals2(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  function equals3(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
  }
  var perspective, ortho, mul2, sub2;
  var init_mat4 = __esm({
    "node_modules/gl-matrix/esm/mat4.js"() {
      init_common();
      perspective = perspectiveNO;
      ortho = orthoNO;
      mul2 = multiply2;
      sub2 = subtract2;
    }
  });

  // node_modules/gl-matrix/esm/vec3.js
  var vec3_exports = {};
  __export(vec3_exports, {
    add: () => add3,
    angle: () => angle,
    bezier: () => bezier,
    ceil: () => ceil,
    clone: () => clone3,
    copy: () => copy3,
    create: () => create3,
    cross: () => cross,
    dist: () => dist,
    distance: () => distance,
    div: () => div,
    divide: () => divide,
    dot: () => dot,
    equals: () => equals4,
    exactEquals: () => exactEquals3,
    floor: () => floor,
    forEach: () => forEach,
    fromValues: () => fromValues3,
    hermite: () => hermite,
    inverse: () => inverse,
    len: () => len,
    length: () => length,
    lerp: () => lerp,
    max: () => max,
    min: () => min,
    mul: () => mul3,
    multiply: () => multiply3,
    negate: () => negate,
    normalize: () => normalize,
    random: () => random,
    rotateX: () => rotateX2,
    rotateY: () => rotateY2,
    rotateZ: () => rotateZ2,
    round: () => round,
    scale: () => scale3,
    scaleAndAdd: () => scaleAndAdd,
    set: () => set3,
    sqrDist: () => sqrDist,
    sqrLen: () => sqrLen,
    squaredDistance: () => squaredDistance,
    squaredLength: () => squaredLength,
    str: () => str3,
    sub: () => sub3,
    subtract: () => subtract3,
    transformMat3: () => transformMat3,
    transformMat4: () => transformMat4,
    transformQuat: () => transformQuat,
    zero: () => zero
  });
  function create3() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone3(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  function fromValues3(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function copy3(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  function set3(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function add3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  function subtract3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  function multiply3(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
  }
  function scale3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  function scaleAndAdd(out, a, b, scale8) {
    out[0] = a[0] + b[0] * scale8;
    out[1] = a[1] + b[1] * scale8;
    out[2] = a[2] + b[2] * scale8;
    return out;
  }
  function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
  }
  function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
  }
  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    return out;
  }
  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len6 = x * x + y * y + z * z;
    if (len6 > 0) {
      len6 = 1 / Math.sqrt(len6);
    }
    out[0] = a[0] * len6;
    out[1] = a[1] * len6;
    out[2] = a[2] * len6;
    return out;
  }
  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  function random(out, scale8) {
    scale8 = scale8 || 1;
    var r = RANDOM() * 2 * Math.PI;
    var z = RANDOM() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * scale8;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale8;
    return out;
  }
  function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  function transformQuat(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2];
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX2(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0];
    r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
    r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateY2(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateZ2(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
    r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
    r[2] = p[2];
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function angle(a, b) {
    var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  function str3(a) {
    return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
  }
  function exactEquals3(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  function equals4(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
  }
  var sub3, mul3, div, dist, sqrDist, len, sqrLen, forEach;
  var init_vec3 = __esm({
    "node_modules/gl-matrix/esm/vec3.js"() {
      init_common();
      sub3 = subtract3;
      mul3 = multiply3;
      div = divide;
      dist = distance;
      sqrDist = squaredDistance;
      len = length;
      sqrLen = squaredLength;
      forEach = function() {
        var vec = create3();
        return function(a, stride, offset, count, fn, arg) {
          var i, l;
          if (!stride) {
            stride = 3;
          }
          if (!offset) {
            offset = 0;
          }
          if (count) {
            l = Math.min(count * stride + offset, a.length);
          } else {
            l = a.length;
          }
          for (i = offset; i < l; i += stride) {
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
          }
          return a;
        };
      }();
    }
  });

  // node_modules/gl-matrix/esm/vec4.js
  var vec4_exports = {};
  __export(vec4_exports, {
    add: () => add4,
    ceil: () => ceil2,
    clone: () => clone4,
    copy: () => copy4,
    create: () => create4,
    cross: () => cross2,
    dist: () => dist2,
    distance: () => distance2,
    div: () => div2,
    divide: () => divide2,
    dot: () => dot2,
    equals: () => equals5,
    exactEquals: () => exactEquals4,
    floor: () => floor2,
    forEach: () => forEach2,
    fromValues: () => fromValues4,
    inverse: () => inverse2,
    len: () => len2,
    length: () => length2,
    lerp: () => lerp2,
    max: () => max2,
    min: () => min2,
    mul: () => mul4,
    multiply: () => multiply4,
    negate: () => negate2,
    normalize: () => normalize2,
    random: () => random2,
    round: () => round2,
    scale: () => scale4,
    scaleAndAdd: () => scaleAndAdd2,
    set: () => set4,
    sqrDist: () => sqrDist2,
    sqrLen: () => sqrLen2,
    squaredDistance: () => squaredDistance2,
    squaredLength: () => squaredLength2,
    str: () => str4,
    sub: () => sub4,
    subtract: () => subtract4,
    transformMat4: () => transformMat42,
    transformQuat: () => transformQuat2,
    zero: () => zero2
  });
  function create4() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function clone4(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  function fromValues4(x, y, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  function copy4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  function set4(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  function add4(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  function subtract4(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  function multiply4(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
  }
  function divide2(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
  }
  function ceil2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
  }
  function floor2(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
  }
  function min2(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
  }
  function max2(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
  }
  function round2(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
  }
  function scale4(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  function scaleAndAdd2(out, a, b, scale8) {
    out[0] = a[0] + b[0] * scale8;
    out[1] = a[1] + b[1] * scale8;
    out[2] = a[2] + b[2] * scale8;
    out[3] = a[3] + b[3] * scale8;
    return out;
  }
  function distance2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.hypot(x, y, z, w);
  }
  function squaredDistance2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
  }
  function length2(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.hypot(x, y, z, w);
  }
  function squaredLength2(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
  }
  function negate2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
  }
  function inverse2(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    out[3] = 1 / a[3];
    return out;
  }
  function normalize2(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len6 = x * x + y * y + z * z + w * w;
    if (len6 > 0) {
      len6 = 1 / Math.sqrt(len6);
    }
    out[0] = x * len6;
    out[1] = y * len6;
    out[2] = z * len6;
    out[3] = w * len6;
    return out;
  }
  function dot2(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  function cross2(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0], B = v[0] * w[2] - v[2] * w[0], C = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
  }
  function lerp2(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  function random2(out, scale8) {
    scale8 = scale8 || 1;
    var v1, v2, v3, v4;
    var s1, s2;
    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);
    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s2 = v3 * v3 + v4 * v4;
    } while (s2 >= 1);
    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale8 * v1;
    out[1] = scale8 * v2;
    out[2] = scale8 * v3 * d;
    out[3] = scale8 * v4 * d;
    return out;
  }
  function transformMat42(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  function transformQuat2(out, a, q) {
    var x = a[0], y = a[1], z = a[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
  }
  function zero2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
  }
  function str4(a) {
    return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
  }
  function exactEquals4(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  function equals5(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
  }
  var sub4, mul4, div2, dist2, sqrDist2, len2, sqrLen2, forEach2;
  var init_vec4 = __esm({
    "node_modules/gl-matrix/esm/vec4.js"() {
      init_common();
      sub4 = subtract4;
      mul4 = multiply4;
      div2 = divide2;
      dist2 = distance2;
      sqrDist2 = squaredDistance2;
      len2 = length2;
      sqrLen2 = squaredLength2;
      forEach2 = function() {
        var vec = create4();
        return function(a, stride, offset, count, fn, arg) {
          var i, l;
          if (!stride) {
            stride = 4;
          }
          if (!offset) {
            offset = 0;
          }
          if (count) {
            l = Math.min(count * stride + offset, a.length);
          } else {
            l = a.length;
          }
          for (i = offset; i < l; i += stride) {
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            vec[3] = a[i + 3];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
            a[i + 3] = vec[3];
          }
          return a;
        };
      }();
    }
  });

  // node_modules/gl-matrix/esm/quat.js
  var quat_exports = {};
  __export(quat_exports, {
    add: () => add5,
    calculateW: () => calculateW,
    clone: () => clone5,
    conjugate: () => conjugate,
    copy: () => copy5,
    create: () => create5,
    dot: () => dot3,
    equals: () => equals6,
    exactEquals: () => exactEquals5,
    exp: () => exp,
    fromEuler: () => fromEuler,
    fromMat3: () => fromMat3,
    fromValues: () => fromValues5,
    getAngle: () => getAngle,
    getAxisAngle: () => getAxisAngle,
    identity: () => identity3,
    invert: () => invert3,
    len: () => len3,
    length: () => length3,
    lerp: () => lerp3,
    ln: () => ln,
    mul: () => mul5,
    multiply: () => multiply5,
    normalize: () => normalize3,
    pow: () => pow,
    random: () => random3,
    rotateX: () => rotateX3,
    rotateY: () => rotateY3,
    rotateZ: () => rotateZ3,
    rotationTo: () => rotationTo,
    scale: () => scale5,
    set: () => set5,
    setAxes: () => setAxes,
    setAxisAngle: () => setAxisAngle,
    slerp: () => slerp,
    sqlerp: () => sqlerp,
    sqrLen: () => sqrLen3,
    squaredLength: () => squaredLength3,
    str: () => str5
  });
  function create5() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity3(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2;
    var s = Math.sin(rad / 2);
    if (s > EPSILON) {
      out_axis[0] = q[0] / s;
      out_axis[1] = q[1] / s;
      out_axis[2] = q[2] / s;
    } else {
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }
    return rad;
  }
  function getAngle(a, b) {
    var dotproduct = dot3(a, b);
    return Math.acos(2 * dotproduct * dotproduct - 1);
  }
  function multiply5(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ3(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW(out, a) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
    return out;
  }
  function exp(out, a) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var et = Math.exp(w);
    var s = r > 0 ? et * Math.sin(r) / r : 0;
    out[0] = x * s;
    out[1] = y * s;
    out[2] = z * s;
    out[3] = et * Math.cos(r);
    return out;
  }
  function ln(out, a) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var t = r > 0 ? Math.atan2(r, w) / r : 0;
    out[0] = x * t;
    out[1] = y * t;
    out[2] = z * t;
    out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
    return out;
  }
  function pow(out, a, b) {
    ln(out, a);
    scale5(out, out, b);
    exp(out, out);
    return out;
  }
  function slerp(out, a, b, t) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function random3(out) {
    var u1 = RANDOM();
    var u2 = RANDOM();
    var u3 = RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
    return out;
  }
  function invert3(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var dot6 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot6 ? 1 / dot6 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
  }
  function fromMat3(out, m) {
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      var i = 0;
      if (m[4] > m[0])
        i = 1;
      if (m[8] > m[i * 3 + i])
        i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }
    return out;
  }
  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  function str5(a) {
    return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
  }
  var clone5, fromValues5, copy5, set5, add5, mul5, scale5, dot3, lerp3, length3, len3, squaredLength3, sqrLen3, normalize3, exactEquals5, equals6, rotationTo, sqlerp, setAxes;
  var init_quat = __esm({
    "node_modules/gl-matrix/esm/quat.js"() {
      init_common();
      init_mat3();
      init_vec3();
      init_vec4();
      clone5 = clone4;
      fromValues5 = fromValues4;
      copy5 = copy4;
      set5 = set4;
      add5 = add4;
      mul5 = multiply5;
      scale5 = scale4;
      dot3 = dot2;
      lerp3 = lerp2;
      length3 = length2;
      len3 = length3;
      squaredLength3 = squaredLength2;
      sqrLen3 = squaredLength3;
      normalize3 = normalize2;
      exactEquals5 = exactEquals4;
      equals6 = equals5;
      rotationTo = function() {
        var tmpvec3 = create3();
        var xUnitVec3 = fromValues3(1, 0, 0);
        var yUnitVec3 = fromValues3(0, 1, 0);
        return function(out, a, b) {
          var dot6 = dot(a, b);
          if (dot6 < -0.999999) {
            cross(tmpvec3, xUnitVec3, a);
            if (len(tmpvec3) < 1e-6)
              cross(tmpvec3, yUnitVec3, a);
            normalize(tmpvec3, tmpvec3);
            setAxisAngle(out, tmpvec3, Math.PI);
            return out;
          } else if (dot6 > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
          } else {
            cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot6;
            return normalize3(out, out);
          }
        };
      }();
      sqlerp = function() {
        var temp1 = create5();
        var temp2 = create5();
        return function(out, a, b, c, d, t) {
          slerp(temp1, a, d, t);
          slerp(temp2, b, c, t);
          slerp(out, temp1, temp2, 2 * t * (1 - t));
          return out;
        };
      }();
      setAxes = function() {
        var matr = create();
        return function(out, view, right, up) {
          matr[0] = right[0];
          matr[3] = right[1];
          matr[6] = right[2];
          matr[1] = up[0];
          matr[4] = up[1];
          matr[7] = up[2];
          matr[2] = -view[0];
          matr[5] = -view[1];
          matr[8] = -view[2];
          return normalize3(out, fromMat3(out, matr));
        };
      }();
    }
  });

  // node_modules/gl-matrix/esm/quat2.js
  var quat2_exports = {};
  __export(quat2_exports, {
    add: () => add6,
    clone: () => clone6,
    conjugate: () => conjugate2,
    copy: () => copy6,
    create: () => create6,
    dot: () => dot4,
    equals: () => equals7,
    exactEquals: () => exactEquals6,
    fromMat4: () => fromMat42,
    fromRotation: () => fromRotation3,
    fromRotationTranslation: () => fromRotationTranslation2,
    fromRotationTranslationValues: () => fromRotationTranslationValues,
    fromTranslation: () => fromTranslation3,
    fromValues: () => fromValues6,
    getDual: () => getDual,
    getReal: () => getReal,
    getTranslation: () => getTranslation2,
    identity: () => identity4,
    invert: () => invert4,
    len: () => len4,
    length: () => length4,
    lerp: () => lerp4,
    mul: () => mul6,
    multiply: () => multiply6,
    normalize: () => normalize4,
    rotateAroundAxis: () => rotateAroundAxis,
    rotateByQuatAppend: () => rotateByQuatAppend,
    rotateByQuatPrepend: () => rotateByQuatPrepend,
    rotateX: () => rotateX4,
    rotateY: () => rotateY4,
    rotateZ: () => rotateZ4,
    scale: () => scale6,
    set: () => set6,
    setDual: () => setDual,
    setReal: () => setReal,
    sqrLen: () => sqrLen4,
    squaredLength: () => squaredLength4,
    str: () => str6,
    translate: () => translate3
  });
  function create6() {
    var dq = new ARRAY_TYPE(8);
    if (ARRAY_TYPE != Float32Array) {
      dq[0] = 0;
      dq[1] = 0;
      dq[2] = 0;
      dq[4] = 0;
      dq[5] = 0;
      dq[6] = 0;
      dq[7] = 0;
    }
    dq[3] = 1;
    return dq;
  }
  function clone6(a) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = a[0];
    dq[1] = a[1];
    dq[2] = a[2];
    dq[3] = a[3];
    dq[4] = a[4];
    dq[5] = a[5];
    dq[6] = a[6];
    dq[7] = a[7];
    return dq;
  }
  function fromValues6(x1, y1, z1, w1, x2, y2, z2, w2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    dq[4] = x2;
    dq[5] = y2;
    dq[6] = z2;
    dq[7] = w2;
    return dq;
  }
  function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    var ax = x2 * 0.5, ay = y2 * 0.5, az = z2 * 0.5;
    dq[4] = ax * w1 + ay * z1 - az * y1;
    dq[5] = ay * w1 + az * x1 - ax * z1;
    dq[6] = az * w1 + ax * y1 - ay * x1;
    dq[7] = -ax * x1 - ay * y1 - az * z1;
    return dq;
  }
  function fromRotationTranslation2(out, q, t) {
    var ax = t[0] * 0.5, ay = t[1] * 0.5, az = t[2] * 0.5, bx = q[0], by = q[1], bz = q[2], bw = q[3];
    out[0] = bx;
    out[1] = by;
    out[2] = bz;
    out[3] = bw;
    out[4] = ax * bw + ay * bz - az * by;
    out[5] = ay * bw + az * bx - ax * bz;
    out[6] = az * bw + ax * by - ay * bx;
    out[7] = -ax * bx - ay * by - az * bz;
    return out;
  }
  function fromTranslation3(out, t) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = t[0] * 0.5;
    out[5] = t[1] * 0.5;
    out[6] = t[2] * 0.5;
    out[7] = 0;
    return out;
  }
  function fromRotation3(out, q) {
    out[0] = q[0];
    out[1] = q[1];
    out[2] = q[2];
    out[3] = q[3];
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  function fromMat42(out, a) {
    var outer = create5();
    getRotation(outer, a);
    var t = new ARRAY_TYPE(3);
    getTranslation(t, a);
    fromRotationTranslation2(out, outer, t);
    return out;
  }
  function copy6(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    return out;
  }
  function identity4(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  function set6(out, x1, y1, z1, w1, x2, y2, z2, w2) {
    out[0] = x1;
    out[1] = y1;
    out[2] = z1;
    out[3] = w1;
    out[4] = x2;
    out[5] = y2;
    out[6] = z2;
    out[7] = w2;
    return out;
  }
  function getDual(out, a) {
    out[0] = a[4];
    out[1] = a[5];
    out[2] = a[6];
    out[3] = a[7];
    return out;
  }
  function setDual(out, q) {
    out[4] = q[0];
    out[5] = q[1];
    out[6] = q[2];
    out[7] = q[3];
    return out;
  }
  function getTranslation2(out, a) {
    var ax = a[4], ay = a[5], az = a[6], aw = a[7], bx = -a[0], by = -a[1], bz = -a[2], bw = a[3];
    out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    return out;
  }
  function translate3(out, a, v) {
    var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3], bx1 = v[0] * 0.5, by1 = v[1] * 0.5, bz1 = v[2] * 0.5, ax2 = a[4], ay2 = a[5], az2 = a[6], aw2 = a[7];
    out[0] = ax1;
    out[1] = ay1;
    out[2] = az1;
    out[3] = aw1;
    out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
    out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
    out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
    out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
    return out;
  }
  function rotateX4(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateX3(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  function rotateY4(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateY3(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  function rotateZ4(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateZ3(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  function rotateByQuatAppend(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3], ax = a[0], ay = a[1], az = a[2], aw = a[3];
    out[0] = ax * qw + aw * qx + ay * qz - az * qy;
    out[1] = ay * qw + aw * qy + az * qx - ax * qz;
    out[2] = az * qw + aw * qz + ax * qy - ay * qx;
    out[3] = aw * qw - ax * qx - ay * qy - az * qz;
    ax = a[4];
    ay = a[5];
    az = a[6];
    aw = a[7];
    out[4] = ax * qw + aw * qx + ay * qz - az * qy;
    out[5] = ay * qw + aw * qy + az * qx - ax * qz;
    out[6] = az * qw + aw * qz + ax * qy - ay * qx;
    out[7] = aw * qw - ax * qx - ay * qy - az * qz;
    return out;
  }
  function rotateByQuatPrepend(out, q, a) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3], bx = a[0], by = a[1], bz = a[2], bw = a[3];
    out[0] = qx * bw + qw * bx + qy * bz - qz * by;
    out[1] = qy * bw + qw * by + qz * bx - qx * bz;
    out[2] = qz * bw + qw * bz + qx * by - qy * bx;
    out[3] = qw * bw - qx * bx - qy * by - qz * bz;
    bx = a[4];
    by = a[5];
    bz = a[6];
    bw = a[7];
    out[4] = qx * bw + qw * bx + qy * bz - qz * by;
    out[5] = qy * bw + qw * by + qz * bx - qx * bz;
    out[6] = qz * bw + qw * bz + qx * by - qy * bx;
    out[7] = qw * bw - qx * bx - qy * by - qz * bz;
    return out;
  }
  function rotateAroundAxis(out, a, axis, rad) {
    if (Math.abs(rad) < EPSILON) {
      return copy6(out, a);
    }
    var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
    rad = rad * 0.5;
    var s = Math.sin(rad);
    var bx = s * axis[0] / axisLength;
    var by = s * axis[1] / axisLength;
    var bz = s * axis[2] / axisLength;
    var bw = Math.cos(rad);
    var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3];
    out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    var ax = a[4], ay = a[5], az = a[6], aw = a[7];
    out[4] = ax * bw + aw * bx + ay * bz - az * by;
    out[5] = ay * bw + aw * by + az * bx - ax * bz;
    out[6] = az * bw + aw * bz + ax * by - ay * bx;
    out[7] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function add6(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    return out;
  }
  function multiply6(out, a, b) {
    var ax0 = a[0], ay0 = a[1], az0 = a[2], aw0 = a[3], bx1 = b[4], by1 = b[5], bz1 = b[6], bw1 = b[7], ax1 = a[4], ay1 = a[5], az1 = a[6], aw1 = a[7], bx0 = b[0], by0 = b[1], bz0 = b[2], bw0 = b[3];
    out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
    out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
    out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
    out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
    out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
    out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
    out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
    out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
    return out;
  }
  function scale6(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    return out;
  }
  function lerp4(out, a, b, t) {
    var mt = 1 - t;
    if (dot4(a, b) < 0)
      t = -t;
    out[0] = a[0] * mt + b[0] * t;
    out[1] = a[1] * mt + b[1] * t;
    out[2] = a[2] * mt + b[2] * t;
    out[3] = a[3] * mt + b[3] * t;
    out[4] = a[4] * mt + b[4] * t;
    out[5] = a[5] * mt + b[5] * t;
    out[6] = a[6] * mt + b[6] * t;
    out[7] = a[7] * mt + b[7] * t;
    return out;
  }
  function invert4(out, a) {
    var sqlen = squaredLength4(a);
    out[0] = -a[0] / sqlen;
    out[1] = -a[1] / sqlen;
    out[2] = -a[2] / sqlen;
    out[3] = a[3] / sqlen;
    out[4] = -a[4] / sqlen;
    out[5] = -a[5] / sqlen;
    out[6] = -a[6] / sqlen;
    out[7] = a[7] / sqlen;
    return out;
  }
  function conjugate2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    out[4] = -a[4];
    out[5] = -a[5];
    out[6] = -a[6];
    out[7] = a[7];
    return out;
  }
  function normalize4(out, a) {
    var magnitude = squaredLength4(a);
    if (magnitude > 0) {
      magnitude = Math.sqrt(magnitude);
      var a0 = a[0] / magnitude;
      var a1 = a[1] / magnitude;
      var a2 = a[2] / magnitude;
      var a3 = a[3] / magnitude;
      var b0 = a[4];
      var b1 = a[5];
      var b2 = a[6];
      var b3 = a[7];
      var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
      out[0] = a0;
      out[1] = a1;
      out[2] = a2;
      out[3] = a3;
      out[4] = (b0 - a0 * a_dot_b) / magnitude;
      out[5] = (b1 - a1 * a_dot_b) / magnitude;
      out[6] = (b2 - a2 * a_dot_b) / magnitude;
      out[7] = (b3 - a3 * a_dot_b) / magnitude;
    }
    return out;
  }
  function str6(a) {
    return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
  }
  function exactEquals6(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
  }
  function equals7(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7));
  }
  var getReal, setReal, mul6, dot4, length4, len4, squaredLength4, sqrLen4;
  var init_quat2 = __esm({
    "node_modules/gl-matrix/esm/quat2.js"() {
      init_common();
      init_quat();
      init_mat4();
      getReal = copy5;
      setReal = copy5;
      mul6 = multiply6;
      dot4 = dot3;
      length4 = length3;
      len4 = length4;
      squaredLength4 = squaredLength3;
      sqrLen4 = squaredLength4;
    }
  });

  // node_modules/gl-matrix/esm/vec2.js
  var vec2_exports = {};
  __export(vec2_exports, {
    add: () => add7,
    angle: () => angle2,
    ceil: () => ceil3,
    clone: () => clone7,
    copy: () => copy7,
    create: () => create7,
    cross: () => cross3,
    dist: () => dist3,
    distance: () => distance3,
    div: () => div3,
    divide: () => divide3,
    dot: () => dot5,
    equals: () => equals8,
    exactEquals: () => exactEquals7,
    floor: () => floor3,
    forEach: () => forEach3,
    fromValues: () => fromValues7,
    inverse: () => inverse3,
    len: () => len5,
    length: () => length5,
    lerp: () => lerp5,
    max: () => max3,
    min: () => min3,
    mul: () => mul7,
    multiply: () => multiply7,
    negate: () => negate3,
    normalize: () => normalize5,
    random: () => random4,
    rotate: () => rotate3,
    round: () => round3,
    scale: () => scale7,
    scaleAndAdd: () => scaleAndAdd3,
    set: () => set7,
    sqrDist: () => sqrDist3,
    sqrLen: () => sqrLen5,
    squaredDistance: () => squaredDistance3,
    squaredLength: () => squaredLength5,
    str: () => str7,
    sub: () => sub5,
    subtract: () => subtract5,
    transformMat2: () => transformMat2,
    transformMat2d: () => transformMat2d,
    transformMat3: () => transformMat32,
    transformMat4: () => transformMat43,
    zero: () => zero3
  });
  function create7() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function clone7(a) {
    var out = new ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  function fromValues7(x, y) {
    var out = new ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
  }
  function copy7(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  function set7(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
  }
  function add7(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  function subtract5(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
  }
  function multiply7(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
  }
  function divide3(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
  }
  function ceil3(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
  }
  function floor3(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
  }
  function min3(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
  }
  function max3(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
  }
  function round3(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
  }
  function scale7(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
  }
  function scaleAndAdd3(out, a, b, scale8) {
    out[0] = a[0] + b[0] * scale8;
    out[1] = a[1] + b[1] * scale8;
    return out;
  }
  function distance3(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return Math.hypot(x, y);
  }
  function squaredDistance3(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return x * x + y * y;
  }
  function length5(a) {
    var x = a[0], y = a[1];
    return Math.hypot(x, y);
  }
  function squaredLength5(a) {
    var x = a[0], y = a[1];
    return x * x + y * y;
  }
  function negate3(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
  }
  function inverse3(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    return out;
  }
  function normalize5(out, a) {
    var x = a[0], y = a[1];
    var len6 = x * x + y * y;
    if (len6 > 0) {
      len6 = 1 / Math.sqrt(len6);
    }
    out[0] = a[0] * len6;
    out[1] = a[1] * len6;
    return out;
  }
  function dot5(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function cross3(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
  }
  function lerp5(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  function random4(out, scale8) {
    scale8 = scale8 || 1;
    var r = RANDOM() * 2 * Math.PI;
    out[0] = Math.cos(r) * scale8;
    out[1] = Math.sin(r) * scale8;
    return out;
  }
  function transformMat2(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
  }
  function transformMat2d(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
  }
  function transformMat32(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  function transformMat43(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  function rotate3(out, a, b, rad) {
    var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
  }
  function angle2(a, b) {
    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero3(out) {
    out[0] = 0;
    out[1] = 0;
    return out;
  }
  function str7(a) {
    return "vec2(" + a[0] + ", " + a[1] + ")";
  }
  function exactEquals7(a, b) {
    return a[0] === b[0] && a[1] === b[1];
  }
  function equals8(a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
  }
  var len5, sub5, mul7, div3, dist3, sqrDist3, sqrLen5, forEach3;
  var init_vec2 = __esm({
    "node_modules/gl-matrix/esm/vec2.js"() {
      init_common();
      len5 = length5;
      sub5 = subtract5;
      mul7 = multiply7;
      div3 = divide3;
      dist3 = distance3;
      sqrDist3 = squaredDistance3;
      sqrLen5 = squaredLength5;
      forEach3 = function() {
        var vec = create7();
        return function(a, stride, offset, count, fn, arg) {
          var i, l;
          if (!stride) {
            stride = 2;
          }
          if (!offset) {
            offset = 0;
          }
          if (count) {
            l = Math.min(count * stride + offset, a.length);
          } else {
            l = a.length;
          }
          for (i = offset; i < l; i += stride) {
            vec[0] = a[i];
            vec[1] = a[i + 1];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
          }
          return a;
        };
      }();
    }
  });

  // node_modules/gl-matrix/esm/index.js
  var init_esm = __esm({
    "node_modules/gl-matrix/esm/index.js"() {
      init_common();
      init_mat3();
      init_mat4();
      init_quat();
      init_quat2();
      init_vec2();
      init_vec3();
      init_vec4();
    }
  });

  // node_modules/@wonderlandengine/components/cursor.js
  var cursor_exports = {};
  var init_cursor = __esm({
    "node_modules/@wonderlandengine/components/cursor.js"() {
      init_esm();
      WL.registerComponent("cursor", {
        /** Collision group for the ray cast. Only objects in this group will be affected by this cursor. */
        collisionGroup: { type: WL.Type.Int, default: 1 },
        /** (optional) Object that visualizes the cursor's ray. */
        cursorRayObject: { type: WL.Type.Object },
        /** Axis along which to scale the `cursorRayObject`. */
        cursorRayScalingAxis: { type: WL.Type.Enum, values: ["x", "y", "z", "none"], default: "z" },
        /** (optional) Object that visualizes the cursor's hit location. */
        cursorObject: { type: WL.Type.Object },
        /** Handedness for VR cursors to accept trigger events only from respective controller. */
        handedness: { type: WL.Type.Enum, values: ["input component", "left", "right", "none"], default: "input component" },
        /** Mode for raycasting, whether to use PhysX or simple collision components */
        rayCastMode: { type: WL.Type.Enum, values: ["collision", "physx"], default: "collision" },
        /** Whether to set the CSS style of the mouse cursor on desktop */
        styleCursor: { type: WL.Type.Bool, default: true }
      }, {
        init: function() {
          this.session = null;
          this.collisionMask = 1 << this.collisionGroup;
          this.maxDistance = 100;
          const sceneLoaded = this.onDestroy.bind(this);
          WL.onSceneLoaded.push(sceneLoaded);
          this.onDestroyCallbacks = [() => {
            const index = WL.onSceneLoaded.indexOf(sceneLoaded);
            if (index >= 0)
              WL.onSceneLoaded.splice(index, 1);
          }];
        },
        start: function() {
          if (this.handedness == 0) {
            const inputComp = this.object.getComponent("input");
            if (!inputComp) {
              console.warn(
                "cursor component on object",
                this.object.name,
                'was configured with handedness "input component", but object has no input component.'
              );
            } else {
              this.handedness = inputComp.handedness;
              this.input = inputComp;
            }
          } else {
            this.handedness = ["left", "right"][this.handedness - 1];
          }
          this.globalTarget = this.object.addComponent("cursor-target");
          this.origin = new Float32Array(3);
          this.cursorObjScale = new Float32Array(3);
          this.direction = [0, 0, 0];
          this.tempQuat = new Float32Array(4);
          this.viewComponent = this.object.getComponent("view");
          if (this.viewComponent != null) {
            const onClick = this.onClick.bind(this);
            WL.canvas.addEventListener("click", onClick);
            const onPointerMove = this.onPointerMove.bind(this);
            WL.canvas.addEventListener("pointermove", onPointerMove);
            const onPointerDown = this.onPointerDown.bind(this);
            WL.canvas.addEventListener("pointerdown", onPointerDown);
            const onPointerUp = this.onPointerUp.bind(this);
            WL.canvas.addEventListener("pointerup", onPointerUp);
            this.projectionMatrix = new Float32Array(16);
            mat4_exports.invert(this.projectionMatrix, this.viewComponent.projectionMatrix);
            const onViewportResize = this.onViewportResize.bind(this);
            window.addEventListener("resize", onViewportResize);
            this.onDestroyCallbacks.push(() => {
              WL.canvas.removeEventListener("click", onClick);
              WL.canvas.removeEventListener("pointermove", onPointerMove);
              WL.canvas.removeEventListener("pointerdown", onPointerDown);
              WL.canvas.removeEventListener("pointerup", onPointerUp);
              window.removeEventListener("resize", onViewportResize);
            });
          }
          this.isHovering = false;
          this.visible = true;
          this.isDown = false;
          this.lastIsDown = false;
          this.cursorPos = new Float32Array(3);
          this.hoveringObject = null;
          const onXRSessionStart = this.setupVREvents.bind(this);
          WL.onXRSessionStart.push(onXRSessionStart);
          this.onDestroyCallbacks.push(() => {
            const index = WL.onXRSessionStart.indexOf(onXRSessionStart);
            if (index >= 0)
              WL.onXRSessionStart.splice(index, 1);
          });
          if (this.cursorRayObject) {
            this.cursorRayScale = new Float32Array(3);
            this.cursorRayScale.set(this.cursorRayObject.scalingLocal);
            this.object.getTranslationWorld(this.origin);
            this.object.getForward(this.direction);
            this._setCursorRayTransform([
              this.origin[0] + this.direction[0],
              this.origin[1] + this.direction[1],
              this.origin[2] + this.direction[2]
            ]);
          }
        },
        onViewportResize: function() {
          if (!this.viewComponent)
            return;
          mat4_exports.invert(this.projectionMatrix, this.viewComponent.projectionMatrix);
        },
        _setCursorRayTransform: function(hitPosition) {
          if (!this.cursorRayObject)
            return;
          const dist4 = vec3_exports.dist(this.origin, hitPosition);
          this.cursorRayObject.setTranslationLocal([0, 0, -dist4 / 2]);
          if (this.cursorRayScalingAxis != 4) {
            this.cursorRayObject.resetScaling();
            this.cursorRayScale[this.cursorRayScalingAxis] = dist4 / 2;
            this.cursorRayObject.scale(this.cursorRayScale);
          }
        },
        _setCursorVisibility: function(visible) {
          if (this.visible == visible)
            return;
          this.visible = visible;
          if (!this.cursorObject)
            return;
          if (visible) {
            this.cursorObject.resetScaling();
            this.cursorObject.scale(this.cursorObjScale);
          } else {
            this.cursorObjScale.set(this.cursorObject.scalingLocal);
            this.cursorObject.scale([0, 0, 0]);
          }
        },
        update: function() {
          this.doUpdate(false);
        },
        doUpdate: function(doClick) {
          if (this.session) {
            if (this.arTouchDown && this.input && WL.xrSession.inputSources[0].handedness === "none" && WL.xrSession.inputSources[0].gamepad) {
              const p = WL.xrSession.inputSources[0].gamepad.axes;
              this.direction = [p[0], -p[1], -1];
              this.updateDirection();
            } else {
              this.object.getTranslationWorld(this.origin);
              this.object.getForward(this.direction);
            }
            const rayHit = this.rayHit = this.rayCastMode == 0 ? WL.scene.rayCast(this.origin, this.direction, this.collisionMask) : WL.physics.rayCast(this.origin, this.direction, this.collisionMask, this.maxDistance);
            if (rayHit.hitCount > 0) {
              this.cursorPos.set(rayHit.locations[0]);
            } else {
              this.cursorPos.fill(0);
            }
            this.hoverBehaviour(rayHit, doClick);
          }
          if (this.cursorObject) {
            if (this.hoveringObject && (this.cursorPos[0] != 0 || this.cursorPos[1] != 0 || this.cursorPos[2] != 0)) {
              this._setCursorVisibility(true);
              this.cursorObject.setTranslationWorld(this.cursorPos);
              this._setCursorRayTransform(this.cursorPos);
            } else {
              this._setCursorVisibility(false);
            }
          }
        },
        hoverBehaviour: function(rayHit, doClick) {
          if (rayHit.hitCount > 0) {
            if (!this.hoveringObject || !this.hoveringObject.equals(rayHit.objects[0])) {
              if (this.hoveringObject) {
                const cursorTarget3 = this.hoveringObject.getComponent("cursor-target");
                if (cursorTarget3)
                  cursorTarget3.onUnhover(this.hoveringObject, this);
                this.globalTarget.onUnhover(this.hoveringObject, this);
              }
              this.hoveringObject = rayHit.objects[0];
              if (this.styleCursor)
                WL.canvas.style.cursor = "pointer";
              let cursorTarget2 = this.hoveringObject.getComponent("cursor-target");
              if (cursorTarget2) {
                this.hoveringObjectTarget = cursorTarget2;
                cursorTarget2.onHover(this.hoveringObject, this);
              }
              this.globalTarget.onHover(this.hoveringObject, this);
            }
            if (this.hoveringObjectTarget) {
              this.hoveringObjectTarget.onMove(this.hoveringObject, this);
            }
            const cursorTarget = this.hoveringObject.getComponent("cursor-target");
            if (this.isDown !== this.lastIsDown) {
              if (this.isDown) {
                if (cursorTarget)
                  cursorTarget.onDown(this.hoveringObject, this);
                this.globalTarget.onDown(this.hoveringObject, this);
              } else {
                if (cursorTarget)
                  cursorTarget.onUp(this.hoveringObject, this);
                this.globalTarget.onUp(this.hoveringObject, this);
              }
            }
            if (doClick) {
              if (cursorTarget)
                cursorTarget.onClick(this.hoveringObject, this);
              this.globalTarget.onClick(this.hoveringObject, this);
            }
          } else if (this.hoveringObject && rayHit.hitCount == 0) {
            const cursorTarget = this.hoveringObject.getComponent("cursor-target");
            if (cursorTarget)
              cursorTarget.onUnhover(this.hoveringObject, this);
            this.globalTarget.onUnhover(this.hoveringObject, this);
            this.hoveringObject = null;
            this.hoveringObjectTarget = null;
            if (this.styleCursor)
              WL.canvas.style.cursor = "default";
          }
          this.lastIsDown = this.isDown;
        },
        /**
         * Setup event listeners on session object
         * @param s WebXR session
         *
         * Sets up 'select' and 'end' events and caches the session to avoid
         * Module object access.
         */
        setupVREvents: function(s) {
          this.session = s;
          const onSessionEnd = function(e) {
            this.session = null;
          }.bind(this);
          s.addEventListener("end", onSessionEnd);
          const onSelect = this.onSelect.bind(this);
          s.addEventListener("select", onSelect);
          const onSelectStart = this.onSelectStart.bind(this);
          s.addEventListener("selectstart", onSelectStart);
          const onSelectEnd = this.onSelectEnd.bind(this);
          s.addEventListener("selectend", onSelectEnd);
          this.onDestroyCallbacks.push(() => {
            if (!this.session)
              return;
            s.removeEventListener("end", onSessionEnd);
            s.removeEventListener("select", onSelect);
            s.removeEventListener("selectstart", onSelectStart);
            s.removeEventListener("selectend", onSelectEnd);
          });
          this.onViewportResize();
        },
        /** 'select' event listener */
        onSelect: function(e) {
          if (e.inputSource.handedness != this.handedness)
            return;
          this.doUpdate(true);
        },
        /** 'selectstart' event listener */
        onSelectStart: function(e) {
          this.arTouchDown = true;
          if (e.inputSource.handedness == this.handedness)
            this.isDown = true;
        },
        /** 'selectend' event listener */
        onSelectEnd: function(e) {
          this.arTouchDown = false;
          if (e.inputSource.handedness == this.handedness)
            this.isDown = false;
        },
        /** 'pointermove' event listener */
        onPointerMove: function(e) {
          if (!e.isPrimary)
            return;
          const bounds = e.target.getBoundingClientRect();
          const rayHit = this.updateMousePos(e.clientX, e.clientY, bounds.width, bounds.height);
          this.hoverBehaviour(rayHit, false);
        },
        /** 'click' event listener */
        onClick: function(e) {
          const bounds = e.target.getBoundingClientRect();
          const rayHit = this.updateMousePos(e.clientX, e.clientY, bounds.width, bounds.height);
          this.hoverBehaviour(rayHit, true);
        },
        /** 'pointerdown' event listener */
        onPointerDown: function(e) {
          if (!e.isPrimary || e.button !== 0)
            return;
          const bounds = e.target.getBoundingClientRect();
          const rayHit = this.updateMousePos(e.clientX, e.clientY, bounds.width, bounds.height);
          this.isDown = true;
          this.hoverBehaviour(rayHit, false);
        },
        /** 'pointerup' event listener */
        onPointerUp: function(e) {
          if (!e.isPrimary || e.button !== 0)
            return;
          const bounds = e.target.getBoundingClientRect();
          const rayHit = this.updateMousePos(e.clientX, e.clientY, bounds.width, bounds.height);
          this.isDown = false;
          this.hoverBehaviour(rayHit, false);
        },
        /**
         * Update mouse position in non-VR mode and raycast for new position
         * @returns @ref WL.RayHit for new position.
         */
        updateMousePos: function(clientX, clientY, w, h) {
          const left = clientX / w;
          const top = clientY / h;
          this.direction = [left * 2 - 1, -top * 2 + 1, -1];
          return this.updateDirection();
        },
        updateDirection: function() {
          this.object.getTranslationWorld(this.origin);
          vec3_exports.transformMat4(
            this.direction,
            this.direction,
            this.projectionMatrix
          );
          vec3_exports.normalize(this.direction, this.direction);
          vec3_exports.transformQuat(this.direction, this.direction, this.object.transformWorld);
          const rayHit = this.rayHit = this.rayCastMode == 0 ? WL.scene.rayCast(this.origin, this.direction, this.collisionMask) : WL.physics.rayCast(this.origin, this.direction, this.collisionMask, this.maxDistance);
          if (rayHit.hitCount > 0) {
            this.cursorPos.set(rayHit.locations[0]);
          } else {
            this.cursorPos.fill(0);
          }
          return rayHit;
        },
        onDeactivate: function() {
          this._setCursorVisibility(false);
          if (this.hoveringObject) {
            const target = this.hoveringObject.getComponent("cursor-target");
            if (target)
              target.onUnhover(this.hoveringObject, this);
            this.globalTarget.onUnhover(this.hoveringObject, this);
          }
          if (this.cursorRayObject)
            this.cursorRayObject.scale([0, 0, 0]);
        },
        onActivate: function() {
          this._setCursorVisibility(true);
        },
        onDestroy: function() {
          for (const f of this.onDestroyCallbacks)
            f();
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/debug-object.js
  var require_debug_object = __commonJS({
    "node_modules/@wonderlandengine/components/debug-object.js"() {
      WL.registerComponent("debug-object", {
        /** A second object to print the name of */
        obj: { type: WL.Type.Object }
      }, {
        start: function() {
        },
        init: function() {
          let origin = [0, 0, 0];
          glMatrix.quat2.getTranslation(origin, this.object.transformWorld);
          console.log("Debug Object:", this.object.name);
          console.log("Other object:", this.obj.name);
          console.log("	translation", origin);
          console.log("	transformWorld", this.object.transformWorld);
          console.log("	transformLocal", this.object.transformLocal);
        },
        update: function() {
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/device-orientation-look.js
  var require_device_orientation_look = __commonJS({
    "node_modules/@wonderlandengine/components/device-orientation-look.js"() {
      function quatFromEulerYXZ(out, x, y, z) {
        const c1 = Math.cos(x / 2);
        const c2 = Math.cos(y / 2);
        const c3 = Math.cos(z / 2);
        const s1 = Math.sin(x / 2);
        const s2 = Math.sin(y / 2);
        const s3 = Math.sin(z / 2);
        out[0] = s1 * c2 * c3 + c1 * s2 * s3;
        out[1] = c1 * s2 * c3 - s1 * c2 * s3;
        out[2] = c1 * c2 * s3 - s1 * s2 * c3;
        out[3] = c1 * c2 * c3 + s1 * s2 * s3;
      }
      WL.registerComponent("device-orientation-look", {}, {
        start: function() {
          this.rotationX = 0;
          this.rotationY = 0;
          this.lastClientX = -1;
          this.lastClientY = -1;
        },
        init: function() {
          this.deviceOrientation = [0, 0, 0, 1];
          this.screenOrientation = 0;
          this._origin = [0, 0, 0];
          window.addEventListener("deviceorientation", function(e) {
            let alpha = e.alpha || 0;
            let beta = e.beta || 0;
            let gamma = e.gamma || 0;
            const toRad = Math.PI / 180;
            quatFromEulerYXZ(this.deviceOrientation, beta * toRad, alpha * toRad, -gamma * toRad);
          }.bind(this));
          window.addEventListener("orientationchange", function(e) {
            this.screenOrientation = window.orientation || 0;
          }.bind(this), false);
        },
        update: function() {
          if (Module["webxr_session"] != null)
            return;
          glMatrix.quat2.getTranslation(this._origin, this.object.transformLocal);
          this.object.resetTransform();
          if (this.screenOrientation != 0) {
            this.object.rotateAxisAngleDeg([0, 0, 1], this.screenOrientation);
          }
          this.object.rotate([-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)]);
          this.object.rotate(this.deviceOrientation);
          this.object.translate(this._origin);
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/finger-cursor.js
  var require_finger_cursor = __commonJS({
    "node_modules/@wonderlandengine/components/finger-cursor.js"() {
      WL.registerComponent("finger-cursor", {}, {
        init: function() {
          this.lastTarget = null;
        },
        start: function() {
          this.tip = this.object.getComponent("collision");
        },
        update: function() {
          const overlaps = this.tip.queryOverlaps();
          let overlapFound = null;
          for (let i = 0; i < overlaps.length; ++i) {
            const o = overlaps[i].object;
            const target = o.getComponent("cursor-target");
            if (target) {
              if (!target.equals(this.lastTarget)) {
                target.onHover(o, this);
                target.onClick(o, this);
              }
              overlapFound = target;
              break;
            }
          }
          if (!overlapFound) {
            if (this.lastTarget)
              this.lastTarget.onUnhover(this.lastTarget.object, this);
            this.lastTarget = null;
            return;
          } else {
            this.lastTarget = overlapFound;
          }
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/fixed-foveation.js
  var require_fixed_foveation = __commonJS({
    "node_modules/@wonderlandengine/components/fixed-foveation.js"() {
      WL.registerComponent("fixed-foveation", {
        /** Amount to apply from 0 (none) to 1 (full) */
        fixedFoveation: { type: WL.Type.Float, default: 0.5 }
      }, {
        start: function() {
          if (WL.xrSession) {
            this.setFixedFoveation();
          } else {
            WL.onXRSessionStart.push(this.setFixedFoveation.bind(this));
          }
        },
        setFixedFoveation: function() {
          if ("webxr_baseLayer" in Module) {
            Module.webxr_baseLayer.fixedFoveation = this.fixedFoveation;
          }
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/hand-tracking.js
  var hand_tracking_exports = {};
  var init_hand_tracking = __esm({
    "node_modules/@wonderlandengine/components/hand-tracking.js"() {
      init_esm();
      WL.registerComponent("hand-tracking", {
        /** Handedness determining whether to receive tracking input from right or left hand */
        handedness: { type: WL.Type.Enum, default: "left", values: ["left", "right"] },
        /** (optional) Mesh to use to visualize joints */
        jointMesh: { type: WL.Type.Mesh, default: null },
        /** Material to use for display. Applied to either the spawned skinned mesh or the joint spheres. */
        jointMaterial: { type: WL.Type.Material, default: null },
        /** (optional) Skin to apply tracked joint poses to. If not present, joint spheres will be used for display instead. */
        handSkin: { type: WL.Type.Skin, default: null },
        /** Deactivate children if no pose was tracked */
        deactivateChildrenWithoutPose: { type: WL.Type.Bool, default: true },
        /** Controller objects to activate including children if no pose is available */
        controllerToDeactivate: { type: WL.Type.Object }
      }, {
        ORDERED_JOINTS: [
          "wrist",
          "thumb-metacarpal",
          "thumb-phalanx-proximal",
          "thumb-phalanx-distal",
          "thumb-tip",
          "index-finger-metacarpal",
          "index-finger-phalanx-proximal",
          "index-finger-phalanx-intermediate",
          "index-finger-phalanx-distal",
          "index-finger-tip",
          "middle-finger-metacarpal",
          "middle-finger-phalanx-proximal",
          "middle-finger-phalanx-intermediate",
          "middle-finger-phalanx-distal",
          "middle-finger-tip",
          "ring-finger-metacarpal",
          "ring-finger-phalanx-proximal",
          "ring-finger-phalanx-intermediate",
          "ring-finger-phalanx-distal",
          "ring-finger-tip",
          "pinky-finger-metacarpal",
          "pinky-finger-phalanx-proximal",
          "pinky-finger-phalanx-intermediate",
          "pinky-finger-phalanx-distal",
          "pinky-finger-tip"
        ],
        init: function() {
          this.handedness = ["left", "right"][this.handedness];
        },
        start: function() {
          this.joints = [];
          this.session = null;
          this.hasPose = false;
          this._childrenActive = true;
          if (!("XRHand" in window)) {
            console.warn("WebXR Hand Tracking not supported by this browser.");
            this.active = false;
            return;
          }
          if (this.handSkin) {
            let skin = this.handSkin;
            let jointIds = skin.jointIds;
            this.joints[this.ORDERED_JOINTS[0]] = new WL.Object(jointIds[0]);
            for (let j = 0; j < jointIds.length; ++j) {
              let joint = new WL.Object(jointIds[j]);
              this.joints[joint.name] = joint;
            }
            return;
          }
          for (let j = 0; j <= this.ORDERED_JOINTS.length; ++j) {
            let joint = WL.scene.addObject(this.object.parent);
            let mesh = joint.addComponent("mesh");
            mesh.mesh = this.jointMesh;
            mesh.material = this.jointMaterial;
            this.joints[this.ORDERED_JOINTS[j]] = joint;
          }
        },
        update: function(dt) {
          if (!this.session) {
            if (WL.xrSession)
              this.setupVREvents(WL.xrSession);
          }
          if (!this.session)
            return;
          this.hasPose = false;
          if (this.session && this.session.inputSources) {
            for (let i = 0; i <= this.session.inputSources.length; ++i) {
              const inputSource = this.session.inputSources[i];
              if (!inputSource || !inputSource.hand || inputSource.handedness != this.handedness)
                continue;
              this.hasPose = true;
              if (inputSource.hand.get("wrist") !== null) {
                const p = Module["webxr_frame"].getJointPose(inputSource.hand.get("wrist"), WebXR.refSpaces[WebXR.refSpace]);
                if (p) {
                  this.object.resetTranslationRotation();
                  this.object.transformLocal.set([
                    p.transform.orientation.x,
                    p.transform.orientation.y,
                    p.transform.orientation.z,
                    p.transform.orientation.w
                  ]);
                  this.object.translate([
                    p.transform.position.x,
                    p.transform.position.y,
                    p.transform.position.z
                  ]);
                }
              }
              let invTranslation = new Float32Array(3);
              let invRotation = new Float32Array(4);
              quat_exports.invert(invRotation, this.object.transformLocal);
              this.object.getTranslationLocal(invTranslation);
              for (let j = 0; j < this.ORDERED_JOINTS.length; ++j) {
                const jointName = this.ORDERED_JOINTS[j];
                const joint = this.joints[jointName];
                if (joint == null)
                  continue;
                let jointPose = null;
                if (inputSource.hand.get(jointName) !== null) {
                  jointPose = Module["webxr_frame"].getJointPose(inputSource.hand.get(jointName), WebXR.refSpaces[WebXR.refSpace]);
                }
                if (jointPose !== null) {
                  if (this.handSkin) {
                    joint.resetTranslationRotation();
                    joint.translate([
                      jointPose.transform.position.x - invTranslation[0],
                      jointPose.transform.position.y - invTranslation[1],
                      jointPose.transform.position.z - invTranslation[2]
                    ]);
                    joint.rotate(invRotation);
                    joint.rotateObject([
                      jointPose.transform.orientation.x,
                      jointPose.transform.orientation.y,
                      jointPose.transform.orientation.z,
                      jointPose.transform.orientation.w
                    ]);
                  } else {
                    joint.resetTransform();
                    joint.transformLocal.set([
                      jointPose.transform.orientation.x,
                      jointPose.transform.orientation.y,
                      jointPose.transform.orientation.z,
                      jointPose.transform.orientation.w
                    ]);
                    joint.translate([
                      jointPose.transform.position.x,
                      jointPose.transform.position.y,
                      jointPose.transform.position.z
                    ]);
                    const r = jointPose.radius || 7e-3;
                    joint.scale([r, r, r]);
                  }
                } else {
                  if (!this.handSkin)
                    joint.scale([0, 0, 0]);
                }
              }
            }
          }
          if (!this.hasPose && this._childrenActive) {
            this._childrenActive = false;
            if (this.deactivateChildrenWithoutPose) {
              this.setChildrenActive(false);
            }
            if (this.controllerToDeactivate) {
              this.controllerToDeactivate.active = true;
              this.setChildrenActive(true, this.controllerToDeactivate);
            }
          } else if (this.hasPose && !this._childrenActive) {
            this._childrenActive = true;
            if (this.deactivateChildrenWithoutPose) {
              this.setChildrenActive(true);
            }
            if (this.controllerToDeactivate) {
              this.controllerToDeactivate.active = false;
              this.setChildrenActive(false, this.controllerToDeactivate);
            }
          }
        },
        setChildrenActive: function(active, object) {
          object = object || this.object;
          const children = object.children;
          for (const o of children) {
            o.active = active;
            this.setChildrenActive(active, o);
          }
        },
        isGrabbing: function() {
          const indexTipPos = [0, 0, 0];
          quat2_exports.getTranslation(indexTipPos, this.joints["index-finger-tip"].transformLocal);
          const thumbTipPos = [0, 0, 0];
          quat2_exports.getTranslation(thumbTipPos, this.joints["thumb-tip"].transformLocal);
          return vec3_exports.sqrDist(thumbTipPos, indexTipPos) < 1e-3;
        },
        setupVREvents: function(s) {
          this.session = s;
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/hit-test-location.js
  var hit_test_location_exports = {};
  var init_hit_test_location = __esm({
    "node_modules/@wonderlandengine/components/hit-test-location.js"() {
      init_esm();
      WL.registerComponent("hit-test-location", {}, {
        init: function() {
          WL.onXRSessionStart.push(this.xrSessionStart.bind(this));
          WL.onXRSessionStart.push(this.xrSessionEnd.bind(this));
          this.tempScaling = new Float32Array(3);
          this.tempScaling.set(this.object.scalingLocal);
          this.visible = false;
          this.object.scale([0, 0, 0]);
        },
        update: function(dt) {
          const wasVisible = this.visible;
          if (this.xrHitTestSource) {
            const frame = Module["webxr_frame"];
            if (!frame)
              return;
            let hitTestResults = frame.getHitTestResults(this.xrHitTestSource);
            if (hitTestResults.length > 0) {
              let pose = hitTestResults[0].getPose(this.xrViewerSpace);
              this.visible = true;
              quat2_exports.fromMat4(this.object.transformLocal, pose.transform.matrix);
              this.object.setDirty();
            } else {
              this.visible = false;
            }
          }
          if (this.visible != wasVisible) {
            if (!this.visible) {
              this.tempScaling.set(this.object.scalingLocal);
              this.object.scale([0, 0, 0]);
            } else {
              this.object.scalingLocal.set(this.tempScaling);
              this.object.setDirty();
            }
          }
        },
        xrSessionStart: function(session) {
          session.requestReferenceSpace("viewer").then(function(refSpace) {
            this.xrViewerSpace = refSpace;
            session.requestHitTestSource({ space: this.xrViewerSpace }).then(function(hitTestSource) {
              this.xrHitTestSource = hitTestSource;
            }.bind(this)).catch(console.error);
          }.bind(this)).catch(console.error);
        },
        xrSessionEnd: function() {
          if (!this.xrHitTestSource)
            return;
          this.xrHitTestSource.cancel();
          this.xrHitTestSource = null;
        }
      });
    }
  });

  // node_modules/howler/dist/howler.js
  var require_howler = __commonJS({
    "node_modules/howler/dist/howler.js"(exports) {
      (function() {
        "use strict";
        var HowlerGlobal2 = function() {
          this.init();
        };
        HowlerGlobal2.prototype = {
          /**
           * Initialize the global Howler object.
           * @return {Howler}
           */
          init: function() {
            var self2 = this || Howler14;
            self2._counter = 1e3;
            self2._html5AudioPool = [];
            self2.html5PoolSize = 10;
            self2._codecs = {};
            self2._howls = [];
            self2._muted = false;
            self2._volume = 1;
            self2._canPlayEvent = "canplaythrough";
            self2._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
            self2.masterGain = null;
            self2.noAudio = false;
            self2.usingWebAudio = true;
            self2.autoSuspend = true;
            self2.ctx = null;
            self2.autoUnlock = true;
            self2._setup();
            return self2;
          },
          /**
           * Get/set the global volume for all sounds.
           * @param  {Float} vol Volume from 0.0 to 1.0.
           * @return {Howler/Float}     Returns self or current volume.
           */
          volume: function(vol) {
            var self2 = this || Howler14;
            vol = parseFloat(vol);
            if (!self2.ctx) {
              setupAudioContext();
            }
            if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
              self2._volume = vol;
              if (self2._muted) {
                return self2;
              }
              if (self2.usingWebAudio) {
                self2.masterGain.gain.setValueAtTime(vol, Howler14.ctx.currentTime);
              }
              for (var i = 0; i < self2._howls.length; i++) {
                if (!self2._howls[i]._webAudio) {
                  var ids = self2._howls[i]._getSoundIds();
                  for (var j = 0; j < ids.length; j++) {
                    var sound = self2._howls[i]._soundById(ids[j]);
                    if (sound && sound._node) {
                      sound._node.volume = sound._volume * vol;
                    }
                  }
                }
              }
              return self2;
            }
            return self2._volume;
          },
          /**
           * Handle muting and unmuting globally.
           * @param  {Boolean} muted Is muted or not.
           */
          mute: function(muted) {
            var self2 = this || Howler14;
            if (!self2.ctx) {
              setupAudioContext();
            }
            self2._muted = muted;
            if (self2.usingWebAudio) {
              self2.masterGain.gain.setValueAtTime(muted ? 0 : self2._volume, Howler14.ctx.currentTime);
            }
            for (var i = 0; i < self2._howls.length; i++) {
              if (!self2._howls[i]._webAudio) {
                var ids = self2._howls[i]._getSoundIds();
                for (var j = 0; j < ids.length; j++) {
                  var sound = self2._howls[i]._soundById(ids[j]);
                  if (sound && sound._node) {
                    sound._node.muted = muted ? true : sound._muted;
                  }
                }
              }
            }
            return self2;
          },
          /**
           * Handle stopping all sounds globally.
           */
          stop: function() {
            var self2 = this || Howler14;
            for (var i = 0; i < self2._howls.length; i++) {
              self2._howls[i].stop();
            }
            return self2;
          },
          /**
           * Unload and destroy all currently loaded Howl objects.
           * @return {Howler}
           */
          unload: function() {
            var self2 = this || Howler14;
            for (var i = self2._howls.length - 1; i >= 0; i--) {
              self2._howls[i].unload();
            }
            if (self2.usingWebAudio && self2.ctx && typeof self2.ctx.close !== "undefined") {
              self2.ctx.close();
              self2.ctx = null;
              setupAudioContext();
            }
            return self2;
          },
          /**
           * Check for codec support of specific extension.
           * @param  {String} ext Audio file extention.
           * @return {Boolean}
           */
          codecs: function(ext) {
            return (this || Howler14)._codecs[ext.replace(/^x-/, "")];
          },
          /**
           * Setup various state values for global tracking.
           * @return {Howler}
           */
          _setup: function() {
            var self2 = this || Howler14;
            self2.state = self2.ctx ? self2.ctx.state || "suspended" : "suspended";
            self2._autoSuspend();
            if (!self2.usingWebAudio) {
              if (typeof Audio !== "undefined") {
                try {
                  var test = new Audio();
                  if (typeof test.oncanplaythrough === "undefined") {
                    self2._canPlayEvent = "canplay";
                  }
                } catch (e) {
                  self2.noAudio = true;
                }
              } else {
                self2.noAudio = true;
              }
            }
            try {
              var test = new Audio();
              if (test.muted) {
                self2.noAudio = true;
              }
            } catch (e) {
            }
            if (!self2.noAudio) {
              self2._setupCodecs();
            }
            return self2;
          },
          /**
           * Check for browser support for various codecs and cache the results.
           * @return {Howler}
           */
          _setupCodecs: function() {
            var self2 = this || Howler14;
            var audioTest = null;
            try {
              audioTest = typeof Audio !== "undefined" ? new Audio() : null;
            } catch (err) {
              return self2;
            }
            if (!audioTest || typeof audioTest.canPlayType !== "function") {
              return self2;
            }
            var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
            var ua = self2._navigator ? self2._navigator.userAgent : "";
            var checkOpera = ua.match(/OPR\/(\d+)/g);
            var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
            var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
            var safariVersion = ua.match(/Version\/(.*?) /);
            var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
            self2._codecs = {
              mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
              mpeg: !!mpegTest,
              opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
              ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
              oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
              wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
              aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
              caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
              m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
              m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
              mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
              weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
              webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
              dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
              flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
            };
            return self2;
          },
          /**
           * Some browsers/devices will only allow audio to be played after a user interaction.
           * Attempt to automatically unlock audio on the first user interaction.
           * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
           * @return {Howler}
           */
          _unlockAudio: function() {
            var self2 = this || Howler14;
            if (self2._audioUnlocked || !self2.ctx) {
              return;
            }
            self2._audioUnlocked = false;
            self2.autoUnlock = false;
            if (!self2._mobileUnloaded && self2.ctx.sampleRate !== 44100) {
              self2._mobileUnloaded = true;
              self2.unload();
            }
            self2._scratchBuffer = self2.ctx.createBuffer(1, 1, 22050);
            var unlock = function(e) {
              while (self2._html5AudioPool.length < self2.html5PoolSize) {
                try {
                  var audioNode = new Audio();
                  audioNode._unlocked = true;
                  self2._releaseHtml5Audio(audioNode);
                } catch (e2) {
                  self2.noAudio = true;
                  break;
                }
              }
              for (var i = 0; i < self2._howls.length; i++) {
                if (!self2._howls[i]._webAudio) {
                  var ids = self2._howls[i]._getSoundIds();
                  for (var j = 0; j < ids.length; j++) {
                    var sound = self2._howls[i]._soundById(ids[j]);
                    if (sound && sound._node && !sound._node._unlocked) {
                      sound._node._unlocked = true;
                      sound._node.load();
                    }
                  }
                }
              }
              self2._autoResume();
              var source = self2.ctx.createBufferSource();
              source.buffer = self2._scratchBuffer;
              source.connect(self2.ctx.destination);
              if (typeof source.start === "undefined") {
                source.noteOn(0);
              } else {
                source.start(0);
              }
              if (typeof self2.ctx.resume === "function") {
                self2.ctx.resume();
              }
              source.onended = function() {
                source.disconnect(0);
                self2._audioUnlocked = true;
                document.removeEventListener("touchstart", unlock, true);
                document.removeEventListener("touchend", unlock, true);
                document.removeEventListener("click", unlock, true);
                document.removeEventListener("keydown", unlock, true);
                for (var i2 = 0; i2 < self2._howls.length; i2++) {
                  self2._howls[i2]._emit("unlock");
                }
              };
            };
            document.addEventListener("touchstart", unlock, true);
            document.addEventListener("touchend", unlock, true);
            document.addEventListener("click", unlock, true);
            document.addEventListener("keydown", unlock, true);
            return self2;
          },
          /**
           * Get an unlocked HTML5 Audio object from the pool. If none are left,
           * return a new Audio object and throw a warning.
           * @return {Audio} HTML5 Audio object.
           */
          _obtainHtml5Audio: function() {
            var self2 = this || Howler14;
            if (self2._html5AudioPool.length) {
              return self2._html5AudioPool.pop();
            }
            var testPlay = new Audio().play();
            if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
              testPlay.catch(function() {
                console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
              });
            }
            return new Audio();
          },
          /**
           * Return an activated HTML5 Audio object to the pool.
           * @return {Howler}
           */
          _releaseHtml5Audio: function(audio) {
            var self2 = this || Howler14;
            if (audio._unlocked) {
              self2._html5AudioPool.push(audio);
            }
            return self2;
          },
          /**
           * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
           * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
           * @return {Howler}
           */
          _autoSuspend: function() {
            var self2 = this;
            if (!self2.autoSuspend || !self2.ctx || typeof self2.ctx.suspend === "undefined" || !Howler14.usingWebAudio) {
              return;
            }
            for (var i = 0; i < self2._howls.length; i++) {
              if (self2._howls[i]._webAudio) {
                for (var j = 0; j < self2._howls[i]._sounds.length; j++) {
                  if (!self2._howls[i]._sounds[j]._paused) {
                    return self2;
                  }
                }
              }
            }
            if (self2._suspendTimer) {
              clearTimeout(self2._suspendTimer);
            }
            self2._suspendTimer = setTimeout(function() {
              if (!self2.autoSuspend) {
                return;
              }
              self2._suspendTimer = null;
              self2.state = "suspending";
              var handleSuspension = function() {
                self2.state = "suspended";
                if (self2._resumeAfterSuspend) {
                  delete self2._resumeAfterSuspend;
                  self2._autoResume();
                }
              };
              self2.ctx.suspend().then(handleSuspension, handleSuspension);
            }, 3e4);
            return self2;
          },
          /**
           * Automatically resume the Web Audio AudioContext when a new sound is played.
           * @return {Howler}
           */
          _autoResume: function() {
            var self2 = this;
            if (!self2.ctx || typeof self2.ctx.resume === "undefined" || !Howler14.usingWebAudio) {
              return;
            }
            if (self2.state === "running" && self2.ctx.state !== "interrupted" && self2._suspendTimer) {
              clearTimeout(self2._suspendTimer);
              self2._suspendTimer = null;
            } else if (self2.state === "suspended" || self2.state === "running" && self2.ctx.state === "interrupted") {
              self2.ctx.resume().then(function() {
                self2.state = "running";
                for (var i = 0; i < self2._howls.length; i++) {
                  self2._howls[i]._emit("resume");
                }
              });
              if (self2._suspendTimer) {
                clearTimeout(self2._suspendTimer);
                self2._suspendTimer = null;
              }
            } else if (self2.state === "suspending") {
              self2._resumeAfterSuspend = true;
            }
            return self2;
          }
        };
        var Howler14 = new HowlerGlobal2();
        var Howl4 = function(o) {
          var self2 = this;
          if (!o.src || o.src.length === 0) {
            console.error("An array of source files must be passed with any new Howl.");
            return;
          }
          self2.init(o);
        };
        Howl4.prototype = {
          /**
           * Initialize a new Howl group object.
           * @param  {Object} o Passed in properties for this group.
           * @return {Howl}
           */
          init: function(o) {
            var self2 = this;
            if (!Howler14.ctx) {
              setupAudioContext();
            }
            self2._autoplay = o.autoplay || false;
            self2._format = typeof o.format !== "string" ? o.format : [o.format];
            self2._html5 = o.html5 || false;
            self2._muted = o.mute || false;
            self2._loop = o.loop || false;
            self2._pool = o.pool || 5;
            self2._preload = typeof o.preload === "boolean" || o.preload === "metadata" ? o.preload : true;
            self2._rate = o.rate || 1;
            self2._sprite = o.sprite || {};
            self2._src = typeof o.src !== "string" ? o.src : [o.src];
            self2._volume = o.volume !== void 0 ? o.volume : 1;
            self2._xhr = {
              method: o.xhr && o.xhr.method ? o.xhr.method : "GET",
              headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
              withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false
            };
            self2._duration = 0;
            self2._state = "unloaded";
            self2._sounds = [];
            self2._endTimers = {};
            self2._queue = [];
            self2._playLock = false;
            self2._onend = o.onend ? [{ fn: o.onend }] : [];
            self2._onfade = o.onfade ? [{ fn: o.onfade }] : [];
            self2._onload = o.onload ? [{ fn: o.onload }] : [];
            self2._onloaderror = o.onloaderror ? [{ fn: o.onloaderror }] : [];
            self2._onplayerror = o.onplayerror ? [{ fn: o.onplayerror }] : [];
            self2._onpause = o.onpause ? [{ fn: o.onpause }] : [];
            self2._onplay = o.onplay ? [{ fn: o.onplay }] : [];
            self2._onstop = o.onstop ? [{ fn: o.onstop }] : [];
            self2._onmute = o.onmute ? [{ fn: o.onmute }] : [];
            self2._onvolume = o.onvolume ? [{ fn: o.onvolume }] : [];
            self2._onrate = o.onrate ? [{ fn: o.onrate }] : [];
            self2._onseek = o.onseek ? [{ fn: o.onseek }] : [];
            self2._onunlock = o.onunlock ? [{ fn: o.onunlock }] : [];
            self2._onresume = [];
            self2._webAudio = Howler14.usingWebAudio && !self2._html5;
            if (typeof Howler14.ctx !== "undefined" && Howler14.ctx && Howler14.autoUnlock) {
              Howler14._unlockAudio();
            }
            Howler14._howls.push(self2);
            if (self2._autoplay) {
              self2._queue.push({
                event: "play",
                action: function() {
                  self2.play();
                }
              });
            }
            if (self2._preload && self2._preload !== "none") {
              self2.load();
            }
            return self2;
          },
          /**
           * Load the audio file.
           * @return {Howler}
           */
          load: function() {
            var self2 = this;
            var url = null;
            if (Howler14.noAudio) {
              self2._emit("loaderror", null, "No audio support.");
              return;
            }
            if (typeof self2._src === "string") {
              self2._src = [self2._src];
            }
            for (var i = 0; i < self2._src.length; i++) {
              var ext, str8;
              if (self2._format && self2._format[i]) {
                ext = self2._format[i];
              } else {
                str8 = self2._src[i];
                if (typeof str8 !== "string") {
                  self2._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                  continue;
                }
                ext = /^data:audio\/([^;,]+);/i.exec(str8);
                if (!ext) {
                  ext = /\.([^.]+)$/.exec(str8.split("?", 1)[0]);
                }
                if (ext) {
                  ext = ext[1].toLowerCase();
                }
              }
              if (!ext) {
                console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
              }
              if (ext && Howler14.codecs(ext)) {
                url = self2._src[i];
                break;
              }
            }
            if (!url) {
              self2._emit("loaderror", null, "No codec support for selected audio sources.");
              return;
            }
            self2._src = url;
            self2._state = "loading";
            if (window.location.protocol === "https:" && url.slice(0, 5) === "http:") {
              self2._html5 = true;
              self2._webAudio = false;
            }
            new Sound2(self2);
            if (self2._webAudio) {
              loadBuffer(self2);
            }
            return self2;
          },
          /**
           * Play a sound or resume previous playback.
           * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
           * @param  {Boolean} internal Internal Use: true prevents event firing.
           * @return {Number}          Sound ID.
           */
          play: function(sprite, internal) {
            var self2 = this;
            var id = null;
            if (typeof sprite === "number") {
              id = sprite;
              sprite = null;
            } else if (typeof sprite === "string" && self2._state === "loaded" && !self2._sprite[sprite]) {
              return null;
            } else if (typeof sprite === "undefined") {
              sprite = "__default";
              if (!self2._playLock) {
                var num = 0;
                for (var i = 0; i < self2._sounds.length; i++) {
                  if (self2._sounds[i]._paused && !self2._sounds[i]._ended) {
                    num++;
                    id = self2._sounds[i]._id;
                  }
                }
                if (num === 1) {
                  sprite = null;
                } else {
                  id = null;
                }
              }
            }
            var sound = id ? self2._soundById(id) : self2._inactiveSound();
            if (!sound) {
              return null;
            }
            if (id && !sprite) {
              sprite = sound._sprite || "__default";
            }
            if (self2._state !== "loaded") {
              sound._sprite = sprite;
              sound._ended = false;
              var soundId = sound._id;
              self2._queue.push({
                event: "play",
                action: function() {
                  self2.play(soundId);
                }
              });
              return soundId;
            }
            if (id && !sound._paused) {
              if (!internal) {
                self2._loadQueue("play");
              }
              return sound._id;
            }
            if (self2._webAudio) {
              Howler14._autoResume();
            }
            var seek = Math.max(0, sound._seek > 0 ? sound._seek : self2._sprite[sprite][0] / 1e3);
            var duration = Math.max(0, (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3 - seek);
            var timeout = duration * 1e3 / Math.abs(sound._rate);
            var start = self2._sprite[sprite][0] / 1e3;
            var stop = (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3;
            sound._sprite = sprite;
            sound._ended = false;
            var setParams = function() {
              sound._paused = false;
              sound._seek = seek;
              sound._start = start;
              sound._stop = stop;
              sound._loop = !!(sound._loop || self2._sprite[sprite][2]);
            };
            if (seek >= stop) {
              self2._ended(sound);
              return;
            }
            var node = sound._node;
            if (self2._webAudio) {
              var playWebAudio = function() {
                self2._playLock = false;
                setParams();
                self2._refreshBuffer(sound);
                var vol = sound._muted || self2._muted ? 0 : sound._volume;
                node.gain.setValueAtTime(vol, Howler14.ctx.currentTime);
                sound._playStart = Howler14.ctx.currentTime;
                if (typeof node.bufferSource.start === "undefined") {
                  sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
                } else {
                  sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
                }
                if (timeout !== Infinity) {
                  self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
                }
                if (!internal) {
                  setTimeout(function() {
                    self2._emit("play", sound._id);
                    self2._loadQueue();
                  }, 0);
                }
              };
              if (Howler14.state === "running" && Howler14.ctx.state !== "interrupted") {
                playWebAudio();
              } else {
                self2._playLock = true;
                self2.once("resume", playWebAudio);
                self2._clearTimer(sound._id);
              }
            } else {
              var playHtml5 = function() {
                node.currentTime = seek;
                node.muted = sound._muted || self2._muted || Howler14._muted || node.muted;
                node.volume = sound._volume * Howler14.volume();
                node.playbackRate = sound._rate;
                try {
                  var play = node.play();
                  if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
                    self2._playLock = true;
                    setParams();
                    play.then(function() {
                      self2._playLock = false;
                      node._unlocked = true;
                      if (!internal) {
                        self2._emit("play", sound._id);
                      } else {
                        self2._loadQueue();
                      }
                    }).catch(function() {
                      self2._playLock = false;
                      self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                      sound._ended = true;
                      sound._paused = true;
                    });
                  } else if (!internal) {
                    self2._playLock = false;
                    setParams();
                    self2._emit("play", sound._id);
                  }
                  node.playbackRate = sound._rate;
                  if (node.paused) {
                    self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                    return;
                  }
                  if (sprite !== "__default" || sound._loop) {
                    self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
                  } else {
                    self2._endTimers[sound._id] = function() {
                      self2._ended(sound);
                      node.removeEventListener("ended", self2._endTimers[sound._id], false);
                    };
                    node.addEventListener("ended", self2._endTimers[sound._id], false);
                  }
                } catch (err) {
                  self2._emit("playerror", sound._id, err);
                }
              };
              if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
                node.src = self2._src;
                node.load();
              }
              var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler14._navigator.isCocoonJS;
              if (node.readyState >= 3 || loadedNoReadyState) {
                playHtml5();
              } else {
                self2._playLock = true;
                self2._state = "loading";
                var listener = function() {
                  self2._state = "loaded";
                  playHtml5();
                  node.removeEventListener(Howler14._canPlayEvent, listener, false);
                };
                node.addEventListener(Howler14._canPlayEvent, listener, false);
                self2._clearTimer(sound._id);
              }
            }
            return sound._id;
          },
          /**
           * Pause playback and save current position.
           * @param  {Number} id The sound ID (empty to pause all in group).
           * @return {Howl}
           */
          pause: function(id) {
            var self2 = this;
            if (self2._state !== "loaded" || self2._playLock) {
              self2._queue.push({
                event: "pause",
                action: function() {
                  self2.pause(id);
                }
              });
              return self2;
            }
            var ids = self2._getSoundIds(id);
            for (var i = 0; i < ids.length; i++) {
              self2._clearTimer(ids[i]);
              var sound = self2._soundById(ids[i]);
              if (sound && !sound._paused) {
                sound._seek = self2.seek(ids[i]);
                sound._rateSeek = 0;
                sound._paused = true;
                self2._stopFade(ids[i]);
                if (sound._node) {
                  if (self2._webAudio) {
                    if (!sound._node.bufferSource) {
                      continue;
                    }
                    if (typeof sound._node.bufferSource.stop === "undefined") {
                      sound._node.bufferSource.noteOff(0);
                    } else {
                      sound._node.bufferSource.stop(0);
                    }
                    self2._cleanBuffer(sound._node);
                  } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                    sound._node.pause();
                  }
                }
              }
              if (!arguments[1]) {
                self2._emit("pause", sound ? sound._id : null);
              }
            }
            return self2;
          },
          /**
           * Stop playback and reset to start.
           * @param  {Number} id The sound ID (empty to stop all in group).
           * @param  {Boolean} internal Internal Use: true prevents event firing.
           * @return {Howl}
           */
          stop: function(id, internal) {
            var self2 = this;
            if (self2._state !== "loaded" || self2._playLock) {
              self2._queue.push({
                event: "stop",
                action: function() {
                  self2.stop(id);
                }
              });
              return self2;
            }
            var ids = self2._getSoundIds(id);
            for (var i = 0; i < ids.length; i++) {
              self2._clearTimer(ids[i]);
              var sound = self2._soundById(ids[i]);
              if (sound) {
                sound._seek = sound._start || 0;
                sound._rateSeek = 0;
                sound._paused = true;
                sound._ended = true;
                self2._stopFade(ids[i]);
                if (sound._node) {
                  if (self2._webAudio) {
                    if (sound._node.bufferSource) {
                      if (typeof sound._node.bufferSource.stop === "undefined") {
                        sound._node.bufferSource.noteOff(0);
                      } else {
                        sound._node.bufferSource.stop(0);
                      }
                      self2._cleanBuffer(sound._node);
                    }
                  } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                    sound._node.currentTime = sound._start || 0;
                    sound._node.pause();
                    if (sound._node.duration === Infinity) {
                      self2._clearSound(sound._node);
                    }
                  }
                }
                if (!internal) {
                  self2._emit("stop", sound._id);
                }
              }
            }
            return self2;
          },
          /**
           * Mute/unmute a single sound or all sounds in this Howl group.
           * @param  {Boolean} muted Set to true to mute and false to unmute.
           * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
           * @return {Howl}
           */
          mute: function(muted, id) {
            var self2 = this;
            if (self2._state !== "loaded" || self2._playLock) {
              self2._queue.push({
                event: "mute",
                action: function() {
                  self2.mute(muted, id);
                }
              });
              return self2;
            }
            if (typeof id === "undefined") {
              if (typeof muted === "boolean") {
                self2._muted = muted;
              } else {
                return self2._muted;
              }
            }
            var ids = self2._getSoundIds(id);
            for (var i = 0; i < ids.length; i++) {
              var sound = self2._soundById(ids[i]);
              if (sound) {
                sound._muted = muted;
                if (sound._interval) {
                  self2._stopFade(sound._id);
                }
                if (self2._webAudio && sound._node) {
                  sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler14.ctx.currentTime);
                } else if (sound._node) {
                  sound._node.muted = Howler14._muted ? true : muted;
                }
                self2._emit("mute", sound._id);
              }
            }
            return self2;
          },
          /**
           * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
           *   volume() -> Returns the group's volume value.
           *   volume(id) -> Returns the sound id's current volume.
           *   volume(vol) -> Sets the volume of all sounds in this Howl group.
           *   volume(vol, id) -> Sets the volume of passed sound id.
           * @return {Howl/Number} Returns self or current volume.
           */
          volume: function() {
            var self2 = this;
            var args = arguments;
            var vol, id;
            if (args.length === 0) {
              return self2._volume;
            } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
              var ids = self2._getSoundIds();
              var index = ids.indexOf(args[0]);
              if (index >= 0) {
                id = parseInt(args[0], 10);
              } else {
                vol = parseFloat(args[0]);
              }
            } else if (args.length >= 2) {
              vol = parseFloat(args[0]);
              id = parseInt(args[1], 10);
            }
            var sound;
            if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
              if (self2._state !== "loaded" || self2._playLock) {
                self2._queue.push({
                  event: "volume",
                  action: function() {
                    self2.volume.apply(self2, args);
                  }
                });
                return self2;
              }
              if (typeof id === "undefined") {
                self2._volume = vol;
              }
              id = self2._getSoundIds(id);
              for (var i = 0; i < id.length; i++) {
                sound = self2._soundById(id[i]);
                if (sound) {
                  sound._volume = vol;
                  if (!args[2]) {
                    self2._stopFade(id[i]);
                  }
                  if (self2._webAudio && sound._node && !sound._muted) {
                    sound._node.gain.setValueAtTime(vol, Howler14.ctx.currentTime);
                  } else if (sound._node && !sound._muted) {
                    sound._node.volume = vol * Howler14.volume();
                  }
                  self2._emit("volume", sound._id);
                }
              }
            } else {
              sound = id ? self2._soundById(id) : self2._sounds[0];
              return sound ? sound._volume : 0;
            }
            return self2;
          },
          /**
           * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
           * @param  {Number} from The value to fade from (0.0 to 1.0).
           * @param  {Number} to   The volume to fade to (0.0 to 1.0).
           * @param  {Number} len  Time in milliseconds to fade.
           * @param  {Number} id   The sound id (omit to fade all sounds).
           * @return {Howl}
           */
          fade: function(from, to, len6, id) {
            var self2 = this;
            if (self2._state !== "loaded" || self2._playLock) {
              self2._queue.push({
                event: "fade",
                action: function() {
                  self2.fade(from, to, len6, id);
                }
              });
              return self2;
            }
            from = Math.min(Math.max(0, parseFloat(from)), 1);
            to = Math.min(Math.max(0, parseFloat(to)), 1);
            len6 = parseFloat(len6);
            self2.volume(from, id);
            var ids = self2._getSoundIds(id);
            for (var i = 0; i < ids.length; i++) {
              var sound = self2._soundById(ids[i]);
              if (sound) {
                if (!id) {
                  self2._stopFade(ids[i]);
                }
                if (self2._webAudio && !sound._muted) {
                  var currentTime = Howler14.ctx.currentTime;
                  var end = currentTime + len6 / 1e3;
                  sound._volume = from;
                  sound._node.gain.setValueAtTime(from, currentTime);
                  sound._node.gain.linearRampToValueAtTime(to, end);
                }
                self2._startFadeInterval(sound, from, to, len6, ids[i], typeof id === "undefined");
              }
            }
            return self2;
          },
          /**
           * Starts the internal interval to fade a sound.
           * @param  {Object} sound Reference to sound to fade.
           * @param  {Number} from The value to fade from (0.0 to 1.0).
           * @param  {Number} to   The volume to fade to (0.0 to 1.0).
           * @param  {Number} len  Time in milliseconds to fade.
           * @param  {Number} id   The sound id to fade.
           * @param  {Boolean} isGroup   If true, set the volume on the group.
           */
          _startFadeInterval: function(sound, from, to, len6, id, isGroup) {
            var self2 = this;
            var vol = from;
            var diff = to - from;
            var steps = Math.abs(diff / 0.01);
            var stepLen = Math.max(4, steps > 0 ? len6 / steps : len6);
            var lastTick = Date.now();
            sound._fadeTo = to;
            sound._interval = setInterval(function() {
              var tick = (Date.now() - lastTick) / len6;
              lastTick = Date.now();
              vol += diff * tick;
              vol = Math.round(vol * 100) / 100;
              if (diff < 0) {
                vol = Math.max(to, vol);
              } else {
                vol = Math.min(to, vol);
              }
              if (self2._webAudio) {
                sound._volume = vol;
              } else {
                self2.volume(vol, sound._id, true);
              }
              if (isGroup) {
                self2._volume = vol;
              }
              if (to < from && vol <= to || to > from && vol >= to) {
                clearInterval(sound._interval);
                sound._interval = null;
                sound._fadeTo = null;
                self2.volume(to, sound._id);
                self2._emit("fade", sound._id);
              }
            }, stepLen);
          },
          /**
           * Internal method that stops the currently playing fade when
           * a new fade starts, volume is changed or the sound is stopped.
           * @param  {Number} id The sound id.
           * @return {Howl}
           */
          _stopFade: function(id) {
            var self2 = this;
            var sound = self2._soundById(id);
            if (sound && sound._interval) {
              if (self2._webAudio) {
                sound._node.gain.cancelScheduledValues(Howler14.ctx.currentTime);
              }
              clearInterval(sound._interval);
              sound._interval = null;
              self2.volume(sound._fadeTo, id);
              sound._fadeTo = null;
              self2._emit("fade", id);
            }
            return self2;
          },
          /**
           * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
           *   loop() -> Returns the group's loop value.
           *   loop(id) -> Returns the sound id's loop value.
           *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
           *   loop(loop, id) -> Sets the loop value of passed sound id.
           * @return {Howl/Boolean} Returns self or current loop value.
           */
          loop: function() {
            var self2 = this;
            var args = arguments;
            var loop, id, sound;
            if (args.length === 0) {
              return self2._loop;
            } else if (args.length === 1) {
              if (typeof args[0] === "boolean") {
                loop = args[0];
                self2._loop = loop;
              } else {
                sound = self2._soundById(parseInt(args[0], 10));
                return sound ? sound._loop : false;
              }
            } else if (args.length === 2) {
              loop = args[0];
              id = parseInt(args[1], 10);
            }
            var ids = self2._getSoundIds(id);
            for (var i = 0; i < ids.length; i++) {
              sound = self2._soundById(ids[i]);
              if (sound) {
                sound._loop = loop;
                if (self2._webAudio && sound._node && sound._node.bufferSource) {
                  sound._node.bufferSource.loop = loop;
                  if (loop) {
                    sound._node.bufferSource.loopStart = sound._start || 0;
                    sound._node.bufferSource.loopEnd = sound._stop;
                    if (self2.playing(ids[i])) {
                      self2.pause(ids[i], true);
                      self2.play(ids[i], true);
                    }
                  }
                }
              }
            }
            return self2;
          },
          /**
           * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
           *   rate() -> Returns the first sound node's current playback rate.
           *   rate(id) -> Returns the sound id's current playback rate.
           *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
           *   rate(rate, id) -> Sets the playback rate of passed sound id.
           * @return {Howl/Number} Returns self or the current playback rate.
           */
          rate: function() {
            var self2 = this;
            var args = arguments;
            var rate, id;
            if (args.length === 0) {
              id = self2._sounds[0]._id;
            } else if (args.length === 1) {
              var ids = self2._getSoundIds();
              var index = ids.indexOf(args[0]);
              if (index >= 0) {
                id = parseInt(args[0], 10);
              } else {
                rate = parseFloat(args[0]);
              }
            } else if (args.length === 2) {
              rate = parseFloat(args[0]);
              id = parseInt(args[1], 10);
            }
            var sound;
            if (typeof rate === "number") {
              if (self2._state !== "loaded" || self2._playLock) {
                self2._queue.push({
                  event: "rate",
                  action: function() {
                    self2.rate.apply(self2, args);
                  }
                });
                return self2;
              }
              if (typeof id === "undefined") {
                self2._rate = rate;
              }
              id = self2._getSoundIds(id);
              for (var i = 0; i < id.length; i++) {
                sound = self2._soundById(id[i]);
                if (sound) {
                  if (self2.playing(id[i])) {
                    sound._rateSeek = self2.seek(id[i]);
                    sound._playStart = self2._webAudio ? Howler14.ctx.currentTime : sound._playStart;
                  }
                  sound._rate = rate;
                  if (self2._webAudio && sound._node && sound._node.bufferSource) {
                    sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler14.ctx.currentTime);
                  } else if (sound._node) {
                    sound._node.playbackRate = rate;
                  }
                  var seek = self2.seek(id[i]);
                  var duration = (self2._sprite[sound._sprite][0] + self2._sprite[sound._sprite][1]) / 1e3 - seek;
                  var timeout = duration * 1e3 / Math.abs(sound._rate);
                  if (self2._endTimers[id[i]] || !sound._paused) {
                    self2._clearTimer(id[i]);
                    self2._endTimers[id[i]] = setTimeout(self2._ended.bind(self2, sound), timeout);
                  }
                  self2._emit("rate", sound._id);
                }
              }
            } else {
              sound = self2._soundById(id);
              return sound ? sound._rate : self2._rate;
            }
            return self2;
          },
          /**
           * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
           *   seek() -> Returns the first sound node's current seek position.
           *   seek(id) -> Returns the sound id's current seek position.
           *   seek(seek) -> Sets the seek position of the first sound node.
           *   seek(seek, id) -> Sets the seek position of passed sound id.
           * @return {Howl/Number} Returns self or the current seek position.
           */
          seek: function() {
            var self2 = this;
            var args = arguments;
            var seek, id;
            if (args.length === 0) {
              if (self2._sounds.length) {
                id = self2._sounds[0]._id;
              }
            } else if (args.length === 1) {
              var ids = self2._getSoundIds();
              var index = ids.indexOf(args[0]);
              if (index >= 0) {
                id = parseInt(args[0], 10);
              } else if (self2._sounds.length) {
                id = self2._sounds[0]._id;
                seek = parseFloat(args[0]);
              }
            } else if (args.length === 2) {
              seek = parseFloat(args[0]);
              id = parseInt(args[1], 10);
            }
            if (typeof id === "undefined") {
              return 0;
            }
            if (typeof seek === "number" && (self2._state !== "loaded" || self2._playLock)) {
              self2._queue.push({
                event: "seek",
                action: function() {
                  self2.seek.apply(self2, args);
                }
              });
              return self2;
            }
            var sound = self2._soundById(id);
            if (sound) {
              if (typeof seek === "number" && seek >= 0) {
                var playing = self2.playing(id);
                if (playing) {
                  self2.pause(id, true);
                }
                sound._seek = seek;
                sound._ended = false;
                self2._clearTimer(id);
                if (!self2._webAudio && sound._node && !isNaN(sound._node.duration)) {
                  sound._node.currentTime = seek;
                }
                var seekAndEmit = function() {
                  if (playing) {
                    self2.play(id, true);
                  }
                  self2._emit("seek", id);
                };
                if (playing && !self2._webAudio) {
                  var emitSeek = function() {
                    if (!self2._playLock) {
                      seekAndEmit();
                    } else {
                      setTimeout(emitSeek, 0);
                    }
                  };
                  setTimeout(emitSeek, 0);
                } else {
                  seekAndEmit();
                }
              } else {
                if (self2._webAudio) {
                  var realTime = self2.playing(id) ? Howler14.ctx.currentTime - sound._playStart : 0;
                  var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
                  return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
                } else {
                  return sound._node.currentTime;
                }
              }
            }
            return self2;
          },
          /**
           * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
           * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
           * @return {Boolean} True if playing and false if not.
           */
          playing: function(id) {
            var self2 = this;
            if (typeof id === "number") {
              var sound = self2._soundById(id);
              return sound ? !sound._paused : false;
            }
            for (var i = 0; i < self2._sounds.length; i++) {
              if (!self2._sounds[i]._paused) {
                return true;
              }
            }
            return false;
          },
          /**
           * Get the duration of this sound. Passing a sound id will return the sprite duration.
           * @param  {Number} id The sound id to check. If none is passed, return full source duration.
           * @return {Number} Audio duration in seconds.
           */
          duration: function(id) {
            var self2 = this;
            var duration = self2._duration;
            var sound = self2._soundById(id);
            if (sound) {
              duration = self2._sprite[sound._sprite][1] / 1e3;
            }
            return duration;
          },
          /**
           * Returns the current loaded state of this Howl.
           * @return {String} 'unloaded', 'loading', 'loaded'
           */
          state: function() {
            return this._state;
          },
          /**
           * Unload and destroy the current Howl object.
           * This will immediately stop all sound instances attached to this group.
           */
          unload: function() {
            var self2 = this;
            var sounds = self2._sounds;
            for (var i = 0; i < sounds.length; i++) {
              if (!sounds[i]._paused) {
                self2.stop(sounds[i]._id);
              }
              if (!self2._webAudio) {
                self2._clearSound(sounds[i]._node);
                sounds[i]._node.removeEventListener("error", sounds[i]._errorFn, false);
                sounds[i]._node.removeEventListener(Howler14._canPlayEvent, sounds[i]._loadFn, false);
                sounds[i]._node.removeEventListener("ended", sounds[i]._endFn, false);
                Howler14._releaseHtml5Audio(sounds[i]._node);
              }
              delete sounds[i]._node;
              self2._clearTimer(sounds[i]._id);
            }
            var index = Howler14._howls.indexOf(self2);
            if (index >= 0) {
              Howler14._howls.splice(index, 1);
            }
            var remCache = true;
            for (i = 0; i < Howler14._howls.length; i++) {
              if (Howler14._howls[i]._src === self2._src || self2._src.indexOf(Howler14._howls[i]._src) >= 0) {
                remCache = false;
                break;
              }
            }
            if (cache && remCache) {
              delete cache[self2._src];
            }
            Howler14.noAudio = false;
            self2._state = "unloaded";
            self2._sounds = [];
            self2 = null;
            return null;
          },
          /**
           * Listen to a custom event.
           * @param  {String}   event Event name.
           * @param  {Function} fn    Listener to call.
           * @param  {Number}   id    (optional) Only listen to events for this sound.
           * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
           * @return {Howl}
           */
          on: function(event, fn, id, once) {
            var self2 = this;
            var events = self2["_on" + event];
            if (typeof fn === "function") {
              events.push(once ? { id, fn, once } : { id, fn });
            }
            return self2;
          },
          /**
           * Remove a custom event. Call without parameters to remove all events.
           * @param  {String}   event Event name.
           * @param  {Function} fn    Listener to remove. Leave empty to remove all.
           * @param  {Number}   id    (optional) Only remove events for this sound.
           * @return {Howl}
           */
          off: function(event, fn, id) {
            var self2 = this;
            var events = self2["_on" + event];
            var i = 0;
            if (typeof fn === "number") {
              id = fn;
              fn = null;
            }
            if (fn || id) {
              for (i = 0; i < events.length; i++) {
                var isId = id === events[i].id;
                if (fn === events[i].fn && isId || !fn && isId) {
                  events.splice(i, 1);
                  break;
                }
              }
            } else if (event) {
              self2["_on" + event] = [];
            } else {
              var keys = Object.keys(self2);
              for (i = 0; i < keys.length; i++) {
                if (keys[i].indexOf("_on") === 0 && Array.isArray(self2[keys[i]])) {
                  self2[keys[i]] = [];
                }
              }
            }
            return self2;
          },
          /**
           * Listen to a custom event and remove it once fired.
           * @param  {String}   event Event name.
           * @param  {Function} fn    Listener to call.
           * @param  {Number}   id    (optional) Only listen to events for this sound.
           * @return {Howl}
           */
          once: function(event, fn, id) {
            var self2 = this;
            self2.on(event, fn, id, 1);
            return self2;
          },
          /**
           * Emit all events of a specific type and pass the sound id.
           * @param  {String} event Event name.
           * @param  {Number} id    Sound ID.
           * @param  {Number} msg   Message to go with event.
           * @return {Howl}
           */
          _emit: function(event, id, msg) {
            var self2 = this;
            var events = self2["_on" + event];
            for (var i = events.length - 1; i >= 0; i--) {
              if (!events[i].id || events[i].id === id || event === "load") {
                setTimeout(function(fn) {
                  fn.call(this, id, msg);
                }.bind(self2, events[i].fn), 0);
                if (events[i].once) {
                  self2.off(event, events[i].fn, events[i].id);
                }
              }
            }
            self2._loadQueue(event);
            return self2;
          },
          /**
           * Queue of actions initiated before the sound has loaded.
           * These will be called in sequence, with the next only firing
           * after the previous has finished executing (even if async like play).
           * @return {Howl}
           */
          _loadQueue: function(event) {
            var self2 = this;
            if (self2._queue.length > 0) {
              var task = self2._queue[0];
              if (task.event === event) {
                self2._queue.shift();
                self2._loadQueue();
              }
              if (!event) {
                task.action();
              }
            }
            return self2;
          },
          /**
           * Fired when playback ends at the end of the duration.
           * @param  {Sound} sound The sound object to work with.
           * @return {Howl}
           */
          _ended: function(sound) {
            var self2 = this;
            var sprite = sound._sprite;
            if (!self2._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
              setTimeout(self2._ended.bind(self2, sound), 100);
              return self2;
            }
            var loop = !!(sound._loop || self2._sprite[sprite][2]);
            self2._emit("end", sound._id);
            if (!self2._webAudio && loop) {
              self2.stop(sound._id, true).play(sound._id);
            }
            if (self2._webAudio && loop) {
              self2._emit("play", sound._id);
              sound._seek = sound._start || 0;
              sound._rateSeek = 0;
              sound._playStart = Howler14.ctx.currentTime;
              var timeout = (sound._stop - sound._start) * 1e3 / Math.abs(sound._rate);
              self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
            }
            if (self2._webAudio && !loop) {
              sound._paused = true;
              sound._ended = true;
              sound._seek = sound._start || 0;
              sound._rateSeek = 0;
              self2._clearTimer(sound._id);
              self2._cleanBuffer(sound._node);
              Howler14._autoSuspend();
            }
            if (!self2._webAudio && !loop) {
              self2.stop(sound._id, true);
            }
            return self2;
          },
          /**
           * Clear the end timer for a sound playback.
           * @param  {Number} id The sound ID.
           * @return {Howl}
           */
          _clearTimer: function(id) {
            var self2 = this;
            if (self2._endTimers[id]) {
              if (typeof self2._endTimers[id] !== "function") {
                clearTimeout(self2._endTimers[id]);
              } else {
                var sound = self2._soundById(id);
                if (sound && sound._node) {
                  sound._node.removeEventListener("ended", self2._endTimers[id], false);
                }
              }
              delete self2._endTimers[id];
            }
            return self2;
          },
          /**
           * Return the sound identified by this ID, or return null.
           * @param  {Number} id Sound ID
           * @return {Object}    Sound object or null.
           */
          _soundById: function(id) {
            var self2 = this;
            for (var i = 0; i < self2._sounds.length; i++) {
              if (id === self2._sounds[i]._id) {
                return self2._sounds[i];
              }
            }
            return null;
          },
          /**
           * Return an inactive sound from the pool or create a new one.
           * @return {Sound} Sound playback object.
           */
          _inactiveSound: function() {
            var self2 = this;
            self2._drain();
            for (var i = 0; i < self2._sounds.length; i++) {
              if (self2._sounds[i]._ended) {
                return self2._sounds[i].reset();
              }
            }
            return new Sound2(self2);
          },
          /**
           * Drain excess inactive sounds from the pool.
           */
          _drain: function() {
            var self2 = this;
            var limit = self2._pool;
            var cnt = 0;
            var i = 0;
            if (self2._sounds.length < limit) {
              return;
            }
            for (i = 0; i < self2._sounds.length; i++) {
              if (self2._sounds[i]._ended) {
                cnt++;
              }
            }
            for (i = self2._sounds.length - 1; i >= 0; i--) {
              if (cnt <= limit) {
                return;
              }
              if (self2._sounds[i]._ended) {
                if (self2._webAudio && self2._sounds[i]._node) {
                  self2._sounds[i]._node.disconnect(0);
                }
                self2._sounds.splice(i, 1);
                cnt--;
              }
            }
          },
          /**
           * Get all ID's from the sounds pool.
           * @param  {Number} id Only return one ID if one is passed.
           * @return {Array}    Array of IDs.
           */
          _getSoundIds: function(id) {
            var self2 = this;
            if (typeof id === "undefined") {
              var ids = [];
              for (var i = 0; i < self2._sounds.length; i++) {
                ids.push(self2._sounds[i]._id);
              }
              return ids;
            } else {
              return [id];
            }
          },
          /**
           * Load the sound back into the buffer source.
           * @param  {Sound} sound The sound object to work with.
           * @return {Howl}
           */
          _refreshBuffer: function(sound) {
            var self2 = this;
            sound._node.bufferSource = Howler14.ctx.createBufferSource();
            sound._node.bufferSource.buffer = cache[self2._src];
            if (sound._panner) {
              sound._node.bufferSource.connect(sound._panner);
            } else {
              sound._node.bufferSource.connect(sound._node);
            }
            sound._node.bufferSource.loop = sound._loop;
            if (sound._loop) {
              sound._node.bufferSource.loopStart = sound._start || 0;
              sound._node.bufferSource.loopEnd = sound._stop || 0;
            }
            sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler14.ctx.currentTime);
            return self2;
          },
          /**
           * Prevent memory leaks by cleaning up the buffer source after playback.
           * @param  {Object} node Sound's audio node containing the buffer source.
           * @return {Howl}
           */
          _cleanBuffer: function(node) {
            var self2 = this;
            var isIOS = Howler14._navigator && Howler14._navigator.vendor.indexOf("Apple") >= 0;
            if (!node.bufferSource) {
              return self2;
            }
            if (Howler14._scratchBuffer && node.bufferSource) {
              node.bufferSource.onended = null;
              node.bufferSource.disconnect(0);
              if (isIOS) {
                try {
                  node.bufferSource.buffer = Howler14._scratchBuffer;
                } catch (e) {
                }
              }
            }
            node.bufferSource = null;
            return self2;
          },
          /**
           * Set the source to a 0-second silence to stop any downloading (except in IE).
           * @param  {Object} node Audio node to clear.
           */
          _clearSound: function(node) {
            var checkIE = /MSIE |Trident\//.test(Howler14._navigator && Howler14._navigator.userAgent);
            if (!checkIE) {
              node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
            }
          }
        };
        var Sound2 = function(howl) {
          this._parent = howl;
          this.init();
        };
        Sound2.prototype = {
          /**
           * Initialize a new Sound object.
           * @return {Sound}
           */
          init: function() {
            var self2 = this;
            var parent = self2._parent;
            self2._muted = parent._muted;
            self2._loop = parent._loop;
            self2._volume = parent._volume;
            self2._rate = parent._rate;
            self2._seek = 0;
            self2._paused = true;
            self2._ended = true;
            self2._sprite = "__default";
            self2._id = ++Howler14._counter;
            parent._sounds.push(self2);
            self2.create();
            return self2;
          },
          /**
           * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
           * @return {Sound}
           */
          create: function() {
            var self2 = this;
            var parent = self2._parent;
            var volume = Howler14._muted || self2._muted || self2._parent._muted ? 0 : self2._volume;
            if (parent._webAudio) {
              self2._node = typeof Howler14.ctx.createGain === "undefined" ? Howler14.ctx.createGainNode() : Howler14.ctx.createGain();
              self2._node.gain.setValueAtTime(volume, Howler14.ctx.currentTime);
              self2._node.paused = true;
              self2._node.connect(Howler14.masterGain);
            } else if (!Howler14.noAudio) {
              self2._node = Howler14._obtainHtml5Audio();
              self2._errorFn = self2._errorListener.bind(self2);
              self2._node.addEventListener("error", self2._errorFn, false);
              self2._loadFn = self2._loadListener.bind(self2);
              self2._node.addEventListener(Howler14._canPlayEvent, self2._loadFn, false);
              self2._endFn = self2._endListener.bind(self2);
              self2._node.addEventListener("ended", self2._endFn, false);
              self2._node.src = parent._src;
              self2._node.preload = parent._preload === true ? "auto" : parent._preload;
              self2._node.volume = volume * Howler14.volume();
              self2._node.load();
            }
            return self2;
          },
          /**
           * Reset the parameters of this sound to the original state (for recycle).
           * @return {Sound}
           */
          reset: function() {
            var self2 = this;
            var parent = self2._parent;
            self2._muted = parent._muted;
            self2._loop = parent._loop;
            self2._volume = parent._volume;
            self2._rate = parent._rate;
            self2._seek = 0;
            self2._rateSeek = 0;
            self2._paused = true;
            self2._ended = true;
            self2._sprite = "__default";
            self2._id = ++Howler14._counter;
            return self2;
          },
          /**
           * HTML5 Audio error listener callback.
           */
          _errorListener: function() {
            var self2 = this;
            self2._parent._emit("loaderror", self2._id, self2._node.error ? self2._node.error.code : 0);
            self2._node.removeEventListener("error", self2._errorFn, false);
          },
          /**
           * HTML5 Audio canplaythrough listener callback.
           */
          _loadListener: function() {
            var self2 = this;
            var parent = self2._parent;
            parent._duration = Math.ceil(self2._node.duration * 10) / 10;
            if (Object.keys(parent._sprite).length === 0) {
              parent._sprite = { __default: [0, parent._duration * 1e3] };
            }
            if (parent._state !== "loaded") {
              parent._state = "loaded";
              parent._emit("load");
              parent._loadQueue();
            }
            self2._node.removeEventListener(Howler14._canPlayEvent, self2._loadFn, false);
          },
          /**
           * HTML5 Audio ended listener callback.
           */
          _endListener: function() {
            var self2 = this;
            var parent = self2._parent;
            if (parent._duration === Infinity) {
              parent._duration = Math.ceil(self2._node.duration * 10) / 10;
              if (parent._sprite.__default[1] === Infinity) {
                parent._sprite.__default[1] = parent._duration * 1e3;
              }
              parent._ended(self2);
            }
            self2._node.removeEventListener("ended", self2._endFn, false);
          }
        };
        var cache = {};
        var loadBuffer = function(self2) {
          var url = self2._src;
          if (cache[url]) {
            self2._duration = cache[url].duration;
            loadSound(self2);
            return;
          }
          if (/^data:[^;]+;base64,/.test(url)) {
            var data = atob(url.split(",")[1]);
            var dataView = new Uint8Array(data.length);
            for (var i = 0; i < data.length; ++i) {
              dataView[i] = data.charCodeAt(i);
            }
            decodeAudioData(dataView.buffer, self2);
          } else {
            var xhr = new XMLHttpRequest();
            xhr.open(self2._xhr.method, url, true);
            xhr.withCredentials = self2._xhr.withCredentials;
            xhr.responseType = "arraybuffer";
            if (self2._xhr.headers) {
              Object.keys(self2._xhr.headers).forEach(function(key) {
                xhr.setRequestHeader(key, self2._xhr.headers[key]);
              });
            }
            xhr.onload = function() {
              var code = (xhr.status + "")[0];
              if (code !== "0" && code !== "2" && code !== "3") {
                self2._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
                return;
              }
              decodeAudioData(xhr.response, self2);
            };
            xhr.onerror = function() {
              if (self2._webAudio) {
                self2._html5 = true;
                self2._webAudio = false;
                self2._sounds = [];
                delete cache[url];
                self2.load();
              }
            };
            safeXhrSend(xhr);
          }
        };
        var safeXhrSend = function(xhr) {
          try {
            xhr.send();
          } catch (e) {
            xhr.onerror();
          }
        };
        var decodeAudioData = function(arraybuffer, self2) {
          var error = function() {
            self2._emit("loaderror", null, "Decoding audio data failed.");
          };
          var success = function(buffer) {
            if (buffer && self2._sounds.length > 0) {
              cache[self2._src] = buffer;
              loadSound(self2, buffer);
            } else {
              error();
            }
          };
          if (typeof Promise !== "undefined" && Howler14.ctx.decodeAudioData.length === 1) {
            Howler14.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
          } else {
            Howler14.ctx.decodeAudioData(arraybuffer, success, error);
          }
        };
        var loadSound = function(self2, buffer) {
          if (buffer && !self2._duration) {
            self2._duration = buffer.duration;
          }
          if (Object.keys(self2._sprite).length === 0) {
            self2._sprite = { __default: [0, self2._duration * 1e3] };
          }
          if (self2._state !== "loaded") {
            self2._state = "loaded";
            self2._emit("load");
            self2._loadQueue();
          }
        };
        var setupAudioContext = function() {
          if (!Howler14.usingWebAudio) {
            return;
          }
          try {
            if (typeof AudioContext !== "undefined") {
              Howler14.ctx = new AudioContext();
            } else if (typeof webkitAudioContext !== "undefined") {
              Howler14.ctx = new webkitAudioContext();
            } else {
              Howler14.usingWebAudio = false;
            }
          } catch (e) {
            Howler14.usingWebAudio = false;
          }
          if (!Howler14.ctx) {
            Howler14.usingWebAudio = false;
          }
          var iOS = /iP(hone|od|ad)/.test(Howler14._navigator && Howler14._navigator.platform);
          var appVersion = Howler14._navigator && Howler14._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
          var version = appVersion ? parseInt(appVersion[1], 10) : null;
          if (iOS && version && version < 9) {
            var safari = /safari/.test(Howler14._navigator && Howler14._navigator.userAgent.toLowerCase());
            if (Howler14._navigator && !safari) {
              Howler14.usingWebAudio = false;
            }
          }
          if (Howler14.usingWebAudio) {
            Howler14.masterGain = typeof Howler14.ctx.createGain === "undefined" ? Howler14.ctx.createGainNode() : Howler14.ctx.createGain();
            Howler14.masterGain.gain.setValueAtTime(Howler14._muted ? 0 : Howler14._volume, Howler14.ctx.currentTime);
            Howler14.masterGain.connect(Howler14.ctx.destination);
          }
          Howler14._setup();
        };
        if (typeof define === "function" && define.amd) {
          define([], function() {
            return {
              Howler: Howler14,
              Howl: Howl4
            };
          });
        }
        if (typeof exports !== "undefined") {
          exports.Howler = Howler14;
          exports.Howl = Howl4;
        }
        if (typeof global !== "undefined") {
          global.HowlerGlobal = HowlerGlobal2;
          global.Howler = Howler14;
          global.Howl = Howl4;
          global.Sound = Sound2;
        } else if (typeof window !== "undefined") {
          window.HowlerGlobal = HowlerGlobal2;
          window.Howler = Howler14;
          window.Howl = Howl4;
          window.Sound = Sound2;
        }
      })();
      (function() {
        "use strict";
        HowlerGlobal.prototype._pos = [0, 0, 0];
        HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
        HowlerGlobal.prototype.stereo = function(pan) {
          var self2 = this;
          if (!self2.ctx || !self2.ctx.listener) {
            return self2;
          }
          for (var i = self2._howls.length - 1; i >= 0; i--) {
            self2._howls[i].stereo(pan);
          }
          return self2;
        };
        HowlerGlobal.prototype.pos = function(x, y, z) {
          var self2 = this;
          if (!self2.ctx || !self2.ctx.listener) {
            return self2;
          }
          y = typeof y !== "number" ? self2._pos[1] : y;
          z = typeof z !== "number" ? self2._pos[2] : z;
          if (typeof x === "number") {
            self2._pos = [x, y, z];
            if (typeof self2.ctx.listener.positionX !== "undefined") {
              self2.ctx.listener.positionX.setTargetAtTime(self2._pos[0], Howler.ctx.currentTime, 0.1);
              self2.ctx.listener.positionY.setTargetAtTime(self2._pos[1], Howler.ctx.currentTime, 0.1);
              self2.ctx.listener.positionZ.setTargetAtTime(self2._pos[2], Howler.ctx.currentTime, 0.1);
            } else {
              self2.ctx.listener.setPosition(self2._pos[0], self2._pos[1], self2._pos[2]);
            }
          } else {
            return self2._pos;
          }
          return self2;
        };
        HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
          var self2 = this;
          if (!self2.ctx || !self2.ctx.listener) {
            return self2;
          }
          var or = self2._orientation;
          y = typeof y !== "number" ? or[1] : y;
          z = typeof z !== "number" ? or[2] : z;
          xUp = typeof xUp !== "number" ? or[3] : xUp;
          yUp = typeof yUp !== "number" ? or[4] : yUp;
          zUp = typeof zUp !== "number" ? or[5] : zUp;
          if (typeof x === "number") {
            self2._orientation = [x, y, z, xUp, yUp, zUp];
            if (typeof self2.ctx.listener.forwardX !== "undefined") {
              self2.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
              self2.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
              self2.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
              self2.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
              self2.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
              self2.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
            } else {
              self2.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
            }
          } else {
            return or;
          }
          return self2;
        };
        Howl.prototype.init = function(_super) {
          return function(o) {
            var self2 = this;
            self2._orientation = o.orientation || [1, 0, 0];
            self2._stereo = o.stereo || null;
            self2._pos = o.pos || null;
            self2._pannerAttr = {
              coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : 360,
              coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : 360,
              coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : 0,
              distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : "inverse",
              maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : 1e4,
              panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : "HRTF",
              refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : 1,
              rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : 1
            };
            self2._onstereo = o.onstereo ? [{ fn: o.onstereo }] : [];
            self2._onpos = o.onpos ? [{ fn: o.onpos }] : [];
            self2._onorientation = o.onorientation ? [{ fn: o.onorientation }] : [];
            return _super.call(this, o);
          };
        }(Howl.prototype.init);
        Howl.prototype.stereo = function(pan, id) {
          var self2 = this;
          if (!self2._webAudio) {
            return self2;
          }
          if (self2._state !== "loaded") {
            self2._queue.push({
              event: "stereo",
              action: function() {
                self2.stereo(pan, id);
              }
            });
            return self2;
          }
          var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
          if (typeof id === "undefined") {
            if (typeof pan === "number") {
              self2._stereo = pan;
              self2._pos = [pan, 0, 0];
            } else {
              return self2._stereo;
            }
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            var sound = self2._soundById(ids[i]);
            if (sound) {
              if (typeof pan === "number") {
                sound._stereo = pan;
                sound._pos = [pan, 0, 0];
                if (sound._node) {
                  sound._pannerAttr.panningModel = "equalpower";
                  if (!sound._panner || !sound._panner.pan) {
                    setupPanner(sound, pannerType);
                  }
                  if (pannerType === "spatial") {
                    if (typeof sound._panner.positionX !== "undefined") {
                      sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                      sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                      sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                    } else {
                      sound._panner.setPosition(pan, 0, 0);
                    }
                  } else {
                    sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
                  }
                }
                self2._emit("stereo", sound._id);
              } else {
                return sound._stereo;
              }
            }
          }
          return self2;
        };
        Howl.prototype.pos = function(x, y, z, id) {
          var self2 = this;
          if (!self2._webAudio) {
            return self2;
          }
          if (self2._state !== "loaded") {
            self2._queue.push({
              event: "pos",
              action: function() {
                self2.pos(x, y, z, id);
              }
            });
            return self2;
          }
          y = typeof y !== "number" ? 0 : y;
          z = typeof z !== "number" ? -0.5 : z;
          if (typeof id === "undefined") {
            if (typeof x === "number") {
              self2._pos = [x, y, z];
            } else {
              return self2._pos;
            }
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            var sound = self2._soundById(ids[i]);
            if (sound) {
              if (typeof x === "number") {
                sound._pos = [x, y, z];
                if (sound._node) {
                  if (!sound._panner || sound._panner.pan) {
                    setupPanner(sound, "spatial");
                  }
                  if (typeof sound._panner.positionX !== "undefined") {
                    sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
                    sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
                    sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
                  } else {
                    sound._panner.setPosition(x, y, z);
                  }
                }
                self2._emit("pos", sound._id);
              } else {
                return sound._pos;
              }
            }
          }
          return self2;
        };
        Howl.prototype.orientation = function(x, y, z, id) {
          var self2 = this;
          if (!self2._webAudio) {
            return self2;
          }
          if (self2._state !== "loaded") {
            self2._queue.push({
              event: "orientation",
              action: function() {
                self2.orientation(x, y, z, id);
              }
            });
            return self2;
          }
          y = typeof y !== "number" ? self2._orientation[1] : y;
          z = typeof z !== "number" ? self2._orientation[2] : z;
          if (typeof id === "undefined") {
            if (typeof x === "number") {
              self2._orientation = [x, y, z];
            } else {
              return self2._orientation;
            }
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            var sound = self2._soundById(ids[i]);
            if (sound) {
              if (typeof x === "number") {
                sound._orientation = [x, y, z];
                if (sound._node) {
                  if (!sound._panner) {
                    if (!sound._pos) {
                      sound._pos = self2._pos || [0, 0, -0.5];
                    }
                    setupPanner(sound, "spatial");
                  }
                  if (typeof sound._panner.orientationX !== "undefined") {
                    sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
                    sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
                    sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
                  } else {
                    sound._panner.setOrientation(x, y, z);
                  }
                }
                self2._emit("orientation", sound._id);
              } else {
                return sound._orientation;
              }
            }
          }
          return self2;
        };
        Howl.prototype.pannerAttr = function() {
          var self2 = this;
          var args = arguments;
          var o, id, sound;
          if (!self2._webAudio) {
            return self2;
          }
          if (args.length === 0) {
            return self2._pannerAttr;
          } else if (args.length === 1) {
            if (typeof args[0] === "object") {
              o = args[0];
              if (typeof id === "undefined") {
                if (!o.pannerAttr) {
                  o.pannerAttr = {
                    coneInnerAngle: o.coneInnerAngle,
                    coneOuterAngle: o.coneOuterAngle,
                    coneOuterGain: o.coneOuterGain,
                    distanceModel: o.distanceModel,
                    maxDistance: o.maxDistance,
                    refDistance: o.refDistance,
                    rolloffFactor: o.rolloffFactor,
                    panningModel: o.panningModel
                  };
                }
                self2._pannerAttr = {
                  coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== "undefined" ? o.pannerAttr.coneInnerAngle : self2._coneInnerAngle,
                  coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== "undefined" ? o.pannerAttr.coneOuterAngle : self2._coneOuterAngle,
                  coneOuterGain: typeof o.pannerAttr.coneOuterGain !== "undefined" ? o.pannerAttr.coneOuterGain : self2._coneOuterGain,
                  distanceModel: typeof o.pannerAttr.distanceModel !== "undefined" ? o.pannerAttr.distanceModel : self2._distanceModel,
                  maxDistance: typeof o.pannerAttr.maxDistance !== "undefined" ? o.pannerAttr.maxDistance : self2._maxDistance,
                  refDistance: typeof o.pannerAttr.refDistance !== "undefined" ? o.pannerAttr.refDistance : self2._refDistance,
                  rolloffFactor: typeof o.pannerAttr.rolloffFactor !== "undefined" ? o.pannerAttr.rolloffFactor : self2._rolloffFactor,
                  panningModel: typeof o.pannerAttr.panningModel !== "undefined" ? o.pannerAttr.panningModel : self2._panningModel
                };
              }
            } else {
              sound = self2._soundById(parseInt(args[0], 10));
              return sound ? sound._pannerAttr : self2._pannerAttr;
            }
          } else if (args.length === 2) {
            o = args[0];
            id = parseInt(args[1], 10);
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            sound = self2._soundById(ids[i]);
            if (sound) {
              var pa = sound._pannerAttr;
              pa = {
                coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : pa.coneInnerAngle,
                coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : pa.coneOuterAngle,
                coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : pa.coneOuterGain,
                distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : pa.distanceModel,
                maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : pa.maxDistance,
                refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : pa.refDistance,
                rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : pa.rolloffFactor,
                panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : pa.panningModel
              };
              var panner = sound._panner;
              if (!panner) {
                if (!sound._pos) {
                  sound._pos = self2._pos || [0, 0, -0.5];
                }
                setupPanner(sound, "spatial");
                panner = sound._panner;
              }
              panner.coneInnerAngle = pa.coneInnerAngle;
              panner.coneOuterAngle = pa.coneOuterAngle;
              panner.coneOuterGain = pa.coneOuterGain;
              panner.distanceModel = pa.distanceModel;
              panner.maxDistance = pa.maxDistance;
              panner.refDistance = pa.refDistance;
              panner.rolloffFactor = pa.rolloffFactor;
              panner.panningModel = pa.panningModel;
            }
          }
          return self2;
        };
        Sound.prototype.init = function(_super) {
          return function() {
            var self2 = this;
            var parent = self2._parent;
            self2._orientation = parent._orientation;
            self2._stereo = parent._stereo;
            self2._pos = parent._pos;
            self2._pannerAttr = parent._pannerAttr;
            _super.call(this);
            if (self2._stereo) {
              parent.stereo(self2._stereo);
            } else if (self2._pos) {
              parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
            }
          };
        }(Sound.prototype.init);
        Sound.prototype.reset = function(_super) {
          return function() {
            var self2 = this;
            var parent = self2._parent;
            self2._orientation = parent._orientation;
            self2._stereo = parent._stereo;
            self2._pos = parent._pos;
            self2._pannerAttr = parent._pannerAttr;
            if (self2._stereo) {
              parent.stereo(self2._stereo);
            } else if (self2._pos) {
              parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
            } else if (self2._panner) {
              self2._panner.disconnect(0);
              self2._panner = void 0;
              parent._refreshBuffer(self2);
            }
            return _super.call(this);
          };
        }(Sound.prototype.reset);
        var setupPanner = function(sound, type) {
          type = type || "spatial";
          if (type === "spatial") {
            sound._panner = Howler.ctx.createPanner();
            sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
            sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
            sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
            sound._panner.distanceModel = sound._pannerAttr.distanceModel;
            sound._panner.maxDistance = sound._pannerAttr.maxDistance;
            sound._panner.refDistance = sound._pannerAttr.refDistance;
            sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
            sound._panner.panningModel = sound._pannerAttr.panningModel;
            if (typeof sound._panner.positionX !== "undefined") {
              sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
              sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
              sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
            } else {
              sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
            }
            if (typeof sound._panner.orientationX !== "undefined") {
              sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
              sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
              sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
            } else {
              sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
            }
          } else {
            sound._panner = Howler.ctx.createStereoPanner();
            sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
          }
          sound._panner.connect(sound._node);
          if (!sound._paused) {
            sound._parent.pause(sound._id, true).play(sound._id, true);
          }
        };
      })();
    }
  });

  // node_modules/@wonderlandengine/components/howler-audio-listener.js
  var howler_audio_listener_exports = {};
  var import_howler;
  var init_howler_audio_listener = __esm({
    "node_modules/@wonderlandengine/components/howler-audio-listener.js"() {
      import_howler = __toESM(require_howler());
      WL.registerComponent("howler-audio-listener", {
        /** Whether audio should be spatialized/positional. */
        spatial: { type: WL.Type.Bool, default: true }
      }, {
        init: function() {
          this.origin = new Float32Array(3);
          this.fwd = new Float32Array(3);
          this.up = new Float32Array(3);
        },
        update: function() {
          if (!this.spatial)
            return;
          this.object.getTranslationWorld(this.origin);
          this.object.getForward(this.fwd);
          this.object.getUp(this.up);
          Howler.pos(this.origin[0], this.origin[1], this.origin[2]);
          Howler.orientation(
            this.fwd[0],
            this.fwd[1],
            this.fwd[2],
            this.up[0],
            this.up[1],
            this.up[2]
          );
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/howler-audio-source.js
  var howler_audio_source_exports = {};
  var import_howler2;
  var init_howler_audio_source = __esm({
    "node_modules/@wonderlandengine/components/howler-audio-source.js"() {
      import_howler2 = __toESM(require_howler());
      WL.registerComponent("howler-audio-source", {
        /** Volume */
        volume: { type: WL.Type.Float, default: 1 },
        /** Whether audio should be spatialized/positional */
        spatial: { type: WL.Type.Bool, default: true },
        /** Whether to loop the sound */
        loop: { type: WL.Type.Bool, default: false },
        /** Whether to start playing automatically */
        autoplay: { type: WL.Type.Bool, default: false },
        /** URL to a sound file to play */
        src: { type: WL.Type.String, default: "" }
      }, {
        start: function() {
          this.audio = new import_howler2.Howl({
            src: [this.src],
            loop: this.loop,
            volume: this.volume,
            autoplay: this.autoplay
          });
          this.lastPlayedAudioId = null;
          this.origin = new Float32Array(3);
          this.lastOrigin = new Float32Array(3);
          if (this.spatial && this.autoplay) {
            this.updatePosition();
            this.play();
          }
          const callback = () => {
            this.stop();
            const idx = WL.onSceneLoaded.indexOf(callback);
            if (idx >= 0)
              WL.onSceneLoaded.splice(idx, 1);
          };
          WL.onSceneLoaded.push(callback);
        },
        update: function() {
          if (!this.spatial || !this.lastPlayedAudioId)
            return;
          this.object.getTranslationWorld(this.origin);
          if (Math.abs(this.lastOrigin[0] - this.origin[0]) > 5e-3 || Math.abs(this.lastOrigin[1] - this.origin[1]) > 5e-3 || Math.abs(this.lastOrigin[2] - this.origin[2]) > 5e-3) {
            this.updatePosition();
          }
        },
        updatePosition: function() {
          this.audio.pos(
            this.origin[0],
            this.origin[1],
            this.origin[2],
            this.lastPlayedAudioId
          );
          this.lastOrigin.set(this.origin);
        },
        play: function() {
          if (this.lastPlayedAudioId)
            this.audio.stop(this.lastPlayedAudioId);
          this.lastPlayedAudioId = this.audio.play();
          if (this.spatial)
            this.updatePosition();
        },
        stop: function() {
          if (!this.lastPlayedAudioId)
            return;
          this.audio.stop(this.lastPlayedAudioId);
          this.lastPlayedAudioId = null;
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/image-texture.js
  var require_image_texture = __commonJS({
    "node_modules/@wonderlandengine/components/image-texture.js"() {
      WL.registerComponent("image-texture", {
        /** URL to download the image from */
        url: { type: WL.Type.String, default: "" },
        /** 0-based mesh component index on this object (e.g. 1 for "second mesh") */
        meshIndex: { type: WL.Type.Int, default: 0 }
      }, {
        init: function() {
          let obj = this.object;
          WL.textures.load(this.url, "anonymous").then(function(texture) {
            const mat = obj.getComponent("mesh", this.meshIndex).material;
            if (mat.shader == "Flat Opaque Textured") {
              mat.flatTexture = texture;
            } else if (mat.shader == "Phong Opaque Textured") {
              mat.diffuseTexture = texture;
            } else {
              console.error("Shader", mat.shader, "not supported by image-texture");
            }
          }).catch(console.err);
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/mouse-look.js
  var mouse_look_exports = {};
  var init_mouse_look = __esm({
    "node_modules/@wonderlandengine/components/mouse-look.js"() {
      init_esm();
      WL.registerComponent("mouse-look", {
        /** Mouse look sensitivity */
        sensitity: { type: WL.Type.Float, default: 0.25 },
        /** Require a mouse button to be pressed to control view.
         * Otherwise view will allways follow mouse movement */
        requireMouseDown: { type: WL.Type.Bool, default: true },
        /** If "moveOnClick" is enabled, mouse button which should
         * be held down to control view */
        mouseButtonIndex: { type: WL.Type.Int, default: 0 }
      }, {
        init: function() {
          this.currentRotationY = 0;
          this.currentRotationX = 0;
          this.origin = new Float32Array(3);
          this.parentOrigin = new Float32Array(3);
          document.addEventListener("mousemove", function(e) {
            if (this.active && (this.mouseDown || !this.requireMouseDown)) {
              this.rotationY = -this.sensitity * e.movementX / 100;
              this.rotationX = -this.sensitity * e.movementY / 100;
              this.currentRotationX += this.rotationX;
              this.currentRotationY += this.rotationY;
              this.currentRotationX = Math.min(1.507, this.currentRotationX);
              this.currentRotationX = Math.max(-1.507, this.currentRotationX);
              this.object.getTranslationWorld(this.origin);
              this.object.parent.getTranslationWorld(this.parentOrigin);
              vec3_exports.sub(this.origin, this.origin, this.parentOrigin);
              this.object.resetTranslationRotation();
              this.object.rotateAxisAngleRad([1, 0, 0], this.currentRotationX);
              this.object.rotateAxisAngleRad([0, 1, 0], this.currentRotationY);
              this.object.translate(this.origin);
            }
          }.bind(this));
          if (this.requireMouseDown) {
            if (this.mouseButtonIndex == 2) {
              WL.canvas.addEventListener("contextmenu", function(e) {
                e.preventDefault();
              }, false);
            }
            WL.canvas.addEventListener("mousedown", function(e) {
              if (e.button == this.mouseButtonIndex) {
                this.mouseDown = true;
                document.body.style.cursor = "grabbing";
                if (e.button == 1) {
                  e.preventDefault();
                  return false;
                }
              }
            }.bind(this));
            WL.canvas.addEventListener("mouseup", function(e) {
              if (e.button == this.mouseButtonIndex) {
                this.mouseDown = false;
                document.body.style.cursor = "initial";
              }
            }.bind(this));
          }
        },
        start: function() {
          this.rotationX = 0;
          this.rotationY = 0;
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/target-framerate.js
  var require_target_framerate = __commonJS({
    "node_modules/@wonderlandengine/components/target-framerate.js"() {
      WL.registerComponent("target-framerate", {
        framerate: { type: WL.Type.Float, default: 90 }
      }, {
        start: function() {
          if (WL.xrSession) {
            this.setTargetFramerate(WL.xrSession);
          } else {
            WL.onXRSessionStart.push(this.setTargetFramerate.bind(this));
          }
        },
        setTargetFramerate: function(s) {
          if (s.supportedFrameRates && s.updateTargetFrameRate) {
            const a = WL.xrSession.supportedFrameRates;
            a.sort((a2, b) => Math.abs(a2 - this.framerate) - Math.abs(b - this.framerate));
            WL.xrSession.updateTargetFrameRate(a[0]);
          }
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/teleport.js
  var teleport_exports = {};
  var init_teleport = __esm({
    "node_modules/@wonderlandengine/components/teleport.js"() {
      init_esm();
      WL.registerComponent("teleport", {
        /** Object that will be placed as indiciation forwhere the player will teleport to. */
        teleportIndicatorMeshObject: { type: WL.Type.Object },
        /** Root of the player, the object that will be positioned on teleportation. */
        camRoot: { type: WL.Type.Object },
        /** Non-vr camera for use outside of VR */
        cam: { type: WL.Type.Object },
        /** Left eye for use in VR*/
        eyeLeft: { type: WL.Type.Object },
        /** Right eye for use in VR*/
        eyeRight: { type: WL.Type.Object },
        /** Handedness for VR cursors to accept trigger events only from respective controller. */
        handedness: { type: WL.Type.Enum, values: ["input component", "left", "right", "none"], default: "input component" },
        /** Collision group of valid "floor" objects that can be teleported on */
        floorGroup: { type: WL.Type.Int, default: 1 },
        /** How far the thumbstick needs to be pushed to have the teleport target indicator show up */
        thumbstickActivationThreshhold: { type: WL.Type.Float, default: -0.7 },
        /** How far the thumbstick needs to be released to execute the teleport */
        thumbstickDeactivationThreshhold: { type: WL.Type.Float, default: 0.3 },
        /** Offset to apply to the indicator object, e.g. to avoid it from Z-fighting with the floor */
        indicatorYOffset: { type: WL.Type.Float, default: 0.01 },
        /** Mode for raycasting, whether to use PhysX or simple collision components */
        rayCastMode: { type: WL.Type.Enum, values: ["collision", "physx"], default: "collision" },
        /** Max distance for PhysX raycast */
        maxDistance: { type: WL.Type.Float, default: 100 }
      }, {
        init: function() {
          this._prevThumbstickAxis = new Float32Array(2);
          this._tempVec = new Float32Array(3);
          this._tempVec0 = new Float32Array(3);
          this._currentIndicatorRotation = 0;
          this.input = this.object.getComponent("input");
          if (!this.input) {
            console.error(this.object.name, "generic-teleport-component.js: input component is required on the object");
            return;
          }
          if (!this.teleportIndicatorMeshObject) {
            console.error(this.object.name, "generic-teleport-component.js: Teleport indicator mesh is missing");
            return;
          }
          if (!this.camRoot) {
            console.error(this.object.name, "generic-teleport-component.js: camRoot not set");
            return;
          }
          this.isIndicating = false;
          if (this.cam) {
            this.isMouseIndicating = false;
            WL.canvas.addEventListener("mousedown", this.onMouseDown.bind(this));
            WL.canvas.addEventListener("mouseup", this.onMouseUp.bind(this));
          }
          this.indicatorHidden = true;
          this.hitSpot = new Float32Array(3);
          this._hasHit = false;
          this._extraRotation = 0;
          this._currentStickAxes = new Float32Array(2);
        },
        start: function() {
          if (this.handedness == 0) {
            const inputComp = this.object.getComponent("input");
            if (!inputComp) {
              console.warn(
                "teleport component on object",
                this.object.name,
                'was configured with handedness "input component", but object has no input component.'
              );
            } else {
              this.handedness = inputComp.handedness;
              this.input = inputComp;
            }
          } else {
            this.handedness = ["left", "right"][this.handedness - 1];
          }
          WL.onXRSessionStart.push(this.setupVREvents.bind(this));
          this.teleportIndicatorMeshObject.active = false;
        },
        /* Get current camera Y rotation */
        _getCamRotation: function() {
          this.eyeLeft.getForward(this._tempVec);
          this._tempVec[1] = 0;
          vec3_exports.normalize(this._tempVec, this._tempVec);
          return Math.atan2(this._tempVec[0], this._tempVec[2]);
        },
        update: function() {
          let inputLength = 0;
          if (this.gamepad && this.gamepad.axes) {
            this._currentStickAxes[0] = this.gamepad.axes[2];
            this._currentStickAxes[1] = this.gamepad.axes[3];
            inputLength = Math.abs(this._currentStickAxes[0]) + Math.abs(this._currentStickAxes[1]);
          }
          if (!this.isIndicating && this._prevThumbstickAxis[1] >= this.thumbstickActivationThreshhold && this._currentStickAxes[1] < this.thumbstickActivationThreshhold) {
            this.isIndicating = true;
          } else if (this.isIndicating && inputLength < this.thumbstickDeactivationThreshhold) {
            this.isIndicating = false;
            this.teleportIndicatorMeshObject.active = false;
            if (this._hasHit) {
              this._teleportPlayer(this.hitSpot, this._extraRotation);
            }
          }
          if (this.isIndicating && this.teleportIndicatorMeshObject && this.input) {
            const origin = this._tempVec0;
            quat2_exports.getTranslation(origin, this.object.transformWorld);
            const direction = this.object.getForward(this._tempVec);
            let rayHit = this.rayHit = this.rayCastMode == 0 ? WL.scene.rayCast(origin, direction, 1 << this.floorGroup) : WL.physics.rayCast(origin, direction, 1 << this.floorGroup, this.maxDistance);
            if (rayHit.hitCount > 0) {
              this.indicatorHidden = false;
              this._extraRotation = Math.PI + Math.atan2(this._currentStickAxes[0], this._currentStickAxes[1]);
              this._currentIndicatorRotation = this._getCamRotation() + (this._extraRotation - Math.PI);
              this.teleportIndicatorMeshObject.resetTranslationRotation();
              this.teleportIndicatorMeshObject.rotateAxisAngleRad([0, 1, 0], this._currentIndicatorRotation);
              this.teleportIndicatorMeshObject.translate(rayHit.locations[0]);
              this.teleportIndicatorMeshObject.translate([0, this.indicatorYOffset, 0]);
              this.teleportIndicatorMeshObject.active = true;
              this.hitSpot.set(rayHit.locations[0]);
              this._hasHit = true;
            } else {
              if (!this.indicatorHidden) {
                this.teleportIndicatorMeshObject.active = false;
                this.indicatorHidden = true;
              }
              this._hasHit = false;
            }
          } else if (this.teleportIndicatorMeshObject && this.isMouseIndicating) {
            this.onMousePressed();
          }
          this._prevThumbstickAxis.set(this._currentStickAxes);
        },
        setupVREvents: function(s) {
          this.session = s;
          s.addEventListener("end", function() {
            this.gamepad = null;
            this.session = null;
          }.bind(this));
          if (s.inputSources && s.inputSources.length) {
            for (let i = 0; i < s.inputSources.length; i++) {
              let inputSource = s.inputSources[i];
              if (inputSource.handedness == this.handedness) {
                this.gamepad = inputSource.gamepad;
              }
            }
          }
          s.addEventListener("inputsourceschange", function(e) {
            if (e.added && e.added.length) {
              for (let i = 0; i < e.added.length; i++) {
                let inputSource = e.added[i];
                if (inputSource.handedness == this.handedness) {
                  this.gamepad = inputSource.gamepad;
                }
              }
            }
          }.bind(this));
        },
        onMouseDown: function() {
          this.isMouseIndicating = true;
        },
        onMouseUp: function() {
          this.isMouseIndicating = false;
          this.teleportIndicatorMeshObject.active = false;
          if (this._hasHit) {
            this._teleportPlayer(this.hitSpot, 0);
          }
        },
        onMousePressed: function() {
          let origin = [0, 0, 0];
          quat2_exports.getTranslation(origin, this.cam.transformWorld);
          const direction = this.cam.getForward(this._tempVec);
          let rayHit = this.rayHit = this.rayCastMode == 0 ? WL.scene.rayCast(origin, direction, 1 << this.floorGroup) : WL.physics.rayCast(origin, direction, 1 << this.floorGroup, this.maxDistance);
          if (rayHit.hitCount > 0) {
            this.indicatorHidden = false;
            direction[1] = 0;
            vec3_exports.normalize(direction, direction);
            this._currentIndicatorRotation = -Math.sign(direction[2]) * Math.acos(direction[0]) - Math.PI * 0.5;
            this.teleportIndicatorMeshObject.resetTranslationRotation();
            this.teleportIndicatorMeshObject.rotateAxisAngleRad([0, 1, 0], this._currentIndicatorRotation);
            this.teleportIndicatorMeshObject.translate(rayHit.locations[0]);
            this.teleportIndicatorMeshObject.active = true;
            this.hitSpot = rayHit.locations[0];
            this._hasHit = true;
          } else {
            if (!this.indicatorHidden) {
              this.teleportIndicatorMeshObject.active = false;
              this.indicatorHidden = true;
            }
            this._hasHit = false;
          }
        },
        _teleportPlayer: function(newPosition, rotationToAdd) {
          this.camRoot.rotateAxisAngleRad([0, 1, 0], rotationToAdd);
          const p = this._tempVec;
          const p1 = this._tempVec0;
          if (this.session) {
            this.eyeLeft.getTranslationWorld(p);
            this.eyeRight.getTranslationWorld(p1);
            vec3_exports.add(p, p, p1);
            vec3_exports.scale(p, p, 0.5);
          } else {
            this.cam.getTranslationWorld(p);
          }
          this.camRoot.getTranslationWorld(p1);
          vec3_exports.sub(p, p1, p);
          p[0] += newPosition[0];
          p[1] = newPosition[1];
          p[2] += newPosition[2];
          this.camRoot.setTranslationWorld(p);
        }
      });
      WL.registerComponent("player-height", {
        height: { type: WL.Type.Float, default: 1.75 }
      }, {
        init: function() {
          WL.onXRSessionStart.push(this.onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this.onXRSessionEnd.bind(this));
        },
        start: function() {
          this.object.resetTranslationRotation();
          this.object.translate([0, this.height, 0]);
        },
        onXRSessionStart: function() {
          if (!["local", "viewer"].includes(WebXR.refSpace)) {
            this.object.resetTranslationRotation();
          }
        },
        onXRSessionEnd: function() {
          if (!["local", "viewer"].includes(WebXR.refSpace)) {
            this.object.resetTranslationRotation();
            this.object.translate([0, this.height, 0]);
          }
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/two-joint-ik-solver.js
  var two_joint_ik_solver_exports = {};
  var twoJointIK;
  var init_two_joint_ik_solver = __esm({
    "node_modules/@wonderlandengine/components/two-joint-ik-solver.js"() {
      init_esm();
      Math.clamp = function(v, a, b) {
        return Math.max(a, Math.min(v, b));
      };
      twoJointIK = function() {
        let ta = new Float32Array(3);
        let ca = new Float32Array(3);
        let ba = new Float32Array(3);
        let ab = new Float32Array(3);
        let cb = new Float32Array(3);
        let axis0 = new Float32Array(3);
        let axis1 = new Float32Array(3);
        let temp = new Float32Array(4);
        let r0 = new Float32Array(4);
        let r1 = new Float32Array(4);
        let r2 = new Float32Array(4);
        return function(a_lr, b_lr, a, b, c, t, eps, a_gr, b_gr, helper) {
          vec3_exports.sub(ba, b, a);
          const lab = vec3_exports.length(ba);
          vec3_exports.sub(ta, b, c);
          const lcb = vec3_exports.length(ta);
          vec3_exports.sub(ta, t, a);
          const lat = Math.clamp(vec3_exports.length(ta), eps, lab + lcb - eps);
          vec3_exports.sub(ca, c, a);
          vec3_exports.sub(ab, a, b);
          vec3_exports.sub(cb, c, b);
          vec3_exports.normalize(ca, ca);
          vec3_exports.normalize(ba, ba);
          vec3_exports.normalize(ab, ab);
          vec3_exports.normalize(cb, cb);
          vec3_exports.normalize(ta, ta);
          const ac_ab_0 = Math.acos(Math.clamp(vec3_exports.dot(ca, ba), -1, 1));
          const ba_bc_0 = Math.acos(Math.clamp(vec3_exports.dot(ab, cb), -1, 1));
          const ac_at_0 = Math.acos(Math.clamp(vec3_exports.dot(ca, ta), -1, 1));
          const ac_ab_1 = Math.acos(Math.clamp((lcb * lcb - lab * lab - lat * lat) / (-2 * lab * lat), -1, 1));
          const ba_bc_1 = Math.acos(Math.clamp((lat * lat - lab * lab - lcb * lcb) / (-2 * lab * lcb), -1, 1));
          vec3_exports.sub(ca, c, a);
          vec3_exports.sub(ba, b, a);
          vec3_exports.sub(ta, t, a);
          vec3_exports.cross(axis0, ca, ba);
          vec3_exports.cross(axis1, ca, ta);
          if (helper) {
            vec3_exports.sub(ba, helper, b);
            vec3_exports.transformQuat(ba, [0, 0, -1], b_gr);
          } else {
            vec3_exports.sub(ba, b, a);
          }
          const l = vec3_exports.length(axis0);
          if (l == 0) {
            axis0.set([1, 0, 0]);
          } else {
            vec3_exports.scale(axis0, axis0, 1 / l);
          }
          vec3_exports.normalize(axis1, axis1);
          quat_exports.conjugate(a_gr, a_gr);
          quat_exports.setAxisAngle(r0, vec3_exports.transformQuat(temp, axis0, a_gr), ac_ab_1 - ac_ab_0);
          quat_exports.setAxisAngle(r2, vec3_exports.transformQuat(temp, axis1, a_gr), ac_at_0);
          quat_exports.mul(a_lr, a_lr, quat_exports.mul(temp, r0, r2));
          quat_exports.normalize(a_lr, a_lr);
          quat_exports.conjugate(b_gr, b_gr);
          quat_exports.setAxisAngle(r1, vec3_exports.transformQuat(temp, axis0, b_gr), ba_bc_1 - ba_bc_0);
          quat_exports.mul(b_lr, b_lr, r1);
          quat_exports.normalize(b_lr, b_lr);
        };
      }();
      WL.registerComponent("two-joint-ik-solver", {
        /** Root bone, never moves */
        root: { type: WL.Type.Object },
        /** Bone attached to the root */
        middle: { type: WL.Type.Object },
        /** Bone attached to the middle */
        end: { type: WL.Type.Object },
        /** Target the joins should reach for */
        target: { type: WL.Type.Object },
        /** Helper object to use to determine joint rotation axis */
        helper: { type: WL.Type.Object }
      }, {
        init: function() {
          this.pos = new Float32Array(3 * 7);
          this.p = [
            this.pos.subarray(0, 3),
            this.pos.subarray(3, 6),
            this.pos.subarray(6, 9),
            this.pos.subarray(9, 12),
            this.pos.subarray(12, 15),
            this.pos.subarray(15, 18),
            this.pos.subarray(18, 21)
          ];
        },
        update: function() {
          const p = this.p;
          this.root.getTranslationWorld(p[0]);
          this.middle.getTranslationWorld(p[1]);
          this.end.getTranslationWorld(p[2]);
          this.target.getTranslationWorld(p[3]);
          const tla = p[4];
          const tlb = p[5];
          this.root.getTranslationLocal(tla);
          this.middle.getTranslationLocal(tlb);
          if (this.helper)
            this.helper.getTranslationWorld(p[6]);
          twoJointIK(
            this.root.transformLocal,
            this.middle.transformLocal,
            p[0],
            p[1],
            p[2],
            p[3],
            0.01,
            this.root.transformWorld.subarray(0, 4),
            this.middle.transformWorld.subarray(0, 4),
            this.helper ? p[6] : null
          );
          this.root.setTranslationLocal(tla);
          this.middle.setTranslationLocal(tlb);
          this.root.setDirty();
          this.middle.setDirty();
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/video-texture.js
  var require_video_texture = __commonJS({
    "node_modules/@wonderlandengine/components/video-texture.js"() {
      WL.registerComponent("video-texture", {
        /** URL to download video from */
        url: { type: WL.Type.String, default: "" },
        /** Material to apply the video texture to */
        material: { type: WL.Type.Material },
        /** Whether to loop the video */
        loop: { type: WL.Type.Bool, default: true },
        /** Whether to automatically start playing the video */
        autoplay: { type: WL.Type.Bool, default: true },
        /** Whether to mute sound */
        muted: { type: WL.Type.Bool, default: true }
      }, {
        init: function() {
          if (!this.material) {
            console.error("video-texture: material property not set");
            return;
          }
          this.loaded = false;
          this.frameUpdateRequested = true;
          this.video = document.createElement("video");
          this.video.src = this.url;
          this.video.crossorigin = "anonymous";
          this.video.autoplay = this.autoplay;
          this.video.loop = this.loop;
          this.video.muted = this.muted;
          this.video.addEventListener("playing", function() {
            this.loaded = true;
          }.bind(this));
          this.video.play();
        },
        applyTexture: function() {
          const mat = this.material;
          this.texture = new WL.Texture(this.video);
          if (mat.shader == "Flat Opaque Textured") {
            mat.flatTexture = this.texture;
          } else if (mat.shader == "Phong Opaque Textured") {
            mat.diffuseTexture = this.texture;
          } else {
            console.error("Shader", mat.shader, "not supported by video-texture");
          }
          if ("requestVideoFrameCallback" in this.video) {
            this.video.requestVideoFrameCallback(this.updateVideo.bind(this));
          } else {
            this.video.addEventListener("timeupdate", function() {
              this.frameUpdateRequested = true;
            }.bind(this));
          }
        },
        update: function(dt) {
          if (this.loaded && this.frameUpdateRequested) {
            if (this.texture) {
              this.texture.update();
            } else {
              this.applyTexture();
            }
            this.frameUpdateRequested = false;
          }
        },
        updateVideo: function() {
          this.frameUpdateRequested = true;
          this.video.requestVideoFrameCallback(this.updateVideo.bind(this));
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/vr-mode-active-switch.js
  var require_vr_mode_active_switch = __commonJS({
    "node_modules/@wonderlandengine/components/vr-mode-active-switch.js"() {
      WL.registerComponent(
        "vr-mode-active-switch",
        {
          /** When components should be active: In VR or when not in VR */
          activateComponents: { type: WL.Type.Enum, values: ["in VR", "in non-VR"], default: "in VR" },
          /** Whether child object's components should be affected */
          affectChildren: { type: WL.Type.Bool, default: true }
        },
        {
          start: function() {
            this.components = [];
            this.getComponents(this.object);
            this.onXRSessionEnd();
            WL.onXRSessionStart.push(this.onXRSessionStart.bind(this));
            WL.onXRSessionEnd.push(this.onXRSessionEnd.bind(this));
          },
          getComponents: function(obj) {
            const comps = obj.getComponents().filter((c) => c.type != "vr-mode-active-switch");
            this.components = this.components.concat(comps);
            if (this.affectChildren) {
              let children = obj.children;
              for (let i = 0; i < children.length; ++i) {
                this.getComponents(children[i]);
              }
            }
          },
          setComponentsActive: function(active) {
            const comps = this.components;
            for (let i = 0; i < comps.length; ++i) {
              comps[i].active = active;
            }
          },
          onXRSessionStart: function() {
            if (!this.active)
              return;
            this.setComponentsActive(this.activateComponents == 0);
          },
          onXRSessionEnd: function() {
            if (!this.active)
              return;
            this.setComponentsActive(this.activateComponents != 0);
          }
        }
      );
    }
  });

  // node_modules/@wonderlandengine/components/wasd-controls.js
  var wasd_controls_exports = {};
  var init_wasd_controls = __esm({
    "node_modules/@wonderlandengine/components/wasd-controls.js"() {
      init_esm();
      WL.registerComponent("wasd-controls", {
        /** Movement speed in m/s. */
        speed: { type: WL.Type.Float, default: 0.1 },
        /** Object of which the orientation is used to determine forward direction */
        headObject: { type: WL.Type.Object }
      }, {
        init: function() {
          this.up = false;
          this.right = false;
          this.down = false;
          this.left = false;
          window.addEventListener("keydown", this.press.bind(this));
          window.addEventListener("keyup", this.release.bind(this));
        },
        start: function() {
          this.headObject = this.headObject || this.object;
        },
        update: function() {
          let direction = [0, 0, 0];
          if (this.up)
            direction[2] -= 1;
          if (this.down)
            direction[2] += 1;
          if (this.left)
            direction[0] -= 1;
          if (this.right)
            direction[0] += 1;
          vec3_exports.normalize(direction, direction);
          direction[0] *= this.speed;
          direction[2] *= this.speed;
          vec3_exports.transformQuat(direction, direction, this.headObject.transformWorld);
          this.object.translate(direction);
        },
        press: function(e) {
          if (e.keyCode === 38 || e.keyCode === 87 || e.keyCode === 90) {
            this.up = true;
          } else if (e.keyCode === 39 || e.keyCode === 68) {
            this.right = true;
          } else if (e.keyCode === 40 || e.keyCode === 83) {
            this.down = true;
          } else if (e.keyCode === 37 || e.keyCode === 65 || e.keyCode === 81) {
            this.left = true;
          }
        },
        release: function(e) {
          if (e.keyCode === 38 || e.keyCode === 87 || e.keyCode === 90) {
            this.up = false;
          } else if (e.keyCode === 39 || e.keyCode === 68) {
            this.right = false;
          } else if (e.keyCode === 40 || e.keyCode === 83) {
            this.down = false;
          } else if (e.keyCode === 37 || e.keyCode === 65 || e.keyCode === 81) {
            this.left = false;
          }
        }
      });
    }
  });

  // node_modules/@wonderlandengine/components/wonderleap-ad.js
  var wonderleap_ad_exports = {};
  var init_wonderleap_ad = __esm({
    "node_modules/@wonderlandengine/components/wonderleap-ad.js"() {
      init_esm();
      WL.registerComponent("wonderleap-ad", {
        /** Ad user id */
        auId: { type: WL.Type.String, default: "ce6f68fc-4809-4409-8f57-c631283ce5a3" },
        /** Ad id */
        adId: { type: WL.Type.String }
      }, {
        init: function() {
          this.mesh = this.object.getComponent("mesh", 0);
          this.collision = this.object.addComponent("collision");
          this.collision.collider = WL.Collider.Box;
          this.collision.group = 2;
          this.cursorTarget = this.object.addComponent("cursor-target");
          this.timeSinceLastVizCheck = 0;
          this.visibleDuration = 0;
          this.durationThreshold = 10;
        },
        start: function() {
          Wonderleap.fetchAd(this.auId).then(function(ad) {
            this.ad = ad;
            WL.textures.load(ad.asset, "").then(function(texture) {
              const image = WL._images[texture._imageIndex];
              this.collision.extents = [image.width / image.height, 1, 0.1];
              this.object.scale([image.width / image.height, 1, 1]);
              if (this.mesh.material.shader == "Phong Textured") {
                this.mesh.material.diffuseTexture = texture;
              } else {
                this.mesh.material.flatTexture = texture;
              }
            }.bind(this)).catch(console.err);
          }.bind(this));
          this.cursorTarget.addClickFunction(this.click.bind(this));
        },
        update: function(dt) {
          this.timeSinceLastVizCheck += dt;
          if (this.timeSinceLastVizCheck > 0.5) {
            const isVisible = this.isVisible();
            if (isVisible) {
              this.visibleDuration += this.timeSinceLastVizCheck;
            }
            this.timeSinceLastVizCheck = 0;
            if (!isVisible && this.visibleDuration > 0 || this.visibleDuration > this.durationThreshold) {
              Wonderleap.sendMetric("gaze", this.visibleDuration, this.ad.adId, this.ad.auId);
              this.visibleDuration = 0;
            }
          }
        },
        isVisible: function() {
          const view = WL.scene.activeViews[0];
          if (!view || !view.active) {
            console.warn("wonderleap-ad: camera object does not have an active view");
            return false;
          }
          const transform = view.object.transformWorld;
          const rayOrigin = [0, 0, 0];
          quat2_exports.getTranslation(rayOrigin, transform);
          const rayDir = [0, 0, -1];
          vec3_exports.transformQuat(rayDir, rayDir, transform);
          let hits = WL.scene.rayCast(rayOrigin, rayDir, 2);
          for (let i = 0; i < hits.hitCount; ++i) {
            const obj = hits.objects[i];
            if (obj.objectId == this.object.objectId) {
              return true;
            }
          }
          return false;
        },
        click: function() {
          const s = Module["webxr_session"];
          if (s) {
            s.end().then(this.click.bind(this));
            return;
          }
          Wonderleap.sendMetric("click", 0, this.ad.adId, this.ad.auId);
          if (this.ad.url) {
            window.open(this.ad.url, "_blank");
          }
        }
      });
    }
  });

  // js/pp/pp.js
  var require_pp = __commonJS({
    "js/pp/pp.js"() {
      PP = {};
    }
  });

  // js/pp/plugin/extensions/array_extension.js
  var array_extension_exports = {};
  var init_array_extension = __esm({
    "js/pp/plugin/extensions/array_extension.js"() {
      init_esm();
      Array.prototype.pp_first = function() {
        return this.length > 0 ? this[0] : void 0;
      };
      Array.prototype.pp_last = function() {
        return this.length > 0 ? this[this.length - 1] : void 0;
      };
      Array.prototype.pp_has = function(callback) {
        return this.pp_find(callback) != void 0;
      };
      Array.prototype.pp_hasEqual = function(elementToFind, elementsEqualCallback = null) {
        return this.pp_findEqual(elementToFind, elementsEqualCallback) != void 0;
      };
      Array.prototype.pp_find = function(callback) {
        let elementFound = void 0;
        let index = this.findIndex(callback);
        if (index >= 0) {
          elementFound = this[index];
        }
        return elementFound;
      };
      Array.prototype.pp_findIndex = function(callback) {
        return this.findIndex(callback);
      };
      Array.prototype.pp_findAll = function(callback) {
        let elementsFound = this.filter(callback);
        return elementsFound;
      };
      Array.prototype.pp_findAllIndexes = function(callback) {
        let indexes = [];
        for (let i = 0; i < this.length; i++) {
          let element = this[i];
          if (callback(element)) {
            indexes.push(i);
          }
        }
        return indexes;
      };
      Array.prototype.pp_findEqual = function(elementToFind, elementsEqualCallback = null) {
        if (elementsEqualCallback == null) {
          return this.pp_find((element) => element === elementToFind);
        }
        return this.pp_find((element) => elementsEqualCallback(element, elementToFind));
      };
      Array.prototype.pp_findAllEqual = function(elementToFind, elementsEqualCallback = null) {
        if (elementsEqualCallback == null) {
          return this.pp_findAll((element) => element === elementToFind);
        }
        return this.pp_findAll((element) => elementsEqualCallback(element, elementToFind));
      };
      Array.prototype.pp_findIndexEqual = function(elementToFind, elementsEqualCallback = null) {
        if (elementsEqualCallback == null) {
          return this.findIndex((element) => element === elementToFind);
        }
        return this.findIndex((element) => elementsEqualCallback(element, elementToFind));
      };
      Array.prototype.pp_findAllIndexesEqual = function(elementToFind, elementsEqualCallback = null) {
        if (elementsEqualCallback == null) {
          return this.pp_findAllIndexes((element) => element === elementToFind);
        }
        return this.pp_findAllIndexes((element) => elementsEqualCallback(element, elementToFind));
      };
      Array.prototype.pp_removeIndex = function(index) {
        let elementRemoved = void 0;
        if (index >= 0 && index < this.length) {
          let arrayRemoved = this.splice(index, 1);
          if (arrayRemoved.length == 1) {
            elementRemoved = arrayRemoved[0];
          }
        }
        return elementRemoved;
      };
      Array.prototype.pp_remove = function(callback) {
        let elementRemoved = void 0;
        let index = this.findIndex(callback);
        if (index >= 0) {
          elementRemoved = this.pp_removeIndex(index);
        }
        return elementRemoved;
      };
      Array.prototype.pp_removeAll = function(callback) {
        let elementsRemoved = [];
        let currentElement = void 0;
        do {
          currentElement = this.pp_remove(callback);
          if (currentElement !== void 0) {
            elementsRemoved.push(currentElement);
          }
        } while (currentElement !== void 0);
        return elementsRemoved;
      };
      Array.prototype.pp_removeEqual = function(elementToRemove, elementsEqualCallback = null) {
        if (elementsEqualCallback == null) {
          return this.pp_remove((element) => element === elementToRemove);
        }
        return this.pp_remove((element) => elementsEqualCallback(element, elementToRemove));
      };
      Array.prototype.pp_removeAllEqual = function(elementToRemove, elementsEqualCallback = null) {
        if (elementsEqualCallback == null) {
          return this.pp_removeAll((element) => element === elementToRemove);
        }
        return this.pp_removeAll((element) => elementsEqualCallback(element, elementToRemove));
      };
      Array.prototype.pp_pushUnique = function(element, elementsEqualCallback = null) {
        let length6 = this.length;
        let hasElement = this.pp_hasEqual(element, elementsEqualCallback);
        if (!hasElement) {
          length6 = this.push(element);
        }
        return length6;
      };
      Array.prototype.pp_unshiftUnique = function(element, elementsEqualCallback = null) {
        let length6 = this.length;
        let hasElement = this.pp_hasEqual(element, elementsEqualCallback);
        if (!hasElement) {
          length6 = this.unshift(element);
        }
        return length6;
      };
      Array.prototype.pp_copy = function(array, copyCallback = null) {
        while (this.length > array.length) {
          this.pop();
        }
        for (let i = 0; i < array.length; i++) {
          if (copyCallback == null) {
            this[i] = array[i];
          } else {
            this[i] = copyCallback(this[i], array[i]);
          }
        }
        return this;
      };
      Array.prototype.pp_clone = function(cloneCallback = null) {
        if (cloneCallback == null) {
          return this.slice(0);
        }
        let clone8 = null;
        switch (this.constructor.name) {
          case "Array":
            clone8 = new Array(this.length);
            break;
          case "Uint32Array":
            clone8 = new Uint32Array(this.length);
            break;
          case "Int32Array":
            clone8 = new Int32Array(this.length);
            break;
          case "Float32Array":
            clone8 = new Float32Array(this.length);
            break;
          case "Float64Array":
            clone8 = new Float64Array(this.length);
            break;
          default:
            clone8 = new Array(this.length);
            console.error("Cloned array type not supported!");
            break;
        }
        for (let i = 0; i < this.length; i++) {
          clone8[i] = cloneCallback(this[i]);
        }
        return clone8;
      };
      Array.prototype.pp_equals = function(array, elementsEqualCallback = null) {
        let equals9 = true;
        if (array != null && this.length == array.length) {
          for (let i = 0; i < this.length; i++) {
            if (elementsEqualCallback != null && !elementsEqualCallback(this[i], array[i]) || elementsEqualCallback == null && this[i] != array[i]) {
              equals9 = false;
              break;
            }
          }
        } else {
          equals9 = false;
        }
        return equals9;
      };
      Array.prototype.pp_clear = function() {
        this.length = 0;
        return this;
      };
      Array.prototype.vec_toString = function(decimalPlaces = null) {
        let message = this._vec_buildConsoleMessage(decimalPlaces);
        return message;
      };
      Array.prototype.vec_log = function(decimalPlaces = 4) {
        let message = this._vec_buildConsoleMessage(decimalPlaces);
        console.log(message);
      };
      Array.prototype.vec_error = function(decimalPlaces = 4) {
        let message = this._vec_buildConsoleMessage(decimalPlaces);
        console.error(message);
      };
      Array.prototype.vec_warn = function(decimalPlaces = 4) {
        let message = this._vec_buildConsoleMessage(decimalPlaces);
        console.warn(message);
      };
      Array.prototype.vec_scale = function(value, out = null) {
        out = this._vec_prepareOut(out);
        for (let i = 0; i < out.length; i++) {
          out[i] = out[i] * value;
        }
        return out;
      };
      Array.prototype.vec_round = function(out = null) {
        out = this._vec_prepareOut(out);
        for (let i = 0; i < out.length; i++) {
          out[i] = Math.round(out[i]);
        }
        return out;
      };
      Array.prototype.vec_floor = function(out = null) {
        out = this._vec_prepareOut(out);
        for (let i = 0; i < out.length; i++) {
          out[i] = Math.floor(out[i]);
        }
        return out;
      };
      Array.prototype.vec_ceil = function(out = null) {
        out = this._vec_prepareOut(out);
        for (let i = 0; i < out.length; i++) {
          out[i] = Math.ceil(out[i]);
        }
        return out;
      };
      Array.prototype.vec_clamp = function(start, end, out = null) {
        out = this._vec_prepareOut(out);
        let fixedStart = start != null ? start : -Number.MAX_VALUE;
        let fixedEnd = end != null ? end : Number.MAX_VALUE;
        let min4 = Math.min(fixedStart, fixedEnd);
        let max4 = Math.max(fixedStart, fixedEnd);
        for (let i = 0; i < out.length; i++) {
          out[i] = Math.min(Math.max(out[i], min4), max4);
        }
        return out;
      };
      Array.prototype.vec_equals = function(vector, epsilon = 0) {
        let equals9 = this.length == vector.length;
        for (let i = 0; i < this.length && equals9; i++) {
          equals9 = equals9 && Math.abs(this[i] - vector[i]) <= epsilon;
        }
        return equals9;
      };
      Array.prototype.vec2_set = function(x, y = null) {
        if (y == null) {
          vec2_exports.set(this, x, x);
        } else {
          vec2_exports.set(this, x, y);
        }
        return this;
      };
      Array.prototype.vec2_length = function() {
        return vec2_exports.length(this);
      };
      Array.prototype.vec2_normalize = function(out = vec2_exports.create()) {
        vec2_exports.normalize(out, this);
        return out;
      };
      Array.prototype.vec2_copy = function(vector) {
        vec2_exports.copy(this, vector);
        return this;
      };
      Array.prototype.vec2_clone = function(out = vec2_exports.create()) {
        vec2_exports.copy(out, this);
        return out;
      };
      Array.prototype.vec2_zero = function() {
        vec2_exports.zero(this);
        return this;
      };
      Array.prototype.vec2_isZero = function(epsilon = 0) {
        return this.vec2_length() <= epsilon;
      };
      Array.prototype.vec3_normalize = function(out = vec3_exports.create()) {
        vec3_exports.normalize(out, this);
        return out;
      };
      Array.prototype.vec3_copy = function(vector) {
        vec3_exports.copy(this, vector);
        return this;
      };
      Array.prototype.vec3_clone = function(out = vec3_exports.create()) {
        vec3_exports.copy(out, this);
        return out;
      };
      Array.prototype.vec3_set = function(x, y = null, z = null) {
        if (y == null) {
          vec3_exports.set(this, x, x, x);
        } else {
          vec3_exports.set(this, x, y, z);
        }
        return this;
      };
      Array.prototype.vec3_zero = function() {
        vec3_exports.zero(this);
        return this;
      };
      Array.prototype.vec3_angle = function(vector) {
        return this.vec3_angleDegrees(vector);
      };
      Array.prototype.vec3_angleDegrees = function(vector) {
        return this.vec3_angleRadians(vector) * (180 / Math.PI);
      };
      Array.prototype.vec3_angleRadians = function(vector) {
        return this.vec3_isZero() || vector.vec3_isZero() ? 0 : vec3_exports.angle(this, vector);
      };
      Array.prototype.vec3_length = function() {
        return vec3_exports.length(this);
      };
      Array.prototype.vec3_distance = function(vector) {
        return vec3_exports.dist(this, vector);
      };
      Array.prototype.vec3_add = function(vector, out = vec3_exports.create()) {
        vec3_exports.add(out, this, vector);
        return out;
      };
      Array.prototype.vec3_sub = function(vector, out = vec3_exports.create()) {
        vec3_exports.sub(out, this, vector);
        return out;
      };
      Array.prototype.vec3_mul = function(vector, out = vec3_exports.create()) {
        vec3_exports.mul(out, this, vector);
        return out;
      };
      Array.prototype.vec3_div = function(vector, out = vec3_exports.create()) {
        vec3_exports.div(out, this, vector);
        return out;
      };
      Array.prototype.vec3_scale = function(value, out = vec3_exports.create()) {
        vec3_exports.scale(out, this, value);
        return out;
      };
      Array.prototype.vec3_negate = function(out = vec3_exports.create()) {
        vec3_exports.negate(out, this);
        return out;
      };
      Array.prototype.vec3_cross = function(vector, out = vec3_exports.create()) {
        vec3_exports.cross(out, this, vector);
        return out;
      };
      Array.prototype.vec3_transformQuat = function(quat, out = vec3_exports.create()) {
        vec3_exports.transformQuat(out, this, quat);
        return out;
      };
      Array.prototype.vec3_transformMat4 = function(mat4, out = vec3_exports.create()) {
        vec3_exports.transformMat4(out, this, mat4);
        return out;
      };
      Array.prototype.vec3_lengthSigned = function(positiveDirection) {
        let signedLength = vec3_exports.length(this);
        if (!this.vec3_isConcordant(positiveDirection)) {
          signedLength *= -1;
        }
        return signedLength;
      };
      Array.prototype.vec3_angleSigned = function(vector, upAxis) {
        return this.vec3_angleSignedDegrees(vector, upAxis);
      };
      Array.prototype.vec3_angleSignedDegrees = function(vector, upAxis) {
        return this.vec3_angleSignedRadians(vector, upAxis) * (180 / Math.PI);
      };
      Array.prototype.vec3_angleSignedRadians = function() {
        let crossAxis = vec3_exports.create();
        return function vec3_angleSignedRadians(vector, upAxis) {
          this.vec3_cross(vector, crossAxis);
          let angle3 = this.vec3_angleRadians(vector);
          if (!crossAxis.vec3_isConcordant(upAxis)) {
            angle3 = -angle3;
          }
          return angle3;
        };
      }();
      Array.prototype.vec3_toRadians = function(out = vec3_exports.create()) {
        vec3_exports.set(out, common_exports.toRadian(this[0]), common_exports.toRadian(this[1]), common_exports.toRadian(this[2]));
        return out;
      };
      Array.prototype.vec3_toDegrees = function(out = vec3_exports.create()) {
        vec3_exports.set(out, this[0] * (180 / Math.PI), this[1] * (180 / Math.PI), this[2] * (180 / Math.PI));
        return out;
      };
      Array.prototype.vec3_toQuat = function(out) {
        return this.vec3_degreesToQuat(out);
      };
      Array.prototype.vec3_radiansToQuat = function(out = quat_exports.create()) {
        out.quat_fromRadians(this);
        return out;
      };
      Array.prototype.vec3_degreesToQuat = function(out = quat_exports.create()) {
        out.quat_fromDegrees(this);
        return out;
      };
      Array.prototype.vec3_isNormalized = function(epsilon = this._pp_normalizedEpsilon) {
        return Math.abs(vec3_exports.length(this) - 1) < epsilon;
      };
      Array.prototype.vec3_isZero = function(epsilon = 0) {
        return this.vec3_length() <= epsilon;
      };
      Array.prototype.vec3_componentAlongAxis = function(axis, out = vec3_exports.create()) {
        let angle3 = vec3_exports.angle(this, axis);
        let length6 = Math.cos(angle3) * vec3_exports.length(this);
        vec3_exports.copy(out, axis);
        vec3_exports.scale(out, out, length6);
        return out;
      };
      Array.prototype.vec3_valueAlongAxis = function() {
        let componentAlong = vec3_exports.create();
        return function vec3_valueAlongAxis(axis) {
          this.vec3_componentAlongAxis(axis, componentAlong);
          let value = componentAlong.vec3_length();
          if (!componentAlong.vec3_isConcordant(axis)) {
            value = -value;
          }
          return value;
        };
      }();
      Array.prototype.vec3_removeComponentAlongAxis = function() {
        let componentAlong = vec3_exports.create();
        return function vec3_removeComponentAlongAxis(axis, out = vec3_exports.create()) {
          this.vec3_componentAlongAxis(axis, componentAlong);
          vec3_exports.sub(out, this, componentAlong);
          return out;
        };
      }();
      Array.prototype.vec3_copyComponentAlongAxis = function() {
        let componentAlong = vec3_exports.create();
        return function vec3_copyComponentAlongAxis(vector, axis, out = vec3_exports.create()) {
          this.vec3_removeComponentAlongAxis(axis, out);
          vector.vec3_componentAlongAxis(axis, componentAlong);
          out.vec3_add(componentAlong, out);
          return out;
        };
      }();
      Array.prototype.vec3_isConcordant = function(vector) {
        return vec3_exports.angle(this, vector) <= Math.PI / 2;
      };
      Array.prototype.vec3_isFartherAlongAxis = function() {
        let componentAlong = vec3_exports.create();
        return function vec3_isFartherAlongAxis(vector, axis) {
          let thisAxisLength = this.vec3_componentAlongAxis(axis, componentAlong).vec3_length();
          let thisAxisLengthSigned = this.vec3_isConcordant(axis) ? thisAxisLength : -thisAxisLength;
          let vectorAxisLength = vector.vec3_componentAlongAxis(axis, componentAlong).vec3_length();
          let vectorAxisLengthSigned = vector.vec3_isConcordant(axis) ? vectorAxisLength : -vectorAxisLength;
          return thisAxisLengthSigned > vectorAxisLengthSigned;
        };
      }();
      Array.prototype.vec3_isToTheRight = function(vector, upAxis) {
        return this.vec3_signTo(vector, upAxis) >= 0;
      };
      Array.prototype.vec3_signTo = function() {
        let componentAlongThis = vec3_exports.create();
        let componentAlongVector = vec3_exports.create();
        return function vec3_signTo(vector, upAxis, zeroSign = 1) {
          this.vec3_removeComponentAlongAxis(upAxis, componentAlongThis);
          vector.vec3_removeComponentAlongAxis(upAxis, componentAlongVector);
          let angleSigned = this.vec3_angleSigned(vector, upAxis);
          return angleSigned > 0 ? 1 : angleSigned == 0 ? zeroSign : -1;
        };
      }();
      Array.prototype.vec3_projectOnAxis = function(axis, out = vec3_exports.create()) {
        this.vec3_componentAlongAxis(axis, out);
        return out;
      };
      Array.prototype.vec3_projectOnAxisAlongAxis = function() {
        let up = vec3_exports.create();
        let thisToAxis = vec3_exports.create();
        let fixedProjectAlongAxis = vec3_exports.create();
        return function vec3_projectOnAxisAlongAxis(axis, projectAlongAxis, out = vec3_exports.create()) {
          if (this.vec3_isOnAxis(axis) || projectAlongAxis.vec3_isOnAxis(axis)) {
            out.vec3_copy(this);
          } else {
            projectAlongAxis.vec3_cross(axis, up);
            up.vec3_normalize(up);
            this.vec3_removeComponentAlongAxis(up, out);
            if (!out.vec3_isOnAxis(axis)) {
              out.vec3_projectOnAxis(axis, thisToAxis);
              thisToAxis.vec3_sub(out, thisToAxis);
              if (thisToAxis.vec3_isConcordant(projectAlongAxis)) {
                fixedProjectAlongAxis.vec3_copy(projectAlongAxis);
              } else {
                projectAlongAxis.vec3_negate(fixedProjectAlongAxis);
              }
              let angleWithAlongAxis = fixedProjectAlongAxis.vec3_angleRadians(thisToAxis);
              let lengthToRemove = thisToAxis.vec3_length() / Math.cos(angleWithAlongAxis);
              fixedProjectAlongAxis.vec3_normalize(fixedProjectAlongAxis);
              fixedProjectAlongAxis.vec3_scale(lengthToRemove, fixedProjectAlongAxis);
              out.vec3_add(fixedProjectAlongAxis, out);
              out.vec3_projectOnAxis(axis, out);
            }
          }
          return out;
        };
      }();
      Array.prototype.vec3_projectOnPlane = function(planeNormal, out = vec3_exports.create()) {
        this.vec3_removeComponentAlongAxis(planeNormal, out);
        return out;
      };
      Array.prototype.vec3_projectOnPlaneAlongAxis = function() {
        let thisToPlane = vec3_exports.create();
        let fixedProjectAlongAxis = vec3_exports.create();
        return function vec3_projectOnPlaneAlongAxis(planeNormal, projectAlongAxis, out = vec3_exports.create()) {
          if (this.vec3_isOnPlane(planeNormal) || projectAlongAxis.vec3_isOnPlane(planeNormal)) {
            out.vec3_copy(this);
          } else {
            out.vec3_copy(this);
            out.vec3_projectOnPlane(planeNormal, thisToPlane);
            thisToPlane.vec3_sub(out, thisToPlane);
            if (thisToPlane.vec3_isConcordant(projectAlongAxis)) {
              fixedProjectAlongAxis.vec3_copy(projectAlongAxis);
            } else {
              projectAlongAxis.vec3_negate(fixedProjectAlongAxis);
            }
            let angleWithAlongAxis = fixedProjectAlongAxis.vec3_angleRadians(thisToPlane);
            let lengthToRemove = thisToPlane.vec3_length() / Math.cos(angleWithAlongAxis);
            fixedProjectAlongAxis.vec3_normalize(fixedProjectAlongAxis);
            fixedProjectAlongAxis.vec3_scale(lengthToRemove, fixedProjectAlongAxis);
            out.vec3_add(fixedProjectAlongAxis, out);
            out.vec3_projectOnPlane(planeNormal, out);
          }
          return out;
        };
      }();
      Array.prototype.vec3_isOnAxis = function(axis) {
        let angle3 = this.vec3_angle(axis);
        return Math.abs(angle3) < this._pp_degreesEpsilon || Math.abs(angle3 - 180) < this._pp_degreesEpsilon;
      };
      Array.prototype.vec3_isOnPlane = function(planeNormal) {
        let angle3 = this.vec3_angle(planeNormal);
        return Math.abs(angle3 - 90) < this._pp_degreesEpsilon;
      };
      Array.prototype.vec3_rotate = function(rotation, out) {
        return this.vec3_rotateDegrees(rotation, out);
      };
      Array.prototype.vec3_rotateDegrees = function() {
        let zero4 = vec3_exports.create();
        return function vec3_rotateDegrees(rotation, out) {
          return this.vec3_rotateAroundDegrees(rotation, zero4, out);
        };
      }();
      Array.prototype.vec3_rotateRadians = function() {
        let zero4 = vec3_exports.create();
        return function vec3_rotateRadians(rotation, out) {
          return this.vec3_rotateAroundRadians(rotation, zero4, out);
        };
      }();
      Array.prototype.vec3_rotateQuat = function() {
        let zero4 = vec3_exports.create();
        return function vec3_rotateQuat(rotation, out) {
          return this.vec3_rotateAroundQuat(rotation, zero4, out);
        };
      }();
      Array.prototype.vec3_rotateAxis = function(angle3, axis, out) {
        return this.vec3_rotateAxisDegrees(angle3, axis, out);
      };
      Array.prototype.vec3_rotateAxisDegrees = function() {
        let zero4 = vec3_exports.create();
        return function vec3_rotateAxisDegrees(angle3, axis, out) {
          return this.vec3_rotateAroundAxisDegrees(angle3, axis, zero4, out);
        };
      }();
      Array.prototype.vec3_rotateAxisRadians = function() {
        let zero4 = vec3_exports.create();
        return function vec3_rotateAxisRadians(angle3, axis, out) {
          return this.vec3_rotateAroundAxisRadians(angle3, axis, zero4, out);
        };
      }();
      Array.prototype.vec3_rotateAround = function(rotation, origin, out) {
        return this.vec3_rotateAroundDegrees(rotation, origin, out);
      };
      Array.prototype.vec3_rotateAroundDegrees = function() {
        let quat = quat_exports.create();
        return function vec3_rotateAroundDegrees(rotation, origin, out = vec3_exports.create()) {
          rotation.vec3_degreesToQuat(quat);
          return this.vec3_rotateAroundQuat(quat, origin, out);
        };
      }();
      Array.prototype.vec3_rotateAroundRadians = function() {
        let quat = quat_exports.create();
        return function vec3_rotateAroundRadians(rotation, origin, out = vec3_exports.create()) {
          rotation.vec3_radiansToQuat(quat);
          return this.vec3_rotateAroundQuat(quat, origin, out);
        };
      }();
      Array.prototype.vec3_rotateAroundQuat = function(rotation, origin, out = vec3_exports.create()) {
        vec3_exports.sub(out, this, origin);
        vec3_exports.transformQuat(out, out, rotation);
        vec3_exports.add(out, out, origin);
        return out;
      };
      Array.prototype.vec3_rotateAroundAxis = function(angle3, axis, origin, out) {
        return this.vec3_rotateAroundAxisDegrees(angle3, axis, origin, out);
      };
      Array.prototype.vec3_rotateAroundAxisDegrees = function(angle3, axis, origin, out) {
        return this.vec3_rotateAroundAxisRadians(common_exports.toRadian(angle3), axis, origin, out);
      };
      Array.prototype.vec3_rotateAroundAxisRadians = function() {
        let quat = quat_exports.create();
        return function vec3_rotateAroundAxisRadians(angle3, axis, origin, out = vec3_exports.create()) {
          quat_exports.setAxisAngle(quat, axis, angle3);
          return this.vec3_rotateAroundQuat(quat, origin, out);
        };
      }();
      Array.prototype.vec3_convertPositionToWorld = function(parentTransform, out) {
        return this.vec3_convertPositionToWorldMatrix(parentTransform, out);
      };
      Array.prototype.vec3_convertPositionToLocal = function(parentTransform, out) {
        return this.vec3_convertPositionToLocalMatrix(parentTransform, out);
      };
      Array.prototype.vec3_convertPositionToWorldMatrix = function(parentTransform, out = vec3_exports.create()) {
        vec3_exports.transformMat4(out, this, parentTransform);
        return out;
      };
      Array.prototype.vec3_convertPositionToLocalMatrix = function() {
        let inverse4 = mat4_exports.create();
        return function vec3_convertPositionToLocalMatrix(parentTransform, out = vec3_exports.create()) {
          mat4_exports.invert(inverse4, parentTransform);
          vec3_exports.transformMat4(out, this, inverse4);
          return out;
        };
      }();
      Array.prototype.vec3_convertPositionToWorldQuat = function() {
        let parentTransformMatrix = mat4_exports.create();
        let position = vec3_exports.create();
        let rotation = quat_exports.create();
        let one = vec3_exports.create();
        vec3_exports.set(one, 1, 1, 1);
        return function vec3_convertPositionToWorldQuat(parentTransform, out = vec3_exports.create()) {
          parentTransform.quat2_getPosition(position);
          parentTransform.quat2_getRotationQuat(rotation);
          parentTransformMatrix.mat4_setPositionRotationQuatScale(position, rotation, one);
          return this.vec3_convertPositionToWorldMatrix(parentTransformMatrix, out);
        };
      }();
      Array.prototype.vec3_convertPositionToLocalQuat = function() {
        let parentTransformMatrix = mat4_exports.create();
        let position = vec3_exports.create();
        let rotation = quat_exports.create();
        let one = vec3_exports.create();
        vec3_exports.set(one, 1, 1, 1);
        return function vec3_convertPositionToLocalQuat(parentTransform, out = vec3_exports.create()) {
          parentTransform.quat2_getPosition(position);
          parentTransform.quat2_getRotationQuat(rotation);
          parentTransformMatrix.mat4_setPositionRotationQuatScale(position, rotation, one);
          return this.vec3_convertPositionToLocalMatrix(parentTransformMatrix, out);
        };
      }();
      Array.prototype.vec3_convertDirectionToWorld = function(parentTransform, out) {
        return this.vec3_convertDirectionToWorldMatrix(parentTransform, out);
      };
      Array.prototype.vec3_convertDirectionToLocal = function(parentTransform, out) {
        return this.vec3_convertDirectionToLocalMatrix(parentTransform, out);
      };
      Array.prototype.vec3_convertDirectionToWorldMatrix = function() {
        let rotation = quat_exports.create();
        return function vec3_convertDirectionToWorldMatrix(parentTransform, out = vec3_exports.create()) {
          parentTransform.mat4_getRotationQuat(rotation);
          vec3_exports.transformQuat(out, this, rotation);
          return out;
        };
      }();
      Array.prototype.vec3_convertDirectionToLocalMatrix = function() {
        let rotation = quat_exports.create();
        return function vec3_convertDirectionToLocalMatrix(parentTransform, out = vec3_exports.create()) {
          parentTransform.mat4_getRotationQuat(rotation);
          quat_exports.conjugate(rotation, rotation);
          vec3_exports.transformQuat(out, this, rotation);
          return out;
        };
      }();
      Array.prototype.vec3_convertDirectionToWorldQuat = function() {
        let rotation = quat_exports.create();
        return function vec3_convertDirectionToWorldQuat(parentTransform, out = vec3_exports.create()) {
          parentTransform.quat2_getRotationQuat(rotation);
          vec3_exports.transformQuat(out, this, rotation);
          return out;
        };
      }();
      Array.prototype.vec3_convertDirectionToLocalQuat = function() {
        let rotation = quat_exports.create();
        return function vec3_convertDirectionToLocalQuat(parentTransform, out = vec3_exports.create()) {
          parentTransform.quat2_getRotationQuat(rotation);
          quat_exports.conjugate(rotation, rotation);
          vec3_exports.transformQuat(out, this, rotation);
          return out;
        };
      }();
      Array.prototype.vec3_log = function(decimalPlaces = 4) {
        this.vec_log(decimalPlaces);
      };
      Array.prototype.vec3_error = function(decimalPlaces = 4) {
        this.vec_error(decimalPlaces);
      };
      Array.prototype.vec3_warn = function(decimalPlaces = 4) {
        this.vec_warn(decimalPlaces);
      };
      Array.prototype.vec3_addRotation = function(rotation, out) {
        return this.vec3_degreesAddRotation(rotation, out);
      };
      Array.prototype.vec3_addRotationDegrees = function(rotation, out) {
        return this.vec3_degreesAddRotationDegrees(rotation, out);
      };
      Array.prototype.vec3_addRotationRadians = function(rotation, out) {
        return this.vec3_degreesAddRotationRadians(rotation, out);
      };
      Array.prototype.vec3_addRotationQuat = function(rotation, out) {
        return this.vec3_degreesAddRotationQuat(rotation, out);
      };
      Array.prototype.vec3_degreesAddRotation = function(rotation, out) {
        return this.vec3_degreesAddRotationDegrees(rotation, out);
      };
      Array.prototype.vec3_degreesAddRotationDegrees = function() {
        let quat = quat_exports.create();
        return function vec3_degreesAddRotationDegrees(rotation, out = vec3_exports.create()) {
          this.vec3_degreesToQuat(quat);
          return quat.quat_addRotationDegrees(rotation, quat).quat_toDegrees(out);
        };
      }();
      Array.prototype.vec3_degreesAddRotationRadians = function() {
        let quat = quat_exports.create();
        return function vec3_degreesAddRotationRadians(rotation, out = vec3_exports.create()) {
          this.vec3_degreesToQuat(quat);
          return quat.quat_addRotationRadians(rotation, quat).quat_toDegrees(out);
        };
      }();
      Array.prototype.vec3_degreesAddRotationQuat = function() {
        let quat = quat_exports.create();
        return function vec3_degreesAddRotationQuat(rotation, out = vec3_exports.create()) {
          this.vec3_degreesToQuat(quat);
          return quat.quat_addRotationQuat(rotation, quat).quat_toDegrees(out);
        };
      }();
      Array.prototype.vec3_radiansAddRotation = function(rotation, out) {
        return this.vec3_radiansAddRotationDegrees(rotation, out);
      };
      Array.prototype.vec3_radiansAddRotationDegrees = function() {
        let quat = quat_exports.create();
        return function vec3_radiansAddRotationDegrees(rotation, out = vec3_exports.create()) {
          this.vec3_radiansToQuat(quat);
          return quat.quat_addRotationDegrees(rotation, quat).quat_toRadians(out);
        };
      }();
      Array.prototype.vec3_radiansAddRotationRadians = function() {
        let quat = quat_exports.create();
        return function vec3_radiansAddRotationRadians(rotation, out = vec3_exports.create()) {
          this.vec3_radiansToQuat(quat);
          return quat.quat_addRotationRadians(rotation, quat).quat_toRadians(out);
        };
      }();
      Array.prototype.vec3_radiansAddRotationQuat = function() {
        let quat = quat_exports.create();
        return function vec3_radiansAddRotationQuat(rotation, out = vec3_exports.create()) {
          this.vec3_radiansToQuat(quat);
          return quat.quat_addRotationQuat(rotation, quat).quat_toRadians(out);
        };
      }();
      Array.prototype.vec3_toMatrix = function(out = mat3_exports.create()) {
        return this.vec3_degreesToMatrix(out);
      };
      Array.prototype.vec3_degreesToMatrix = function() {
        let quat = quat_exports.create();
        return function vec3_degreesToMatrix(out = mat3_exports.create()) {
          this.vec3_degreesToQuat(quat);
          return quat.quat_toMatrix(out);
        };
      }();
      Array.prototype.vec3_radiansToMatrix = function() {
        let quat = quat_exports.create();
        return function vec3_radiansToMatrix(out = mat3_exports.create()) {
          this.vec3_radiansToQuat(quat);
          return quat.quat_toMatrix(out);
        };
      }();
      Array.prototype.vec3_rotationTo = function(direction, out) {
        return this.vec3_rotationToDegrees(direction, out);
      };
      Array.prototype.vec3_rotationToDegrees = function() {
        let rotationQuat = quat_exports.create();
        return function vec3_rotationToDegrees(direction, out = vec3_exports.create()) {
          this.vec3_rotationToQuat(direction, rotationQuat);
          rotationQuat.quat_toDegrees(out);
          return out;
        };
      }();
      Array.prototype.vec3_rotationToRadians = function() {
        let rotationQuat = quat_exports.create();
        return function vec3_rotationToRadians(direction, out = vec3_exports.create()) {
          this.vec3_rotationToQuat(direction, rotationQuat);
          rotationQuat.quat_toRadians(out);
          return out;
        };
      }();
      Array.prototype.vec3_rotationToQuat = function() {
        let rotationAxis = vec3_exports.create();
        return function vec3_rotationToQuat(direction, out = quat_exports.create()) {
          this.vec3_cross(direction, rotationAxis);
          rotationAxis.vec3_normalize(rotationAxis);
          let signedAngle = this.vec3_angleSigned(direction, rotationAxis);
          out.quat_fromAxis(signedAngle, rotationAxis);
          return out;
        };
      }();
      Array.prototype.vec3_rotationToPivoted = function(direction, pivotAxis, out) {
        return this.vec3_rotationToPivotedDegrees(direction, pivotAxis, out);
      };
      Array.prototype.vec3_rotationToPivotedDegrees = function() {
        let rotationQuat = quat_exports.create();
        return function vec3_rotationToPivotedDegrees(direction, pivotAxis, out = vec3_exports.create()) {
          this.vec3_rotationToPivotedQuat(direction, pivotAxis, rotationQuat);
          rotationQuat.quat_toDegrees(out);
          return out;
        };
      }();
      Array.prototype.vec3_rotationToPivotedRadians = function() {
        let rotationQuat = quat_exports.create();
        return function vec3_rotationToPivotedRadians(direction, pivotAxis, out = vec3_exports.create()) {
          this.vec3_rotationToPivotedQuat(direction, pivotAxis, rotationQuat);
          rotationQuat.quat_toRadians(out);
          return out;
        };
      }();
      Array.prototype.vec3_rotationToPivotedQuat = function() {
        let thisFlat = vec3_exports.create();
        let directionFlat = vec3_exports.create();
        let rotationAxis = vec3_exports.create();
        return function vec3_rotationToPivotedQuat(direction, pivotAxis, out = quat_exports.create()) {
          this.vec3_removeComponentAlongAxis(pivotAxis, thisFlat);
          direction.vec3_removeComponentAlongAxis(pivotAxis, directionFlat);
          thisFlat.vec3_cross(directionFlat, rotationAxis);
          rotationAxis.vec3_normalize(rotationAxis);
          let signedAngle = thisFlat.vec3_angleSigned(directionFlat, rotationAxis);
          out.quat_fromAxis(signedAngle, rotationAxis);
          return out;
        };
      }();
      Array.prototype.vec3_lerp = function(to, interpolationValue, out = vec3_exports.create()) {
        if (interpolationValue <= 0) {
          out.vec3_copy(this);
          return out;
        } else if (interpolationValue >= 1) {
          out.vec3_copy(to);
          return out;
        }
        vec3_exports.lerp(out, this, to, interpolationValue);
        return out;
      };
      Array.prototype.vec3_interpolate = function(to, interpolationValue, easingFunction = PP.EasingFunction.linear, out = vec3_exports.create()) {
        let lerpValue = easingFunction(interpolationValue);
        return this.vec3_lerp(to, lerpValue, out);
      };
      Array.prototype.vec4_set = function(x, y = null, z = null, w = null) {
        if (y == null) {
          vec4_exports.set(this, x, x, x, x);
        } else {
          vec4_exports.set(this, x, y, z, w);
        }
        return this;
      };
      Array.prototype.vec4_copy = function(vector) {
        vec4_exports.copy(this, vector);
        return this;
      };
      Array.prototype.quat_normalize = function(out = quat_exports.create()) {
        quat_exports.normalize(out, this);
        return out;
      };
      Array.prototype.quat_copy = function(quat) {
        quat_exports.copy(this, quat);
        return this;
      };
      Array.prototype.quat_clone = function(out = quat_exports.create()) {
        quat_exports.copy(out, this);
        return out;
      };
      Array.prototype.quat_set = function(x, y = null, z = null, w = null) {
        if (y == null) {
          quat_exports.set(this, x, x, x, x);
        } else {
          quat_exports.set(this, x, y, z, w);
        }
        return this;
      };
      Array.prototype.quat_identity = function() {
        quat_exports.identity(this);
        return this;
      };
      Array.prototype.quat_length = function() {
        return quat_exports.length(this);
      };
      Array.prototype.quat_invert = function(out = quat_exports.create()) {
        quat_exports.invert(out, this);
        return out;
      };
      Array.prototype.quat_mul = function(rotation, out = quat_exports.create()) {
        quat_exports.mul(out, this, rotation);
        return out;
      };
      Array.prototype.quat_getAxis = function(out = vec3_exports.create()) {
        quat_exports.getAxisAngle(out, this);
        return out;
      };
      Array.prototype.quat_getAngle = function() {
        return this.quat_getAngleDegrees();
      };
      Array.prototype.quat_getAngleDegrees = function() {
        let angle3 = this.quat_getAngleRadians();
        return angle3 * (180 / Math.PI);
      };
      Array.prototype.quat_getAngleRadians = function() {
        let vector = vec3_exports.create();
        return function quat_getAngleRadians() {
          let angle3 = quat_exports.getAxisAngle(vector, this);
          return angle3;
        };
      }();
      Array.prototype.quat_getAxisScaled = function(out = vec3_exports.create()) {
        return this.quat_getAxisScaledDegrees(out);
      };
      Array.prototype.quat_getAxisScaledDegrees = function(out = vec3_exports.create()) {
        this.quat_getAxis(out);
        let angle3 = this.quat_getAngleDegrees();
        out.vec3_scale(angle3, out);
        return out;
      };
      Array.prototype.quat_getAxisScaledRadians = function(out = vec3_exports.create()) {
        this.quat_getAxis(out);
        let angle3 = this.quat_getAngleRadians();
        out.vec3_scale(angle3, out);
        return out;
      };
      Array.prototype.quat_getAxes = function(out = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()]) {
        this.quat_getLeft(out[0]);
        this.quat_getUp(out[1]);
        this.quat_getForward(out[2]);
        return out;
      };
      Array.prototype.quat_getForward = function() {
        let rotationMatrix = mat3_exports.create();
        return function quat_getForward(out = vec3_exports.create()) {
          mat3_exports.fromQuat(rotationMatrix, this);
          vec3_exports.set(out, rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);
          vec3_exports.normalize(out, out);
          return out;
        };
      }();
      Array.prototype.quat_getBackward = function(out) {
        out = this.quat_getForward(out);
        out.vec3_negate(out);
        return out;
      };
      Array.prototype.quat_getLeft = function() {
        let rotationMatrix = mat3_exports.create();
        return function quat_getLeft(out = vec3_exports.create()) {
          mat3_exports.fromQuat(rotationMatrix, this);
          vec3_exports.set(out, rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
          vec3_exports.normalize(out, out);
          return out;
        };
      }();
      Array.prototype.quat_getRight = function(out) {
        out = this.quat_getLeft(out);
        out.vec3_negate(out);
        return out;
      };
      Array.prototype.quat_getUp = function() {
        let rotationMatrix = mat3_exports.create();
        return function quat_getUp(out = vec3_exports.create()) {
          mat3_exports.fromQuat(rotationMatrix, this);
          vec3_exports.set(out, rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
          vec3_exports.normalize(out, out);
          return out;
        };
      }();
      Array.prototype.quat_getDown = function(out) {
        out = this.quat_getUp(out);
        out.vec3_negate(out);
        return out;
      };
      Array.prototype.quat_setAxes = function(left, up, forward) {
        if (forward != null) {
          return this.quat_setForward(forward, up, left);
        } else if (up != null) {
          return this.quat_setUp(up, forward, left);
        } else {
          return this.quat_setLeft(left, up, forward);
        }
      };
      Array.prototype.quat_setForward = function(forward, up = null, left = null) {
        return this._quat_setAxes([left, up, forward], [2, 1, 0]);
      };
      Array.prototype.quat_setBackward = function() {
        let forward = vec3_exports.create();
        return function quat_setBackward(backward, up = null, left = null) {
          backward.vec3_negate(forward);
          return this._quat_setAxes([left, up, forward], [2, 1, 0]);
        };
      }();
      Array.prototype.quat_setUp = function(up, forward = null, left = null) {
        return this._quat_setAxes([left, up, forward], [1, 2, 0]);
      };
      Array.prototype.quat_setDown = function() {
        let up = vec3_exports.create();
        return function quat_setDown(down, forward = null, left = null) {
          down.vec3_negate(up);
          return this._quat_setAxes([left, up, forward], [1, 2, 0]);
        };
      }();
      Array.prototype.quat_setLeft = function(left, up = null, forward = null) {
        return this._quat_setAxes([left, up, forward], [0, 1, 2]);
      };
      Array.prototype.quat_setRight = function() {
        let left = vec3_exports.create();
        return function quat_setRight(right, up = null, forward = null) {
          right.vec3_negate(left);
          return this._quat_setAxes([left, up, forward], [0, 1, 2]);
        };
      }();
      Array.prototype.quat_toWorld = function(parentQuat, out = quat_exports.create()) {
        quat_exports.mul(out, parentQuat, this);
        return out;
      };
      Array.prototype.quat_toLocal = function() {
        let invertQuat = quat_exports.create();
        return function quat_toLocal(parentQuat, out = quat_exports.create()) {
          quat_exports.conjugate(invertQuat, parentQuat);
          quat_exports.mul(out, invertQuat, this);
          return out;
        };
      }();
      Array.prototype.quat_fromAxis = function(angle3, axis) {
        return this.quat_fromAxisDegrees(angle3, axis);
      };
      Array.prototype.quat_fromAxisDegrees = function(angle3, axis) {
        quat_exports.setAxisAngle(this, axis, common_exports.toRadian(angle3));
        return this;
      };
      Array.prototype.quat_fromAxisRadians = function(angle3, axis) {
        quat_exports.setAxisAngle(this, axis, angle3);
        return this;
      };
      Array.prototype.quat_fromAxes = function() {
        let mat3 = mat3_exports.create();
        return function quat_fromAxes(leftAxis, upAxis, forwardAxis) {
          mat3.mat3_fromAxes(leftAxis, upAxis, forwardAxis);
          return mat3.mat3_toQuat(this);
        };
      }();
      Array.prototype.quat_fromRadians = function() {
        let vector = vec3_exports.create();
        return function quat_fromRadians(radiansRotation) {
          radiansRotation.vec3_toDegrees(vector);
          return this.quat_fromDegrees(vector);
        };
      }();
      Array.prototype.quat_fromDegrees = function(degreesRotation) {
        quat_exports.fromEuler(this, degreesRotation[0], degreesRotation[1], degreesRotation[2]);
        return this;
      };
      Array.prototype.quat_toRadians = function() {
        let mat3 = mat3_exports.create();
        return function quat_toRadians(out = vec3_exports.create()) {
          mat3_exports.fromQuat(mat3, this);
          out[1] = Math.asin(-this._pp_clamp(mat3[2], -1, 1));
          if (Math.abs(mat3[2]) < 1 - this._pp_epsilon) {
            out[0] = Math.atan2(mat3[5], mat3[8]);
            out[2] = Math.atan2(mat3[1], mat3[0]);
          } else {
            out[0] = 0;
            out[2] = Math.atan2(-mat3[3], mat3[4]);
          }
          return out;
        };
      }();
      Array.prototype.quat_toDegrees = function(out = vec3_exports.create()) {
        this.quat_toRadians(out);
        out.vec3_toDegrees(out);
        return out;
      };
      Array.prototype.quat_isNormalized = function(epsilon = this._pp_normalizedEpsilon) {
        return Math.abs(quat_exports.length(this) - 1) < epsilon;
      };
      Array.prototype.quat_addRotation = function(rotation, out) {
        return this.quat_addRotationDegrees(rotation, out);
      };
      Array.prototype.quat_addRotationDegrees = function() {
        let quat = quat_exports.create();
        return function quat_addRotationDegrees(rotation, out) {
          rotation.vec3_degreesToQuat(quat);
          return this.quat_addRotationQuat(quat, out);
        };
      }();
      Array.prototype.quat_addRotationRadians = function() {
        let quat = quat_exports.create();
        return function quat_addRotationRadians(rotation, out) {
          rotation.vec3_radiansToQuat(quat);
          return this.quat_addRotationQuat(quat, out);
        };
      }();
      Array.prototype.quat_addRotationQuat = function(rotation, out = quat_exports.create()) {
        rotation.quat_mul(this, out);
        return out;
      };
      Array.prototype.quat_subRotation = function(rotation, out) {
        return this.quat_subRotationDegrees(rotation, out);
      };
      Array.prototype.quat_subRotationDegrees = function() {
        let quat = quat_exports.create();
        return function quat_subRotationDegrees(rotation, out) {
          rotation.vec3_degreesToQuat(quat);
          return this.quat_subRotationQuat(quat, out);
        };
      }();
      Array.prototype.quat_subRotationRadians = function() {
        let quat = quat_exports.create();
        return function quat_subRotationRadians(rotation, out) {
          rotation.vec3_radiansToQuat(quat);
          return this.quat_subRotationQuat(quat, out);
        };
      }();
      Array.prototype.quat_subRotationQuat = function() {
        let inverse4 = quat_exports.create();
        return function quat_subRotationQuat(rotation, out = quat_exports.create()) {
          rotation.quat_invert(inverse4);
          this.quat_mul(inverse4, out);
          if (this.quat_isNormalized() && rotation.quat_isNormalized()) {
            out.quat_normalize(out);
          }
          return out;
        };
      }();
      Array.prototype.quat_rotationTo = function(rotation, out) {
        return this.quat_rotationToDegrees(rotation, out);
      };
      Array.prototype.quat_rotationToDegrees = function() {
        let rotationQuat = quat_exports.create();
        return function quat_rotationToDegrees(rotation, out) {
          rotation.vec3_degreesToQuat(rotationQuat);
          return this.quat_rotationToQuat(rotationQuat, out);
        };
      }();
      Array.prototype.quat_rotationToRadians = function() {
        let rotationQuat = quat_exports.create();
        return function quat_rotationToRadians(rotation, out) {
          rotation.vec3_radiansToQuat(rotationQuat);
          return this.quat_rotationToQuat(rotationQuat, out);
        };
      }();
      Array.prototype.quat_rotationToQuat = function(rotation, out) {
        return rotation.quat_subRotationQuat(this, out);
      };
      Array.prototype.quat_getTwist = function() {
        let rotationAxis = vec3_exports.create();
        let projection2 = vec3_exports.create();
        let rotationAlongAxis = quat_exports.create();
        return function quat_getTwist(axis, out = quat_exports.create()) {
          rotationAxis[0] = this[0];
          rotationAxis[1] = this[1];
          rotationAxis[2] = this[2];
          let dotProd = vec3_exports.dot(axis, rotationAxis);
          axis.vec3_scale(dotProd, projection2);
          rotationAlongAxis[0] = projection2[0];
          rotationAlongAxis[1] = projection2[1];
          rotationAlongAxis[2] = projection2[2];
          rotationAlongAxis[3] = this[3];
          rotationAlongAxis.quat_normalize(rotationAlongAxis);
          if (dotProd < 0) {
            rotationAlongAxis[0] = -rotationAlongAxis[0];
            rotationAlongAxis[1] = -rotationAlongAxis[1];
            rotationAlongAxis[2] = -rotationAlongAxis[2];
            rotationAlongAxis[3] = -rotationAlongAxis[3];
          }
          return out.quat_copy(rotationAlongAxis);
        };
      }();
      Array.prototype.quat_getSwing = function() {
        let twist = quat_exports.create();
        return function quat_getSwing(axis, out = quat_exports.create()) {
          this.quat_getTwist(axis, twist);
          this.quat_getSwingFromTwist(twist, out);
          return out;
        };
      }();
      Array.prototype.quat_getSwingFromTwist = function(twist, out = quat_exports.create()) {
        return this.quat_subRotationQuat(twist, out);
      };
      Array.prototype.quat_getTwistFromSwing = function() {
        let inverse4 = quat_exports.create();
        return function quat_getTwistFromSwing(swing, out = quat_exports.create()) {
          swing.quat_invert(inverse4);
          this.quat_addRotationQuat(inverse4, out);
          return out;
        };
      }();
      Array.prototype.quat_fromTwistSwing = function(twist, swing) {
        return twist.quat_addRotationQuat(swing, this);
      };
      Array.prototype.quat_toMatrix = function(out = mat3_exports.create()) {
        mat3_exports.fromQuat(out, this);
        return out;
      };
      Array.prototype.quat_rotate = function(rotation, out) {
        return this.quat_rotateDegrees(rotation, out);
      };
      Array.prototype.quat_rotateDegrees = function(rotation, out) {
        return this.quat_addRotationDegrees(rotation, out);
      };
      Array.prototype.quat_rotateRadians = function(rotation, out) {
        return this.quat_addRotationRadians(rotation, out);
      };
      Array.prototype.quat_rotateQuat = function(rotation, out) {
        return this.quat_addRotationQuat(rotation, out);
      };
      Array.prototype.quat_rotateAxis = function(angle3, axis, out) {
        return this.quat_rotateAxisDegrees(angle3, axis, out);
      };
      Array.prototype.quat_rotateAxisDegrees = function() {
        let rotationQuat = quat_exports.create();
        return function quat_rotateAxisDegrees(angle3, axis, out) {
          rotationQuat.quat_fromAxisDegrees(angle3, axis);
          return this.quat_rotateQuat(rotationQuat, out);
        };
      }();
      Array.prototype.quat_rotateAxisRadians = function() {
        let rotationQuat = quat_exports.create();
        return function quat_rotateAxisRadians(angle3, axis, out) {
          rotationQuat.quat_fromAxisRadians(angle3, axis);
          return this.quat_rotateQuat(rotationQuat, out);
        };
      }();
      Array.prototype.quat_lerp = function(to, interpolationValue, out = quat_exports.create()) {
        if (interpolationValue <= 0) {
          out.quat_copy(this);
          return out;
        } else if (interpolationValue >= 1) {
          out.quat_copy(to);
          return out;
        }
        quat_exports.lerp(out, this, to, interpolationValue);
        return out;
      };
      Array.prototype.quat_interpolate = function(to, interpolationValue, easingFunction = PP.EasingFunction.linear, out = quat_exports.create()) {
        let lerpValue = easingFunction(interpolationValue);
        return this.quat_lerp(to, lerpValue, out);
      };
      Array.prototype.quat_slerp = function(to, interpolationValue, out = quat_exports.create()) {
        if (interpolationValue <= 0) {
          out.quat_copy(this);
          return out;
        } else if (interpolationValue >= 1) {
          out.quat_copy(to);
          return out;
        }
        quat_exports.slerp(out, this, to, interpolationValue);
        return out;
      };
      Array.prototype.quat_sinterpolate = function(to, interpolationValue, easingFunction = PP.EasingFunction.linear, out = quat_exports.create()) {
        let lerpValue = easingFunction(interpolationValue);
        return this.quat_slerp(to, lerpValue, out);
      };
      Array.prototype.quat2_normalize = function(out = quat2_exports.create()) {
        quat2_exports.normalize(out, this);
        return out;
      };
      Array.prototype.quat2_copy = function(quat2) {
        quat2_exports.copy(this, quat2);
        return this;
      };
      Array.prototype.quat2_identity = function() {
        quat2_exports.identity(this);
        return this;
      };
      Array.prototype.quat2_getPosition = function(out = vec3_exports.create()) {
        quat2_exports.getTranslation(out, this);
        return out;
      };
      Array.prototype.quat2_getRotation = function(out) {
        return this.quat2_getRotationDegrees(out);
      };
      Array.prototype.quat2_getRotationDegrees = function() {
        let rotationQuat = quat_exports.create();
        return function quat2_getRotationDegrees(out = vec3_exports.create()) {
          this.quat2_getRotationQuat(rotationQuat).quat_toDegrees(out);
          return out;
        };
      }();
      Array.prototype.quat2_getRotationRadians = function() {
        let rotationQuat = quat_exports.create();
        return function quat2_getRotationRadians(out = vec3_exports.create()) {
          this.quat2_getRotationQuat(rotationQuat).quat_toRadians(out);
          return out;
        };
      }();
      Array.prototype.quat2_getRotationQuat = function(out = quat_exports.create()) {
        quat_exports.copy(out, this);
        return out;
      };
      Array.prototype.quat2_setPosition = function() {
        let rotationQuat = quat_exports.create();
        return function quat2_setPosition(position) {
          this.quat2_getRotationQuat(rotationQuat);
          this.quat2_setPositionRotationQuat(position, rotationQuat);
          return this;
        };
      }();
      Array.prototype.quat2_setRotation = function(rotation) {
        return this.quat2_setRotationDegrees(rotation);
      };
      Array.prototype.quat2_setRotationDegrees = function() {
        let position = vec3_exports.create();
        return function quat2_setRotationDegrees(rotation) {
          this.quat2_getPosition(position);
          this.quat2_setPositionRotationDegrees(position, rotation);
          return this;
        };
      }();
      Array.prototype.quat2_setRotationRadians = function() {
        let position = vec3_exports.create();
        return function quat2_setRotationRadians(rotation) {
          this.quat2_getPosition(position);
          this.quat2_setPositionRotationRadians(position, rotation);
          return this;
        };
      }();
      Array.prototype.quat2_setRotationQuat = function() {
        let position = vec3_exports.create();
        return function quat2_setRotationQuat(rotation) {
          this.quat2_getPosition(position);
          this.quat2_setPositionRotationQuat(position, rotation);
          return this;
        };
      }();
      Array.prototype.quat2_setPositionRotation = function(position, rotation) {
        return this.quat2_setPositionRotationDegrees(position, rotation);
      };
      Array.prototype.quat2_setPositionRotationDegrees = function() {
        let rotationQuat = quat_exports.create();
        return function quat2_setPositionRotationDegrees(position, rotation) {
          rotation.vec3_degreesToQuat(rotationQuat);
          quat2_exports.fromRotationTranslation(this, rotationQuat, position);
          return this;
        };
      }();
      Array.prototype.quat2_setPositionRotationRadians = function() {
        let rotationQuat = quat_exports.create();
        return function quat2_setPositionRotationRadians(position, rotation) {
          rotation.vec3_radiansToQuat(rotationQuat);
          quat2_exports.fromRotationTranslation(this, rotationQuat, position);
          return this;
        };
      }();
      Array.prototype.quat2_setPositionRotationQuat = function(position, rotation) {
        quat2_exports.fromRotationTranslation(this, rotation, position);
        return this;
      };
      Array.prototype.quat2_isNormalized = function(epsilon = this._pp_normalizedEpsilon) {
        return Math.abs(quat2_exports.length(this) - 1) < epsilon;
      };
      Array.prototype.quat2_getAxes = function(out = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()]) {
        this.quat2_getLeft(out[0]);
        this.quat2_getUp(out[1]);
        this.quat2_getForward(out[2]);
        return out;
      };
      Array.prototype.quat2_getForward = function() {
        let rotationMatrix = mat3_exports.create();
        return function quat2_getForward(out = vec3_exports.create()) {
          mat3_exports.fromQuat(rotationMatrix, this);
          vec3_exports.set(out, rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);
          vec3_exports.normalize(out, out);
          return out;
        };
      }();
      Array.prototype.quat2_getBackward = function(out) {
        out = this.quat2_getForward(out);
        out.vec3_negate(out);
        return out;
      };
      Array.prototype.quat2_getLeft = function() {
        let rotationMatrix = mat3_exports.create();
        return function quat2_getLeft(out = vec3_exports.create()) {
          mat3_exports.fromQuat(rotationMatrix, this);
          vec3_exports.set(out, rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
          vec3_exports.normalize(out, out);
          return out;
        };
      }();
      Array.prototype.quat2_getRight = function(out) {
        out = this.quat2_getLeft(out);
        out.vec3_negate(out);
        return out;
      };
      Array.prototype.quat2_getUp = function() {
        let rotationMatrix = mat3_exports.create();
        return function quat2_getUp(out = vec3_exports.create()) {
          mat3_exports.fromQuat(rotationMatrix, this);
          vec3_exports.set(out, rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
          vec3_exports.normalize(out, out);
          return out;
        };
      }();
      Array.prototype.quat2_getDown = function(out) {
        out = this.quat2_getUp(out);
        out.vec3_negate(out);
        return out;
      };
      Array.prototype.quat2_toWorld = function(parentTransformQuat, out = quat2_exports.create()) {
        quat2_exports.mul(out, parentTransformQuat, this);
        return out;
      };
      Array.prototype.quat2_toLocal = function() {
        let invertQuat = quat2_exports.create();
        return function quat2_toLocal(parentTransformQuat, out = quat2_exports.create()) {
          quat2_exports.conjugate(invertQuat, parentTransformQuat);
          quat2_exports.mul(out, invertQuat, this);
          return out;
        };
      }();
      Array.prototype.quat2_toMatrix = function(out = mat4_exports.create()) {
        mat4_exports.fromQuat2(out, this);
        return out;
      };
      Array.prototype.quat2_fromMatrix = function(transformMatrix) {
        transformMatrix.mat4_toQuat(this);
        return this;
      };
      Array.prototype.quat2_lerp = function(to, interpolationValue, out = quat2_exports.create()) {
        if (interpolationValue <= 0) {
          out.quat2_copy(this);
          return out;
        } else if (interpolationValue >= 1) {
          out.quat2_copy(to);
          return out;
        }
        quat2_exports.lerp(out, this, to, interpolationValue);
        return out;
      };
      Array.prototype.quat2_interpolate = function(to, interpolationValue, easingFunction = PP.EasingFunction.linear, out = quat2_exports.create()) {
        let lerpValue = easingFunction(interpolationValue);
        return this.quat2_lerp(to, lerpValue, out);
      };
      Array.prototype.mat3_toDegrees = function() {
        let quat = quat_exports.create();
        return function mat3_toDegrees(out = vec3_exports.create()) {
          this.mat3_toQuat(quat);
          quat.quat_toDegrees(out);
          return out;
        };
      }();
      Array.prototype.mat3_toRadians = function() {
        let quat = quat_exports.create();
        return function mat3_toRadians(out = vec3_exports.create()) {
          this.mat3_toQuat(quat);
          quat.quat_toRadians(out);
          return out;
        };
      }();
      Array.prototype.mat3_toQuat = function(out = quat_exports.create()) {
        quat_exports.fromMat3(out, this);
        return out;
      };
      Array.prototype.mat3_fromAxes = function(leftAxis, upAxis, forwardAxis) {
        mat3_exports.set(
          this,
          leftAxis[0],
          leftAxis[1],
          leftAxis[2],
          upAxis[0],
          upAxis[1],
          upAxis[2],
          forwardAxis[0],
          forwardAxis[1],
          forwardAxis[2]
        );
        return this;
      };
      Array.prototype.mat4_copy = function(mat4) {
        mat4_exports.copy(this, mat4);
        return this;
      };
      Array.prototype.mat4_identity = function() {
        mat4_exports.identity(this);
        return this;
      };
      Array.prototype.mat4_invert = function(out = mat4_exports.create()) {
        mat4_exports.invert(out, this);
        return out;
      };
      Array.prototype.mat4_clone = function(out = mat4_exports.create()) {
        mat4_exports.copy(out, this);
        return out;
      };
      Array.prototype.mat4_getPosition = function(out = vec3_exports.create()) {
        mat4_exports.getTranslation(out, this);
        return out;
      };
      Array.prototype.mat4_getRotation = function(out = vec3_exports.create()) {
        return this.mat4_getRotationDegrees(out);
      };
      Array.prototype.mat4_getRotationDegrees = function() {
        let quat = quat_exports.create();
        return function mat4_getRotationDegrees(out = vec3_exports.create()) {
          this.mat4_getRotationQuat(quat);
          quat.quat_toDegrees(out);
          return out;
        };
      }();
      Array.prototype.mat4_getRotationRadians = function() {
        let quat = quat_exports.create();
        return function mat4_getRotationRadians(out = vec3_exports.create()) {
          this.mat4_getRotationQuat(quat);
          quat.quat_toRadians(out);
          return out;
        };
      }();
      Array.prototype.mat4_getRotationQuat = function() {
        let scale8 = vec3_exports.create();
        let transformMatrixNoScale = mat4_exports.create();
        let inverseScale = vec3_exports.create();
        let one = vec3_exports.create();
        vec3_exports.set(one, 1, 1, 1);
        return function mat4_getRotationQuat(out = quat_exports.create()) {
          mat4_exports.getScaling(scale8, this);
          vec3_exports.divide(inverseScale, one, scale8);
          mat4_exports.scale(transformMatrixNoScale, this, inverseScale);
          mat4_exports.getRotation(out, transformMatrixNoScale);
          quat_exports.normalize(out, out);
          return out;
        };
      }();
      Array.prototype.mat4_getScale = function(out = vec3_exports.create()) {
        mat4_exports.getScaling(out, this);
        return out;
      };
      Array.prototype.mat4_setPosition = function(position) {
        this[12] = position[0];
        this[13] = position[1];
        this[14] = position[2];
        return this;
      };
      Array.prototype.mat4_setRotation = function(rotation) {
        this.mat4_setRotationDegrees(rotation);
        return this;
      };
      Array.prototype.mat4_setRotationDegrees = function() {
        let quat = quat_exports.create();
        return function mat4_setRotationDegrees(rotation) {
          this.mat4_setRotationQuat(rotation.vec3_degreesToQuat(quat));
          return this;
        };
      }();
      Array.prototype.mat4_setRotationRadians = function() {
        let vector = vec3_exports.create();
        return function mat4_setRotationRadians(rotation) {
          this.mat4_setRotationDegrees(rotation.vec3_toDegrees(vector));
          return this;
        };
      }();
      Array.prototype.mat4_setRotationQuat = function() {
        let position = vec3_exports.create();
        let scale8 = vec3_exports.create();
        return function mat4_setRotationQuat(rotation) {
          this.mat4_getPosition(position);
          this.mat4_getScale(scale8);
          this.mat4_setPositionRotationQuatScale(position, rotation, scale8);
          return this;
        };
      }();
      Array.prototype.mat4_setScale = function() {
        let tempScale = vec3_exports.create();
        return function mat4_setScale(scale8) {
          mat4_exports.getScaling(tempScale, this);
          vec3_exports.divide(tempScale, scale8, tempScale);
          mat4_exports.scale(this, this, tempScale);
          return this;
        };
      }();
      Array.prototype.mat4_setPositionRotationScale = function(position, rotation, scale8) {
        this.mat4_setPositionRotationDegreesScale(position, rotation, scale8);
        return this;
      };
      Array.prototype.mat4_setPositionRotationDegreesScale = function() {
        let quat = quat_exports.create();
        return function mat4_setPositionRotationDegreesScale(position, rotation, scale8) {
          this.mat4_setPositionRotationQuatScale(position, rotation.vec3_degreesToQuat(quat), scale8);
          return this;
        };
      }();
      Array.prototype.mat4_setPositionRotationRadiansScale = function() {
        let vector = vec3_exports.create();
        return function mat4_setPositionRotationRadiansScale(position, rotation, scale8) {
          this.mat4_setPositionRotationDegreesScale(position, rotation.vec3_toDegrees(vector), scale8);
          return this;
        };
      }();
      Array.prototype.mat4_setPositionRotationQuatScale = function(position, rotation, scale8) {
        mat4_exports.fromRotationTranslationScale(this, rotation, position, scale8);
        return this;
      };
      Array.prototype.mat4_setPositionRotation = function(position, rotation) {
        this.mat4_setPositionRotationDegrees(position, rotation);
        return this;
      };
      Array.prototype.mat4_setPositionRotationDegrees = function() {
        let quat = quat_exports.create();
        return function mat4_setPositionRotationDegrees(position, rotation) {
          this.mat4_setPositionRotationQuat(position, rotation.vec3_degreesToQuat(quat));
          return this;
        };
      }();
      Array.prototype.mat4_setPositionRotationRadians = function() {
        let vector = vec3_exports.create();
        return function mat4_setPositionRotationRadians(position, rotation) {
          this.mat4_setPositionRotationDegrees(position, rotation.vec3_toDegrees(vector));
          return this;
        };
      }();
      Array.prototype.mat4_setPositionRotationQuat = function(position, rotation) {
        mat4_exports.fromRotationTranslation(this, rotation, position);
        return this;
      };
      Array.prototype.mat4_getAxes = function(out = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()]) {
        this.mat4_getLeft(out[0]);
        this.mat4_getUp(out[1]);
        this.mat4_getForward(out[2]);
        return out;
      };
      Array.prototype.mat4_getForward = function(out = vec3_exports.create()) {
        vec3_exports.set(out, this[8], this[9], this[10]);
        vec3_exports.normalize(out, out);
        return out;
      };
      Array.prototype.mat4_getBackward = function(out) {
        out = this.mat4_getForward(out);
        out.vec3_negate(out);
        return out;
      };
      Array.prototype.mat4_getLeft = function(out = vec3_exports.create()) {
        vec3_exports.set(out, this[0], this[1], this[2]);
        vec3_exports.normalize(out, out);
        return out;
      };
      Array.prototype.mat4_getRight = function(out) {
        out = this.mat4_getLeft(out);
        out.vec3_negate(out);
        return out;
      };
      Array.prototype.mat4_getUp = function(out = vec3_exports.create()) {
        vec3_exports.set(out, this[4], this[5], this[6]);
        vec3_exports.normalize(out, out);
        return out;
      };
      Array.prototype.mat4_getDown = function(out) {
        out = this.mat4_getUp(out);
        out.vec3_negate(out);
        return out;
      };
      Array.prototype.mat4_toWorld = function() {
        let convertTransform = mat4_exports.create();
        let position = vec3_exports.create();
        let scale8 = vec3_exports.create();
        let inverseScale = vec3_exports.create();
        let one = vec3_exports.create();
        vec3_exports.set(one, 1, 1, 1);
        return function mat4_toWorld(parentTransformMatrix, out = mat4_exports.create()) {
          if (parentTransformMatrix.mat4_hasUniformScale()) {
            mat4_exports.mul(out, parentTransformMatrix, this);
          } else {
            vec3_exports.set(position, this[12], this[13], this[14]);
            position.vec3_convertPositionToWorldMatrix(parentTransformMatrix, position);
            mat4_exports.getScaling(scale8, parentTransformMatrix);
            vec3_exports.divide(inverseScale, one, scale8);
            mat4_exports.scale(convertTransform, parentTransformMatrix, inverseScale);
            mat4_exports.mul(out, convertTransform, this);
            mat4_exports.scale(out, out, scale8);
            out[12] = position[0];
            out[13] = position[1];
            out[14] = position[2];
            out[15] = 1;
          }
          return out;
        };
      }();
      Array.prototype.mat4_toLocal = function() {
        let convertTransform = mat4_exports.create();
        let position = vec3_exports.create();
        let scale8 = vec3_exports.create();
        let inverseScale = vec3_exports.create();
        let one = vec3_exports.create();
        vec3_exports.set(one, 1, 1, 1);
        return function mat4_toLocal(parentTransformMatrix, out = mat4_exports.create()) {
          if (parentTransformMatrix.mat4_hasUniformScale()) {
            mat4_exports.invert(convertTransform, parentTransformMatrix);
            mat4_exports.mul(out, convertTransform, this);
          } else {
            vec3_exports.set(position, this[12], this[13], this[14]);
            position.vec3_convertPositionToLocalMatrix(parentTransformMatrix, position);
            mat4_exports.getScaling(scale8, parentTransformMatrix);
            vec3_exports.divide(inverseScale, one, scale8);
            mat4_exports.scale(convertTransform, parentTransformMatrix, inverseScale);
            mat4_exports.invert(convertTransform, convertTransform);
            mat4_exports.mul(out, convertTransform, this);
            mat4_exports.scale(out, out, inverseScale);
            out[12] = position[0];
            out[13] = position[1];
            out[14] = position[2];
            out[15] = 1;
          }
          return out;
        };
      }();
      Array.prototype.mat4_hasUniformScale = function() {
        let scale8 = vec3_exports.create();
        return function mat4_hasUniformScale() {
          mat4_exports.getScaling(scale8, this);
          return Math.abs(scale8[0] - scale8[1]) < this._pp_epsilon && Math.abs(scale8[1] - scale8[2]) < this._pp_epsilon && Math.abs(scale8[0] - scale8[2]) < this._pp_epsilon;
        };
      }();
      Array.prototype.mat4_toQuat = function() {
        let position = vec3_exports.create();
        let rotation = quat_exports.create();
        return function mat4_toQuat(out = quat2_exports.create()) {
          mat4_exports.getTranslation(position, this);
          this.mat4_getRotationQuat(rotation);
          quat2_exports.fromRotationTranslation(out, rotation, position);
          return out;
        };
      }();
      Array.prototype.mat4_fromQuat = function(transformQuat3) {
        transformQuat3.quat2_toMatrix(this);
        return this;
      };
      PP.vec2_create = function(x = null, y = null) {
        let out = vec2_exports.create();
        if (x != null) {
          out.vec2_set(x, y);
        }
        return out;
      };
      PP.vec3_create = function(x = null, y = null, z = null) {
        let out = vec3_exports.create();
        if (x != null) {
          out.vec3_set(x, y, z);
        }
        return out;
      };
      PP.vec4_create = function(x = null, y = null, z = null, w = null) {
        let out = vec4_exports.create();
        if (x != null) {
          out.vec4_set(x, y, z, w);
        }
        return out;
      };
      PP.quat_create = function(x = null, y = null, z = null, w = null) {
        let out = quat_exports.create();
        if (x != null) {
          out.quat_set(x, y, z, w);
        }
        return out;
      };
      PP.quat2_create = function() {
        let out = quat2_exports.create();
        return out;
      };
      PP.quat2_fromPositionRotation = function(position, rotation) {
        return PP.quat2_fromPositionRotationDegrees(position, rotation);
      };
      PP.quat2_fromPositionRotationDegrees = function(position, rotation) {
        let out = mat4_exports.create();
        out.quat2_setPositionRotationDegrees(position, rotation);
        return out;
      };
      PP.quat2_fromPositionRotationRadians = function(position, rotation) {
        let out = mat4_exports.create();
        out.quat2_setPositionRotationRadians(position, rotation);
        return out;
      };
      PP.quat2_fromPositionRotationQuat = function(position, rotation) {
        let out = quat2_exports.create();
        out.quat2_setPositionRotationQuat(position, rotation);
        return out;
      };
      PP.mat4_create = function() {
        let out = mat4_exports.create();
        return out;
      };
      PP.mat4_fromPositionRotation = function(position, rotation) {
        return PP.mat4_fromPositionRotationDegrees(position, rotation);
      };
      PP.mat4_fromPositionRotationDegrees = function(position, rotation) {
        let out = mat4_exports.create();
        out.mat4_setPositionRotationDegrees(position, rotation);
        return out;
      };
      PP.mat4_fromPositionRotationRadians = function(position, rotation) {
        let out = mat4_exports.create();
        out.mat4_setPositionRotationRadians(position, rotation);
        return out;
      };
      PP.mat4_fromPositionRotationQuat = function(position, rotation) {
        let out = mat4_exports.create();
        out.mat4_setPositionRotationQuat(position, rotation);
        return out;
      };
      PP.mat4_fromPositionRotationScale = function(position, rotation, scale8) {
        return PP.mat4_fromPositionRotationDegreesScale(position, rotation, scale8);
      };
      PP.mat4_fromPositionRotationDegreesScale = function(position, rotation, scale8) {
        let out = mat4_exports.create();
        out.mat4_setPositionRotationDegreesScale(position, rotation, scale8);
        return out;
      };
      PP.mat4_fromPositionRotationRadiansScale = function(position, rotation, scale8) {
        let out = mat4_exports.create();
        out.mat4_setPositionRotationRadiansScale(position, rotation, scale8);
        return out;
      };
      PP.mat4_fromPositionRotationQuatScale = function(position, rotation, scale8) {
        let out = mat4_exports.create();
        out.mat4_setPositionRotationQuatScale(position, rotation, scale8);
        return out;
      };
      Array.prototype._pp_epsilon = 1e-6;
      Array.prototype._pp_degreesEpsilon = 1e-5;
      Array.prototype._pp_normalizedEpsilon = 1e-7;
      Array.prototype._pp_clamp = function(value, min4, max4) {
        return Math.min(Math.max(value, min4), max4);
      };
      Array.prototype._vec_buildConsoleMessage = function(decimalPlaces) {
        let message = "[";
        for (let i = 0; i < this.length; i++) {
          if (i != 0) {
            message = message.concat(", ");
          }
          if (decimalPlaces != null) {
            message = message.concat(this[i].toFixed(decimalPlaces));
          } else {
            message = message.concat(this[i].toString());
          }
        }
        message = message.concat("]");
        return message;
      };
      Array.prototype._vec_prepareOut = function(out) {
        if (out == null) {
          out = this.pp_clone();
        } else if (out != this) {
          out.pp_copy(this);
        }
        return out;
      };
      Array.prototype._quat_setAxes = function() {
        let fixedAxes = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()];
        let fixedAxesFixSignMap = [
          [1, -1, 1],
          [1, 1, -1],
          [-1, 1, -1]
        ];
        let fixedLeft = vec3_exports.create();
        let fixedUp = vec3_exports.create();
        let fixedForward = vec3_exports.create();
        let currentAxis = vec3_exports.create();
        let rotationAxis = vec3_exports.create();
        let rotationMat = mat3_exports.create();
        let rotationQuat = quat_exports.create();
        return function _quat_setAxes(axes, priority) {
          let firstAxis = axes[priority[0]];
          let secondAxis = axes[priority[1]];
          let thirdAxis = axes[priority[2]];
          if (firstAxis == null || firstAxis.vec3_length() <= this._pp_epsilon) {
            return;
          }
          let secondAxisValid = false;
          if (secondAxis != null) {
            let angleBetween = vec3_exports.angle(firstAxis, secondAxis);
            if (angleBetween > this._pp_epsilon) {
              secondAxisValid = true;
            }
          }
          let thirdAxisValid = false;
          if (thirdAxis != null) {
            let angleBetween = vec3_exports.angle(firstAxis, thirdAxis);
            if (angleBetween > this._pp_epsilon) {
              thirdAxisValid = true;
            }
          }
          if (secondAxisValid || thirdAxisValid) {
            let crossAxis = null;
            let secondAxisIndex = null;
            let thirdAxisIndex = null;
            if (secondAxisValid) {
              crossAxis = secondAxis;
              secondAxisIndex = 1;
              thirdAxisIndex = 2;
            } else {
              crossAxis = thirdAxis;
              secondAxisIndex = 2;
              thirdAxisIndex = 1;
            }
            let fixSignMap = fixedAxesFixSignMap[priority[0]];
            vec3_exports.cross(fixedAxes[thirdAxisIndex], firstAxis, crossAxis);
            vec3_exports.scale(fixedAxes[thirdAxisIndex], fixedAxes[thirdAxisIndex], fixSignMap[priority[thirdAxisIndex]]);
            vec3_exports.cross(fixedAxes[secondAxisIndex], firstAxis, fixedAxes[thirdAxisIndex]);
            vec3_exports.scale(fixedAxes[secondAxisIndex], fixedAxes[secondAxisIndex], fixSignMap[priority[secondAxisIndex]]);
            vec3_exports.cross(fixedAxes[0], fixedAxes[1], fixedAxes[2]);
            vec3_exports.scale(fixedAxes[0], fixedAxes[0], fixSignMap[priority[0]]);
            vec3_exports.normalize(fixedLeft, fixedAxes[priority.pp_findIndexEqual(0)]);
            vec3_exports.normalize(fixedUp, fixedAxes[priority.pp_findIndexEqual(1)]);
            vec3_exports.normalize(fixedForward, fixedAxes[priority.pp_findIndexEqual(2)]);
            mat3_exports.set(
              rotationMat,
              fixedLeft[0],
              fixedLeft[1],
              fixedLeft[2],
              fixedUp[0],
              fixedUp[1],
              fixedUp[2],
              fixedForward[0],
              fixedForward[1],
              fixedForward[2]
            );
            quat_exports.fromMat3(rotationQuat, rotationMat);
            quat_exports.normalize(rotationQuat, rotationQuat);
            this.quat_copy(rotationQuat);
          } else {
            if (priority[0] == 0) {
              this.quat_getLeft(currentAxis);
            } else if (priority[0] == 1) {
              this.quat_getUp(currentAxis);
            } else {
              this.quat_getForward(currentAxis);
            }
            let angle3 = vec3_exports.angle(firstAxis, currentAxis);
            if (angle3 != 0) {
              vec3_exports.cross(rotationAxis, currentAxis, firstAxis);
              vec3_exports.normalize(rotationAxis, rotationAxis);
              quat_exports.setAxisAngle(rotationQuat, rotationAxis, angle3);
              this.quat_rotateQuat(rotationQuat, this);
            }
          }
          return this;
        };
      }();
      for (let key in Array.prototype) {
        let prefixes = ["pp_", "vec_", "vec2_", "vec3_", "vec4_", "quat_", "quat2_", "mat3_", "mat4_", "_pp_", "_vec_", "_quat_"];
        let found = false;
        for (let prefix of prefixes) {
          if (key.startsWith(prefix)) {
            found = true;
            break;
          }
        }
        if (found) {
          Object.defineProperty(Array.prototype, key, { enumerable: false });
          Uint8ClampedArray.prototype[key] = Array.prototype[key];
          Object.defineProperty(Uint8ClampedArray.prototype, key, { enumerable: false });
          Uint8ClampedArray.prototype[key] = Array.prototype[key];
          Object.defineProperty(Uint8ClampedArray.prototype, key, { enumerable: false });
          Uint8Array.prototype[key] = Array.prototype[key];
          Object.defineProperty(Uint8Array.prototype, key, { enumerable: false });
          Uint16Array.prototype[key] = Array.prototype[key];
          Object.defineProperty(Uint16Array.prototype, key, { enumerable: false });
          Uint32Array.prototype[key] = Array.prototype[key];
          Object.defineProperty(Uint32Array.prototype, key, { enumerable: false });
          Int8Array.prototype[key] = Array.prototype[key];
          Object.defineProperty(Int8Array.prototype, key, { enumerable: false });
          Int16Array.prototype[key] = Array.prototype[key];
          Object.defineProperty(Int16Array.prototype, key, { enumerable: false });
          Int32Array.prototype[key] = Array.prototype[key];
          Object.defineProperty(Int32Array.prototype, key, { enumerable: false });
          Float32Array.prototype[key] = Array.prototype[key];
          Object.defineProperty(Float32Array.prototype, key, { enumerable: false });
          Float64Array.prototype[key] = Array.prototype[key];
          Object.defineProperty(Float64Array.prototype, key, { enumerable: false });
        }
      }
    }
  });

  // js/pp/plugin/extensions/object_extension.js
  var object_extension_exports = {};
  var init_object_extension = __esm({
    "js/pp/plugin/extensions/object_extension.js"() {
      init_esm();
      if (WL && WL.Object) {
        WL.Object.prototype.pp_getPosition = function(position) {
          return this.pp_getPositionWorld(position);
        };
        WL.Object.prototype.pp_getPositionWorld = function(position = vec3_exports.create()) {
          this.getTranslationWorld(position);
          return position;
        };
        WL.Object.prototype.pp_getPositionLocal = function(position = vec3_exports.create()) {
          this.getTranslationLocal(position);
          return position;
        };
        WL.Object.prototype.pp_getRotation = function(rotation) {
          return this.pp_getRotationWorld(rotation);
        };
        WL.Object.prototype.pp_getRotationDegrees = function(rotation) {
          return this.pp_getRotationWorldDegrees(rotation);
        };
        WL.Object.prototype.pp_getRotationRadians = function(rotation) {
          return this.pp_getRotationWorldRadians(rotation);
        };
        WL.Object.prototype.pp_getRotationMatrix = function(rotation) {
          return this.pp_getRotationWorldMatrix(rotation);
        };
        WL.Object.prototype.pp_getRotationQuat = function(rotation) {
          return this.pp_getRotationWorldQuat(rotation);
        };
        WL.Object.prototype.pp_getRotationWorld = function(rotation) {
          return this.pp_getRotationWorldDegrees(rotation);
        };
        WL.Object.prototype.pp_getRotationWorldDegrees = function(rotation) {
          rotation = this.pp_getRotationWorldRadians(rotation);
          rotation.forEach(function(value, index, array) {
            array[index] = this._pp_toDegrees(value);
          }.bind(this));
          return rotation;
        };
        WL.Object.prototype.pp_getRotationWorldRadians = function() {
          let quat = quat_exports.create();
          return function pp_getRotationWorldRadians(rotation = vec3_exports.create()) {
            this.pp_getRotationWorldQuat(quat);
            this._pp_quaternionToRadians(quat, rotation);
            return rotation;
          };
        }();
        WL.Object.prototype.pp_getRotationWorldMatrix = function() {
          let quat = quat_exports.create();
          return function pp_getRotationWorldMatrix(rotation = mat3_exports.create()) {
            this.pp_getRotationWorldQuat(quat);
            mat3_exports.fromQuat(rotation, quat);
            return rotation;
          };
        }();
        WL.Object.prototype.pp_getRotationWorldQuat = function(rotation = quat_exports.create()) {
          quat_exports.copy(rotation, this.rotationWorld);
          return rotation;
        };
        WL.Object.prototype.pp_getRotationLocal = function(rotation) {
          return this.pp_getRotationLocalDegrees(rotation);
        };
        WL.Object.prototype.pp_getRotationLocalDegrees = function(rotation) {
          rotation = this.pp_getRotationLocalRadians(rotation);
          rotation.forEach(function(value, index, array) {
            array[index] = this._pp_toDegrees(value);
          }.bind(this));
          return rotation;
        };
        WL.Object.prototype.pp_getRotationLocalRadians = function() {
          let quat = quat_exports.create();
          return function pp_getRotationLocalRadians(rotation = vec3_exports.create()) {
            this.pp_getRotationLocalQuat(quat);
            this._pp_quaternionToRadians(quat, rotation);
            return rotation;
          };
        }();
        WL.Object.prototype.pp_getRotationLocalMatrix = function() {
          let quat = quat_exports.create();
          return function pp_getRotationLocalMatrix(rotation = mat3_exports.create()) {
            this.pp_getRotationLocalQuat(quat);
            mat3_exports.fromQuat(rotation, quat);
            return rotation;
          };
        }();
        WL.Object.prototype.pp_getRotationLocalQuat = function(rotation = quat_exports.create()) {
          quat_exports.copy(rotation, this.rotationLocal);
          return rotation;
        };
        WL.Object.prototype.pp_getScale = function(scale8) {
          return this.pp_getScaleWorld(scale8);
        };
        WL.Object.prototype.pp_getScaleWorld = function(scale8 = vec3_exports.create()) {
          vec3_exports.copy(scale8, this.scalingWorld);
          return scale8;
        };
        WL.Object.prototype.pp_getScaleLocal = function(scale8 = vec3_exports.create()) {
          vec3_exports.copy(scale8, this.scalingLocal);
          return scale8;
        };
        WL.Object.prototype.pp_getTransform = function(transform) {
          return this.pp_getTransformWorld(transform);
        };
        WL.Object.prototype.pp_getTransformMatrix = function(transform) {
          return this.pp_getTransformWorldMatrix(transform);
        };
        WL.Object.prototype.pp_getTransformQuat = function(transform) {
          return this.pp_getTransformWorldQuat(transform);
        };
        WL.Object.prototype.pp_getTransformWorld = function(transform) {
          return this.pp_getTransformWorldMatrix(transform);
        };
        WL.Object.prototype.pp_getTransformWorldMatrix = function() {
          let transformQuat3 = quat2_exports.create();
          let scale8 = vec3_exports.create();
          return function pp_getTransformWorldMatrix(transform = mat4_exports.create()) {
            this.pp_getTransformWorldQuat(transformQuat3);
            this.pp_getScaleWorld(scale8);
            mat4_exports.fromQuat2(transform, transformQuat3);
            mat4_exports.scale(transform, transform, scale8);
            return transform;
          };
        }();
        WL.Object.prototype.pp_getTransformWorldQuat = function(transform = quat2_exports.create()) {
          quat2_exports.copy(transform, this.transformWorld);
          return transform;
        };
        WL.Object.prototype.pp_getTransformLocal = function(transform) {
          return this.pp_getTransformLocalMatrix(transform);
        };
        WL.Object.prototype.pp_getTransformLocalMatrix = function() {
          let transformQuat3 = quat2_exports.create();
          let scale8 = vec3_exports.create();
          return function pp_getTransformLocal(transform = mat4_exports.create()) {
            this.pp_getTransformLocalQuat(transformQuat3);
            this.pp_getScaleLocal(scale8);
            mat4_exports.fromQuat2(transform, transformQuat3);
            mat4_exports.scale(transform, transform, scale8);
            return transform;
          };
        }();
        WL.Object.prototype.pp_getTransformLocalQuat = function(transform = quat2_exports.create()) {
          quat2_exports.copy(transform, this.transformLocal);
          return transform;
        };
        WL.Object.prototype.pp_getAxes = function(axes) {
          return this.pp_getAxesWorld(axes);
        };
        WL.Object.prototype.pp_getAxesWorld = function(axes = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()]) {
          this.pp_getLeftWorld(axes[0]);
          this.pp_getUpWorld(axes[1]);
          this.pp_getForwardWorld(axes[2]);
          return axes;
        };
        WL.Object.prototype.pp_getAxesLocal = function(axes = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()]) {
          this.pp_getLeftLocal(axes[0]);
          this.pp_getUpLocal(axes[1]);
          this.pp_getForwardLocal(axes[2]);
          return axes;
        };
        WL.Object.prototype.pp_getForward = function(forward) {
          return this.pp_getForwardWorld(forward);
        };
        WL.Object.prototype.pp_getForwardWorld = function() {
          let rotation = mat3_exports.create();
          return function pp_getForwardWorld(forward = vec3_exports.create()) {
            this.pp_getRotationWorldMatrix(rotation);
            forward[0] = rotation[6];
            forward[1] = rotation[7];
            forward[2] = rotation[8];
            return forward;
          };
        }();
        WL.Object.prototype.pp_getForwardLocal = function() {
          let rotation = mat3_exports.create();
          return function pp_getForwardLocal(forward = vec3_exports.create()) {
            this.pp_getRotationLocalMatrix(rotation);
            forward[0] = rotation[6];
            forward[1] = rotation[7];
            forward[2] = rotation[8];
            return forward;
          };
        }();
        WL.Object.prototype.pp_getBackward = function(backward) {
          return this.pp_getBackwardWorld(backward);
        };
        WL.Object.prototype.pp_getBackwardWorld = function() {
          let rotation = mat3_exports.create();
          return function pp_getBackwardWorld(backward = vec3_exports.create()) {
            this.pp_getRotationWorldMatrix(rotation);
            backward[0] = -rotation[6];
            backward[1] = -rotation[7];
            backward[2] = -rotation[8];
            return backward;
          };
        }();
        WL.Object.prototype.pp_getBackwardLocal = function() {
          let rotation = mat3_exports.create();
          return function pp_getBackwardLocal(backward = vec3_exports.create()) {
            this.pp_getRotationLocalMatrix(rotation);
            backward[0] = -rotation[6];
            backward[1] = -rotation[7];
            backward[2] = -rotation[8];
            return backward;
          };
        }();
        WL.Object.prototype.pp_getUp = function(up) {
          return this.pp_getUpWorld(up);
        };
        WL.Object.prototype.pp_getUpWorld = function() {
          let rotation = mat3_exports.create();
          return function pp_getUpWorld(up = vec3_exports.create()) {
            this.pp_getRotationWorldMatrix(rotation);
            up[0] = rotation[3];
            up[1] = rotation[4];
            up[2] = rotation[5];
            return up;
          };
        }();
        WL.Object.prototype.pp_getUpLocal = function() {
          let rotation = mat3_exports.create();
          return function pp_getUpLocal(up = vec3_exports.create()) {
            this.pp_getRotationLocalMatrix(rotation);
            up[0] = rotation[3];
            up[1] = rotation[4];
            up[2] = rotation[5];
            return up;
          };
        }();
        WL.Object.prototype.pp_getDown = function(down) {
          return this.pp_getDownWorld(down);
        };
        WL.Object.prototype.pp_getDownWorld = function() {
          let rotation = mat3_exports.create();
          return function pp_getDownWorld(down = vec3_exports.create()) {
            this.pp_getRotationWorldMatrix(rotation);
            down[0] = -rotation[3];
            down[1] = -rotation[4];
            down[2] = -rotation[5];
            return down;
          };
        }();
        WL.Object.prototype.pp_getDownLocal = function() {
          let rotation = mat3_exports.create();
          return function pp_getDownLocal(down = vec3_exports.create()) {
            this.pp_getRotationLocalMatrix(rotation);
            down[0] = -rotation[3];
            down[1] = -rotation[4];
            down[2] = -rotation[5];
            return down;
          };
        }();
        WL.Object.prototype.pp_getLeft = function(left) {
          return this.pp_getLeftWorld(left);
        };
        WL.Object.prototype.pp_getLeftWorld = function() {
          let rotation = mat3_exports.create();
          return function pp_getLeftWorld(left = vec3_exports.create()) {
            this.pp_getRotationWorldMatrix(rotation);
            left[0] = rotation[0];
            left[1] = rotation[1];
            left[2] = rotation[2];
            return left;
          };
        }();
        WL.Object.prototype.pp_getLeftLocal = function() {
          let rotation = mat3_exports.create();
          return function pp_getLeftLocal(left = vec3_exports.create()) {
            this.pp_getRotationLocalMatrix(rotation);
            left[0] = rotation[0];
            left[1] = rotation[1];
            left[2] = rotation[2];
            return left;
          };
        }();
        WL.Object.prototype.pp_getRight = function(right) {
          return this.pp_getRightWorld(right);
        };
        WL.Object.prototype.pp_getRightWorld = function() {
          let rotation = mat3_exports.create();
          return function pp_getRightWorld(right = vec3_exports.create()) {
            this.pp_getRotationWorldMatrix(rotation);
            right[0] = -rotation[0];
            right[1] = -rotation[1];
            right[2] = -rotation[2];
            return right;
          };
        }();
        WL.Object.prototype.pp_getRightLocal = function() {
          let rotation = mat3_exports.create();
          return function pp_getRightLocal(right = vec3_exports.create()) {
            this.pp_getRotationLocalMatrix(rotation);
            right[0] = -rotation[0];
            right[1] = -rotation[1];
            right[2] = -rotation[2];
            return right;
          };
        }();
        WL.Object.prototype.pp_setPosition = function(position) {
          this.pp_setPositionWorld(position);
        };
        WL.Object.prototype.pp_setPositionWorld = function(position) {
          this.setTranslationWorld(position);
        };
        WL.Object.prototype.pp_setPositionLocal = function(position) {
          this.setTranslationLocal(position);
        };
        WL.Object.prototype.pp_setRotation = function(rotation) {
          this.pp_setRotationWorld(rotation);
        };
        WL.Object.prototype.pp_setRotationDegrees = function(rotation) {
          this.pp_setRotationWorldDegrees(rotation);
        };
        WL.Object.prototype.pp_setRotationRadians = function(rotation) {
          this.pp_setRotationWorldRadians(rotation);
        };
        WL.Object.prototype.pp_setRotationMatrix = function(rotation) {
          this.pp_setRotationWorldMatrix(rotation);
        };
        WL.Object.prototype.pp_setRotationQuat = function(rotation) {
          this.pp_setRotationWorldQuat(rotation);
        };
        WL.Object.prototype.pp_setRotationWorld = function(rotation) {
          this.pp_setRotationWorldDegrees(rotation);
        };
        WL.Object.prototype.pp_setRotationWorldDegrees = function() {
          let quat = quat_exports.create();
          return function pp_setRotationWorldDegrees(rotation) {
            this._pp_degreesToQuaternion(rotation, quat);
            this.pp_setRotationWorldQuat(quat);
          };
        }();
        WL.Object.prototype.pp_setRotationWorldRadians = function() {
          let degreesRotation = vec3_exports.create();
          return function pp_setRotationWorldRadians(rotation) {
            rotation.forEach(function(value, index, array) {
              degreesRotation[index] = this._pp_toDegrees(value);
            }.bind(this));
            this.pp_setRotationWorldDegrees(degreesRotation);
          };
        }();
        WL.Object.prototype.pp_setRotationWorldMatrix = function() {
          let quat = quat_exports.create();
          return function pp_setRotationWorldMatrix(rotation) {
            quat_exports.fromMat3(quat, rotation);
            this.pp_setRotationWorldQuat(quat);
          };
        }();
        WL.Object.prototype.pp_setRotationWorldQuat = function(rotation) {
          this.rotationWorld = rotation;
        };
        WL.Object.prototype.pp_setRotationLocal = function(rotation) {
          this.pp_setRotationLocalDegrees(rotation);
        };
        WL.Object.prototype.pp_setRotationLocalDegrees = function() {
          let quat = quat_exports.create();
          return function pp_setRotationLocalDegrees(rotation) {
            this._pp_degreesToQuaternion(rotation, quat);
            this.pp_setRotationLocalQuat(quat);
          };
        }();
        WL.Object.prototype.pp_setRotationLocalRadians = function() {
          let degreesRotation = vec3_exports.create();
          return function pp_setRotationLocalRadians(rotation) {
            rotation.forEach(function(value, index, array) {
              degreesRotation[index] = this._pp_toDegrees(value);
            }.bind(this));
            this.pp_setRotationLocalDegrees(degreesRotation);
          };
        }();
        WL.Object.prototype.pp_setRotationLocalMatrix = function() {
          let quat = quat_exports.create();
          return function pp_setRotationLocalMatrix(rotation) {
            quat_exports.fromMat3(quat, rotation);
            this.pp_setRotationLocalQuat(quat);
          };
        }();
        WL.Object.prototype.pp_setRotationLocalQuat = function(rotation) {
          this.rotationLocal = rotation;
        };
        WL.Object.prototype.pp_setScale = function(scale8) {
          this.pp_setScaleWorld(scale8);
        };
        WL.Object.prototype.pp_setScaleWorld = function() {
          let vector = vec3_exports.create();
          return function pp_setScaleWorld(scale8) {
            if (isNaN(scale8)) {
              this.scalingWorld = scale8;
            } else {
              vec3_exports.set(vector, scale8, scale8, scale8);
              this.scalingWorld = vector;
            }
          };
        }();
        WL.Object.prototype.pp_setScaleLocal = function() {
          let vector = vec3_exports.create();
          return function pp_setScaleLocal(scale8) {
            if (isNaN(scale8)) {
              this.scalingLocal = scale8;
            } else {
              vec3_exports.set(vector, scale8, scale8, scale8);
              this.scalingLocal = vector;
            }
          };
        }();
        WL.Object.prototype.pp_setAxes = function(left, up, forward) {
          this.pp_setAxesWorld(left, up, forward);
        };
        WL.Object.prototype.pp_setAxesWorld = function(left, up, forward) {
          if (forward != null) {
            this.pp_setForwardWorld(forward, up, left);
          } else if (up != null) {
            this.pp_setUpWorld(up, forward, left);
          } else {
            this.pp_setLeftWorld(left, up, forward);
          }
        };
        WL.Object.prototype.pp_setAxesLocal = function(left, up, forward) {
          if (forward != null) {
            this.pp_setForwardLocal(forward, up, left);
          } else if (up != null) {
            this.pp_setUpLocal(up, forward, left);
          } else {
            this.pp_setLeftLocal(left, up, forward);
          }
        };
        WL.Object.prototype.pp_setForward = function(forward, up, left) {
          this.pp_setForwardWorld(forward, up, left);
        };
        WL.Object.prototype.pp_setForwardWorld = function(forward, up = null, left = null) {
          this._pp_setAxes([left, up, forward], [2, 1, 0], false);
        };
        WL.Object.prototype.pp_setForwardLocal = function(forward, up = null, left = null) {
          this._pp_setAxes([left, up, forward], [2, 1, 0], true);
        };
        WL.Object.prototype.pp_setBackward = function(backward, up, left) {
          this.pp_setBackwardWorld(backward, up, left);
        };
        WL.Object.prototype.pp_setBackwardWorld = function() {
          let forward = vec3_exports.create();
          return function pp_setBackwardWorld(backward, up = null, left = null) {
            vec3_exports.negate(forward, backward);
            this._pp_setAxes([left, up, forward], [2, 1, 0], false);
          };
        }();
        WL.Object.prototype.pp_setBackwardLocal = function() {
          let forward = vec3_exports.create();
          return function pp_setBackwardLocal(backward, up = null, left = null) {
            vec3_exports.negate(forward, backward);
            this._pp_setAxes([left, up, forward], [2, 1, 0], true);
          };
        }();
        WL.Object.prototype.pp_setUp = function(up, forward, left) {
          this.pp_setUpWorld(up, forward, left);
        };
        WL.Object.prototype.pp_setUpWorld = function(up, forward = null, left = null) {
          this._pp_setAxes([left, up, forward], [1, 2, 0], false);
        };
        WL.Object.prototype.pp_setUpLocal = function(up, forward = null, left = null) {
          this._pp_setAxes([left, up, forward], [1, 2, 0], true);
        };
        WL.Object.prototype.pp_setDown = function(down, forward, left) {
          this.pp_setDownWorld(down, forward, left);
        };
        WL.Object.prototype.pp_setDownWorld = function() {
          let up = vec3_exports.create();
          return function pp_setDownWorld(down, forward = null, left = null) {
            vec3_exports.negate(up, down);
            this._pp_setAxes([left, up, forward], [1, 2, 0], false);
          };
        }();
        WL.Object.prototype.pp_setDownLocal = function() {
          let up = vec3_exports.create();
          return function pp_setDownLocal(down, forward = null, left = null) {
            vec3_exports.negate(up, down);
            this._pp_setAxes([left, up, forward], [1, 2, 0], true);
          };
        }();
        WL.Object.prototype.pp_setLeft = function(left, up, forward) {
          this.pp_setLeftWorld(left, up, forward);
        };
        WL.Object.prototype.pp_setLeftWorld = function(left, up = null, forward = null) {
          this._pp_setAxes([left, up, forward], [0, 1, 2], false);
        };
        WL.Object.prototype.pp_setLeftLocal = function(left, up = null, forward = null) {
          this._pp_setAxes([left, up, forward], [0, 1, 2], true);
        };
        WL.Object.prototype.pp_setRight = function(right, up, forward) {
          this.pp_setRightWorld(right, up, forward);
        };
        WL.Object.prototype.pp_setRightWorld = function() {
          let left = vec3_exports.create();
          return function pp_setRightWorld(right, up = null, forward = null) {
            vec3_exports.negate(left, right);
            this._pp_setAxes([left, up, forward], [0, 1, 2], false);
          };
        }();
        WL.Object.prototype.pp_setRightLocal = function() {
          let left = vec3_exports.create();
          return function pp_setRightLocal(right, up = null, forward = null) {
            vec3_exports.negate(left, right);
            this._pp_setAxes([left, up, forward], [0, 1, 2], true);
          };
        }();
        WL.Object.prototype.pp_setTransform = function(transform) {
          this.pp_setTransformWorld(transform);
        };
        WL.Object.prototype.pp_setTransformMatrix = function(transform) {
          this.pp_setTransformWorldMatrix(transform);
        };
        WL.Object.prototype.pp_setTransformQuat = function(transform) {
          this.pp_setTransformWorldQuat(transform);
        };
        WL.Object.prototype.pp_setTransformWorld = function(transform) {
          return this.pp_setTransformWorldMatrix(transform);
        };
        WL.Object.prototype.pp_setTransformWorldMatrix = function() {
          let position = vec3_exports.create();
          let rotation = quat_exports.create();
          let scale8 = vec3_exports.create();
          let transformMatrixNoScale = mat4_exports.create();
          let inverseScale = vec3_exports.create();
          let one = vec3_exports.create();
          vec3_exports.set(one, 1, 1, 1);
          return function pp_setTransformWorldMatrix(transform) {
            mat4_exports.getTranslation(position, transform);
            mat4_exports.getScaling(scale8, transform);
            vec3_exports.divide(inverseScale, one, scale8);
            mat4_exports.scale(transformMatrixNoScale, transform, inverseScale);
            mat4_exports.getRotation(rotation, transformMatrixNoScale);
            quat_exports.normalize(rotation, rotation);
            this.pp_setScaleWorld(scale8);
            this.pp_setRotationWorldQuat(rotation);
            this.pp_setPositionWorld(position);
          };
        }();
        WL.Object.prototype.pp_setTransformWorldQuat = function(transform) {
          this.transformWorld = transform;
        };
        WL.Object.prototype.pp_setTransformLocal = function(transform) {
          return this.pp_setTransformLocalMatrix(transform);
        };
        WL.Object.prototype.pp_setTransformLocalMatrix = function() {
          let position = vec3_exports.create();
          let rotation = quat_exports.create();
          let scale8 = vec3_exports.create();
          let transformMatrixNoScale = mat4_exports.create();
          let inverseScale = vec3_exports.create();
          let one = vec3_exports.create();
          vec3_exports.set(one, 1, 1, 1);
          return function pp_setTransformLocalMatrix(transform) {
            mat4_exports.getTranslation(position, transform);
            mat4_exports.getScaling(scale8, transform);
            vec3_exports.divide(inverseScale, one, scale8);
            mat4_exports.scale(transformMatrixNoScale, transform, inverseScale);
            mat4_exports.getRotation(rotation, transformMatrixNoScale);
            quat_exports.normalize(rotation, rotation);
            this.pp_setScaleLocal(scale8);
            this.pp_setRotationLocalQuat(rotation);
            this.pp_setPositionLocal(position);
          };
        }();
        WL.Object.prototype.pp_setTransformLocalQuat = function(transform) {
          this.transformLocal = transform;
        };
        WL.Object.prototype.pp_resetPosition = function() {
          this.pp_resetPositionWorld();
        };
        WL.Object.prototype.pp_resetPositionWorld = function() {
          let zero4 = vec3_exports.create();
          return function pp_resetPositionWorld() {
            this.pp_setPositionWorld(zero4);
          };
        }();
        WL.Object.prototype.pp_resetPositionLocal = function() {
          let zero4 = vec3_exports.create();
          return function pp_resetPositionLocal() {
            this.pp_setPositionLocal(zero4);
          };
        }();
        WL.Object.prototype.pp_resetRotation = function() {
          this.pp_resetRotationWorld();
        };
        WL.Object.prototype.pp_resetRotationWorld = function() {
          let identity5 = quat_exports.create();
          return function pp_resetRotationWorld() {
            this.pp_setRotationWorldQuat(identity5);
          };
        }();
        WL.Object.prototype.pp_resetRotationLocal = function() {
          let identity5 = quat_exports.create();
          return function pp_resetRotationLocal() {
            this.pp_setRotationLocalQuat(identity5);
          };
        }();
        WL.Object.prototype.pp_resetScale = function() {
          this.pp_resetScaleWorld();
        };
        WL.Object.prototype.pp_resetScaleWorld = function() {
          let one = vec3_exports.create();
          vec3_exports.set(one, 1, 1, 1);
          return function pp_resetScaleWorld() {
            this.pp_setScaleWorld(one);
          };
        }();
        WL.Object.prototype.pp_resetScaleLocal = function() {
          let one = vec3_exports.create();
          vec3_exports.set(one, 1, 1, 1);
          return function pp_resetScaleLocal() {
            this.pp_setScaleLocal(one);
          };
        }();
        WL.Object.prototype.pp_resetTransform = function() {
          this.pp_resetTransformWorld();
        };
        WL.Object.prototype.pp_resetTransformWorld = function() {
          this.pp_resetScaleWorld();
          this.pp_resetRotationWorld();
          this.pp_resetPositionWorld();
        };
        WL.Object.prototype.pp_resetTransformLocal = function() {
          this.pp_resetScaleLocal();
          this.pp_resetRotationLocal();
          this.pp_resetPositionLocal();
        };
        WL.Object.prototype.pp_translate = function(translation) {
          this.pp_translateWorld(translation);
        };
        WL.Object.prototype.pp_translateWorld = function(translation) {
          this.translateWorld(translation);
        };
        WL.Object.prototype.pp_translateLocal = function(translation) {
          this.translate(translation);
        };
        WL.Object.prototype.pp_translateObject = function(translation) {
          this.translateObject(translation);
        };
        WL.Object.prototype.pp_translateAxis = function(amount, direction) {
          this.pp_translateAxisWorld(amount, direction);
        };
        WL.Object.prototype.pp_translateAxisWorld = function() {
          let translation = vec3_exports.create();
          return function pp_translateAxisWorld(amount, direction) {
            vec3_exports.scale(translation, direction, amount);
            this.pp_translateWorld(translation);
          };
        }();
        WL.Object.prototype.pp_translateAxisLocal = function() {
          let translation = vec3_exports.create();
          return function pp_translateAxisLocal(amount, direction) {
            vec3_exports.scale(translation, direction, amount);
            this.pp_translateLocal(translation);
          };
        }();
        WL.Object.prototype.pp_translateAxisObject = function() {
          let translation = vec3_exports.create();
          return function pp_translateAxisObject(amount, direction) {
            vec3_exports.scale(translation, direction, amount);
            this.pp_translateObject(translation);
          };
        }();
        WL.Object.prototype.pp_rotate = function(rotation) {
          this.pp_rotateWorld(rotation);
        };
        WL.Object.prototype.pp_rotateDegrees = function(rotation) {
          this.pp_rotateWorldDegrees(rotation);
        };
        WL.Object.prototype.pp_rotateRadians = function(rotation) {
          this.pp_rotateWorldRadians(rotation);
        };
        WL.Object.prototype.pp_rotateMatrix = function(rotation) {
          this.pp_rotateWorldMatrix(rotation);
        };
        WL.Object.prototype.pp_rotateQuat = function(rotation) {
          this.pp_rotateWorldQuat(rotation);
        };
        WL.Object.prototype.pp_rotateWorld = function(rotation) {
          this.pp_rotateWorldDegrees(rotation);
        };
        WL.Object.prototype.pp_rotateWorldDegrees = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateWorldDegrees(rotation) {
            this._pp_degreesToQuaternion(rotation, rotationQuat);
            this.pp_rotateWorldQuat(rotationQuat);
          };
        }();
        WL.Object.prototype.pp_rotateWorldRadians = function() {
          let degreesRotation = vec3_exports.create();
          return function pp_rotateWorldRadians(rotation) {
            rotation.forEach(function(value, index, array) {
              degreesRotation[index] = this._pp_toDegrees(value);
            }.bind(this));
            this.pp_rotateWorldDegrees(degreesRotation);
          };
        }();
        WL.Object.prototype.pp_rotateWorldMatrix = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateWorldMatrix(rotation) {
            quat_exports.fromMat3(rotationQuat, rotation);
            quat_exports.normalize(rotationQuat, rotationQuat);
            this.pp_rotateWorldQuat(rotationQuat);
          };
        }();
        WL.Object.prototype.pp_rotateWorldQuat = function() {
          let currentRotationQuat = quat_exports.create();
          return function pp_rotateWorldQuat(rotation) {
            this.pp_getRotationWorldQuat(currentRotationQuat);
            quat_exports.mul(currentRotationQuat, rotation, currentRotationQuat);
            quat_exports.normalize(currentRotationQuat, currentRotationQuat);
            this.pp_setRotationWorldQuat(currentRotationQuat);
          };
        }();
        WL.Object.prototype.pp_rotateLocal = function(rotation) {
          this.pp_rotateLocalDegrees(rotation);
        };
        WL.Object.prototype.pp_rotateLocalDegrees = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateLocalDegrees(rotation) {
            this._pp_degreesToQuaternion(rotation, rotationQuat);
            this.pp_rotateLocalQuat(rotationQuat);
          };
        }();
        WL.Object.prototype.pp_rotateLocalRadians = function() {
          let degreesRotation = vec3_exports.create();
          return function pp_rotateLocalRadians(rotation) {
            rotation.forEach(function(value, index, array) {
              degreesRotation[index] = this._pp_toDegrees(value);
            }.bind(this));
            this.pp_rotateLocalDegrees(degreesRotation);
          };
        }();
        WL.Object.prototype.pp_rotateLocalMatrix = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateLocalMatrix(rotation) {
            quat_exports.fromMat3(rotationQuat, rotation);
            quat_exports.normalize(rotationQuat, rotationQuat);
            this.pp_rotateLocalQuat(rotationQuat);
          };
        }();
        WL.Object.prototype.pp_rotateLocalQuat = function() {
          let currentRotationQuat = quat_exports.create();
          return function pp_rotateLocalQuat(rotation) {
            this.pp_getRotationLocalQuat(currentRotationQuat);
            quat_exports.mul(currentRotationQuat, rotation, currentRotationQuat);
            quat_exports.normalize(currentRotationQuat, currentRotationQuat);
            this.pp_setRotationLocalQuat(currentRotationQuat);
          };
        }();
        WL.Object.prototype.pp_rotateObject = function(rotation) {
          this.pp_rotateObjectDegrees(rotation);
        };
        WL.Object.prototype.pp_rotateObjectDegrees = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateObjectDegrees(rotation) {
            this._pp_degreesToQuaternion(rotation, rotationQuat);
            this.pp_rotateObjectQuat(rotationQuat);
          };
        }();
        WL.Object.prototype.pp_rotateObjectRadians = function() {
          let degreesRotation = vec3_exports.create();
          return function pp_rotateObjectRadians(rotation) {
            rotation.forEach(function(value, index, array) {
              degreesRotation[index] = this._pp_toDegrees(value);
            }.bind(this));
            this.pp_rotateObjectDegrees(degreesRotation);
          };
        }();
        WL.Object.prototype.pp_rotateObjectMatrix = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateObjectMatrix(rotation) {
            quat_exports.fromMat3(rotationQuat, rotation);
            quat_exports.normalize(rotationQuat, rotationQuat);
            this.pp_rotateObjectQuat(rotationQuat);
          };
        }();
        WL.Object.prototype.pp_rotateObjectQuat = function(rotation) {
          this.rotateObject(rotation);
        };
        WL.Object.prototype.pp_rotateAxis = function(angle3, axis) {
          this.pp_rotateAxisWorld(angle3, axis);
        };
        WL.Object.prototype.pp_rotateAxisDegrees = function(angle3, axis) {
          this.pp_rotateAxisWorldDegrees(angle3, axis);
        };
        WL.Object.prototype.pp_rotateAxisRadians = function(angle3, axis) {
          this.pp_rotateAxisWorldRadians(angle3, axis);
        };
        WL.Object.prototype.pp_rotateAxisWorld = function(angle3, axis) {
          this.pp_rotateAxisWorldDegrees(angle3, axis);
        };
        WL.Object.prototype.pp_rotateAxisWorldDegrees = function(angle3, axis) {
          this.pp_rotateAxisWorldRadians(common_exports.toRadian(angle3), axis);
        };
        WL.Object.prototype.pp_rotateAxisWorldRadians = function() {
          let rotation = quat_exports.create();
          return function pp_rotateAxisWorldRadians(angle3, axis) {
            quat_exports.setAxisAngle(rotation, axis, angle3);
            this.pp_rotateWorldQuat(rotation);
          };
        }();
        WL.Object.prototype.pp_rotateAxisLocal = function(angle3, axis) {
          this.pp_rotateAxisLocalDegrees(angle3, axis);
        };
        WL.Object.prototype.pp_rotateAxisLocalDegrees = function(angle3, axis) {
          this.pp_rotateAxisLocalRadians(common_exports.toRadian(angle3), axis);
        };
        WL.Object.prototype.pp_rotateAxisLocalRadians = function() {
          let rotation = quat_exports.create();
          return function pp_rotateAxisLocalRadians(angle3, axis) {
            quat_exports.setAxisAngle(rotation, axis, angle3);
            this.pp_rotateLocalQuat(rotation);
          };
        }();
        WL.Object.prototype.pp_rotateAxisObject = function(angle3, axis) {
          this.pp_rotateAxisObjectDegrees(angle3, axis);
        };
        WL.Object.prototype.pp_rotateAxisObjectDegrees = function(angle3, axis) {
          this.pp_rotateAxisObjectRadians(common_exports.toRadian(angle3), axis);
        };
        WL.Object.prototype.pp_rotateAxisObjectRadians = function() {
          let rotation = quat_exports.create();
          return function pp_rotateAxisObjectRadians(angle3, axis) {
            quat_exports.setAxisAngle(rotation, axis, angle3);
            this.pp_rotateObjectQuat(rotation);
          };
        }();
        WL.Object.prototype.pp_rotateAround = function(rotation, origin) {
          this.pp_rotateAroundWorld(rotation, origin);
        };
        WL.Object.prototype.pp_rotateAroundDegrees = function(rotation, origin) {
          this.pp_rotateAroundWorldDegrees(rotation, origin);
        };
        WL.Object.prototype.pp_rotateAroundRadians = function(rotation, origin) {
          this.pp_rotateAroundWorldRadians(rotation, origin);
        };
        WL.Object.prototype.pp_rotateAroundMatrix = function(rotation, origin) {
          this.pp_rotateAroundWorldMatrix(rotation, origin);
        };
        WL.Object.prototype.pp_rotateAroundQuat = function(rotation, origin) {
          this.pp_rotateAroundWorldQuat(rotation, origin);
        };
        WL.Object.prototype.pp_rotateAroundWorld = function(rotation, origin) {
          this.pp_rotateAroundWorldDegrees(rotation, origin);
        };
        WL.Object.prototype.pp_rotateAroundWorldDegrees = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateAroundWorldDegrees(rotation, origin) {
            this._pp_degreesToQuaternion(rotation, rotationQuat);
            this.pp_rotateAroundWorldQuat(rotationQuat, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundWorldRadians = function() {
          let degreesRotation = vec3_exports.create();
          return function pp_rotateAroundWorldRadians(rotation, origin) {
            rotation.forEach(function(value, index, array) {
              degreesRotation[index] = this._pp_toDegrees(value);
            }.bind(this));
            this.pp_rotateAroundWorldDegrees(degreesRotation, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundWorldMatrix = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateAroundWorldMatrix(rotation, origin) {
            quat_exports.fromMat3(rotationQuat, rotation);
            quat_exports.normalize(rotationQuat, rotationQuat);
            this.pp_rotateAroundWorldQuat(rotationQuat, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundWorldQuat = function() {
          let axis = vec3_exports.create();
          return function pp_rotateAroundWorldQuat(rotation, origin) {
            let angle3 = quat_exports.getAxisAngle(axis, rotation);
            this.pp_rotateAroundAxisWorldRadians(angle3, axis, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundLocal = function(rotation, origin) {
          this.pp_rotateAroundLocalDegrees(rotation, origin);
        };
        WL.Object.prototype.pp_rotateAroundLocalDegrees = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateAroundLocalDegrees(rotation, origin) {
            this._pp_degreesToQuaternion(rotation, rotationQuat);
            this.pp_rotateAroundLocalQuat(rotationQuat, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundLocalRadians = function() {
          let degreesRotation = vec3_exports.create();
          return function pp_rotateAroundLocalRadians(rotation, origin) {
            rotation.forEach(function(value, index, array) {
              degreesRotation[index] = this._pp_toDegrees(value);
            }.bind(this));
            this.pp_rotateAroundLocalDegrees(degreesRotation, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundLocalMatrix = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateAroundLocalMatrix(rotation, origin) {
            quat_exports.fromMat3(rotationQuat, rotation);
            quat_exports.normalize(rotationQuat, rotationQuat);
            this.pp_rotateAroundLocalQuat(rotationQuat, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundLocalQuat = function() {
          let axis = vec3_exports.create();
          return function pp_rotateAroundLocalQuat(rotation, origin) {
            let angle3 = quat_exports.getAxisAngle(axis, rotation);
            this.pp_rotateAroundAxisLocalRadians(angle3, axis, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundObject = function(rotation, origin) {
          this.pp_rotateAroundObjectDegrees(rotation, origin);
        };
        WL.Object.prototype.pp_rotateAroundObjectDegrees = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateAroundObjectDegrees(rotation, origin) {
            this._pp_degreesToQuaternion(rotation, rotationQuat);
            this.pp_rotateAroundObjectQuat(rotationQuat, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundObjectRadians = function() {
          let degreesRotation = vec3_exports.create();
          return function pp_rotateAroundObjectRadians(rotation, origin) {
            rotation.forEach(function(value, index, array) {
              degreesRotation[index] = this._pp_toDegrees(value);
            }.bind(this));
            this.pp_rotateAroundObjectDegrees(degreesRotation, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundObjectMatrix = function() {
          let rotationQuat = quat_exports.create();
          return function pp_rotateAroundObjectMatrix(rotation, origin) {
            quat_exports.fromMat3(rotationQuat, rotation);
            quat_exports.normalize(rotationQuat, rotationQuat);
            this.pp_rotateAroundObjectQuat(rotationQuat, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundObjectQuat = function() {
          let axis = vec3_exports.create();
          return function pp_rotateAroundObjectQuat(rotation, origin) {
            let angle3 = quat_exports.getAxisAngle(axis, rotation);
            this.pp_rotateAroundAxisObjectRadians(angle3, axis, origin);
          };
        }();
        WL.Object.prototype.pp_rotateAroundAxis = function(angle3, axis, origin) {
          this.pp_rotateAroundAxisWorld(angle3, axis, origin);
        };
        WL.Object.prototype.pp_rotateAroundAxisDegrees = function(angle3, axis, origin) {
          this.pp_rotateAroundAxisWorldDegrees(angle3, axis, origin);
        };
        WL.Object.prototype.pp_rotateAroundAxisRadians = function(angle3, axis, origin) {
          this.pp_rotateAroundAxisWorldRadians(angle3, axis, origin);
        };
        WL.Object.prototype.pp_rotateAroundAxisWorld = function(angle3, axis, origin) {
          this.pp_rotateAroundAxisWorldDegrees(angle3, axis, origin);
        };
        WL.Object.prototype.pp_rotateAroundAxisWorldDegrees = function(angle3, axis, origin) {
          this.pp_rotateAroundAxisWorldRadians(common_exports.toRadian(angle3), axis, origin);
        };
        WL.Object.prototype.pp_rotateAroundAxisWorldRadians = function() {
          let transformToRotate = quat2_exports.create();
          let transformToRotateConjugate = quat2_exports.create();
          let transformQuat3 = quat2_exports.create();
          let defaultQuat = quat_exports.create();
          return function pp_rotateAroundAxisWorldRadians(angle3, axis, origin) {
            quat2_exports.fromRotationTranslation(transformToRotate, defaultQuat, origin);
            this.pp_getTransformWorldQuat(transformQuat3);
            quat2_exports.conjugate(transformToRotateConjugate, transformToRotate);
            quat2_exports.mul(transformQuat3, transformToRotateConjugate, transformQuat3);
            quat2_exports.rotateAroundAxis(transformToRotate, transformToRotate, axis, angle3);
            quat2_exports.mul(transformQuat3, transformToRotate, transformQuat3);
            this.pp_setTransformWorldQuat(transformQuat3);
          };
        }();
        WL.Object.prototype.pp_rotateAroundAxisLocal = function(angle3, axis, origin) {
          this.pp_rotateAroundAxisLocalDegrees(angle3, axis, origin);
        };
        WL.Object.prototype.pp_rotateAroundAxisLocalDegrees = function(angle3, axis, origin) {
          this.pp_rotateAroundAxisLocalRadians(common_exports.toRadian(angle3), axis, origin);
        };
        WL.Object.prototype.pp_rotateAroundAxisLocalRadians = function() {
          let convertedPosition = vec3_exports.create();
          let convertedAxis = vec3_exports.create();
          return function pp_rotateAroundAxisLocalRadians(angle3, axis, origin) {
            this.pp_convertPositionLocalToWorld(origin, convertedPosition);
            this.pp_convertDirectionLocalToWorld(axis, convertedAxis);
            this.pp_rotateAroundAxisWorldRadians(angle3, convertedAxis, convertedPosition);
          };
        }();
        WL.Object.prototype.pp_rotateAroundAxisObject = function(angle3, axis, origin) {
          this.pp_rotateAroundAxisObjectDegrees(angle3, axis, origin);
        };
        WL.Object.prototype.pp_rotateAroundAxisObjectDegrees = function(angle3, axis, origin) {
          this.pp_rotateAroundAxisObjectRadians(common_exports.toRadian(angle3), axis, origin);
        };
        WL.Object.prototype.pp_rotateAroundAxisObjectRadians = function() {
          let convertedPosition = vec3_exports.create();
          let convertedAxis = vec3_exports.create();
          return function pp_rotateAroundAxisObjectRadians(angle3, axis, origin) {
            this.pp_convertPositionObjectToWorld(origin, convertedPosition);
            this.pp_convertDirectionObjectToWorld(axis, convertedAxis);
            this.pp_rotateAroundAxisWorldRadians(angle3, convertedAxis, convertedPosition);
          };
        }();
        WL.Object.prototype.pp_scaleObject = function() {
          let vector = vec3_exports.create();
          return function pp_scaleObject(scale8) {
            if (isNaN(scale8)) {
              this.scale(scale8);
            } else {
              vec3_exports.set(vector, scale8, scale8, scale8);
              this.scale(vector);
            }
          };
        }();
        WL.Object.prototype.pp_lookAt = function(position, up) {
          this.pp_lookAtWorld(position, up);
        };
        WL.Object.prototype.pp_lookAtWorld = function() {
          let direction = vec3_exports.create();
          return function pp_lookAtWorld(position, up) {
            this.pp_getPositionWorld(direction);
            vec3_exports.sub(direction, position, direction);
            this.pp_lookToWorld(direction, up);
          };
        }();
        WL.Object.prototype.pp_lookAtLocal = function() {
          let direction = vec3_exports.create();
          return function pp_lookAtLocal(position, up) {
            this.pp_getPositionLocal(direction);
            vec3_exports.sub(direction, position, direction);
            this.pp_lookToLocal(direction, up);
          };
        }();
        WL.Object.prototype.pp_lookTo = function(direction, up) {
          this.pp_lookToWorld(direction, up);
        };
        WL.Object.prototype.pp_lookToWorld = function() {
          let internalUp = vec3_exports.create();
          return function pp_lookToWorld(direction, up = this.pp_getUpWorld(internalUp)) {
            this.pp_setForwardWorld(direction, up);
          };
        }();
        WL.Object.prototype.pp_lookToLocal = function() {
          let internalUp = vec3_exports.create();
          return function pp_lookToLocal(direction, up = this.pp_getUpLocal(internalUp)) {
            this.pp_setForwardLocal(direction, up);
          };
        }();
        WL.Object.prototype.pp_setParent = function() {
          let position = vec3_exports.create();
          let rotation = quat_exports.create();
          let scale8 = vec3_exports.create();
          return function pp_setParent(newParent, keepTransform = true) {
            if (!keepTransform) {
              this.parent = newParent;
            } else {
              this.pp_getPositionWorld(position);
              this.pp_getRotationWorldQuat(rotation);
              this.pp_getScaleWorld(scale8);
              this.parent = newParent;
              this.pp_setScaleWorld(scale8);
              this.pp_setRotationWorldQuat(rotation);
              this.pp_setPositionWorld(position);
            }
          };
        }();
        WL.Object.prototype.pp_getParent = function() {
          return this.parent;
        };
        WL.Object.prototype.pp_convertPositionObjectToWorld = function() {
          let matrix = mat4_exports.create();
          return function pp_convertPositionObjectToWorld(position, resultPosition = vec3_exports.create()) {
            this.pp_getTransformWorldMatrix(matrix);
            vec3_exports.transformMat4(resultPosition, position, matrix);
            return resultPosition;
          };
        }();
        WL.Object.prototype.pp_convertDirectionObjectToWorld = function() {
          let rotation = quat_exports.create();
          return function pp_convertDirectionObjectToWorld(direction, resultDirection = vec3_exports.create()) {
            this.pp_getRotationWorldQuat(rotation);
            vec3_exports.transformQuat(resultDirection, direction, rotation);
            return resultDirection;
          };
        }();
        WL.Object.prototype.pp_convertPositionWorldToObject = function() {
          let matrix = mat4_exports.create();
          return function pp_convertPositionWorldToObject(position, resultPosition = vec3_exports.create()) {
            this.pp_getTransformWorldMatrix(matrix);
            mat4_exports.invert(matrix, matrix);
            vec3_exports.transformMat4(resultPosition, position, matrix);
            return resultPosition;
          };
        }();
        WL.Object.prototype.pp_convertDirectionWorldToObject = function() {
          let rotation = quat_exports.create();
          return function pp_convertDirectionWorldToObject(direction, resultDirection = vec3_exports.create()) {
            this.pp_getRotationWorldQuat(rotation);
            quat_exports.conjugate(rotation, rotation);
            vec3_exports.transformQuat(resultDirection, direction, rotation);
            return resultDirection;
          };
        }();
        WL.Object.prototype.pp_convertPositionLocalToWorld = function(position, resultPosition = vec3_exports.create()) {
          if (this.pp_getParent()) {
            this.pp_getParent().pp_convertPositionObjectToWorld(position, resultPosition);
          } else {
            vec3_exports.copy(resultPosition, position);
          }
          return resultPosition;
        };
        WL.Object.prototype.pp_convertDirectionLocalToWorld = function(direction, resultDirection = vec3_exports.create()) {
          if (this.pp_getParent()) {
            this.pp_getParent().pp_convertDirectionObjectToWorld(direction, resultDirection);
          } else {
            vec3_exports.copy(resultDirection, direction);
          }
          return resultDirection;
        };
        WL.Object.prototype.pp_convertPositionWorldToLocal = function(position, resultPosition = vec3_exports.create()) {
          if (this.pp_getParent()) {
            this.pp_getParent().pp_convertPositionWorldToObject(position, resultPosition);
          } else {
            vec3_exports.copy(resultPosition, position);
          }
          return resultPosition;
        };
        WL.Object.prototype.pp_convertDirectionWorldToLocal = function(direction, resultDirection = vec3_exports.create()) {
          if (this.pp_getParent()) {
            this.pp_getParent().pp_convertDirectionWorldToObject(direction, resultDirection);
          } else {
            vec3_exports.copy(resultDirection, direction);
          }
          return resultDirection;
        };
        WL.Object.prototype.pp_convertPositionObjectToLocal = function(position, resultPosition = vec3_exports.create()) {
          this.pp_convertPositionObjectToWorld(position, resultPosition);
          this.pp_convertPositionWorldToLocal(resultPosition, resultPosition);
          return resultPosition;
        };
        WL.Object.prototype.pp_convertDirectionObjectToLocal = function(direction, resultDirection = vec3_exports.create()) {
          this.pp_convertDirectionObjectToWorld(direction, resultDirection);
          this.pp_convertDirectionWorldToLocal(resultDirection, resultDirection);
          return resultDirection;
        };
        WL.Object.prototype.pp_convertPositionLocalToObject = function(position, resultPosition = vec3_exports.create()) {
          this.pp_convertPositionLocalToWorld(position, resultPosition);
          this.pp_convertPositionWorldToObject(resultPosition, resultPosition);
          return resultPosition;
        };
        WL.Object.prototype.pp_convertDirectionLocalToObject = function(direction, resultDirection = vec3_exports.create()) {
          this.pp_convertDirectionLocalToWorld(direction, resultDirection);
          this.pp_convertDirectionWorldToObject(resultDirection, resultDirection);
          return resultDirection;
        };
        WL.Object.prototype.pp_convertTransformObjectToWorld = function(transform, resultTransform) {
          return this.pp_convertTransformObjectToWorldMatrix(transform, resultTransform);
        };
        WL.Object.prototype.pp_convertTransformObjectToWorldMatrix = function() {
          let convertTransform = mat4_exports.create();
          let position = vec3_exports.create();
          let scale8 = vec3_exports.create();
          let inverseScale = vec3_exports.create();
          let one = vec3_exports.create();
          vec3_exports.set(one, 1, 1, 1);
          return function pp_convertTransformObjectToWorldMatrix(transform, resultTransform = mat4_exports.create()) {
            this.pp_getTransformWorldMatrix(convertTransform);
            if (this.pp_hasUniformScaleWorld()) {
              mat4_exports.mul(resultTransform, convertTransform, transform);
            } else {
              vec3_exports.set(position, transform[12], transform[13], transform[14]);
              this.pp_convertPositionObjectToWorld(position, position);
              mat4_exports.getScaling(scale8, convertTransform);
              vec3_exports.divide(inverseScale, one, scale8);
              mat4_exports.scale(convertTransform, convertTransform, inverseScale);
              mat4_exports.mul(resultTransform, convertTransform, transform);
              mat4_exports.scale(resultTransform, resultTransform, scale8);
              resultTransform[12] = position[0];
              resultTransform[13] = position[1];
              resultTransform[14] = position[2];
              resultTransform[15] = 1;
            }
            return resultTransform;
          };
        }();
        WL.Object.prototype.pp_convertTransformObjectToWorldQuat = function() {
          let position = vec3_exports.create();
          let rotation = quat_exports.create();
          return function pp_convertTransformObjectToWorldQuat(transform, resultTransform = quat2_exports.create()) {
            this.pp_getRotationWorldQuat(rotation);
            quat_exports.mul(rotation, rotation, transform);
            quat2_exports.getTranslation(position, transform);
            this.pp_convertPositionObjectToWorld(position, position);
            quat2_exports.fromRotationTranslation(resultTransform, rotation, position);
            return resultTransform;
          };
        }();
        WL.Object.prototype.pp_convertTransformWorldToObject = function(transform, resultTransform) {
          return this.pp_convertTransformWorldToObjectMatrix(transform, resultTransform);
        };
        WL.Object.prototype.pp_convertTransformWorldToObjectMatrix = function() {
          let convertTransform = mat4_exports.create();
          let position = vec3_exports.create();
          let scale8 = vec3_exports.create();
          let inverseScale = vec3_exports.create();
          let one = vec3_exports.create();
          vec3_exports.set(one, 1, 1, 1);
          return function pp_convertTransformWorldToObjectMatrix(transform, resultTransform = mat4_exports.create()) {
            this.pp_getTransformWorldMatrix(convertTransform);
            if (this.pp_hasUniformScaleWorld()) {
              mat4_exports.invert(convertTransform, convertTransform);
              mat4_exports.mul(resultTransform, convertTransform, transform);
            } else {
              vec3_exports.set(position, transform[12], transform[13], transform[14]);
              this.pp_convertPositionWorldToObject(position, position);
              mat4_exports.getScaling(scale8, convertTransform);
              vec3_exports.divide(inverseScale, one, scale8);
              mat4_exports.scale(convertTransform, convertTransform, inverseScale);
              mat4_exports.invert(convertTransform, convertTransform);
              mat4_exports.mul(resultTransform, convertTransform, transform);
              mat4_exports.scale(resultTransform, resultTransform, inverseScale);
              resultTransform[12] = position[0];
              resultTransform[13] = position[1];
              resultTransform[14] = position[2];
              resultTransform[15] = 1;
            }
            return resultTransform;
          };
        }();
        WL.Object.prototype.pp_convertTransformWorldToObjectQuat = function() {
          let position = vec3_exports.create();
          let rotation = quat_exports.create();
          return function pp_convertTransformWorldToObjectQuat(transform, resultTransform = quat2_exports.create()) {
            this.pp_getRotationWorldQuat(rotation);
            quat_exports.conjugate(rotation, rotation);
            quat_exports.mul(rotation, rotation, transform);
            quat2_exports.getTranslation(position, transform);
            this.pp_convertPositionWorldToObject(position, position);
            quat2_exports.fromRotationTranslation(resultTransform, rotation, position);
            return resultTransform;
          };
        }();
        WL.Object.prototype.pp_convertTransformLocalToWorld = function(transform, resultTransform) {
          return this.pp_convertTransformLocalToWorldMatrix(transform, resultTransform);
        };
        WL.Object.prototype.pp_convertTransformLocalToWorldMatrix = function(transform, resultTransform = mat4_exports.create()) {
          if (this.pp_getParent()) {
            this.pp_getParent().pp_convertTransformObjectToWorldMatrix(transform, resultTransform);
          } else {
            mat4_exports.copy(resultTransform, transform);
          }
          return resultTransform;
        };
        WL.Object.prototype.pp_convertTransformLocalToWorldQuat = function(transform, resultTransform = quat2_exports.create()) {
          if (this.pp_getParent()) {
            this.pp_getParent().pp_convertTransformObjectToWorldQuat(transform, resultTransform);
          } else {
            quat2_exports.copy(resultTransform, transform);
          }
          return resultTransform;
        };
        WL.Object.prototype.pp_convertTransformWorldToLocal = function(transform, resultTransform) {
          return this.pp_convertTransformWorldToLocalMatrix(transform, resultTransform);
        };
        WL.Object.prototype.pp_convertTransformWorldToLocalMatrix = function(transform, resultTransform = mat4_exports.create()) {
          if (this.pp_getParent()) {
            this.pp_getParent().pp_convertTransformWorldToObjectMatrix(transform, resultTransform);
          } else {
            mat4_exports.copy(resultTransform, transform);
          }
          return resultTransform;
        };
        WL.Object.prototype.pp_convertTransformWorldToLocalQuat = function(transform, resultTransform = quat2_exports.create()) {
          if (this.pp_getParent()) {
            this.pp_getParent().pp_convertTransformWorldToObjectQuat(transform, resultTransform);
          } else {
            quat2_exports.copy(resultTransform, transform);
          }
          return resultTransform;
        };
        WL.Object.prototype.pp_convertTransformObjectToLocal = function(transform, resultTransform) {
          return this.pp_convertTransformObjectToLocalMatrix(transform, resultTransform);
        };
        WL.Object.prototype.pp_convertTransformObjectToLocalMatrix = function(transform, resultTransform = mat4_exports.create()) {
          this.pp_convertTransformObjectToWorldMatrix(transform, resultTransform);
          this.pp_convertTransformWorldToLocalMatrix(resultTransform, resultTransform);
          return resultTransform;
        };
        WL.Object.prototype.pp_convertTransformObjectToLocalQuat = function(transform, resultTransform = quat2_exports.create()) {
          this.pp_convertTransformObjectToWorldQuat(transform, resultTransform);
          this.pp_convertTransformWorldToLocalQuat(resultTransform, resultTransform);
          return resultTransform;
        };
        WL.Object.prototype.pp_convertTransformLocalToObject = function(transform, resultTransform) {
          return this.pp_convertTransformLocalToObjectMatrix(transform, resultTransform);
        };
        WL.Object.prototype.pp_convertTransformLocalToObjectMatrix = function(transform, resultTransform = mat4_exports.create()) {
          this.pp_convertTransformLocalToWorldMatrix(transform, resultTransform);
          this.pp_convertTransformWorldToObjectMatrix(resultTransform, resultTransform);
          return resultTransform;
        };
        WL.Object.prototype.pp_convertTransformLocalToObjectQuat = function(transform, resultTransform = quat2_exports.create()) {
          this.pp_convertTransformLocalToWorldQuat(transform, resultTransform);
          this.pp_convertTransformWorldToObjectQuat(resultTransform, resultTransform);
          return resultTransform;
        };
        WL.Object.prototype.pp_addComponent = function(type, paramsOrActive, active = null) {
          let params = null;
          if (typeof paramsOrActive == "boolean") {
            params = {};
            params["active"] = paramsOrActive;
          } else {
            params = paramsOrActive;
            if (active != null) {
              if (params == null) {
                params = {};
              }
              params["active"] = active;
            }
          }
          return this.addComponent(type, params);
        };
        WL.Object.prototype.pp_getComponent = function(type, index = 0) {
          return this.pp_getComponentHierarchy(type, index);
        };
        WL.Object.prototype.pp_getComponentSelf = function(type, index = 0) {
          return this.getComponent(type, index);
        };
        WL.Object.prototype.pp_getComponentHierarchy = function(type, index = 0) {
          return this.pp_getComponentHierarchyBreadth(type, index);
        };
        WL.Object.prototype.pp_getComponentHierarchyBreadth = function(type, index = 0) {
          let objects = this.pp_getHierarchyBreadth();
          return WL.Object.pp_getComponentObjects(objects, type, index);
        };
        WL.Object.prototype.pp_getComponentHierarchyDepth = function(type, index = 0) {
          let objects = this.pp_getHierarchyDepth();
          return WL.Object.pp_getComponentObjects(objects, type, index);
        };
        WL.Object.prototype.pp_getComponentDescendants = function(type, index = 0) {
          return this.pp_getComponentDescendantsBreadth(type, index);
        };
        WL.Object.prototype.pp_getComponentDescendantsBreadth = function(type, index = 0) {
          let objects = this.pp_getDescendantsBreadth();
          return WL.Object.pp_getComponentObjects(objects, type, index);
        };
        WL.Object.prototype.pp_getComponentDescendantsDepth = function(type, index = 0) {
          let objects = this.pp_getDescendantsDepth();
          return WL.Object.pp_getComponentObjects(objects, type, index);
        };
        WL.Object.prototype.pp_getComponentChildren = function(type, index = 0) {
          let objects = this.pp_getChildren();
          return WL.Object.pp_getComponentObjects(objects, type, index);
        };
        WL.Object.prototype.pp_getComponents = function(type) {
          return this.pp_getComponentsHierarchy(type);
        };
        WL.Object.prototype.pp_getComponentsSelf = function(type) {
          return this.getComponents(type);
        };
        WL.Object.prototype.pp_getComponentsHierarchy = function(type) {
          return this.pp_getComponentsHierarchyBreadth(type);
        };
        WL.Object.prototype.pp_getComponentsHierarchyBreadth = function(type) {
          let objects = this.pp_getHierarchyBreadth();
          return WL.Object.pp_getComponentsObjects(objects, type);
        };
        WL.Object.prototype.pp_getComponentsHierarchyDepth = function(type) {
          let objects = this.pp_getHierarchyDepth();
          return WL.Object.pp_getComponentsObjects(objects, type);
        };
        WL.Object.prototype.pp_getComponentsDescendants = function(type) {
          return this.pp_getComponentsDescendantsBreadth(type);
        };
        WL.Object.prototype.pp_getComponentsDescendantsBreadth = function(type) {
          let objects = this.pp_getDescendantsBreadth();
          return WL.Object.pp_getComponentsObjects(objects, type);
        };
        WL.Object.prototype.pp_getComponentsDescendantsDepth = function(type) {
          let objects = this.pp_getDescendantsDepth();
          return WL.Object.pp_getComponentsObjects(objects, type);
        };
        WL.Object.prototype.pp_getComponentsChildren = function(type) {
          let objects = this.pp_getChildren();
          return WL.Object.pp_getComponentsObjects(objects, type);
        };
        WL.Object.prototype.pp_setActive = function(active, applyToHierarchy = true) {
          if (applyToHierarchy) {
            this.pp_setActiveHierarchy(active);
          } else {
            this.active = active;
          }
        };
        WL.Object.prototype.pp_setActiveSelf = function(active) {
          this.pp_setActive(active, false);
        };
        WL.Object.prototype.pp_setActiveHierarchy = function(active) {
          this.pp_setActiveHierarchyBreadth(active);
        };
        WL.Object.prototype.pp_setActiveHierarchyBreadth = function(active) {
          let objects = this.pp_getHierarchyBreadth();
          return WL.Object.pp_setActiveObjects(objects, active);
        };
        WL.Object.prototype.pp_setActiveHierarchyDepth = function(active) {
          let objects = this.pp_getHierarchyDepth();
          return WL.Object.pp_setActiveObjects(objects, active);
        };
        WL.Object.prototype.pp_setActiveDescendants = function(active) {
          this.pp_setActiveDescendantsBreadth(active);
        };
        WL.Object.prototype.pp_setActiveDescendantsBreadth = function(active) {
          let objects = this.pp_getDescendantsBreadth();
          return WL.Object.pp_setActiveObjects(objects, active);
        };
        WL.Object.prototype.pp_setActiveDescendantsDepth = function(active) {
          let objects = this.pp_getDescendantsDepth();
          return WL.Object.pp_setActiveObjects(objects, active);
        };
        WL.Object.prototype.pp_setActiveChildren = function(active) {
          let objects = this.pp_getChildren();
          return WL.Object.pp_setActiveObjects(objects, active);
        };
        WL.Object.prototype.pp_hasUniformScale = function() {
          return this.pp_hasUniformScaleWorld();
        };
        WL.Object.prototype.pp_hasUniformScaleWorld = function() {
          let scale8 = vec3_exports.create();
          return function pp_hasUniformScaleWorld() {
            this.pp_getScaleWorld(scale8);
            return Math.abs(scale8[0] - scale8[1]) < this._pp_epsilon && Math.abs(scale8[1] - scale8[2]) < this._pp_epsilon && Math.abs(scale8[0] - scale8[2]) < this._pp_epsilon;
          };
        }();
        WL.Object.prototype.pp_hasUniformScaleLocal = function() {
          let scale8 = vec3_exports.create();
          return function pp_hasUniformScaleLocal() {
            this.pp_getScaleLocal(scale8);
            return Math.abs(scale8[0] - scale8[1]) < this._pp_epsilon && Math.abs(scale8[1] - scale8[2]) < this._pp_epsilon && Math.abs(scale8[0] - scale8[2]) < this._pp_epsilon;
          };
        }();
        PP.CloneParams = class CloneParams {
          constructor() {
            this.myIgnoreNonCloneable = false;
            this.myIgnoreComponents = false;
            this.myIgnoreChildren = false;
            this.myComponentsToIgnore = [];
            this.myComponentsToInclude = [];
            this.myIgnoreComponentCallback = null;
            this.myChildrenToIgnore = [];
            this.myChildrenToInclude = [];
            this.myIgnoreChildCallback = null;
            this.myDeepCloneParams = new PP.DeepCloneParams();
            this.myCustomParamsMap = /* @__PURE__ */ new Map();
          }
        };
        PP.DeepCloneParams = class DeepCloneParams {
          constructor() {
            this._myDeepCloneObject = false;
            this._myOverrideDeepCloneComponentsMap = /* @__PURE__ */ new Map();
            this._myOverrideDeepCloneComponentsVariablesMap = /* @__PURE__ */ new Map();
          }
          // The implementation is component dependant, not every component implements the deep clone
          setDeepCloneObject(deepClone) {
            this._myDeepCloneObject = deepClone;
          }
          // This value override the deep clone object value
          // The implementation is component dependant, not every component implements the deep clone
          setDeepCloneComponent(componentName, deepClone) {
            this._myOverrideDeepCloneComponentsMap.set(componentName, deepClone);
          }
          // This value override both the deep clone object value and the deep clone component one
          // The implementation is component dependant, not every component variable override is taken into consideration
          setDeepCloneComponentVariable(componentName, variableName, deepClone) {
            let componentsVariablesMap = null;
            if (!this._myOverrideDeepCloneComponentsVariablesMap.has(componentName)) {
              this._myOverrideDeepCloneComponentsVariablesMap.set(componentName, /* @__PURE__ */ new Map());
            }
            componentsVariablesMap = this._myOverrideDeepCloneComponentsVariablesMap.get(componentName);
            componentsVariablesMap.set(variableName, deepClone);
          }
          isDeepCloneComponent(componentName) {
            let overrideValue = this._myOverrideDeepCloneComponentsMap.get(componentName);
            if (overrideValue != null) {
              return overrideValue;
            }
            return this._myDeepCloneObject;
          }
          isDeepCloneComponentVariable(componentName, variableName) {
            let componentsVariablesMap = this._myOverrideDeepCloneComponentsVariablesMap.get(componentName);
            if (componentsVariablesMap != null) {
              let overrideValue = componentsVariablesMap.get(variableName);
              if (overrideValue != null) {
                return overrideValue;
              }
            }
            return this.isDeepCloneComponent(componentName);
          }
        };
        WL.Object.prototype.pp_clone = function() {
          let scale8 = vec3_exports.create();
          let transformQuat3 = quat2_exports.create();
          return function pp_clone(params = new PP.CloneParams()) {
            let clonedObject = null;
            if (this.pp_isCloneable(params)) {
              let objectsToCloneData = [];
              objectsToCloneData.push([this.parent, this]);
              let objectsToCloneComponentsData = [];
              while (objectsToCloneData.length > 0) {
                let cloneData = objectsToCloneData.shift();
                let parent = cloneData[0];
                let objectToClone = cloneData[1];
                let currentClonedObject = WL.scene.addObject(parent);
                currentClonedObject.name = objectToClone.name;
                currentClonedObject.pp_setScaleLocal(objectToClone.pp_getScaleLocal(scale8));
                currentClonedObject.pp_setTransformLocalQuat(objectToClone.pp_getTransformLocalQuat(transformQuat3));
                if (!params.myIgnoreComponents) {
                  objectsToCloneComponentsData.push([objectToClone, currentClonedObject]);
                }
                if (!params.myIgnoreChildren) {
                  for (let child of objectToClone.children) {
                    let cloneChild = false;
                    if (params.myChildrenToInclude.length > 0) {
                      cloneChild = params.myChildrenToInclude.find((childToInclude) => childToInclude.pp_equals(child)) != null;
                    } else {
                      cloneChild = params.myChildrenToIgnore.find((childToIgnore) => childToIgnore.pp_equals(child)) == null;
                    }
                    if (cloneChild && params.myIgnoreChildCallback != null) {
                      cloneChild = !params.myIgnoreChildCallback(child);
                    }
                    if (cloneChild) {
                      objectsToCloneData.push([currentClonedObject, child]);
                    }
                  }
                }
                if (clonedObject == null) {
                  clonedObject = currentClonedObject;
                }
              }
              let componentsToCloneData = [];
              while (objectsToCloneComponentsData.length > 0) {
                let cloneData = objectsToCloneComponentsData.shift();
                let objectToClone = cloneData[0];
                let currentClonedObject = cloneData[1];
                let components = objectToClone.pp_getComponentsSelf();
                for (let component of components) {
                  if (component.pp_clone != null) {
                    let cloneComponent = false;
                    if (params.myComponentsToInclude.length > 0) {
                      cloneComponent = params.myComponentsToInclude.indexOf(component.type) != -1;
                    } else {
                      cloneComponent = params.myComponentsToIgnore.indexOf(component.type) == -1;
                    }
                    if (cloneComponent && params.myIgnoreComponentCallback != null) {
                      cloneComponent = !params.myIgnoreComponentCallback(component);
                    }
                    if (cloneComponent) {
                      componentsToCloneData.push([component, currentClonedObject]);
                    }
                  }
                }
              }
              let componentsToPostProcessData = [];
              while (componentsToCloneData.length > 0) {
                let cloneData = componentsToCloneData.shift();
                let componentToClone = cloneData[0];
                let currentClonedObject = cloneData[1];
                let clonedComponent = componentToClone.pp_clone(currentClonedObject, params.myDeepCloneParams, params.myCustomParamsMap);
                if (componentToClone.pp_clonePostProcess != null) {
                  componentsToPostProcessData.push([componentToClone, clonedComponent]);
                }
              }
              while (componentsToPostProcessData.length > 0) {
                let cloneData = componentsToPostProcessData.shift();
                let componentToClone = cloneData[0];
                let currentClonedComponent = cloneData[1];
                componentToClone.pp_clonePostProcess(currentClonedComponent, params.myDeepCloneParams, params.myCustomParamsMap);
              }
            }
            return clonedObject;
          };
        }();
        WL.Object.prototype.pp_isCloneable = function(params = new PP.CloneParams()) {
          if (params.myIgnoreNonCloneable || params.myIgnoreComponents) {
            return true;
          }
          let isCloneable = true;
          let objects = [];
          objects.push(this);
          while (isCloneable && objects.length > 0) {
            let object = objects.shift();
            let components = this.pp_getComponentsSelf();
            for (let component of components) {
              let cloneComponent = false;
              if (params.myComponentsToInclude.length > 0) {
                cloneComponent = params.myComponentsToInclude.indexOf(component.type) != -1;
              } else {
                cloneComponent = params.myComponentsToIgnore.indexOf(component.type) == -1;
              }
              if (cloneComponent && params.myIgnoreComponentCallback != null) {
                cloneComponent = !params.myIgnoreComponentCallback(component);
              }
              if (cloneComponent && component.pp_clone == null) {
                isCloneable = false;
                break;
              }
            }
            if (isCloneable && !params.myIgnoreChildren) {
              for (let child of object.children) {
                let cloneChild = false;
                if (params.myChildrenToInclude.length > 0) {
                  cloneChild = params.myChildrenToInclude.find((childToInclude) => childToInclude.pp_equals(child)) != null;
                } else {
                  cloneChild = params.myChildrenToIgnore.find((childToInclude) => childToInclude.pp_equals(child)) == null;
                }
                if (cloneChild && params.myIgnoreChildCallback != null) {
                  cloneChild = !params.myIgnoreChildCallback(child);
                }
                if (cloneChild) {
                  objects.push(child);
                }
              }
            }
          }
          return isCloneable;
        };
        WL.Object.prototype.pp_toString = function() {
          return this.pp_toStringCompact();
        };
        WL.Object.prototype.pp_toStringExtended = function() {
          let tab = "    ";
          let newLine = "\n";
          let startObject = "{";
          let endObject = "}";
          let nameLabel = "name: ";
          let idLabel = "id: ";
          let componentsLabel = "components: ";
          let typeLabel = "type: ";
          let childrenLabel = "children: ";
          let startComponents = "[";
          let endComponents = "]";
          let startChildren = startComponents;
          let endChildren = endComponents;
          let separator = ",";
          let newLineTab = newLine.concat(tab, tab);
          return function pp_toStringExtended() {
            let objectString = "";
            objectString = objectString.concat(startObject, newLine);
            let components = this.pp_getComponentsSelf();
            let children = this.pp_getChildren();
            let name = this.pp_getName();
            if (components.length > 0 || children.length > 0 || name.length > 0) {
              objectString = objectString.concat(tab, idLabel, this.pp_getID(), separator, newLine);
            } else {
              objectString = objectString.concat(tab, idLabel, this.pp_getID(), newLine);
            }
            if (name.length > 0) {
              if (components.length > 0 || children.length > 0) {
                objectString = objectString.concat(tab, nameLabel, this.pp_getName(), separator, newLine);
              } else {
                objectString = objectString.concat(tab, nameLabel, this.pp_getName(), newLine);
              }
            }
            if (components.length > 0) {
              objectString = objectString.concat(tab, componentsLabel, newLine, tab, startComponents, newLine);
              for (let i = 0; i < components.length; i++) {
                let component = components[i];
                objectString = objectString.concat(tab, tab, startObject, newLine);
                objectString = objectString.concat(tab, tab, tab, typeLabel, component.type, separator, newLine);
                objectString = objectString.concat(tab, tab, tab, idLabel, component._id, separator, newLine);
                objectString = objectString.concat(tab, tab, endObject);
                if (i != components.length - 1) {
                  objectString = objectString.concat(separator, newLine);
                } else {
                  objectString = objectString.concat(newLine);
                }
              }
              if (children.length > 0) {
                objectString = objectString.concat(tab, endComponents, separator, newLine);
              } else {
                objectString = objectString.concat(tab, endComponents, newLine);
              }
            }
            if (children.length > 0) {
              objectString = objectString.concat(tab, childrenLabel, newLine, tab, startChildren, newLine);
              for (let i = 0; i < children.length; i++) {
                let child = children[i];
                let childString = child.pp_toStringExtended();
                childString = childString.replaceAll(newLine, newLineTab);
                childString = tab.concat(tab, childString);
                objectString = objectString.concat(childString);
                if (i != children.length - 1) {
                  objectString = objectString.concat(separator, newLine);
                } else {
                  objectString = objectString.concat(newLine);
                }
              }
              objectString = objectString.concat(tab, endChildren, newLine);
            }
            objectString = objectString.concat(endObject);
            return objectString;
          };
        }();
        WL.Object.prototype.pp_toStringCompact = function() {
          let tab = "    ";
          let newLine = "\n";
          let emptyName = "<none>";
          let nameLabel = "name: ";
          let componentsLabel = "components: ";
          let separator = ", ";
          let newLineTab = newLine.concat(tab);
          return function pp_toStringCompact() {
            let objectString = "";
            let name = this.pp_getName();
            if (name.length > 0) {
              objectString = objectString.concat(nameLabel, name);
            } else {
              objectString = objectString.concat(nameLabel, emptyName);
            }
            let components = this.pp_getComponentsSelf();
            if (components.length > 0) {
              objectString = objectString.concat(separator, componentsLabel);
              for (let i = 0; i < components.length; i++) {
                let component = components[i];
                objectString = objectString.concat(component.type);
                if (i != components.length - 1) {
                  objectString = objectString.concat(separator);
                }
              }
            }
            let children = this.pp_getChildren();
            if (children.length > 0) {
              objectString = objectString.concat(newLine);
              for (let i = 0; i < children.length; i++) {
                let child = children[i];
                let childString = child.pp_toStringCompact();
                childString = childString.replaceAll(newLine, newLineTab);
                childString = tab.concat(childString);
                objectString = objectString.concat(childString);
                if (i != children.length - 1) {
                  objectString = objectString.concat(newLine);
                }
              }
            }
            return objectString;
          };
        }();
        WL.Object.prototype.pp_getObjectByName = function(name) {
          return this.pp_getObjectByNameHierarchy(name);
        };
        WL.Object.prototype.pp_getObjectByNameHierarchy = function(name) {
          return this.pp_getObjectByNameHierarchyBreadth(name);
        };
        WL.Object.prototype.pp_getObjectByNameHierarchyBreadth = function(name) {
          let objects = this.pp_getHierarchyBreadth();
          return WL.Object.pp_getObjectByNameObjects(objects, name);
        };
        WL.Object.prototype.pp_getObjectByNameHierarchyDepth = function(name) {
          let objects = this.pp_getHierarchyDepth();
          return WL.Object.pp_getObjectByNameObjects(objects, name);
        };
        WL.Object.prototype.pp_getObjectByNameDescendants = function(name) {
          return this.pp_getObjectByNameDescendantsBreadth(name);
        };
        WL.Object.prototype.pp_getObjectByNameDescendantsBreadth = function(name) {
          let objects = this.pp_getDescendantsBreadth();
          return WL.Object.pp_getObjectByNameObjects(objects, name);
        };
        WL.Object.prototype.pp_getObjectByNameDescendantsDepth = function(name) {
          let objects = this.pp_getDescendantsDepth();
          return WL.Object.pp_getObjectByNameObjects(objects, name);
        };
        WL.Object.prototype.pp_getObjectByNameChildren = function(name) {
          let objects = this.pp_getChildren();
          return WL.Object.pp_getObjectByNameObjects(objects, name);
        };
        WL.Object.prototype.pp_getObjectsByName = function(name) {
          return this.pp_getObjectsByNameHierarchy(name);
        };
        WL.Object.prototype.pp_getObjectsByNameHierarchy = function(name) {
          return this.pp_getObjectsByNameHierarchyBreadth(name);
        };
        WL.Object.prototype.pp_getObjectsByNameHierarchyBreadth = function(name) {
          let objects = this.pp_getHierarchyBreadth();
          return WL.Object.pp_getObjectsByNameObjects(objects, name);
        };
        WL.Object.prototype.pp_getObjectsByNameHierarchyDepth = function(name) {
          let objects = this.pp_getHierarchyDepth();
          return WL.Object.pp_getObjectsByNameObjects(objects, name);
        };
        WL.Object.prototype.pp_getObjectsByNameDescendants = function(name) {
          return this.pp_getObjectsByNameDescendantsBreadth(name);
        };
        WL.Object.prototype.pp_getObjectsByNameDescendantsBreadth = function(name) {
          let objects = this.pp_getDescendantsBreadth();
          return WL.Object.pp_getObjectsByNameObjects(objects, name);
        };
        WL.Object.prototype.pp_getObjectsByNameDescendantsDepth = function(name) {
          let objects = this.pp_getDescendantsDepth();
          return WL.Object.pp_getObjectsByNameObjects(objects, name);
        };
        WL.Object.prototype.pp_getObjectsByNameChildren = function(name) {
          let objects = this.pp_getChildren();
          return WL.Object.pp_getObjectsByNameObjects(objects, name);
        };
        WL.Object.prototype.pp_getHierarchy = function() {
          return this.pp_getHierarchyBreadth();
        };
        WL.Object.prototype.pp_getHierarchyBreadth = function() {
          let hierarchy = this.pp_getDescendantsBreadth();
          hierarchy.unshift(this);
          return hierarchy;
        };
        WL.Object.prototype.pp_getHierarchyDepth = function() {
          let hierarchy = this.pp_getDescendantsDepth();
          hierarchy.unshift(this);
          return hierarchy;
        };
        WL.Object.prototype.pp_getDescendants = function() {
          return this.pp_getDescendantsBreadth();
        };
        WL.Object.prototype.pp_getDescendantsBreadth = function() {
          let descendants = [];
          let descendantsQueue = this.children;
          while (descendantsQueue.length > 0) {
            let descendant = descendantsQueue.shift();
            descendants.push(descendant);
            for (let object of descendant.children) {
              descendantsQueue.push(object);
            }
          }
          return descendants;
        };
        WL.Object.prototype.pp_getDescendantsDepth = function() {
          let descendants = [];
          let children = this.pp_getChildren();
          for (let child of children) {
            descendants.push(child);
            let childDescendants = child.pp_getDescendantsDepth();
            if (childDescendants.length > 0) {
              descendants.push(...childDescendants);
            }
          }
          return descendants;
        };
        WL.Object.prototype.pp_getChildren = function() {
          return this.children;
        };
        WL.Object.prototype.pp_getSelf = function() {
          return this;
        };
        WL.Object.prototype.pp_addObject = function() {
          return WL.scene.addObject(this);
        };
        WL.Object.prototype.pp_getName = function() {
          return this.name;
        };
        WL.Object.prototype.pp_setName = function(name) {
          this.name = name;
        };
        WL.Object.prototype.pp_getID = function() {
          return this.objectId;
        };
        WL.Object.prototype.pp_markDirty = function() {
          return this.setDirty();
        };
        WL.Object.prototype.pp_equals = function(otherObject) {
          return this.equals(otherObject);
        };
        WL.Object.prototype.pp_destroy = function() {
          return this.destroy();
        };
        WL.Object.prototype.pp_reserveObjects = function(count) {
          this.pp_reserveObjectsHierarchy(count);
        };
        WL.Object.prototype.pp_reserveObjectsSelf = function(count) {
          let componentsAmountMap = this.pp_getComponentsAmountMapSelf();
          this._pp_reserveObjects(count, componentsAmountMap);
        };
        WL.Object.prototype.pp_reserveObjectsHierarchy = function(count) {
          let componentsAmountMap = this.pp_getComponentsAmountMapHierarchy();
          this._pp_reserveObjects(count, componentsAmountMap);
        };
        WL.Object.prototype.pp_reserveObjectsDescendants = function(count) {
          let componentsAmountMap = this.pp_getComponentsAmountMapDescendants();
          this._pp_reserveObjects(count, componentsAmountMap);
        };
        WL.Object.prototype.pp_reserveObjectsChildren = function(count) {
          let componentsAmountMap = this.pp_getComponentsAmountMapChildren();
          this._pp_reserveObjects(count, componentsAmountMap);
        };
        WL.Object.prototype.pp_getComponentsAmountMap = function(amountMap = /* @__PURE__ */ new Map()) {
          return this.pp_getComponentsAmountMapHierarchy(amountMap);
        };
        WL.Object.prototype.pp_getComponentsAmountMapSelf = function(amountMap = /* @__PURE__ */ new Map()) {
          let objectsAmount = amountMap.get("object");
          if (objectsAmount == null) {
            objectsAmount = 0;
          }
          objectsAmount += 1;
          amountMap.set("object", objectsAmount);
          let components = this.pp_getComponentsSelf();
          for (let component of components) {
            let type = component.type;
            let typeAmount = amountMap.get(type);
            if (typeAmount == null) {
              typeAmount = 0;
            }
            typeAmount += 1;
            amountMap.set(type, typeAmount);
          }
          return amountMap;
        };
        WL.Object.prototype.pp_getComponentsAmountMapHierarchy = function(amountMap = /* @__PURE__ */ new Map()) {
          let hierarchy = this.pp_getHierarchy();
          for (let object of hierarchy) {
            object.pp_getComponentsAmountMapSelf(amountMap);
          }
          return amountMap;
        };
        WL.Object.prototype.pp_getComponentsAmountMapDescendants = function(amountMap = /* @__PURE__ */ new Map()) {
          let descendants = this.pp_getDescendants();
          for (let object of descendants) {
            object.pp_getComponentsAmountMapSelf(amountMap);
          }
          return amountMap;
        };
        WL.Object.prototype.pp_getComponentsAmountMapChildren = function(amountMap = /* @__PURE__ */ new Map()) {
          let children = this.pp_getChildren();
          for (let object of children) {
            object.pp_getComponentsAmountMapSelf(amountMap);
          }
          return amountMap;
        };
        WL.Object.pp_getComponentObjects = function(objects, type, index = 0) {
          let component = null;
          for (let object of objects) {
            component = object.getComponent(type, index);
            if (component != null) {
              break;
            }
          }
          return component;
        };
        WL.Object.pp_getComponentsObjects = function(objects, type) {
          let components = [];
          for (let object of objects) {
            components.push(...object.getComponents(type));
          }
          return components;
        };
        WL.Object.pp_setActiveObjects = function(objects, active) {
          for (let object of objects) {
            object.active = active;
          }
        };
        WL.Object.pp_getObjectByNameObjects = function(objects, name) {
          let objectFound = null;
          for (let object of objects) {
            if (object.pp_getName() == name) {
              objectFound = object;
              break;
            }
          }
          return objectFound;
        };
        WL.Object.pp_getObjectsByNameObjects = function(objects, name) {
          let objectsFound = [];
          for (let object of objects) {
            if (object.pp_getName() == name) {
              objectsFound.push(object);
            }
          }
          return objectsFound;
        };
        WL.Object.prototype._pp_epsilon = 1e-6;
        WL.Object.prototype._pp_quaternionToRadians = function() {
          let mat3 = mat3_exports.create();
          return function _pp_quaternionToRadians(quatRotation, radiansRotation = vec3_exports.create()) {
            mat3_exports.fromQuat(mat3, quatRotation);
            radiansRotation[1] = Math.asin(-this._pp_clamp(mat3[2], -1, 1));
            if (Math.abs(mat3[2]) < 0.9999999) {
              radiansRotation[0] = Math.atan2(mat3[5], mat3[8]);
              radiansRotation[2] = Math.atan2(mat3[1], mat3[0]);
            } else {
              radiansRotation[0] = 0;
              radiansRotation[2] = Math.atan2(-mat3[3], mat3[4]);
            }
            return radiansRotation;
          };
        }();
        WL.Object.prototype._pp_degreesToQuaternion = function(degreesRotation, quatRotation = quat_exports.create()) {
          quat_exports.fromEuler(quatRotation, degreesRotation[0], degreesRotation[1], degreesRotation[2]);
          return quatRotation;
        };
        WL.Object.prototype._pp_toDegrees = function(angle3) {
          return angle3 * (180 / Math.PI);
        };
        WL.Object.prototype._pp_clamp = function(value, min4, max4) {
          return Math.min(Math.max(value, min4), max4);
        };
        WL.Object.prototype._pp_reserveObjects = function(count, componentsAmountMap) {
          let objectsToReserve = componentsAmountMap.get("object") * count;
          componentsAmountMap.delete("object");
          let componentsToReserve = {};
          for (let [componentName, componentCount] of componentsAmountMap.entries()) {
            componentsToReserve[componentName] = componentCount * count;
          }
          WL.scene.reserveObjects(objectsToReserve, componentsToReserve);
        };
        WL.Object.prototype._pp_setAxes = function() {
          let fixedAxes = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()];
          let fixedAxesFixSignMap = [
            [1, -1, 1],
            [1, 1, -1],
            [-1, 1, -1]
          ];
          let fixedLeft = vec3_exports.create();
          let fixedUp = vec3_exports.create();
          let fixedForward = vec3_exports.create();
          let currentAxis = vec3_exports.create();
          let rotationAxis = vec3_exports.create();
          let rotationMat = mat3_exports.create();
          let rotationQuat = quat_exports.create();
          return function _pp_setAxes(axes, priority, isLocal) {
            let firstAxis = axes[priority[0]];
            let secondAxis = axes[priority[1]];
            let thirdAxis = axes[priority[2]];
            if (firstAxis == null || firstAxis.vec3_length() <= this._pp_epsilon) {
              return;
            }
            let secondAxisValid = false;
            if (secondAxis != null) {
              let angleBetween = vec3_exports.angle(firstAxis, secondAxis);
              if (angleBetween > this._pp_epsilon) {
                secondAxisValid = true;
              }
            }
            let thirdAxisValid = false;
            if (thirdAxis != null) {
              let angleBetween = vec3_exports.angle(firstAxis, thirdAxis);
              if (angleBetween > this._pp_epsilon) {
                thirdAxisValid = true;
              }
            }
            if (secondAxisValid || thirdAxisValid) {
              let crossAxis = null;
              let secondAxisIndex = null;
              let thirdAxisIndex = null;
              if (secondAxisValid) {
                crossAxis = secondAxis;
                secondAxisIndex = 1;
                thirdAxisIndex = 2;
              } else {
                crossAxis = thirdAxis;
                secondAxisIndex = 2;
                thirdAxisIndex = 1;
              }
              let fixSignMap = fixedAxesFixSignMap[priority[0]];
              vec3_exports.cross(fixedAxes[thirdAxisIndex], firstAxis, crossAxis);
              vec3_exports.scale(fixedAxes[thirdAxisIndex], fixedAxes[thirdAxisIndex], fixSignMap[priority[thirdAxisIndex]]);
              vec3_exports.cross(fixedAxes[secondAxisIndex], firstAxis, fixedAxes[thirdAxisIndex]);
              vec3_exports.scale(fixedAxes[secondAxisIndex], fixedAxes[secondAxisIndex], fixSignMap[priority[secondAxisIndex]]);
              vec3_exports.cross(fixedAxes[0], fixedAxes[1], fixedAxes[2]);
              vec3_exports.scale(fixedAxes[0], fixedAxes[0], fixSignMap[priority[0]]);
              vec3_exports.normalize(fixedLeft, fixedAxes[priority.pp_findIndexEqual(0)]);
              vec3_exports.normalize(fixedUp, fixedAxes[priority.pp_findIndexEqual(1)]);
              vec3_exports.normalize(fixedForward, fixedAxes[priority.pp_findIndexEqual(2)]);
              mat3_exports.set(
                rotationMat,
                fixedLeft[0],
                fixedLeft[1],
                fixedLeft[2],
                fixedUp[0],
                fixedUp[1],
                fixedUp[2],
                fixedForward[0],
                fixedForward[1],
                fixedForward[2]
              );
              quat_exports.fromMat3(rotationQuat, rotationMat);
              quat_exports.normalize(rotationQuat, rotationQuat);
              if (isLocal) {
                this.pp_setRotationLocalQuat(rotationQuat);
              } else {
                this.pp_setRotationWorldQuat(rotationQuat);
              }
            } else {
              if (priority[0] == 0) {
                if (isLocal) {
                  this.pp_getLeftLocal(currentAxis);
                } else {
                  this.pp_getLeftWorld(currentAxis);
                }
              } else if (priority[0] == 1) {
                if (isLocal) {
                  this.pp_getUpLocal(currentAxis);
                } else {
                  this.pp_getUpWorld(currentAxis);
                }
              } else {
                if (isLocal) {
                  this.pp_getForwardLocal(currentAxis);
                } else {
                  this.pp_getForwardWorld(currentAxis);
                }
              }
              let angle3 = vec3_exports.angle(firstAxis, currentAxis);
              if (angle3 != 0) {
                vec3_exports.cross(rotationAxis, currentAxis, firstAxis);
                vec3_exports.normalize(rotationAxis, rotationAxis);
                quat_exports.setAxisAngle(rotationQuat, rotationAxis, angle3);
                if (isLocal) {
                  this.pp_rotateLocalQuat(rotationQuat);
                } else {
                  this.pp_rotateWorldQuat(rotationQuat);
                }
              }
            }
          };
        }();
        for (let key in WL.Object.prototype) {
          let prefixes = ["pp_", "_pp_"];
          let found = false;
          for (let prefix of prefixes) {
            if (key.startsWith(prefix)) {
              found = true;
              break;
            }
          }
          if (found) {
            Object.defineProperty(WL.Object.prototype, key, { enumerable: false });
          }
        }
      }
    }
  });

  // js/pp/plugin/extensions/math_extension.js
  var require_math_extension = __commonJS({
    "js/pp/plugin/extensions/math_extension.js"() {
      Math.PP_EPSILON_NUMBER = 1e-5;
      Math.PP_EPSILON_DEGREES = 1e-4;
      Math.pp_clamp = function(value, start, end) {
        let fixedStart = start != null ? start : -Number.MAX_VALUE;
        let fixedEnd = end != null ? end : Number.MAX_VALUE;
        let min4 = Math.min(fixedStart, fixedEnd);
        let max4 = Math.max(fixedStart, fixedEnd);
        return Math.min(Math.max(value, min4), max4);
      };
      Math.pp_sign = function(value, zeroSign = 1) {
        let sign = Math.sign(value);
        if (sign == 0) {
          sign = Math.sign(zeroSign);
        }
        return sign;
      };
      Math.pp_toDegrees = function(angle3) {
        return angle3 * (180 / Math.PI);
      };
      Math.pp_toRadians = function(angle3) {
        return angle3 * (Math.PI / 180);
      };
      Math.pp_roundDecimal = function(number, decimalPlaces) {
        let factor = Math.pow(10, decimalPlaces);
        number = Math.round(number * factor) / factor;
        return number;
      };
      Math.pp_mapToRange = function(value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd) {
        if (originRangeStart == originRangeEnd) {
          return newRangeStart;
        }
        let clampedValue = Math.pp_clamp(value, originRangeStart, originRangeEnd);
        if (clampedValue == originRangeStart) {
          return newRangeStart;
        } else if (clampedValue == originRangeEnd) {
          return newRangeEnd;
        }
        let newValue = newRangeStart + (newRangeEnd - newRangeStart) / (originRangeEnd - originRangeStart) * (clampedValue - originRangeStart);
        let clampedNewValue = Math.pp_clamp(newValue, newRangeStart, newRangeEnd);
        return clampedNewValue;
      };
      Math.pp_random = function(start = 0, end = 1) {
        return Math.random() * (end - start) + start;
      };
      Math.pp_randomInt = function(start, end) {
        let min4 = Math.min(start, end);
        let max4 = Math.max(start, end);
        return Math.floor(Math.random() * (max4 - min4 + 1) + min4);
      };
      Math.pp_randomBool = function() {
        return Math.pp_randomInt(0, 1) == 0;
      };
      Math.pp_randomSign = function() {
        return Math.random() < 0.5 ? 1 : -1;
      };
      Math.pp_randomPick = function(...args) {
        let random5 = null;
        if (args.length > 0) {
          if (args.length == 1 && args[0].length != null) {
            if (args[0].length > 0) {
              let randomIndex = Math.pp_randomInt(0, args[0].length - 1);
              random5 = args[0][randomIndex];
            }
          } else {
            let randomIndex = Math.pp_randomInt(0, args.length - 1);
            random5 = args[randomIndex];
          }
        }
        return random5;
      };
      Math.pp_lerp = function(from, to, interpolationValue) {
        if (interpolationValue <= 0) {
          return from;
        } else if (interpolationValue >= 1) {
          return to;
        }
        return interpolationValue * (to - from) + from;
      };
      PP.EasingFunction = {
        linear: (t) => t,
        easeIn: (t) => t * t * t,
        easeOut: (t) => (t - 1) * (t - 1) * (t - 1) + 1,
        easeInOut: (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
      };
      Math.pp_interpolate = function(from, to, interpolationValue, easingFunction = PP.EasingFunction.linear) {
        let lerpValue = easingFunction(interpolationValue);
        return Math.pp_lerp(from, to, lerpValue);
      };
      Math.pp_angleDistance = function(from, to) {
        return Math.pp_angleDistanceDegrees(from, to);
      };
      Math.pp_angleDistanceDegrees = function(from, to) {
        return Math.abs(Math.pp_angleDistanceSignedDegrees(from, to));
      };
      Math.pp_angleDistanceRadians = function(from, to) {
        return Math.abs(Math.pp_angleDistanceSignedRadians(from, to));
      };
      Math.pp_angleDistanceSigned = function(from, to) {
        return Math.pp_angleDistanceSignedDegrees(from, to);
      };
      Math.pp_angleDistanceSignedDegrees = function(from, to) {
        let clampedFrom = Math.pp_angleClampDegrees(from, true);
        let clampedTo = Math.pp_angleClampDegrees(to, true);
        let distance4 = clampedTo - clampedFrom;
        if (clampedTo - clampedFrom > 180) {
          distance4 = clampedTo - clampedFrom - 360;
        } else if (clampedTo - clampedFrom < -180) {
          distance4 = clampedTo - clampedFrom + 360;
        }
        return distance4;
      };
      Math.pp_angleDistanceSignedRadians = function(from, to) {
        return Math.pp_toRadians(Math.pp_angleDistanceSignedDegrees(Math.pp_toDegrees(from), Math.pp_toDegrees(to)));
      };
      Math.pp_angleClamp = function(angle3, usePositiveRange = false) {
        return Math.pp_angleClampDegrees(angle3, usePositiveRange);
      };
      Math.pp_angleClampDegrees = function(angle3, usePositiveRange = false) {
        let clampedAngle = angle3 % 360;
        if (clampedAngle < 0) {
          clampedAngle += 360;
        }
        if (!usePositiveRange) {
          if (clampedAngle > 180) {
            clampedAngle -= 360;
          }
        }
        return clampedAngle;
      };
      Math.pp_angleClampRadians = function(angle3, usePositiveRange = false) {
        return Math.pp_toRadians(Math.pp_angleClampDegrees(Math.pp_toDegrees(angle3), usePositiveRange));
      };
      Math.pp_isInsideAngleRange = function(angle3, start, end, useShortestAngle = false) {
        return Math.pp_isInsideAngleRangeDegrees(angle3, start, end, useShortestAngle);
      };
      Math.pp_isInsideAngleRangeDegrees = function(angle3, start, end, useShortestAngle = false) {
        let isInside = false;
        let anglePositive = Math.pp_angleClampDegrees(angle3, true);
        let startPositive = Math.pp_angleClampDegrees(start, true);
        let endPositive = Math.pp_angleClampDegrees(end, true);
        if (useShortestAngle) {
          if (Math.pp_angleDistanceSignedDegrees(startPositive, endPositive) < 0) {
            let temp = startPositive;
            startPositive = endPositive;
            endPositive = temp;
          }
        }
        if (startPositive < endPositive) {
          isInside = anglePositive >= startPositive && anglePositive <= endPositive;
        } else {
          isInside = anglePositive >= startPositive || anglePositive <= endPositive;
        }
        return isInside;
      };
      Math.pp_isInsideAngleRangeRadians = function(angle3, start, end, useShortestAngle = false) {
        return Math.pp_isInsideAngleRangeDegrees(Math.pp_toDegrees(angle3), Math.pp_toDegrees(start), Math.pp_toDegrees(end), useShortestAngle);
      };
      for (let key in Math) {
        let prefixes = ["pp_", "_pp_"];
        let found = false;
        for (let prefix of prefixes) {
          if (key.startsWith(prefix)) {
            found = true;
            break;
          }
        }
        if (found) {
          Object.defineProperty(Math, key, { enumerable: false });
        }
      }
    }
  });

  // js/pp/plugin/extensions/scene_extension.js
  var require_scene_extension = __commonJS({
    "js/pp/plugin/extensions/scene_extension.js"() {
      if (WL && WL.Scene) {
        WL.Scene.prototype.pp_getRoot = function() {
          return new WL.Object(0);
        };
        WL.Scene.prototype.pp_getObjects = function() {
          return this.pp_getObjectsBreadth();
        };
        WL.Scene.prototype.pp_getObjectsBreadth = function() {
          return this.pp_getRoot().pp_getHierarchyBreadth();
        };
        WL.Scene.prototype.pp_getObjectsDepth = function() {
          return this.pp_getRoot().pp_getHierarchyDepth();
        };
        WL.Scene.prototype.pp_getComponent = function(type, index = 0) {
          return this.pp_getComponentBreadth(type, index);
        };
        WL.Scene.prototype.pp_getComponentBreadth = function(type, index = 0) {
          return this.pp_getRoot().pp_getComponentHierarchyBreadth(type, index);
        };
        WL.Scene.prototype.pp_getComponentDepth = function(type, index = 0) {
          return this.pp_getRoot().pp_getComponentHierarchyDepth(type, index);
        };
        WL.Scene.prototype.pp_getComponents = function(type) {
          return this.pp_getComponentsBreadth(type);
        };
        WL.Scene.prototype.pp_getComponentsBreadth = function(type) {
          return this.pp_getRoot().pp_getComponentsHierarchyBreadth(type);
        };
        WL.Scene.prototype.pp_getComponentsDepth = function(type) {
          return this.pp_getRoot().pp_getComponentsHierarchyDepth(type);
        };
        WL.Scene.prototype.pp_getObjectByName = function(name) {
          return this.pp_getObjectByNameBreadth(name);
        };
        WL.Scene.prototype.pp_getObjectByNameBreadth = function(name) {
          return this.pp_getRoot().pp_getObjectByNameHierarchyBreadth(name);
        };
        WL.Scene.prototype.pp_getObjectByNameDepth = function(name) {
          return this.pp_getRoot().pp_getObjectByNameHierarchyDepth(name);
        };
        WL.Scene.prototype.pp_getObjectsByName = function(name) {
          return this.pp_getObjectsByNameBreadth(name);
        };
        WL.Scene.prototype.pp_getObjectsByNameBreadth = function(name) {
          return this.pp_getRoot().pp_getObjectsByNameHierarchyBreadth(name);
        };
        WL.Scene.prototype.pp_getObjectsByNameDepth = function(name) {
          return this.pp_getRoot().pp_getObjectsByNameHierarchyDepth(name);
        };
        WL.Scene.prototype.pp_toString = function() {
          return this.pp_toStringCompact();
        };
        WL.Scene.prototype.pp_toStringCompact = function() {
          return this.pp_getRoot().pp_toStringCompact();
        };
        WL.Scene.prototype.pp_toStringExtended = function() {
          return this.pp_getRoot().pp_toStringExtended();
        };
        WL.Scene.prototype.pp_getComponentsAmountMap = function(amountMap = /* @__PURE__ */ new Map()) {
          return this.pp_getRoot().pp_getComponentsAmountMapHierarchy(amountMap);
        };
        for (let key in WL.Scene.prototype) {
          let prefixes = ["pp_", "_pp_"];
          let found = false;
          for (let prefix of prefixes) {
            if (key.startsWith(prefix)) {
              found = true;
              break;
            }
          }
          if (found) {
            Object.defineProperty(WL.Scene.prototype, key, { enumerable: false });
          }
        }
      }
    }
  });

  // js/pp/plugin/component_mods/clone_component_mod.js
  var require_clone_component_mod = __commonJS({
    "js/pp/plugin/component_mods/clone_component_mod.js"() {
      if (WL && WL.Object) {
        WL.MeshComponent.prototype.pp_clone = function(targetObject, deepCloneParams = new PP.DeepCloneParams(), customParamsMap = null) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          if (deepCloneParams.isDeepCloneComponentVariable("mesh", "material")) {
            clonedComponent.material = this.material.clone();
          } else {
            clonedComponent.material = this.material;
          }
          if (deepCloneParams.isDeepCloneComponentVariable("mesh", "mesh")) {
            clonedComponent.mesh = PP.MeshUtils.cloneMesh(this.mesh);
          } else {
            clonedComponent.mesh = this.mesh;
          }
          clonedComponent.skin = this.skin;
          return clonedComponent;
        };
        WL.CollisionComponent.prototype.pp_clone = function(targetObject, deepCloneParams = new PP.DeepCloneParams(), customParamsMap = null) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          clonedComponent.collider = this.collider;
          clonedComponent.extents = this.extents.slice(0);
          clonedComponent.group = this.group;
          return clonedComponent;
        };
        WL.TextComponent.prototype.pp_clone = function(targetObject, deepCloneParams = new PP.DeepCloneParams(), customParamsMap = null) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          if (deepCloneParams.isDeepCloneComponent("text")) {
            clonedComponent.text = this.text.slice(0);
          } else {
            clonedComponent.text = this.text;
          }
          if (deepCloneParams.isDeepCloneComponentVariable("text", "material")) {
            clonedComponent.material = this.material.clone();
          } else {
            clonedComponent.material = this.material;
          }
          clonedComponent.alignment = this.alignment;
          clonedComponent.justification = this.justification;
          return clonedComponent;
        };
        WL.PhysXComponent.prototype.pp_clone = function(targetObject, deepCloneParams = new PP.DeepCloneParams(), customParamsMap = null) {
          let clonedComponent = targetObject.pp_addComponent(this.type, {
            "angularDamping": this.angularDamping,
            //"angularVelocity": this.angularVelocity,
            "dynamicFriction": this.dynamicFriction,
            "extents": this.extents,
            "kinematic": this.kinematic,
            "linearDamping": this.linearDamping,
            //"linearVelocity": this.linearVelocity,
            "mass": this.mass,
            "restituition": this.restituition,
            "shape": this.shape,
            "shapeData": this.shapeData,
            "static": this.static,
            "staticFriction": this.staticFriction
          });
          clonedComponent.backupExtents = this.extents.vec3_clone();
          clonedComponent.active = this.active;
          return clonedComponent;
        };
        Object.defineProperty(WL.MeshComponent.prototype, "pp_clone", { enumerable: false });
        Object.defineProperty(WL.CollisionComponent.prototype, "pp_clone", { enumerable: false });
        Object.defineProperty(WL.TextComponent.prototype, "pp_clone", { enumerable: false });
        Object.defineProperty(WL.PhysXComponent.prototype, "pp_clone", { enumerable: false });
      }
    }
  });

  // js/pp/plugin/component_mods/cursor_component_mod.js
  var cursor_component_mod_exports = {};
  var init_cursor_component_mod = __esm({
    "js/pp/plugin/component_mods/cursor_component_mod.js"() {
      init_esm();
      if (_WL && _WL._componentTypes && _WL._componentTypes[_WL._componentTypeIndices["cursor"]]) {
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.init = function() {
          this.session = null;
          this.collisionMask = 1 << this.collisionGroup;
          this.maxDistance = 100;
          this.doubleClickTimer = 0;
          this.tripleClickTimer = 0;
          this.multipleClickObject = null;
          this.multipleClickDelay = 0.3;
          this.visible = false;
          const sceneLoaded = this.onDestroy.bind(this);
          WL.onSceneLoaded.push(sceneLoaded);
          this.onDestroyCallbacks = [() => {
            const index = WL.onSceneLoaded.indexOf(sceneLoaded);
            if (index >= 0)
              WL.onSceneLoaded.splice(index, 1);
          }];
          this.prevHitLocationLocalToTarget = PP.vec3_create();
          this.pointerId = null;
          this.lastClientX = null;
          this.lastClientY = null;
          this.lastWidth = null;
          this.lastHeight = null;
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.start = function() {
          if (this.handedness == 0) {
            const inputComp = this.object.getComponent("input");
            if (!inputComp) {
              console.warn(
                "cursor component on object",
                this.object.name,
                'was configured with handedness "input component", but object has no input component.'
              );
            } else {
              this.handedness = inputComp.handedness;
              this.input = inputComp;
            }
          } else {
            this.handedness = ["left", "right"][this.handedness - 1];
          }
          this.globalTarget = this.object.addComponent("cursor-target");
          this.transformQuat = PP.quat2_create();
          this.rotationQuat = PP.quat_create();
          this.transformMatrix = PP.mat4_create();
          this.origin = new Float32Array(3);
          this.cursorObjScale = new Float32Array(3);
          this.direction = PP.vec3_create();
          this.tempQuat = new Float32Array(4);
          this.setViewComponent(this.object.getComponent("view"));
          this.isHovering = false;
          this.visible = true;
          this.isDown = false;
          this.lastIsDown = false;
          this.isUpWithNoDown = false;
          this.isRealDown = false;
          this.cursorPos = new Float32Array(3);
          this.hoveringObject = null;
          const onXRSessionStart = this.setupVREvents.bind(this);
          WL.onXRSessionStart.push(onXRSessionStart);
          this.onDestroyCallbacks.push(() => {
            const index = WL.onXRSessionStart.indexOf(onXRSessionStart);
            if (index >= 0)
              WL.onXRSessionStart.splice(index, 1);
          });
          this.showRay = true;
          if (this.cursorRayObject) {
            this.cursorRayObject.pp_setActive(true);
            this.showRay = false;
            this.cursorRayOrigin = new Float32Array(3);
            this.cursorRayScale = new Float32Array(3);
            this.cursorRayScale.set(this.cursorRayObject.scalingLocal);
            this._setCursorRayTransform(null);
          }
          this._setCursorVisibility(false);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.setViewComponent = function(viewComponent) {
          this.viewComponent = viewComponent;
          if (this.viewComponent != null) {
            const onClick = this.onClick.bind(this);
            WL.canvas.addEventListener("click", onClick);
            const onPointerDown = this.onPointerDown.bind(this);
            WL.canvas.addEventListener("pointerdown", onPointerDown);
            const onPointerMove = this.onPointerMove.bind(this);
            WL.canvas.addEventListener("pointermove", onPointerMove);
            const onPointerUp = this.onPointerUp.bind(this);
            WL.canvas.addEventListener("pointerup", onPointerUp);
            const onPointerLeave = this.onPointerLeave.bind(this);
            WL.canvas.addEventListener("pointerleave", onPointerLeave);
            this.projectionMatrix = new Float32Array(16);
            mat4_exports.invert(this.projectionMatrix, this.viewComponent.projectionMatrix);
            const onViewportResize = this.onViewportResize.bind(this);
            window.addEventListener("resize", onViewportResize);
            this.onDestroyCallbacks.push(() => {
              WL.canvas.removeEventListener("click", onClick);
              WL.canvas.removeEventListener("pointerdown", onPointerDown);
              WL.canvas.removeEventListener("pointermove", onPointerMove);
              WL.canvas.removeEventListener("pointerup", onPointerUp);
              WL.canvas.removeEventListener("pointerleave", onPointerLeave);
              window.removeEventListener("resize", onViewportResize);
            });
          }
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onViewportResize = function() {
          if (!this.viewComponent)
            return;
          mat4_exports.invert(this.projectionMatrix, this.viewComponent.projectionMatrix);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype._setCursorRayTransform = function(hitPosition) {
          if (!this.cursorRayObject)
            return;
          if (this.cursorRayScalingAxis != 4) {
            this.cursorRayObject.resetScaling();
            if (hitPosition != null) {
              this.cursorRayObject.getTranslationWorld(this.cursorRayOrigin);
              let dist4 = vec3_exports.dist(this.cursorRayOrigin, hitPosition);
              this.cursorRayScale[this.cursorRayScalingAxis] = dist4;
              this.cursorRayObject.scale(this.cursorRayScale);
            }
          }
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype._setCursorVisibility = function(visible) {
          this.visible = visible;
          if (!this.cursorObject)
            return;
          this.cursorObject.pp_setActive(visible);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.update = function(dt) {
          if (this.doubleClickTimer > 0) {
            this.doubleClickTimer -= dt;
          }
          if (this.tripleClickTimer > 0) {
            this.tripleClickTimer -= dt;
          }
          this.doUpdate(false);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.doUpdate = function(doClick) {
          if (this.session) {
            if (this.arTouchDown && this.input && WL.xrSession.inputSources[0].handedness === "none" && WL.xrSession.inputSources[0].gamepad) {
              const p = WL.xrSession.inputSources[0].gamepad.axes;
              this.direction.vec3_set(p[0], -p[1], -1);
              this.updateDirection();
            } else {
              this.object.getTranslationWorld(this.origin);
              this.object.getForward(this.direction);
            }
            const rayHit = this.rayHit = this.rayCastMode == 0 ? WL.scene.rayCast(this.origin, this.direction, this.collisionMask) : WL.physics.rayCast(this.origin, this.direction, this.collisionMask, this.maxDistance);
            if (rayHit.hitCount > 0) {
              this.cursorPos.set(rayHit.locations[0]);
            } else {
              this.cursorPos.fill(0);
            }
            this.hoverBehaviour(rayHit, doClick);
          } else {
            if (this.viewComponent != null && this.lastClientX != null) {
              const rayHit = this.updateMousePos(this.lastClientX, this.lastClientY, this.lastWidth, this.lastHeight);
              this.hoverBehaviour(rayHit, false);
            }
          }
          if (this.cursorObject) {
            if (this.hoveringObject && (this.cursorPos[0] != 0 || this.cursorPos[1] != 0 || this.cursorPos[2] != 0)) {
              this._setCursorVisibility(true);
              this.cursorObject.setTranslationWorld(this.cursorPos);
              this.cursorObject.transformLocal = this.cursorObject.transformLocal.quat2_normalize(this.transformQuat);
              this._setCursorRayTransform(this.cursorPos);
            } else {
              if (this.visible && this.cursorRayObject) {
                this._setCursorRayTransform(null);
              }
              this._setCursorVisibility(false);
            }
          }
          if (this.cursorRayObject) {
            this.cursorRayObject.pp_setActive(true);
          }
          if (this.hoveringObject == null) {
            this.pointerId = null;
          }
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.hoverBehaviour = function(rayHit, doClick, forceUnhover = false) {
          if (!forceUnhover && rayHit.hitCount > 0) {
            let hoveringObjectChanged = false;
            if (!this.hoveringObject || !this.hoveringObject.equals(rayHit.objects[0])) {
              if (this.hoveringObject) {
                let cursorTarget3 = this.hoveringObject.getComponent("cursor-target");
                if (cursorTarget3)
                  cursorTarget3.onUnhover(this.hoveringObject, this);
                this.globalTarget.onUnhover(this.hoveringObject, this);
              }
              hoveringObjectChanged = true;
              this.hoveringObject = rayHit.objects[0];
              if (this.styleCursor)
                document.body.style.cursor = "pointer";
              let cursorTarget2 = this.hoveringObject.getComponent("cursor-target");
              if (cursorTarget2) {
                cursorTarget2.onHover(this.hoveringObject, this);
              }
              this.globalTarget.onHover(this.hoveringObject, this);
              if (!this._isDown() && this.isRealDown) {
                this.isDown = false;
                this.lastIsDown = false;
                this.isUpWithNoDown = false;
                if (cursorTarget2)
                  cursorTarget2.onDownOnHover(this.hoveringObject, this);
                this.globalTarget.onDownOnHover(this.hoveringObject, this);
              }
            }
            let cursorTarget = this.hoveringObject.getComponent("cursor-target");
            if (!hoveringObjectChanged && this._isMoving(rayHit.locations[0])) {
              if (cursorTarget)
                cursorTarget.onMove(this.hoveringObject, this);
              this.globalTarget.onMove(this.hoveringObject, this);
            }
            if (this._isDown()) {
              if (cursorTarget)
                cursorTarget.onDown(this.hoveringObject, this);
              this.globalTarget.onDown(this.hoveringObject, this);
              if (this.tripleClickTimer > 0 && this.multipleClickObject && this.multipleClickObject.equals(this.hoveringObject)) {
                if (cursorTarget)
                  cursorTarget.onTripleClick(this.hoveringObject, this);
                this.globalTarget.onTripleClick(this.hoveringObject, this);
                this.tripleClickTimer = 0;
              } else if (this.doubleClickTimer > 0 && this.multipleClickObject && this.multipleClickObject.equals(this.hoveringObject)) {
                if (cursorTarget)
                  cursorTarget.onDoubleClick(this.hoveringObject, this);
                this.globalTarget.onDoubleClick(this.hoveringObject, this);
                this.tripleClickTimer = this.multipleClickDelay;
                this.doubleClickTimer = 0;
              } else {
                if (cursorTarget)
                  cursorTarget.onClick(this.hoveringObject, this);
                this.globalTarget.onClick(this.hoveringObject, this);
                this.tripleClickTimer = 0;
                this.doubleClickTimer = this.multipleClickDelay;
                this.multipleClickObject = this.hoveringObject;
              }
            } else {
              if (!this.isUpWithNoDown && !hoveringObjectChanged && this._isUp()) {
                if (cursorTarget)
                  cursorTarget.onUp(this.hoveringObject, this);
                this.globalTarget.onUp(this.hoveringObject, this);
              } else if (this.isUpWithNoDown || hoveringObjectChanged && this._isUp()) {
                if (cursorTarget)
                  cursorTarget.onUpWithNoDown(this.hoveringObject, this);
                this.globalTarget.onUpWithNoDown(this.hoveringObject, this);
              }
            }
            this.prevHitLocationLocalToTarget = this.hoveringObject.pp_convertPositionWorldToLocal(rayHit.locations[0], this.prevHitLocationLocalToTarget);
          } else if (this.hoveringObject && (forceUnhover || rayHit.hitCount == 0)) {
            let cursorTarget = this.hoveringObject.getComponent("cursor-target");
            if (cursorTarget)
              cursorTarget.onUnhover(this.hoveringObject, this);
            this.globalTarget.onUnhover(this.hoveringObject, this);
            this.hoveringObject = null;
            if (this.styleCursor)
              document.body.style.cursor = "default";
          }
          if (this.hoveringObject) {
            this.lastIsDown = this.isDown;
          } else {
            this.isDown = false;
            this.lastIsDown = false;
          }
          this.isUpWithNoDown = false;
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.setupVREvents = function(s) {
          this.session = s;
          const onSessionEnd = function(e) {
            this.session = null;
          }.bind(this);
          s.addEventListener("end", onSessionEnd);
          const onSelect = this.onSelect.bind(this);
          s.addEventListener("select", onSelect);
          const onSelectStart = this.onSelectStart.bind(this);
          s.addEventListener("selectstart", onSelectStart);
          const onSelectEnd = this.onSelectEnd.bind(this);
          s.addEventListener("selectend", onSelectEnd);
          this.onDestroyCallbacks.push(() => {
            if (!this.session)
              return;
            s.removeEventListener("end", onSessionEnd);
            s.removeEventListener("select", onSelect);
            s.removeEventListener("selectstart", onSelectStart);
            s.removeEventListener("selectend", onSelectEnd);
          });
          this.onViewportResize();
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onSelect = function(e) {
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onSelectStart = function(e) {
          if (this.active) {
            this.arTouchDown = true;
            if (e.inputSource.handedness == this.handedness) {
              this.isDown = true;
            }
          }
          if (e.inputSource.handedness == this.handedness) {
            this.isRealDown = true;
          }
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onSelectEnd = function(e) {
          if (this.active) {
            this.arTouchDown = false;
            if (e.inputSource.handedness == this.handedness) {
              if (!this.isDown) {
                this.isUpWithNoDown = true;
              }
              this.isDown = false;
            }
          }
          if (e.inputSource.handedness == this.handedness) {
            this.isRealDown = false;
          }
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onPointerMove = function(e) {
          if (this.active) {
            if (this.pointerId != null && this.pointerId != e.pointerId)
              return;
            const bounds = document.body.getBoundingClientRect();
            const rayHit = this.updateMousePos(e.clientX, e.clientY, bounds.width, bounds.height);
            this.hoverBehaviour(rayHit, false);
            if (this.hoveringObject != null) {
              this.pointerId = e.pointerId;
            } else {
              this.pointerId = null;
            }
          }
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onClick = function(e) {
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onPointerDown = function(e) {
          if (this.pointerId != null && this.pointerId != e.pointerId || e.button !== 0)
            return;
          if (this.active) {
            const bounds = document.body.getBoundingClientRect();
            let rayHit = this.updateMousePos(e.clientX, e.clientY, bounds.width, bounds.height);
            this.isDown = true;
            this.isRealDown = true;
            this.hoverBehaviour(rayHit, false);
            if (this.hoveringObject != null) {
              this.pointerId = e.pointerId;
            } else {
              this.pointerId = null;
            }
          } else {
            this.isRealDown = true;
          }
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onPointerUp = function(e) {
          if (this.pointerId != null && this.pointerId != e.pointerId || e.button !== 0)
            return;
          if (this.active) {
            const bounds = document.body.getBoundingClientRect();
            let rayHit = this.updateMousePos(e.clientX, e.clientY, bounds.width, bounds.height);
            if (!this.isDown) {
              this.isUpWithNoDown = true;
            }
            this.isDown = false;
            this.isRealDown = false;
            this.hoverBehaviour(rayHit, false);
            if (this.hoveringObject != null) {
              this.pointerId = e.pointerId;
            } else {
              this.pointerId = null;
            }
          } else {
            this.isRealDown = false;
          }
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onPointerLeave = function(e) {
          if (this.pointerId == null || this.pointerId == e.pointerId) {
            if (this.active) {
              this.hoverBehaviour(null, false, true);
            }
            this.pointerId = null;
            this.lastClientX = null;
            this.lastClientY = null;
            this.lastWidth = null;
            this.lastHeight = null;
          }
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.updateMousePos = function(clientX, clientY, w, h) {
          this.lastClientX = clientX;
          this.lastClientY = clientY;
          this.lastWidth = w;
          this.lastHeight = h;
          const left = clientX / w;
          const top = clientY / h;
          this.direction.vec3_set(left * 2 - 1, -top * 2 + 1, -1);
          return this.updateDirection();
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.updateDirection = function() {
          this.object.getTranslationWorld(this.origin);
          vec3_exports.transformMat4(this.direction, this.direction, this.projectionMatrix);
          vec3_exports.normalize(this.direction, this.direction);
          vec3_exports.transformQuat(this.direction, this.direction, this.object.transformWorld);
          const rayHit = this.rayHit = this.rayCastMode == 0 ? WL.scene.rayCast(this.origin, this.direction, this.collisionMask) : WL.physics.rayCast(this.origin, this.direction, this.collisionMask, this.maxDistance);
          if (rayHit.hitCount > 0) {
            this.cursorPos.set(rayHit.locations[0]);
          } else {
            this.cursorPos.fill(0);
          }
          return rayHit;
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onDeactivate = function() {
          if (this.hoveringObject) {
            const cursorTarget = this.hoveringObject.getComponent("cursor-target");
            if (cursorTarget)
              cursorTarget.onUnhover(this.hoveringObject, this);
            this.globalTarget.onUnhover(this.hoveringObject, this);
          }
          this.hoveringObject = null;
          if (this.styleCursor)
            document.body.style.cursor = "default";
          this.isDown = false;
          this.lastIsDown = false;
          this.isUpWithNoDown = false;
          this._setCursorVisibility(false);
          if (this.cursorRayObject) {
            this.cursorRayObject.pp_setActive(false);
          }
          this.pointerId = null;
          this.lastClientX = null;
          this.lastClientY = null;
          this.lastWidth = null;
          this.lastHeight = null;
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onActivate = function() {
          this.showRay = true;
          this.isDown = false;
          this.lastIsDown = false;
          this.isUpWithNoDown = false;
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype.onDestroy = function() {
          for (const f of this.onDestroyCallbacks)
            f();
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype._isDown = function() {
          return this.isDown !== this.lastIsDown && this.isDown;
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype._isUp = function() {
          return this.isDown !== this.lastIsDown && !this.isDown;
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor"]].prototype._isMoving = function() {
          let hitLocationLocalToTarget = PP.vec3_create();
          return function _isMoving(hitLocation) {
            let isMoving = false;
            hitLocationLocalToTarget = this.hoveringObject.pp_convertPositionWorldToLocal(hitLocation, hitLocationLocalToTarget);
            if (!hitLocationLocalToTarget.vec_equals(this.prevHitLocationLocalToTarget, 1e-4)) {
              isMoving = true;
            }
            return isMoving;
          };
        }();
      } else {
        console.error('Wonderland Engine "cursor" component not found.\n Add the component to your project to avoid any issue with the PP bundle.');
      }
    }
  });

  // js/pp/plugin/component_mods/cursor_target_component_mod.js
  var require_cursor_target_component_mod = __commonJS({
    "js/pp/plugin/component_mods/cursor_target_component_mod.js"() {
      if (_WL && _WL._componentTypes && _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]]) {
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.init = function() {
          this.hoverFunctions = [];
          this.unHoverFunctions = [];
          this.clickFunctions = [];
          this.doubleClickFunctions = [];
          this.tripleClickFunctions = [];
          this.moveFunctions = [];
          this.downFunctions = [];
          this.upFunctions = [];
          this.downOnHoverFunctions = [];
          this.upWithNoDownFunctions = [];
          this.isSurface = false;
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onHover = function(object, cursor) {
          for (let f of this.hoverFunctions)
            f(object, cursor);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onUnhover = function(object, cursor) {
          for (let f of this.unHoverFunctions)
            f(object, cursor);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onClick = function(object, cursor) {
          for (let f of this.clickFunctions)
            f(object, cursor);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onMove = function(object, cursor) {
          for (let f of this.moveFunctions)
            f(object, cursor);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onDown = function(object, cursor) {
          for (let f of this.downFunctions)
            f(object, cursor);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onUp = function(object, cursor) {
          for (let f of this.upFunctions)
            f(object, cursor);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.addHoverFunction = function(f) {
          this._validateCallback(f);
          this.hoverFunctions.push(f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.removeHoverFunction = function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.hoverFunctions, f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.addUnHoverFunction = function(f) {
          this._validateCallback(f);
          this.unHoverFunctions.push(f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.removeUnHoverFunction = function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.unHoverFunctions, f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.addClickFunction = function(f) {
          this._validateCallback(f);
          this.clickFunctions.push(f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.removeClickFunction = function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.clickFunctions, f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.addMoveFunction = function(f) {
          this._validateCallback(f);
          this.moveFunctions.push(f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.removeMoveFunction = function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.moveFunctions, f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.addDownFunction = function(f) {
          this._validateCallback(f);
          this.downFunctions.push(f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.removeDownFunction = function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.downFunctions, f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.addUpFunction = function(f) {
          this._validateCallback(f);
          this.upFunctions.push(f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.removeUpFunction = function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.upFunctions, f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype._removeItemOnce = function(arr, value) {
          var index = arr.indexOf(value);
          if (index > -1)
            arr.splice(index, 1);
          return arr;
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype._validateCallback = function(f) {
          if (typeof f !== "function") {
            throw new TypeError(this.object.name + ".cursor-target: Argument needs to be a function");
          }
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onDoubleClick = function(object, cursor) {
          for (let f of this.doubleClickFunctions)
            f(object, cursor);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.addDoubleClickFunction = function(f) {
          this._validateCallback(f);
          this.doubleClickFunctions.push(f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.removeDoubleClickFunction = function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.doubleClickFunctions, f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onTripleClick = function(object, cursor) {
          for (let f of this.tripleClickFunctions)
            f(object, cursor);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.addTripleClickFunction = function(f) {
          this._validateCallback(f);
          this.tripleClickFunctions.push(f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.removeTripleClickFunction = function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.tripleClickFunctions, f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onDownOnHover = function(object, cursor) {
          for (let f of this.downOnHoverFunctions)
            f(object, cursor);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.addDownOnHoverFunction = function(f) {
          this._validateCallback(f);
          this.downOnHoverFunctions.push(f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.removeDownOnHoverFunction = function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.downOnHoverFunctions, f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onUpWithNoDown = function(object, cursor) {
          for (let f of this.upWithNoDownFunctions)
            f(object, cursor);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.addUpWithNoDownFunction = function(f) {
          this._validateCallback(f);
          this.upWithNoDownFunctions.push(f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.removeUpWithNoDownFunction = function(f) {
          this._validateCallback(f);
          this._removeItemOnce(this.upWithNoDownFunctions, f);
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.start = function() {
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.update = function(dt) {
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onActivate = function() {
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onDeactivate = function() {
        };
        _WL._componentTypes[_WL._componentTypeIndices["cursor-target"]].prototype.onDestroy = function() {
        };
      } else {
        console.error('Wonderland Engine "cursor-target" component not found.\n Add the component to your project to avoid any issue with the PP bundle.');
      }
    }
  });

  // js/pp/plugin/component_mods/mouse_look_component_mod.js
  var require_mouse_look_component_mod = __commonJS({
    "js/pp/plugin/component_mods/mouse_look_component_mod.js"() {
      if (_WL && _WL._componentTypes && _WL._componentTypes[_WL._componentTypeIndices["mouse-look"]]) {
        _WL._componentTypes[_WL._componentTypeIndices["mouse-look"]].prototype.init = function() {
          this.pointerId = null;
          this.prevMoveEvent = null;
          this.resetMovingDelay = 0.15;
          this.resetMovingTimer = new PP.Timer(this.resetMovingDelay, false);
          this.isMoving = false;
          document.body.addEventListener("pointermove", this._onMove.bind(this));
          if (this.requireMouseDown) {
            if (this.mouseButtonIndex == 2) {
              WL.canvas.addEventListener("contextmenu", function(event) {
                event.preventDefault();
              }, false);
            }
            WL.canvas.addEventListener("pointerdown", function(event) {
              if (this.pointerId != null)
                return;
              if (!this.mouseDown) {
                if (event.button == this.mouseButtonIndex) {
                  this.pointerId = event.pointerId;
                  this.mouseDown = true;
                  document.body.style.cursor = "grabbing";
                  if (event.button == 1) {
                    event.preventDefault();
                    return false;
                  }
                }
              }
            }.bind(this));
            document.body.addEventListener("pointerup", function(event) {
              if (event.pointerId != this.pointerId)
                return;
              if (this.mouseDown) {
                if (event.button == this.mouseButtonIndex) {
                  this.mouseDown = false;
                  document.body.style.cursor = "initial";
                }
              }
            }.bind(this));
          }
          document.body.addEventListener("pointerleave", function(event) {
            if (event.pointerId != this.pointerId)
              return;
            this.pointerId = null;
            this.prevMoveEvent = null;
            if (this.mouseDown) {
              this.mouseDown = false;
              document.body.style.cursor = "initial";
            }
          }.bind(this));
        };
        _WL._componentTypes[_WL._componentTypeIndices["mouse-look"]].prototype.update = function(dt) {
          if (this.resetMovingTimer.isRunning()) {
            this.resetMovingTimer.update(dt);
            if (this.resetMovingTimer.isDone()) {
              this.resetMovingTimer.reset();
              this.isMoving = false;
            }
          }
          if (!this.isMoving) {
            if (!this.requireMouseDown || !this.mouseDown) {
              this.pointerId = null;
            }
            this.prevMoveEvent = null;
          }
        };
        _WL._componentTypes[_WL._componentTypeIndices["mouse-look"]].prototype._onMove = function() {
          let viewForward = PP.vec3_create();
          let viewUp = PP.vec3_create();
          let referenceUp = PP.vec3_create();
          let referenceUpNegate = PP.vec3_create();
          let referenceRight = PP.vec3_create();
          let newUp = PP.vec3_create();
          return function(event) {
            if (this.pointerId != null && event.pointerId != this.pointerId)
              return;
            if (this.active && (this.mouseDown || !this.requireMouseDown)) {
              viewForward = this.object.pp_getBackward(viewForward);
              viewUp = this.object.pp_getUp(viewUp);
              referenceUp.vec3_set(0, 1, 0);
              if (this.object.pp_getParent() != null) {
                referenceUp = this.object.pp_getParent().pp_getUp(referenceUp);
              }
              referenceRight = viewForward.vec3_cross(referenceUp, referenceRight);
              let minAngle = 1;
              if (viewForward.vec3_angle(referenceUp) < minAngle) {
                referenceRight = viewUp.vec3_negate(referenceRight).vec3_cross(referenceUp, referenceRight);
              } else if (viewForward.vec3_angle(referenceUp.vec3_negate(referenceUpNegate)) < minAngle) {
                referenceRight = viewUp.vec3_cross(referenceUp, referenceRight);
              } else if (!viewUp.vec3_isConcordant(referenceUp)) {
                referenceRight.vec3_negate(referenceRight);
              }
              referenceRight.vec3_normalize(referenceRight);
              let movementX = event.movementX;
              let movementY = event.movementY;
              if (movementX == null || movementY == null) {
                if (this.prevMoveEvent != null) {
                  movementX = event.pageX - this.prevMoveEvent.pageX;
                  movementY = event.pageY - this.prevMoveEvent.pageY;
                } else {
                  movementX = 0;
                  movementY = 0;
                }
              }
              this.rotationX = -this.sensitity * movementX;
              this.rotationY = -this.sensitity * movementY;
              this.object.pp_rotateAxis(this.rotationY, referenceRight);
              let maxVerticalAngle = 90 - 1e-3;
              newUp = this.object.pp_getUp(newUp);
              let angleWithUp = Math.pp_angleClamp(newUp.vec3_angleSigned(referenceUp, referenceRight));
              if (Math.abs(angleWithUp) > maxVerticalAngle) {
                let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
                this.object.pp_rotateAxis(fixAngle, referenceRight);
              }
              this.object.pp_rotateAxis(this.rotationX, referenceUp);
              this.prevMoveEvent = event;
              this.pointerId = event.pointerId;
              this.resetMovingTimer.start(this.resetMovingDelay);
              this.isMoving = true;
            }
          };
        }();
      } else {
        console.error('Wonderland Engine "mouse-look" component not found.\n Add the component to your project to avoid any issue with the PP bundle.');
      }
    }
  });

  // js/pp/audio/spatial_audio_listener.js
  var spatial_audio_listener_exports = {};
  var import_howler3;
  var init_spatial_audio_listener = __esm({
    "js/pp/audio/spatial_audio_listener.js"() {
      import_howler3 = __toESM(require_howler());
      WL.registerComponent("pp-spatial-audio-listener", {
        _myEnabled: { type: WL.Type.Enum, values: ["always", "vr", "non vr"], default: "always" }
      }, {
        init: function() {
          this._myOrigin = new Float32Array(3);
          this._myForward = new Float32Array(3);
          this._myUp = new Float32Array(3);
        },
        update: function() {
          if (this._myEnabled == 0 || this._myEnabled == 1 && WL.xrSession || this._myEnabled == 2 && !WL.xrSession) {
            this.object.pp_getPosition(this._myOrigin);
            this.object.pp_getForward(this._myForward);
            this.object.pp_getUp(this._myUp);
            import_howler3.Howler.pos(this._myOrigin[0], this._myOrigin[1], this._myOrigin[2]);
            import_howler3.Howler.orientation(
              this._myForward[0],
              this._myForward[1],
              this._myForward[2],
              this._myUp[0],
              this._myUp[1],
              this._myUp[2]
            );
          }
        }
      });
    }
  });

  // node_modules/wasm-feature-detect/dist/esm/index.js
  var init_esm2 = __esm({
    "node_modules/wasm-feature-detect/dist/esm/index.js"() {
    }
  });

  // node_modules/@wonderlandengine/api/wonderland.js
  function allocateTempMemory(size) {
    console.log("Allocating temp mem:", size);
    _tempMemSize = size;
    if (_tempMem)
      _free(_tempMem);
    _tempMem = _malloc(_tempMemSize);
    updateTempMemory();
  }
  function requireTempMem(size) {
    if (_tempMemSize >= size)
      return;
    allocateTempMemory(Math.ceil(size / 1024) * 1024);
  }
  function updateTempMemory() {
    _tempMemFloat = new Float32Array(HEAP8.buffer, _tempMem, _tempMemSize >> 2);
    _tempMemInt = new Int32Array(HEAP8.buffer, _tempMem, _tempMemSize >> 2);
    _tempMemUint32 = new Uint32Array(HEAP8.buffer, _tempMem, _tempMemSize >> 2);
    _tempMemUint16 = new Uint16Array(HEAP8.buffer, _tempMem, _tempMemSize >> 1);
    _tempMemUint8 = new Uint8Array(HEAP8.buffer, _tempMem, _tempMemSize);
  }
  function getTempBufferU16(count) {
    requireTempMem(count * 2);
    return _tempMemUint16;
  }
  function getTempBufferF32(count) {
    requireTempMem(count * 4);
    return _tempMemFloat;
  }
  function isString(value) {
    return value && (typeof value === "string" || value.constructor === String);
  }
  function _wrapObject(objectId) {
    const o = ObjectCache[objectId] || (ObjectCache[objectId] = new $Object(objectId));
    o.objectId = objectId;
    return o;
  }
  function _wrapComponent(type, componentType, componentId) {
    if (componentId < 0)
      return null;
    const c = ComponentCache[componentType] || (ComponentCache[componentType] = []);
    if (c[componentId]) {
      return c[componentId];
    }
    let component;
    if (type == "collision") {
      component = new CollisionComponent(componentType, componentId);
    } else if (type == "text") {
      component = new TextComponent(componentType, componentId);
    } else if (type == "view") {
      component = new ViewComponent(componentType, componentId);
    } else if (type == "mesh") {
      component = new MeshComponent(componentType, componentId);
    } else if (type == "input") {
      component = new InputComponent(componentType, componentId);
    } else if (type == "light") {
      component = new LightComponent(componentType, componentId);
    } else if (type == "animation") {
      component = new AnimationComponent(componentType, componentId);
    } else if (type == "physx") {
      component = new PhysXComponent(componentType, componentId);
    } else {
      const typeIndex = _WL._componentTypeIndices[type];
      const constructor = _WL._componentTypes[typeIndex];
      component = new constructor();
    }
    component._manager = componentType;
    component._id = componentId;
    c[componentId] = component;
    return component;
  }
  var ComponentCache, ObjectCache, EXCLUDED_COMPONENT_PROPERTIES, Type, _componentDefaults, Collider, Alignment, Justification, TextEffect, InputType, LightType, AnimationState, ForceMode, CollisionEventType, Shape, MeshAttribute, MaterialParamType, xrSession, physics, _images, _tempMem, _tempMemSize, _tempMemFloat, _tempMemInt, _tempMemUint32, _tempMemUint16, _tempMemUint8, UP_VECTOR, Component, CollisionComponent, TextComponent, ViewComponent, InputComponent, LightComponent, AnimationComponent, MeshComponent, PhysXComponent, MeshIndexType, Mesh, MeshAttributeAccessor, Material, tempCanvas, Texture, textures, Animation, $Object, Skin;
  var init_wonderland = __esm({
    "node_modules/@wonderlandengine/api/wonderland.js"() {
      ComponentCache = {};
      ObjectCache = [];
      EXCLUDED_COMPONENT_PROPERTIES = ["_id", "_manager", "type", "_type", "active"];
      (function(Type2) {
        Type2[Type2["Bool"] = 2] = "Bool";
        Type2[Type2["Int"] = 4] = "Int";
        Type2[Type2["Float"] = 8] = "Float";
        Type2[Type2["String"] = 16] = "String";
        Type2[Type2["Enum"] = 32] = "Enum";
        Type2[Type2["Object"] = 64] = "Object";
        Type2[Type2["Mesh"] = 128] = "Mesh";
        Type2[Type2["Texture"] = 256] = "Texture";
        Type2[Type2["Material"] = 512] = "Material";
        Type2[Type2["Animation"] = 1024] = "Animation";
        Type2[Type2["Skin"] = 2048] = "Skin";
      })(Type || (Type = {}));
      _componentDefaults = new Array(6);
      _componentDefaults[Type.Bool] = false;
      _componentDefaults[Type.Int] = 0;
      _componentDefaults[Type.Float] = 0;
      _componentDefaults[Type.String] = "";
      _componentDefaults[Type.Enum] = 0;
      _componentDefaults[Type.Object] = null;
      _componentDefaults[Type.Mesh] = null;
      _componentDefaults[Type.Texture] = null;
      _componentDefaults[Type.Material] = null;
      _componentDefaults[Type.Animation] = null;
      _componentDefaults[Type.Skin] = null;
      (function(Collider2) {
        Collider2[Collider2["Sphere"] = 0] = "Sphere";
        Collider2[Collider2["AxisAlignedBox"] = 1] = "AxisAlignedBox";
        Collider2[Collider2["Box"] = 2] = "Box";
      })(Collider || (Collider = {}));
      (function(Alignment2) {
        Alignment2[Alignment2["Left"] = 1] = "Left";
        Alignment2[Alignment2["Center"] = 2] = "Center";
        Alignment2[Alignment2["Right"] = 3] = "Right";
      })(Alignment || (Alignment = {}));
      (function(Justification2) {
        Justification2[Justification2["Line"] = 1] = "Line";
        Justification2[Justification2["Middle"] = 2] = "Middle";
        Justification2[Justification2["Top"] = 3] = "Top";
        Justification2[Justification2["Bottom"] = 4] = "Bottom";
      })(Justification || (Justification = {}));
      (function(TextEffect2) {
        TextEffect2[TextEffect2["None"] = 0] = "None";
        TextEffect2[TextEffect2["Outline"] = 1] = "Outline";
      })(TextEffect || (TextEffect = {}));
      (function(InputType2) {
        InputType2[InputType2["Head"] = 0] = "Head";
        InputType2[InputType2["EyeLeft"] = 1] = "EyeLeft";
        InputType2[InputType2["EyeRight"] = 2] = "EyeRight";
        InputType2[InputType2["ControllerLeft"] = 3] = "ControllerLeft";
        InputType2[InputType2["ControllerRight"] = 4] = "ControllerRight";
        InputType2[InputType2["RayLeft"] = 5] = "RayLeft";
        InputType2[InputType2["RayRight"] = 6] = "RayRight";
      })(InputType || (InputType = {}));
      (function(LightType2) {
        LightType2[LightType2["Point"] = 1] = "Point";
        LightType2[LightType2["Spot"] = 2] = "Spot";
        LightType2[LightType2["Sun"] = 3] = "Sun";
      })(LightType || (LightType = {}));
      (function(AnimationState2) {
        AnimationState2[AnimationState2["Playing"] = 1] = "Playing";
        AnimationState2[AnimationState2["Paused"] = 2] = "Paused";
        AnimationState2[AnimationState2["Stopped"] = 3] = "Stopped";
      })(AnimationState || (AnimationState = {}));
      (function(ForceMode2) {
        ForceMode2[ForceMode2["Force"] = 0] = "Force";
        ForceMode2[ForceMode2["Impulse"] = 1] = "Impulse";
        ForceMode2[ForceMode2["VelocityChange"] = 2] = "VelocityChange";
        ForceMode2[ForceMode2["Acceleration"] = 3] = "Acceleration";
      })(ForceMode || (ForceMode = {}));
      (function(CollisionEventType2) {
        CollisionEventType2[CollisionEventType2["Touch"] = 0] = "Touch";
        CollisionEventType2[CollisionEventType2["TouchLost"] = 1] = "TouchLost";
        CollisionEventType2[CollisionEventType2["TriggerTouch"] = 2] = "TriggerTouch";
        CollisionEventType2[CollisionEventType2["TriggerTouchLost"] = 3] = "TriggerTouchLost";
      })(CollisionEventType || (CollisionEventType = {}));
      (function(Shape2) {
        Shape2[Shape2["None"] = 0] = "None";
        Shape2[Shape2["Sphere"] = 1] = "Sphere";
        Shape2[Shape2["Capsule"] = 2] = "Capsule";
        Shape2[Shape2["Box"] = 3] = "Box";
        Shape2[Shape2["Plane"] = 4] = "Plane";
        Shape2[Shape2["ConvexMesh"] = 5] = "ConvexMesh";
        Shape2[Shape2["TriangleMesh"] = 6] = "TriangleMesh";
      })(Shape || (Shape = {}));
      (function(MeshAttribute2) {
        MeshAttribute2[MeshAttribute2["Position"] = 0] = "Position";
        MeshAttribute2[MeshAttribute2["Tangent"] = 1] = "Tangent";
        MeshAttribute2[MeshAttribute2["Normal"] = 2] = "Normal";
        MeshAttribute2[MeshAttribute2["TextureCoordinate"] = 3] = "TextureCoordinate";
        MeshAttribute2[MeshAttribute2["Color"] = 4] = "Color";
        MeshAttribute2[MeshAttribute2["JointId"] = 5] = "JointId";
        MeshAttribute2[MeshAttribute2["JointWeight"] = 6] = "JointWeight";
        MeshAttribute2[MeshAttribute2["SecondaryJointId"] = 7] = "SecondaryJointId";
        MeshAttribute2[MeshAttribute2["SecondaryJointWeight"] = 8] = "SecondaryJointWeight";
      })(MeshAttribute || (MeshAttribute = {}));
      (function(MaterialParamType2) {
        MaterialParamType2[MaterialParamType2["UnsignedInt"] = 0] = "UnsignedInt";
        MaterialParamType2[MaterialParamType2["Int"] = 1] = "Int";
        MaterialParamType2[MaterialParamType2["Float"] = 2] = "Float";
        MaterialParamType2[MaterialParamType2["Sampler"] = 3] = "Sampler";
        MaterialParamType2[MaterialParamType2["Font"] = 4] = "Font";
      })(MaterialParamType || (MaterialParamType = {}));
      xrSession = null;
      physics = void 0;
      _images = [];
      _tempMem = null;
      _tempMemSize = 0;
      _tempMemFloat = null;
      _tempMemInt = null;
      _tempMemUint32 = null;
      _tempMemUint16 = null;
      _tempMemUint8 = null;
      UP_VECTOR = [0, 1, 0];
      Component = class {
        /**
         * Create a new instance
         *
         * @param managerIndex Index of the manager.
         * @param id WASM component instance index.
         *
         * @hidden
         */
        constructor(managerIndex = -1, id = -1) {
          this._manager = managerIndex;
          this._id = id;
          this._object = null;
          this._type = null;
        }
        /** The name of this component's type */
        get type() {
          return this._type || $Object._typeNameFor(this._manager);
        }
        /** The object this component is attached to. */
        get object() {
          if (!this._object) {
            const objectId = _wl_component_get_object(this._manager, this._id);
            this._object = _wrapObject(objectId);
          }
          return this._object;
        }
        /**
         * Set whether this component is active.
         *
         * Activating/deactivating a component comes at a small cost of reordering
         * components in the respective component manager. This function therefore
         * is not a trivial assignment.
         *
         * Does nothing if the component is already activated/deactivated.
         *
         * @param active New active state.
         */
        set active(active) {
          _wl_component_setActive(this._manager, this._id, active);
        }
        /**
         * Whether this component is active
         */
        get active() {
          return _wl_component_isActive(this._manager, this._id) != 0;
        }
        /**
         * Remove this component from its objects and destroy it.
         *
         * It is best practice to set the component to `null` after,
         * to ensure it does not get used later.
         *
         * ```js
         *    c.destroy();
         *    c = null;
         * ```
         * @since 0.9.0
         */
        destroy() {
          _wl_component_remove(this._manager, this._id);
          this._manager = void 0;
          this._id = void 0;
        }
        /**
         * Checks equality by comparing whether the wrapped native component ids
         * and component manager types are equal.
         *
         * @param otherComponent Component to check equality with.
         * @returns Whether this component equals the given component.
         */
        equals(otherComponent) {
          if (!otherComponent)
            return false;
          return this._manager == otherComponent._manager && this._id == otherComponent._id;
        }
      };
      CollisionComponent = class _CollisionComponent extends Component {
        /** Collision component collider */
        get collider() {
          return _wl_collision_component_get_collider(this._id);
        }
        /**
         * Set collision component collider.
         *
         * @param collider Collider of the collision component.
         */
        set collider(collider) {
          _wl_collision_component_set_collider(this._id, collider);
        }
        /**
         * Collision component extents.
         *
         * If {@link collider} returns {@link Collider.Sphere}, only the first
         * component of the returned vector is used.
         */
        get extents() {
          return new Float32Array(HEAPF32.buffer, _wl_collision_component_get_extents(this._id), 3);
        }
        /**
         * Set collision component extents.
         *
         * If {@link collider} returns {@link Collider.Sphere}, only the first
         * component of the passed vector is used.
         *
         * Example:
         *
         * ```js
         * // Spans 1 unit on the x-axis, 2 on the y-axis, 3 on the z-axis.
         * collision.extent = [1, 2, 3];
         * ```
         *
         * @param extents Extents of the collision component, expects a
         *      3 component array.
         */
        set extents(extents) {
          this.extents.set(extents);
        }
        /**
         * Collision component group.
         *
         * The groups is a bitmask that is compared to other components in {@link CollisionComponent#queryOverlaps}
         * or the group in {@link Scene#rayCast}.
         *
         * Colliders that have no common groups will not overlap with each other. If a collider
         * has none of the groups set for {@link Scene#rayCast}, the ray will not hit it.
         *
         * Each bit represents belonging to a group, see example.
         *
         * ```js
         *    // c belongs to group 2
         *    c.group = (1 << 2);
         *
         *    // c belongs to group 0
         *    c.group = (1 << 0);
         *
         *    // c belongs to group 0 *and* 2
         *    c.group = (1 << 0) | (1 << 2);
         *
         *    (c.group & (1 << 2)) != 0; // true
         *    (c.group & (1 << 7)) != 0; // false
         * ```
         */
        get group() {
          return _wl_collision_component_get_group(this._id);
        }
        /**
         * Set collision component group.
         *
         * @param group Group mask of the collision component.
         */
        set group(group) {
          _wl_collision_component_set_group(this._id, group);
        }
        /**
         * Query overlapping objects.
         *
         * Usage:
         *
         * ```js
         * const collision = object.getComponent('collision');
         * const overlaps = collision.queryOverlaps();
         * for(const otherCollision of overlaps) {
         *     const otherObject = otherCollision.object;
         *     console.log(`Collision with object ${otherObject.objectId}`);
         * }
         * ```
         *
         * @returns Collision components overlapping this collider.
         */
        queryOverlaps() {
          const count = _wl_collision_component_query_overlaps(this._id, _tempMem, _tempMemSize >> 1);
          let overlaps = new Array(count);
          for (let i = 0; i < count; ++i) {
            overlaps[i] = new _CollisionComponent(this._manager, _tempMemUint16[i]);
          }
          return overlaps;
        }
      };
      TextComponent = class extends Component {
        /** Text component alignment. */
        get alignment() {
          return _wl_text_component_get_horizontal_alignment(this._id);
        }
        /**
         * Set text component alignment.
         *
         * @param alignment Alignment for the text component.
         */
        set alignment(alignment) {
          _wl_text_component_set_horizontal_alignment(this._id, alignment);
        }
        /** Text component justification. */
        get justification() {
          return _wl_text_component_get_vertical_alignment(this._id);
        }
        /**
         * Set text component justification.
         *
         * @param justification Justification for the text component.
         */
        set justification(justification) {
          _wl_text_component_set_vertical_alignment(this._id, justification);
        }
        /** Text component character spacing. */
        get characterSpacing() {
          return _wl_text_component_get_character_spacing(this._id);
        }
        /**
         * Set text component character spacing.
         *
         * @param spacing Character spacing for the text component.
         */
        set characterSpacing(spacing) {
          _wl_text_component_set_character_spacing(this._id, spacing);
        }
        /** Text component line spacing. */
        get lineSpacing() {
          return _wl_text_component_get_line_spacing(this._id);
        }
        /**
         * Set text component line spacing
         *
         * @param spacing Line spacing for the text component
         */
        set lineSpacing(spacing) {
          _wl_text_component_set_line_spacing(this._id, spacing);
        }
        /** Text component effect. */
        get effect() {
          return _wl_text_component_get_effect(this._id);
        }
        /**
         * Set text component effect
         *
         * @param effect Effect for the text component
         */
        set effect(effect) {
          _wl_text_component_set_effect(this._id, effect);
        }
        /** Text component text. */
        get text() {
          return UTF8ToString(_wl_text_component_get_text(this._id));
        }
        /**
         * Set text component text.
         *
         * @param text Text of the text component.
         */
        set text(text) {
          const strLen = lengthBytesUTF8(text) + 1;
          const ptr = _malloc(strLen);
          stringToUTF8(text, ptr, strLen);
          _wl_text_component_set_text(this._id, ptr);
          _free(ptr);
        }
        /**
         * Set material to render the text with.
         *
         * @param material New material.
         */
        set material(material) {
          const matIndex = material ? material._index : 0;
          _wl_text_component_set_material(this._id, matIndex);
        }
        /** Material used to render the text. */
        get material() {
          const id = _wl_text_component_get_material(this._id);
          return id > 0 ? new Material(id) : null;
        }
      };
      ViewComponent = class extends Component {
        /** Projection matrix. */
        get projectionMatrix() {
          return new Float32Array(HEAPF32.buffer, _wl_view_component_get_projection_matrix(this._id), 16);
        }
        /** ViewComponent near clipping plane value. */
        get near() {
          return _wl_view_component_get_near(this._id);
        }
        /**
         * Set near clipping plane distance for the view.
         *
         * If an XR session is active, the change will apply in the
         * following frame, otherwise the change is immediate.
         *
         * @param near Near depth value.
         */
        set near(near) {
          _wl_view_component_set_near(this._id, near);
        }
        /** Far clipping plane value. */
        get far() {
          return _wl_view_component_get_far(this._id);
        }
        /**
         * Set far clipping plane distance for the view.
         *
         * If an XR session is active, the change will apply in the
         * following frame, otherwise the change is immediate.
         *
         * @param far Near depth value.
         */
        set far(far) {
          _wl_view_component_set_far(this._id, far);
        }
        /**
         * Get the horizontal field of view for the view, **in degrees**.
         *
         * If an XR session is active, this returns the field of view reported by
         * the device, regardless of the fov that was set.
         */
        get fov() {
          return _wl_view_component_get_fov(this._id);
        }
        /**
         * Set the horizontal field of view for the view, **in degrees**.
         *
         * If an XR session is active, the field of view reported by the device is
         * used and this value is ignored. After the XR session ends, the new value
         * is applied.
         *
         * @param fov Horizontal field of view, **in degrees**.
         */
        set fov(fov) {
          _wl_view_component_set_fov(this._id, fov);
        }
      };
      InputComponent = class extends Component {
        /** Input component type */
        get inputType() {
          return _wl_input_component_get_type(this._id);
        }
        /**
         * Set input component type.
         *
         * @params New input component type.
         */
        set inputType(type) {
          _wl_input_component_set_type(this._id, type);
        }
        /**
         * WebXR Device API input source associated with this input component,
         * if type {@link InputType.ControllerLeft} or {@link InputType.ControllerRight}.
         */
        get xrInputSource() {
          if (xrSession) {
            for (let inputSource of xrSession.inputSources) {
              if (inputSource.handedness == this.handedness) {
                return inputSource;
              }
            }
          }
          return null;
        }
        /**
         * 'left', 'right' or {@link null} depending on the {@link InputComponent#inputType}.
         */
        get handedness() {
          const inputType = this.inputType;
          if (inputType == InputType.ControllerRight || inputType == InputType.RayRight || inputType == InputType.EyeRight)
            return "right";
          if (inputType == InputType.ControllerLeft || inputType == InputType.RayLeft || inputType == InputType.EyeLeft)
            return "left";
          return null;
        }
      };
      LightComponent = class extends Component {
        /** View on the light color */
        get color() {
          return new Float32Array(HEAPF32.buffer, _wl_light_component_get_color(this._id), 4);
        }
        /** Light type. */
        get lightType() {
          return _wl_light_component_get_type(this._id);
        }
        /**
         * Set light type.
         *
         * @param lightType Type of the light component.
         */
        set lightType(t) {
          _wl_light_component_set_type(this._id, t);
        }
      };
      AnimationComponent = class extends Component {
        /**
         * Set animation to play.
         *
         * Make sure to {@link Animation#retarget} the animation to affect the
         * right objects.
         *
         * @param anim Animation to play.
         */
        set animation(anim) {
          _wl_animation_component_set_animation(this._id, anim._index);
        }
        /** Animation set for this component */
        get animation() {
          return new Animation(_wl_animation_component_get_animation(this._id));
        }
        /**
         * Set play count. Set to `0` to loop indefinitely.
         *
         * @param playCount Number of times to repeat the animation.
         */
        set playCount(playCount) {
          _wl_animation_component_set_playCount(this._id, playCount);
        }
        /** Number of times the animation is played. */
        get playCount() {
          return _wl_animation_component_get_playCount(this._id);
        }
        /**
         * Set speed. Set to negative values to run the animation backwards.
         *
         * Setting speed has an immediate effect for the current frame's update
         * and will continue with the speed from the current point in the animation.
         *
         * @param speed New speed at which to play the animation.
         * @since 0.8.10
         */
        set speed(speed) {
          _wl_animation_component_set_speed(this._id, speed);
        }
        /**
         * Speed factor at which the animation is played.
         *
         * @since 0.8.10
         */
        get speed() {
          return _wl_animation_component_get_speed(this._id);
        }
        /** Current playing state of the animation */
        get state() {
          return _wl_animation_component_state(this._id);
        }
        /** Play animation. */
        play() {
          _wl_animation_component_play(this._id);
        }
        /** Stop animation. */
        stop() {
          _wl_animation_component_stop(this._id);
        }
        /** Pause animation. */
        pause() {
          _wl_animation_component_pause(this._id);
        }
      };
      MeshComponent = class extends Component {
        /**
         * Set material to render the mesh with.
         *
         * @param material Material to render the mesh with.
         */
        set material(material) {
          _wl_mesh_component_set_material(this._id, material ? material._index : 0);
        }
        /** Material used to render the mesh. */
        get material() {
          const id = _wl_mesh_component_get_material(this._id);
          return id > 0 ? new Material(id) : null;
        }
        /** Mesh rendered by this component. */
        get mesh() {
          return new Mesh(_wl_mesh_component_get_mesh(this._id));
        }
        /**
         * Set mesh to rendered with this component.
         *
         * @param mesh Mesh rendered by this component.
         */
        set mesh(mesh) {
          _wl_mesh_component_set_mesh(this._id, mesh ? mesh._index : 0);
        }
        /** Skin for this mesh component. */
        get skin() {
          return new Skin(_wl_mesh_component_get_skin(this._id));
        }
        /**
         * Set skin to transform this mesh component.
         *
         * @param {?Skin} skin Skin to use for rendering skinned meshes.
         */
        set skin(skin) {
          _wl_mesh_component_set_skin(this._id, skin._index);
        }
      };
      PhysXComponent = class extends Component {
        /**
         * Set whether this rigid body is static.
         *
         * Setting this property only takes effect once the component
         * switches from inactive to active.
         *
         * @param b Whether the rigid body should be static.
         */
        set static(b) {
          _wl_physx_component_set_static(this._id, b);
        }
        /**
         * Whether this rigid body is static.
         *
         * This property returns whether the rigid body is *effectively*
         * static. If static property was set while the rigid body was
         * active, it will not take effect until the rigid body is set
         * inactive and active again. Until the component is set inactive,
         * this getter will return whether the rigidbody is actually
         * static.
         */
        get static() {
          return !!_wl_physx_component_get_static(this._id);
        }
        /**
         * Set whether this rigid body is kinematic.
         *
         * @param b Whether the rigid body should be kinematic.
         */
        set kinematic(b) {
          _wl_physx_component_set_kinematic(this._id, b);
        }
        /**
         * Whether this rigid body is kinematic.
         */
        get kinematic() {
          return !!_wl_physx_component_get_kinematic(this._id);
        }
        /**
         * Set the shape for collision detection.
         *
         * @param s New shape.
         * @since 0.8.5
         */
        set shape(s) {
          _wl_physx_component_set_shape(this._id, s);
        }
        /** The shape for collision detection. */
        get shape() {
          return _wl_physx_component_get_shape(this._id);
        }
        /**
         * Set additional data for the shape.
         *
         * Retrieved only from {@link PhysXComponent#shapeData}.
         * @since 0.8.10
         */
        set shapeData(d) {
          if (d == null || ![Shape.TriangleMesh, Shape.ConvexMesh].includes(this.shape))
            return;
          _wl_physx_component_set_shape_data(this._id, d.index);
        }
        /**
         * Additional data for the shape.
         *
         * `null` for {@link Shape} values: `None`, `Sphere`, `Capsule`, `Box`, `Plane`.
         * `{index: n}` for `TriangleMesh` and `ConvexHull`.
         *
         * This data is currently only for passing onto or creating other {@link PhysXComponent}.
         * @since 0.8.10
         */
        get shapeData() {
          if (![Shape.TriangleMesh, Shape.ConvexMesh].includes(this.shape))
            return null;
          return { index: _wl_physx_component_get_shape_data(this._id) };
        }
        /**
         * Set the shape extents for collision detection.
         *
         * @param e New extents for the shape.
         * @since 0.8.5
         */
        set extents(e) {
          this.extents.set(e);
        }
        /**
         * The shape extents for collision detection.
         */
        get extents() {
          const ptr = _wl_physx_component_get_extents(this._id);
          return new Float32Array(HEAPF32.buffer, ptr, 3);
        }
        /**
         * Get staticFriction.
         */
        get staticFriction() {
          return _wl_physx_component_get_staticFriction(this._id);
        }
        /**
         * Set staticFriction.
         * @param v New staticFriction.
         */
        set staticFriction(v) {
          _wl_physx_component_set_staticFriction(this._id, v);
        }
        /**
         * Get dynamicFriction.
         */
        get dynamicFriction() {
          return _wl_physx_component_get_dynamicFriction(this._id);
        }
        /**
         * Set dynamicFriction
         * @param v New dynamicDamping.
         */
        set dynamicFriction(v) {
          _wl_physx_component_set_dynamicFriction(this._id, v);
        }
        /**
         * Get bounciness.
         * @since 0.9.0
         */
        get bounciness() {
          return _wl_physx_component_get_bounciness(this._id);
        }
        /**
         * Set bounciness.
         * @param v New bounciness.
         * @since 0.9.0
         */
        set bounciness(v) {
          _wl_physx_component_set_bounciness(this._id, v);
        }
        /**
         * Get linearDamping/
         */
        get linearDamping() {
          return _wl_physx_component_get_linearDamping(this._id);
        }
        /**
         * Set linearDamping.
         * @param v New linearDamping.
         */
        set linearDamping(v) {
          _wl_physx_component_set_linearDamping(this._id, v);
        }
        /** Get angularDamping. */
        get angularDamping() {
          return _wl_physx_component_get_angularDamping(this._id);
        }
        /**
         * Set angularDamping.
         * @param v New angularDamping.
         */
        set angularDamping(v) {
          _wl_physx_component_set_angularDamping(this._id, v);
        }
        /**
         * Set linear velocity.
         *
         * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
         *
         * Has no effect, if the component is not active.
         *
         * @param v New linear velocity.
         */
        set linearVelocity(v) {
          _wl_physx_component_set_linearVelocity(this._id, v[0], v[1], v[2]);
        }
        /** Linear velocity or `[0, 0, 0]` if the component is not active. */
        get linearVelocity() {
          _wl_physx_component_get_linearVelocity(this._id, _tempMem);
          return new Float32Array(HEAPF32.buffer, _tempMem, 3);
        }
        /**
         * Set angular velocity
         *
         * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
         *
         * Has no effect, if the component is not active.
         *
         * @param v New angular velocity
         */
        set angularVelocity(v) {
          _wl_physx_component_set_angularVelocity(this._id, v[0], v[1], v[2]);
        }
        /** Angular velocity or `[0, 0, 0]` if the component is not active. */
        get angularVelocity() {
          _wl_physx_component_get_angularVelocity(this._id, _tempMem);
          return new Float32Array(HEAPF32.buffer, _tempMem, 3);
        }
        /**
         * Set mass.
         *
         * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
         *
         * @param m New mass.
         */
        set mass(m) {
          _wl_physx_component_set_mass(this._id, m);
        }
        /** Mass */
        get mass() {
          return _wl_physx_component_get_mass(this._id);
        }
        /**
         * Set mass space interia tensor.
         *
         * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
         *
         * Has no effect, if the component is not active.
         *
         * @param v New mass space interatia tensor.
         */
        set massSpaceInteriaTensor(v) {
          _wl_physx_component_set_massSpaceInertiaTensor(this._id, v[0], v[1], v[2]);
        }
        /**
         * Apply a force.
         *
         * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
         *
         * Has no effect, if the component is not active.
         *
         * @param f Force vector.
         * @param m Force mode, see {@link ForceMode}, default `Force`.
         * @param localForce Whether the force vector is in local space, default `false`.
         * @param p Position to apply force at, default is center of mass.
         * @param local Whether position is in local space, default `false`.
         */
        addForce(f, m, localForce, p, local) {
          m = m || ForceMode.Force;
          if (!p) {
            _wl_physx_component_addForce(this._id, f[0], f[1], f[2], m, !!localForce);
          } else {
            _wl_physx_component_addForceAt(this._id, f[0], f[1], f[2], m, !!localForce, p[0], p[1], p[2], !!local);
          }
        }
        /**
         * Apply torque.
         *
         * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
         *
         * Has no effect, if the component is not active.
         *
         * @param f Force vector.
         * @param m Force mode, see {@link ForceMode}, default `Force`.
         */
        addTorque(f, m = ForceMode.Force) {
          _wl_physx_component_addTorque(this._id, f[0], f[1], f[2], m);
        }
        /**
         * Add on collision callback.
         *
         * @param callback Function to call when this rigid body (un)collides with any other.
         *
         * ```js
         *  let rigidBody = this.object.getComponent('physx');
         *  rigidBody.onCollision(function(type, other) {
         *      // Ignore uncollides
         *      if(type == CollisionEventType.TouchLost) return;
         *
         *      // Take damage on collision with enemies
         *      if(other.object.name.startsWith('enemy-')) {
         *          this.applyDamage(10);
         *      }
         *  }.bind(this));
         * ```
         *
         * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
         */
        onCollision(callback) {
          return this.onCollisionWith(this, callback);
        }
        /**
         * Add filtered on collision callback.
         *
         * @param otherComp Component for which callbacks will
         *        be triggered. If you pass this component, the method is equivalent to.
         *        {@link PhysXComponent#onCollision}.
         * @param callback Function to call when this rigid body
         *        (un)collides with `otherComp`.
         * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
         */
        onCollisionWith(otherComp, callback) {
          physics._callbacks[this._id] = physics._callbacks[this._id] || [];
          physics._callbacks[this._id].push(callback);
          return _wl_physx_component_addCallback(this._id, otherComp._id || this._id);
        }
        /**
         * Remove a collision callback added with {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
         *
         * @param callbackId Callback id as returned by {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
         * @throws When the callback does not belong to the component.
         * @throws When the callback does not exist.
         */
        removeCollisionCallback(callbackId) {
          const r = _wl_physx_component_removeCallback(this._id, callbackId);
          if (r)
            physics._callbacks[this._id].splice(-r);
        }
      };
      for (const prop of [
        "static",
        "extents",
        "staticFriction",
        "dynamicFriction",
        "bounciness",
        "linearDamping",
        "angularDamping",
        "shape",
        "shapeData",
        "kinematic",
        "linearVelocity",
        "angularVelocity",
        "mass"
      ]) {
        Object.defineProperty(PhysXComponent.prototype, prop, { enumerable: true });
      }
      (function(MeshIndexType2) {
        MeshIndexType2[MeshIndexType2["UnsignedByte"] = 1] = "UnsignedByte";
        MeshIndexType2[MeshIndexType2["UnsignedShort"] = 2] = "UnsignedShort";
        MeshIndexType2[MeshIndexType2["UnsignedInt"] = 4] = "UnsignedInt";
      })(MeshIndexType || (MeshIndexType = {}));
      Mesh = class _Mesh {
        /**
         * Size of a vertex in float elements.
         * @deprecated Replaced with {@link Mesh#attribute} and {@link MeshAttributeAccessor}
         */
        static get VERTEX_FLOAT_SIZE() {
          return 3 + 3 + 2;
        }
        /**
         * Size of a vertex in bytes.
         * @deprecated Replaced with {@link Mesh#attribute} and {@link MeshAttributeAccessor}
         */
        static get VERTEX_SIZE() {
          return this.VERTEX_FLOAT_SIZE * 4;
        }
        /**
         * Position attribute offsets in float elements.
         * @deprecated Replaced with {@link Mesh#attribute} and {@link MeshAttribute#Position}
         */
        static get POS() {
          return { X: 0, Y: 1, Z: 2 };
        }
        /**
         * Texture coordinate attribute offsets in float elements.
         * @deprecated Replaced with {@link Mesh#attribute} and {@link MeshAttribute#TextureCoordinate}
         */
        static get TEXCOORD() {
          return { U: 3, V: 4 };
        }
        /**
         * Normal attribute offsets in float elements.
         * @deprecated Replaced with {@link Mesh#attribute} and {@link MeshAttribute#Normal}
         */
        static get NORMAL() {
          return { X: 5, Y: 6, Z: 7 };
        }
        /**
         * Create a new instance.
         *
         * @param params Either a mesh index to wrap or set of parameters to create a new mesh.
         *    For more information, please have a look at the {@link MeshParameters} interface.
         */
        constructor(params) {
          if (typeof params === "object") {
            if (!params.vertexCount && params.vertexData) {
              params.vertexCount = params.vertexData.length / _Mesh.VERTEX_FLOAT_SIZE;
            }
            if (!params.vertexCount)
              throw new Error("Missing parameter 'vertexCount'");
            let indexData = 0;
            let indexType = 0;
            let indexDataSize = 0;
            if (params.indexData) {
              indexType = params.indexType || MeshIndexType.UnsignedShort;
              indexDataSize = params.indexData.length * indexType;
              indexData = _malloc(indexDataSize);
              switch (indexType) {
                case MeshIndexType.UnsignedByte:
                  HEAPU8.set(params.indexData, indexData);
                  break;
                case MeshIndexType.UnsignedShort:
                  HEAPU16.set(params.indexData, indexData >> 1);
                  break;
                case MeshIndexType.UnsignedInt:
                  HEAPU32.set(params.indexData, indexData >> 2);
                  break;
              }
            }
            const { skinned = false } = params;
            this._index = _wl_mesh_create(indexData, indexDataSize, indexType, params.vertexCount, skinned);
            if (params.vertexData) {
              const positions = this.attribute(MeshAttribute.Position);
              const normals = this.attribute(MeshAttribute.Normal);
              const textureCoordinates = this.attribute(MeshAttribute.TextureCoordinate);
              for (let i = 0; i < params.vertexCount; ++i) {
                const start = i * _Mesh.VERTEX_FLOAT_SIZE;
                positions.set(i, params.vertexData.subarray(start, start + 3));
                textureCoordinates === null || textureCoordinates === void 0 ? void 0 : textureCoordinates.set(i, params.vertexData.subarray(start + 3, start + 5));
                normals === null || normals === void 0 ? void 0 : normals.set(i, params.vertexData.subarray(start + 5, start + 8));
              }
            }
          } else {
            this._index = params;
          }
        }
        /**
         * Vertex data (read-only).
         *
         * @deprecated Replaced with {@link attribute}
         */
        get vertexData() {
          const ptr = _wl_mesh_get_vertexData(this._index, _tempMem);
          return new Float32Array(HEAPF32.buffer, ptr, _Mesh.VERTEX_FLOAT_SIZE * HEAPU32[_tempMem / 4]);
        }
        /** Number of vertices in this mesh. */
        get vertexCount() {
          return _wl_mesh_get_vertexCount(this._index);
        }
        /** Index data (read-only) or {@link null} if the mesh is not indexed. */
        get indexData() {
          const ptr = _wl_mesh_get_indexData(this._index, _tempMem, _tempMem + 4);
          if (ptr === null)
            return null;
          const indexCount = HEAPU32[_tempMem / 4];
          const indexSize = HEAPU32[_tempMem / 4 + 1];
          switch (indexSize) {
            case MeshIndexType.UnsignedByte:
              return new Uint8Array(HEAPU8.buffer, ptr, indexCount);
            case MeshIndexType.UnsignedShort:
              return new Uint16Array(HEAPU16.buffer, ptr, indexCount);
            case MeshIndexType.UnsignedInt:
              return new Uint32Array(HEAPU32.buffer, ptr, indexCount);
          }
          return null;
        }
        /** Updates the bounding sphere to match new vertex positions. */
        update() {
          _wl_mesh_update(this._index);
        }
        /**
         * Mesh bounding sphere.
         *
         * @param out Preallocated array to write into, to avoid garbage,
         *     otherwise will allocate a new {@link Float32Array}.
         *
         * ```js
         *  const sphere = new Float32Array(4);
         *  for(...) {
         *      mesh.getBoundingSphere(sphere);
         *      ...
         *  }
         * ```
         *
         * If the position data is changed, call {@link Mesh#update} to update the
         * bounding sphere.
         *
         * @returns Bounding sphere, 0-2 sphere origin, 3 radius.
         */
        getBoundingSphere(out = new Float32Array(4)) {
          _wl_mesh_get_boundingSphere(this._index, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          out[3] = _tempMemFloat[3];
          return out;
        }
        /**
         * Get an attribute accessor to retrieve or modify data of give attribute.
         *
         * @param attr Attribute to get access to
         * @returns {?MeshAttributeAccessor} attr Attribute to get access to or `null`,
         *      if mesh does not have this attribute.
         *
         * If there are no shaders in the scene that use `TextureCoordinate` for example,
         * no meshes will have the `TextureCoordinate` attribute.
         *
         * For flexible reusable components, take this into account that only `Position`
         * is guaranteed to be present at all time.
         */
        attribute(attr) {
          if (typeof attr != "number")
            throw new TypeError("Expected number, but got " + typeof attr);
          _wl_mesh_get_attribute(this._index, attr, _tempMem);
          if (_tempMemUint32[0] == 255)
            return null;
          const a = new MeshAttributeAccessor(attr);
          a._attribute = _tempMemUint32[0];
          a._offset = _tempMemUint32[1];
          a._stride = _tempMemUint32[2];
          a._formatSize = _tempMemUint32[3];
          a._componentCount = _tempMemUint32[4];
          a.length = this.vertexCount;
          return a;
        }
        /**
         * Destroy and free the meshes memory.
         *
         * It is best practice to set the mesh variable to `null` after calling
         * destroy to prevent accidental use:
         *
         * ```js
         *   mesh.destroy();
         *   mesh = null;
         * ```
         *
         * Accessing the mesh after destruction behaves like accessing an empty
         * mesh.
         *
         * @since 0.9.0
         */
        destroy() {
          _wl_mesh_destroy(this._index);
        }
      };
      MeshAttributeAccessor = class {
        /**
         * Create a new instance.
         *
         * @param type The type of data this accessor is wrapping.
         * @note Do not use this constructor. Instead, please use the {@link Mesh.attribute} method.
         *
         * @hidden
         */
        constructor(type = MeshAttribute.Position) {
          this._attribute = -1;
          this._offset = 0;
          this._stride = 0;
          this._formatSize = 0;
          this._componentCount = 0;
          this.length = 0;
          switch (type) {
            case MeshAttribute.Position:
            case MeshAttribute.Normal:
            case MeshAttribute.TextureCoordinate:
            case MeshAttribute.Tangent:
            case MeshAttribute.Color:
            case MeshAttribute.JointWeight:
            case MeshAttribute.SecondaryJointWeight:
              this._bufferType = Float32Array;
              this._tempBufferGetter = getTempBufferF32;
              break;
            case MeshAttribute.JointId:
            case MeshAttribute.SecondaryJointId:
              this._bufferType = Uint16Array;
              this._tempBufferGetter = getTempBufferU16;
              break;
            default:
              throw new Error(`Invalid attribute accessor type: ${type}`);
          }
        }
        /**
         * Create a new TypedArray to hold this attribute values.
         *
         * This method is useful to create a view to hold the data to
         * pass to {@link MeshAttributeAccessor.get} and {@link MeshAttributeAccessor.set}
         *
         * Example:
         *
         * ```js
         * const vertexCount = 4;
         * const positionAttribute = mesh.attribute(MeshAttributes.Position);
         *
         * // A position has 3 floats per vertex. Thus, positions has length 3 * 4.
         * const positions = positionAttribute.createArray(vertexCount);
         * ```
         *
         * @param count The number of **vertices** expected.
         * @returns A TypedArray with the appropriate format to access the data
         */
        createArray(count = 1) {
          count = count > this.length ? this.length : count;
          return new this._bufferType(count * this._componentCount);
        }
        /**
         * Get attribute element.
         *
         * @param {number} index Index
         * @param out Preallocated array to write into,
         *      to avoid garbage, otherwise will allocate a new TypedArray.
         *
         * `out.length` needs to be a multiple of the attributes component count, see
         * {@link MeshAttribute}. If `out.length` is more than one multiple, it will be
         * filled with the next n attribute elements, which can reduce overhead
         * of this call.
         *
         * @returns The `out` parameter
         */
        get(index, out = this.createArray()) {
          if (out.length % this._componentCount !== 0)
            throw new Error(`out.length, ${out.length} is not a multiple of the attribute vector components, ${this._componentCount}`);
          const dest = this._tempBufferGetter(out.length);
          const bytesPerElt = this._bufferType.BYTES_PER_ELEMENT;
          const bytes = bytesPerElt * out.length;
          const destFormatSize = this._componentCount * bytesPerElt;
          _wl_mesh_get_attribute_values(this._attribute, this._formatSize, this._offset + index * this._stride, this._stride, destFormatSize, dest.byteOffset, bytes);
          for (let i = 0; i < out.length; ++i)
            out[i] = dest[i];
          return out;
        }
        /**
         * Set attribute element.
         *
         * @param i Index
         * @param v Value to set the element to
         *
         * `v.length` needs to be a multiple of the attributes component count, see
         * {@link MeshAttribute}. If `v.length` is more than one multiple, it will be
         * filled with the next n attribute elements, which can reduce overhead
         * of this call.
         *
         * @returns Reference to self (for method chaining)
         */
        set(i, v) {
          if (v.length % this._componentCount !== 0)
            throw new Error(`out.length, ${v.length} is not a multiple of the attribute vector components, ${this._componentCount}`);
          const bytesPerElt = this._bufferType.BYTES_PER_ELEMENT;
          const bytes = bytesPerElt * v.length;
          const srcFormatSize = this._componentCount * bytesPerElt;
          if (v.buffer != HEAPU8.buffer) {
            const dest = this._tempBufferGetter(v.length);
            dest.set(v);
            v = dest;
          }
          _wl_mesh_set_attribute_values(this._attribute, srcFormatSize, v.byteOffset, bytes, this._formatSize, this._offset + i * this._stride, this._stride);
          return this;
        }
      };
      Material = class _Material {
        /**
         * Create a new Material.
         *
         * @note Creating material is expensive. Please use {@link Material#clone} to clone a material.
         * @note Do not use this constructor directly with an index, this is reserved for internal purposes.
         */
        constructor(params) {
          if (typeof params !== "number") {
            if (!(params === null || params === void 0 ? void 0 : params.pipeline))
              throw new Error("Missing parameter 'pipeline'");
            const pipeline = params.pipeline;
            const lengthBytes = lengthBytesUTF8(pipeline) + 1;
            stringToUTF8(pipeline, _tempMem, lengthBytes);
            this._index = _wl_material_create(_tempMem);
            if (this._index < 0)
              throw new Error(`No such pipeline '${pipeline}'`);
          } else {
            this._index = params;
          }
          this._definition = _wl_material_get_definition(this._index);
          if (!_WL._materialDefinitions[this._definition])
            throw new Error(`Material Definition ${this._definition} not found for material with index ${this._index}`);
          return new Proxy(this, {
            get(target, prop) {
              const definition = _WL._materialDefinitions[target._definition];
              const param = definition.get(prop);
              if (!param)
                return target[prop];
              if (_wl_material_get_param_value(target._index, param.index, _tempMem)) {
                const type = param.type;
                switch (type.type) {
                  case MaterialParamType.UnsignedInt:
                    return type.componentCount == 1 ? _tempMemUint32[0] : new Uint32Array(HEAPU32.buffer, _tempMem, type.componentCount);
                  case MaterialParamType.Int:
                    return type.componentCount == 1 ? _tempMemInt[0] : new Int32Array(HEAP32.buffer, _tempMem, type.componentCount);
                  case MaterialParamType.Float:
                    return type.componentCount == 1 ? _tempMemFloat[0] : new Float32Array(HEAPF32.buffer, _tempMem, type.componentCount);
                  case MaterialParamType.Sampler:
                    return new Texture(_tempMemInt[0]);
                  default:
                    throw new Error(`Invalid type ${type} on parameter ${param.index} for material ${target._index}`);
                }
              }
            },
            set(target, prop, value) {
              const definition = _WL._materialDefinitions[target._definition];
              const param = definition.get(prop);
              if (!param) {
                target[prop] = value;
                return true;
              }
              const type = param.type;
              switch (type.type) {
                case MaterialParamType.UnsignedInt:
                case MaterialParamType.Int:
                case MaterialParamType.Sampler:
                  const v = value instanceof Texture ? value.id : value;
                  _wl_material_set_param_value_uint(target._index, param.index, v);
                  break;
                case MaterialParamType.Float:
                  let count = 1;
                  if (typeof value === "number") {
                    _tempMemFloat[0] = value;
                  } else {
                    count = value.length;
                    for (let i = 0; i < count; ++i)
                      _tempMemFloat[i] = value[i];
                  }
                  _wl_material_set_param_value_float(target._index, param.index, _tempMem, count);
                  break;
                case MaterialParamType.Font:
                  throw new Error("Setting font properties is currently unsupported.");
              }
              return true;
            }
          });
        }
        /** Name of the shader used by this material. */
        get shader() {
          return UTF8ToString(_wl_material_get_shader(this._index));
        }
        /**
         * Create a copy of the underlying native material.
         *
         * @returns Material clone.
         */
        clone() {
          const id = _wl_material_clone(this._index);
          return id > 0 ? new _Material(id) : null;
        }
        /**
         * Wrap a native material index.
         *
         * @param index The index.
         * @returns Material instance or {@link null} if index <= 0.
         *
         * @deprecated Please use `new Material()` instead.
         */
        static wrap(index) {
          return index > 0 ? new _Material(index) : null;
        }
      };
      tempCanvas = null;
      Texture = class {
        /**
         * @param param HTML media element to create texture from or texture id to wrap.
         */
        constructor(param) {
          this._id = 0;
          this._imageIndex = void 0;
          if (param instanceof HTMLImageElement || param instanceof HTMLVideoElement || param instanceof HTMLCanvasElement) {
            const index = _images.length;
            _images.push(param);
            this._imageIndex = index;
            this._id = _wl_renderer_addImage(index);
          } else {
            this._id = param;
          }
          textures[this._id] = this;
        }
        /** Whether this texture is valid. */
        get valid() {
          return this._id >= 0;
        }
        /** Index in this manager. */
        get id() {
          return this._id;
        }
        /** Update the texture to match the HTML element (e.g. reflect the current frame of a video). */
        update() {
          if (!this.valid)
            return;
          _wl_renderer_updateImage(this._id, this._imageIndex);
        }
        /** Width of the texture. */
        get width() {
          return _wl_texture_width(this._id);
        }
        /** Height of the texture. */
        get height() {
          return _wl_texture_height(this._id);
        }
        /**
         * Update a subrange on the texture to match the HTML element (e.g. reflect the current frame of a video).
         *
         * Usage:
         *
         * ```js
         * // Copies rectangle of pixel starting from (10, 20)
         * texture.updateSubImage(10, 20, 600, 400);
         * ```
         *
         * @param x x offset
         * @param y y offset
         * @param w width
         * @param h height
         */
        updateSubImage(x, y, w, h) {
          var _a;
          if (!this.valid)
            return;
          if (!tempCanvas)
            tempCanvas = document.createElement("canvas");
          const img = _images[this._imageIndex];
          if (!img)
            return;
          tempCanvas.width = w;
          tempCanvas.height = h;
          (_a = tempCanvas.getContext("2d")) === null || _a === void 0 ? void 0 : _a.drawImage(img, x, y, w, h, 0, 0, w, h);
          _images[this._imageIndex] = tempCanvas;
          try {
            _wl_renderer_updateImage(this._id, this._imageIndex, x, (img.videoHeight || img.height) - y - h);
          } finally {
            _images[this._imageIndex] = img;
          }
        }
        /**
         * Destroy and free the texture's texture altas space and memory.
         *
         * It is best practice to set the texture variable to `null` after calling
         * destroy to prevent accidental use of the invalid texture:
         *
         * ```js
         *   texture.destroy();
         *   texture = null;
         * ```
         *
         * @since 0.9.0
         */
        destroy() {
          _wl_texture_destroy(this._id);
          if (this._imageIndex) {
            _images[this._imageIndex] = null;
            this._imageIndex = void 0;
          }
        }
      };
      textures = {
        /**
         * Load an image from URL as {@link Texture}
         * @param {string} filename URL to load from
         * @param {string} crossOrigin Cross origin flag for the {@link Image} object
         * @returns {Promise<Texture>} Loaded texture
         */
        load: function(filename, crossOrigin) {
          let image = new Image();
          if (crossOrigin !== void 0) {
            image.crossOrigin = crossOrigin;
          }
          image.src = filename;
          return new Promise((resolve, reject) => {
            image.onload = function() {
              let texture = new Texture(image);
              if (!texture.valid) {
                reject("Failed to add image " + image.src + " to texture atlas. Probably incompatible format.");
              }
              resolve(texture);
            };
          });
        }
      };
      Animation = class _Animation {
        /**
         * @param index Index in the manager
         */
        constructor(index) {
          this._index = index;
        }
        /** Duration of this animation. */
        get duration() {
          return _wl_animation_get_duration(this._index);
        }
        /** Number of tracks in this animation. */
        get trackCount() {
          return _wl_animation_get_trackCount(this._index);
        }
        /**
         * Clone this animation retargeted to a new set of objects.
         *
         * The clone shares most of the data with the original and is therefore
         * light-weight.
         *
         * **Experimental:** This API might change in upcoming versions.
         *
         * If retargetting to {@link Skin}, the join names will be used to determine a mapping
         * from the previous skin to the new skin. The source skin will be retrieved from
         * the first track in the animation that targets a joint.
         *
         * @param newTargets New targets per track. Expected to have
         *      {@link Animation#trackCount} elements or to be a {@link Skin}.
         * @returns The retargeted clone of this animation.
         */
        retarget(newTargets) {
          if (newTargets instanceof Skin) {
            const animId2 = _wl_animation_retargetToSkin(this._index, newTargets._index);
            return new _Animation(animId2);
          }
          if (newTargets.length != this.trackCount) {
            throw Error("Expected " + this.trackCount.toString() + " targets, but got " + newTargets.length.toString());
          }
          const ptr = _malloc(2 * newTargets.length);
          for (let i = 0; i < newTargets.length; ++i) {
            HEAPU16[ptr >> 1 + i] = newTargets[i].objectId;
          }
          const animId = _wl_animation_retarget(this._index, ptr);
          _free(ptr);
          return new _Animation(animId);
        }
      };
      $Object = class _$Object {
        /**
         * @param o Object id to wrap
         */
        constructor(o) {
          this.objectId = o;
        }
        /**
         * Name of the object.
         *
         * Useful for identifying objects during debugging.
         */
        get name() {
          return UTF8ToString(_wl_object_name(this.objectId));
        }
        /**
         * Set the object's name.
         *
         * @param newName The new name to set.
         */
        set name(newName) {
          const lengthBytes = lengthBytesUTF8(newName) + 1;
          const mem = _malloc(lengthBytes);
          stringToUTF8(newName, mem, lengthBytes);
          _wl_object_set_name(this.objectId, mem);
          _free(mem);
        }
        /**
         * Parent of this object or {@link null} if parented to root.
         */
        get parent() {
          const p = _wl_object_parent(this.objectId);
          return p == 0 ? null : _wrapObject(p);
        }
        /**
         * Children of this object.
         */
        get children() {
          const childrenCount = _wl_object_get_children_count(this.objectId);
          if (childrenCount === 0)
            return [];
          requireTempMem(childrenCount * 2);
          _wl_object_get_children(this.objectId, _tempMem, _tempMemSize >> 1);
          const children = new Array(childrenCount);
          for (let i = 0; i < childrenCount; ++i) {
            children[i] = _wrapObject(_tempMemUint16[i]);
          }
          return children;
        }
        /**
         * Reparent object to given object.
         *
         * @note Reparenting is not trivial and might have a noticeable performance impact.
         *
         * @param newParent New parent or {@link null} to parent to root
         */
        set parent(newParent) {
          _wl_object_set_parent(this.objectId, newParent == null ? 0 : newParent.objectId);
        }
        /** Reset local transformation (translation, rotation and scaling) to identity. */
        resetTransform() {
          _wl_object_reset_translation_rotation(this.objectId);
          _wl_object_reset_scaling(this.objectId);
        }
        /** Reset local translation and rotation to identity */
        resetTranslationRotation() {
          _wl_object_reset_translation_rotation(this.objectId);
        }
        /**
         * Reset local rotation, keep translation.
         * @note To reset both rotation and translation, prefer
         *       {@link resetTranslationRotation}.
         */
        resetRotation() {
          _wl_object_reset_rotation(this.objectId);
        }
        /**
         * Reset local translation, keep rotation.
         * @note To reset both rotation and translation, prefer
         *       {@link resetTranslationRotation}.
         */
        resetTranslation() {
          _wl_object_reset_translation(this.objectId);
        }
        /** Reset local scaling to identity (``[1.0, 1.0, 1.0]``). */
        resetScaling() {
          _wl_object_reset_scaling(this.objectId);
        }
        /**
         * Translate object by a vector in the parent's space.
         * @param v Vector to translate by.
         */
        translate(v) {
          _wl_object_translate(this.objectId, v[0], v[1], v[2]);
        }
        /**
         * Translate object by a vector in object space.
         * @param v Vector to translate by.
         */
        translateObject(v) {
          _wl_object_translate_obj(this.objectId, v[0], v[1], v[2]);
        }
        /**
         * Translate object by a vector in world space.
         * @param v Vector to translate by.
         */
        translateWorld(v) {
          _wl_object_translate_world(this.objectId, v[0], v[1], v[2]);
        }
        /**
         * Rotate around given axis by given angle (degrees) in local space.
         *
         * @param a Vector representing the rotation axis.
         * @param d Angle in degrees.
         *
         * @note If the object is translated the rotation will be around
         *     the parent. To rotate around the object origin, use
         *     {@link rotateAxisAngleDegObject}
         *
         * @see {@link rotateAxisAngleRad}
         */
        rotateAxisAngleDeg(a, d) {
          _wl_object_rotate_axis_angle(this.objectId, a[0], a[1], a[2], d);
        }
        /**
         * Rotate around given axis by given angle (radians) in local space.
         *
         * @param {number[]} a Vector representing the rotation axis.
         * @param {number} d Angle in radians.
         *
         * @note If the object is translated the rotation will be around
         *     the parent. To rotate around the object origin, use
         *     {@link rotateAxisAngleDegObject}
         *
         * @see {@link rotateAxisAngleDeg}
         */
        rotateAxisAngleRad(a, d) {
          _wl_object_rotate_axis_angle_rad(this.objectId, a[0], a[1], a[2], d);
        }
        /**
         * Rotate around given axis by given angle (degrees) in object space.
         *
         * @param a Vector representing the rotation axis.
         * @param d Angle in degrees.
         *
         * Equivalent to prepending a rotation quaternion to the object's
         * local transformation.
         *
         * @see {@link rotateAxisAngleRadObject}
         */
        rotateAxisAngleDegObject(a, d) {
          _wl_object_rotate_axis_angle_obj(this.objectId, a[0], a[1], a[2], d);
        }
        /**
         * Rotate around given axis by given angle (radians) in object space
         * Equivalent to prepending a rotation quaternion to the object's
         * local transformation.
         *
         * @param a Vector representing the rotation axis
         * @param d Angle in degrees
         *
         * @see {@link rotateAxisAngleDegObject}
         */
        rotateAxisAngleRadObject(a, d) {
          _wl_object_rotate_axis_angle_rad_obj(this.objectId, a[0], a[1], a[2], d);
        }
        /**
         * Rotate by a quaternion.
         *
         * @param q the Quaternion to rotate by.
         */
        rotate(q) {
          _wl_object_rotate_quat(this.objectId, q[0], q[1], q[2], q[3]);
        }
        /**
         * Rotate by a quaternion in object space.
         *
         * Equivalent to prepending a rotation quaternion to the object's
         * local transformation.
         *
         * @param q the Quaternion to rotate by.
         */
        rotateObject(q) {
          _wl_object_rotate_quat_obj(this.objectId, q[0], q[1], q[2], q[3]);
        }
        /**
         * Scale object by a vector in object space.
         *
         * @param v Vector to scale by.
         */
        scale(v) {
          _wl_object_scale(this.objectId, v[0], v[1], v[2]);
        }
        /** Local / object space transformation. */
        get transformLocal() {
          return new Float32Array(HEAPF32.buffer, _wl_object_trans_local(this.objectId), 8);
        }
        /**
         * Set local transform.
         *
         * @param t Local space transformation.
         *
         * @since 0.8.5
         */
        set transformLocal(t) {
          this.transformLocal.set(t);
          this.setDirty();
        }
        /**
         * Compute local / object space translation from transformation.
         *
         * @param out Destination array/vector, expected to have at least 3 elements.
         * @return The `out` parameter.
         */
        getTranslationLocal(out) {
          _wl_object_get_translation_local(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          return out;
        }
        /**
         * Compute world space translation from transformation.
         *
         * May recompute transformations of the hierarchy of this object,
         * if they were changed by JavaScript components this frame.
         *
         * @param out Destination array/vector, expected to have at least 3 elements.
         * @return The `out` parameter.
         */
        getTranslationWorld(out) {
          _wl_object_get_translation_world(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          return out;
        }
        /**
         * Set local / object space translation.
         *
         * Concatenates a new translation dual quaternion onto the existing rotation.
         *
         * @param v New local translation array/vector, expected to have at least 3 elements.
         */
        setTranslationLocal(v) {
          _wl_object_set_translation_local(this.objectId, v[0], v[1], v[2]);
        }
        /**
         * Set world space translation.
         *
         * Applies the inverse parent transform with a new translation dual quaternion
         * which is concatenated onto the existing rotation.
         *
         * @param v New world translation array/vector, expected to have at least 3 elements.
         */
        setTranslationWorld(v) {
          _wl_object_set_translation_world(this.objectId, v[0], v[1], v[2]);
        }
        /**
         * Global / world space transformation.
         *
         * May recompute transformations of the hierarchy of this object,
         * if they were changed by JavaScript components this frame.
         */
        get transformWorld() {
          return new Float32Array(HEAPF32.buffer, _wl_object_trans_world(this.objectId), 8);
        }
        /**
         * Set world transform.
         *
         * @param t Global / world space transformation.
         *
         * @since 0.8.5
         */
        set transformWorld(t) {
          this.transformWorld.set(t);
          _wl_object_trans_world_to_local(this.objectId);
        }
        /** Local / object space scaling. */
        get scalingLocal() {
          return new Float32Array(HEAPF32.buffer, _wl_object_scaling_local(this.objectId), 3);
        }
        /**
         * Set scaling local.
         *
         * @param s Global / world space transformation.
         *
         * @since 0.8.7
         */
        set scalingLocal(s) {
          this.scalingLocal.set(s);
          this.setDirty();
        }
        /**
         * Global / world space scaling.
         *
         * May recompute transformations of the hierarchy of this object,
         * if they were changed by JavaScript components this frame.
         */
        get scalingWorld() {
          return new Float32Array(HEAPF32.buffer, _wl_object_scaling_world(this.objectId), 3);
        }
        /**
         * Set scaling world.
         *
         * @param t Global / world space transformation.
         *
         * @since 0.8.7
         */
        set scalingWorld(s) {
          this.scalingWorld.set(s);
          _wl_object_scaling_world_to_local(this.objectId);
        }
        /**
         * Local space rotation.
         *
         * @since 0.8.7
         */
        get rotationLocal() {
          return this.transformLocal.subarray(0, 4);
        }
        /**
         * Global / world space rotation
         *
         * @since 0.8.7
         */
        get rotationWorld() {
          return this.transformWorld.subarray(0, 4);
        }
        /**
         * Set rotation local
         *
         * @param r Local space rotation
         *
         * @since 0.8.7
         */
        set rotationLocal(r) {
          _wl_object_set_rotation_local(this.objectId, r[0], r[1], r[2], r[3]);
        }
        /**
         * Set rotation world.
         *
         * @param {number} r Global / world space rotation.
         *
         * @since 0.8.7
         */
        set rotationWorld(r) {
          _wl_object_set_rotation_world(this.objectId, r[0], r[1], r[2], r[3]);
        }
        /**
         * Compute the object's forward facing world space vector.
         *
         * @param out Destination array/vector, expected to have at least 3 elements.
         * @return The `out` parameter.
         */
        getForward(out) {
          out[0] = 0;
          out[1] = 0;
          out[2] = -1;
          this.transformVectorWorld(out);
          return out;
        }
        /**
         * Compute the object's up facing world space vector.
         *
         * @param out Destination array/vector, expected to have at least 3 elements.
         * @return The `out` parameter.
         */
        getUp(out) {
          out[0] = 0;
          out[1] = 1;
          out[2] = 0;
          this.transformVectorWorld(out);
          return out;
        }
        /**
         * Compute the object's right facing world space vector/
         *
         * @param out Destination array/vector, expected to have at least 3 elements.
         * @return The `out` parameter.
         */
        getRight(out) {
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          this.transformVectorWorld(out);
          return out;
        }
        /**
         * Transform a vector by this object's world transform.
         *
         * @param out Out point
         * @param v Point to transform, default `out`
         * @return The `out` parameter.
         *
         * @since 0.8.7
         */
        transformVectorWorld(out, v) {
          v = v || out;
          _tempMemFloat[0] = v[0];
          _tempMemFloat[1] = v[1];
          _tempMemFloat[2] = v[2];
          _wl_object_transformVectorWorld(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          return out;
        }
        /**
         * Transform a vector by this object's local transform
         *
         * @param out Out point
         * @param v Point to transform, default `out`
         * @return The `out` parameter.
         *
         * @since 0.8.7
         */
        transformVectorLocal(out, v) {
          v = v || out;
          _tempMemFloat[0] = v[0];
          _tempMemFloat[1] = v[1];
          _tempMemFloat[2] = v[2];
          _wl_object_transformVectorLocal(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          return out;
        }
        /**
         * Transform a point by this object's world transform.
         *
         * @param out Out point.
         * @param p Point to transform, default `out`.
         * @return The `out` parameter.
         *
         * @since 0.8.7
         */
        transformPointWorld(out, p) {
          p = p || out;
          _tempMemFloat[0] = p[0];
          _tempMemFloat[1] = p[1];
          _tempMemFloat[2] = p[2];
          _wl_object_transformPointWorld(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          return out;
        }
        /**
         * Transform a point by this object's local transform.
         *
         * @param out Out point.
         * @param p Point to transform, default `out`.
         * @return The `out` parameter.
         *
         * @since 0.8.7
         */
        transformPointLocal(out, p) {
          p = p || out;
          _tempMemFloat[0] = p[0];
          _tempMemFloat[1] = p[1];
          _tempMemFloat[2] = p[2];
          _wl_object_transformPointLocal(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          return out;
        }
        /**
         * Transform a vector by this object's inverse world transform.
         *
         * @param {number[]} out Out point.
         * @param {number[]} v Vector to transform, default `out`.
         * @return The `out` parameter.
         *
         * @since 0.8.7
         */
        transformVectorInverseWorld(out, v) {
          v = v || out;
          _tempMemFloat[0] = v[0];
          _tempMemFloat[1] = v[1];
          _tempMemFloat[2] = v[2];
          _wl_object_transformVectorInverseWorld(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          return out;
        }
        /**
         * Transform a point by this object's inverse local transform.
         *
         * @param out Out point
         * @param v Vector to transform, default `out`
         * @return The `out` parameter.
         *
         * @since 0.8.7
         */
        transformVectorInverseLocal(out, v) {
          v = v || out;
          _tempMemFloat[0] = v[0];
          _tempMemFloat[1] = v[1];
          _tempMemFloat[2] = v[2];
          _wl_object_transformVectorInverseLocal(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          return out;
        }
        /**
         * Transform a point by this object's inverse world transform.
         *
         * @param out Out point.
         * @param v Point to transform, default `out`.
         * @return The `out` parameter.
         *
         * @since 0.8.7
         */
        transformPointInverseWorld(out, p) {
          p = p || out;
          _tempMemFloat[0] = p[0];
          _tempMemFloat[1] = p[1];
          _tempMemFloat[2] = p[2];
          _wl_object_transformPointInverseWorld(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          return out;
        }
        /**
         * Transform a point by this object's inverse local transform.
         *
         * @param out Out point.
         * @param p Point to transform, default `out`.
         * @return The `out` parameter.
         *
         * @since 0.8.7
         */
        transformPointInverseLocal(out, p) {
          p = p || out;
          _tempMemFloat.set(p);
          _wl_object_transformPointInverseLocal(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          return out;
        }
        /**
         * Transform an object space dual quaternion into world space.
         *
         * @param out Out transformation.
         * @param q Local space transformation, default `out`.
         * @return The `out` parameter.
         *
         * @since 0.8.7
         */
        toWorldSpaceTransform(out, q) {
          q = q || out;
          _tempMemFloat.set(q);
          _wl_object_toWorldSpaceTransform(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          out[3] = _tempMemFloat[3];
          out[4] = _tempMemFloat[4];
          out[5] = _tempMemFloat[5];
          out[6] = _tempMemFloat[6];
          out[7] = _tempMemFloat[7];
          return out;
        }
        /**
         * Transform a world space dual quaternion into local space
         *
         * @param {number[]} out Out transformation
         * @param {number[]} q World space transformation, default `out`
         * @return The `out` parameter.
         *
         * @since 0.8.7
         */
        toLocalSpaceTransform(out, q) {
          const p = this.parent;
          q = q || out;
          if (!p) {
            if (out !== q) {
              out[0] = q[0];
              out[1] = q[1];
              out[2] = q[2];
              out[3] = q[3];
              out[4] = q[4];
              out[5] = q[5];
              out[6] = q[6];
              out[7] = q[7];
            }
          } else {
            p.toObjectSpaceTransform(q);
          }
          return out;
        }
        /**
         * Transform a world space dual quaternion into object space
         *
         * @param out Out transformation.
         * @param q World space transformation, default `out`
         * @return The `out` parameter.
         *
         * @since 0.8.7
         */
        toObjectSpaceTransform(out, q) {
          q = q || out;
          _tempMemFloat.set(q);
          _wl_object_toObjectSpaceTransform(this.objectId, _tempMem);
          out[0] = _tempMemFloat[0];
          out[1] = _tempMemFloat[1];
          out[2] = _tempMemFloat[2];
          out[3] = _tempMemFloat[3];
          out[4] = _tempMemFloat[4];
          out[5] = _tempMemFloat[5];
          out[6] = _tempMemFloat[6];
          out[7] = _tempMemFloat[7];
          return out;
        }
        /**
         * Turn towards / look at target.
         *
         * @param v Target vector to turn towards.
         * @param up Up vector of this object, default `[0, 1, 0]`.
         */
        lookAt(v, up = UP_VECTOR) {
          _wl_object_lookAt(this.objectId, v[0], v[1], v[2], up[0], up[1], up[2]);
        }
        /** Destroy the object with all of its components and remove it from the scene */
        destroy() {
          _wl_scene_remove_object(this.objectId);
          this.objectId = null;
        }
        /**
         * Mark transformation dirty.
         *
         * Causes an eventual recalculation of {@link transformWorld}, either
         * on next {@link getTranslationWorld}, {@link transformWorld} or
         * {@link scalingWorld} or the beginning of next frame, whichever
         * happens first.
         */
        setDirty() {
          _wl_object_set_dirty(this.objectId);
        }
        /**
         * Disable/enable all components of this object.
         *
         * @param b New state for the components.
         *
         * @since 0.8.5
         */
        set active(b) {
          const comps = this.getComponents();
          for (let c of comps) {
            c.active = b;
          }
        }
        /**
         * Get a component attached to this object.
         *
         * @param typeOrClass Type name. It's also possible to give a class definition.
         *     In this case, the method will use the `class.TypeName` field to find the component.
         * @param index=0 Index for component of given type. This can be used to access specific
         *      components if the object has multiple components of the same type.
         * @returns The component or {@link null} if there is no such component on this object
         */
        getComponent(typeOrClass, index) {
          const type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
          const lengthBytes = lengthBytesUTF8(type) + 1;
          const mem = _malloc(lengthBytes);
          stringToUTF8(type, mem, lengthBytes);
          const componentType = _wl_get_component_manager_index(mem);
          _free(mem);
          if (componentType < 0) {
            const typeIndex = _WL._componentTypeIndices[type];
            const jsIndex = _wl_get_js_component_index(this.objectId, typeIndex, index || 0);
            return jsIndex < 0 ? null : _WL._components[jsIndex];
          }
          const componentId = _wl_get_component_id(this.objectId, componentType, index || 0);
          return _wrapComponent(type, componentType, componentId);
        }
        /**
         * @param typeOrClass Type name, pass a falsey value (`undefined` or {@link null}) to retrieve all.
         *     It's also possible to give a class definition. In this case, the method will use the `class.TypeName` field to
         *     find the components.
         * @returns All components of given type attached to this object.
         *
         * @note As this function is non-trivial, avoid using it in `update()` repeatedly,
         *      but rather store its result in `init()` or `start()`
         * @warning This method will currently return at most 341 components.
         */
        getComponents(typeOrClass) {
          let componentType = null;
          let type = null;
          if (typeOrClass) {
            type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
            componentType = _$Object._typeIndexFor(type);
          }
          const components = [];
          const maxComps = Math.floor(_tempMemSize / 3 * 2);
          const componentsCount = _wl_object_get_components(this.objectId, _tempMem, maxComps);
          const offset = 2 * componentsCount;
          _wl_object_get_component_types(this.objectId, _tempMem + offset, maxComps);
          const jsManagerIndex = _$Object._typeIndexFor("js");
          for (let i = 0; i < componentsCount; ++i) {
            const t = _tempMemUint8[i + offset];
            const componentId = _tempMemUint16[i];
            if (t == jsManagerIndex) {
              const comp = _WL._components[_wl_get_js_component_index_for_id(componentId)];
              if (componentType === null || comp.type == type)
                components.push(comp);
              continue;
            }
            if (componentType === null) {
              const managerName = _$Object._typeNameFor(t);
              components.push(_wrapComponent(managerName, t, componentId));
            } else if (t == componentType) {
              components.push(_wrapComponent(type, componentType, componentId));
            }
          }
          return components;
        }
        /**
         * Add component of given type to the object.
         *
         * You can use this function to clone components, see the example below.
         *
         * ```js
         *  // Clone existing component (since 0.8.10)
         *  let original = this.object.getComponent('mesh');
         *  otherObject.addComponent('mesh', original);
         *  // Create component from parameters
         *  this.object.addComponent('mesh', {
         *      mesh: someMesh,
         *      material: someMaterial,
         *  });
         * ```
         *
         * @param typeOrClass Typename to create a component of. Can be native or
         *     custom JavaScript component type. It's also possible to give a class definition.
         *     In this case, the method will use the `class.TypeName` field.
         * @param params Parameters to initialize properties of the new component,
         *      can be another component to copy properties from.
         *
         * @returns {?(Component|CollisionComponent|TextComponent|ViewComponent|MeshComponent|InputComponent|LightComponent|AnimationComponent|PhysXComponent)} The component or {@link null} if the type was not found
         */
        addComponent(typeOrClass, params) {
          const type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
          const componentType = _$Object._typeIndexFor(type);
          let component = null;
          let componentIndex = null;
          if (componentType < 0) {
            if (!(type in _WL._componentTypeIndices)) {
              throw new TypeError("Unknown component type '" + type + "'");
            }
            const componentId = _wl_object_add_js_component(this.objectId, _WL._componentTypeIndices[type]);
            componentIndex = _wl_get_js_component_index_for_id(componentId);
            component = _WL._components[componentIndex];
          } else {
            const componentId = _wl_object_add_component(this.objectId, componentType);
            component = _wrapComponent(type, componentType, componentId);
          }
          if (params !== void 0) {
            for (const key in params) {
              if (EXCLUDED_COMPONENT_PROPERTIES.includes(key))
                continue;
              component[key] = params[key];
            }
          }
          if (componentType < 0) {
            _wljs_component_init(componentIndex);
          }
          if (!params || !("active" in params && !params.active)) {
            component.active = true;
          }
          return component;
        }
        /**
         * Whether given object's transformation has changed.
         */
        get changed() {
          return !!_wl_object_is_changed(this.objectId);
        }
        /**
         * Checks equality by comparing whether the wrapped native component ids
         * and component manager types are equal.
         *
         * @param otherObject Object to check equality with.
         * @returns Whether this object equals the given object.
         */
        equals(otherObject) {
          if (!otherObject)
            return false;
          return this.objectId == otherObject.objectId;
        }
        /**
         * Used internally.
         *
         * @param type The type
         * @return The component type
         */
        static _typeIndexFor(type) {
          const lengthBytes = lengthBytesUTF8(type) + 1;
          const mem = _malloc(lengthBytes);
          stringToUTF8(type, mem, lengthBytes);
          const componentType = _wl_get_component_manager_index(mem);
          _free(mem);
          return componentType;
        }
        /**
         * Used internally.
         *
         * @param typeIndex The type index
         * @return The name as a string
         */
        static _typeNameFor(typeIndex) {
          return UTF8ToString(_wl_component_manager_name(typeIndex));
        }
      };
      Skin = class {
        constructor(index) {
          this._index = index;
        }
        /** Amount of joints in this skin. */
        get jointCount() {
          return _wl_skin_get_joint_count(this._index);
        }
        /** Joints object ids for this skin */
        get jointIds() {
          return new Uint16Array(HEAPU16.buffer, _wl_skin_joint_ids(this._index), this.jointCount);
        }
        /**
         * Dual quaternions in a flat array of size 8 times {@link jointCount}.
         *
         * Inverse bind transforms of the skin.
         */
        get inverseBindTransforms() {
          return new Float32Array(HEAPF32.buffer, _wl_skin_inverse_bind_transforms(this._index), 8 * this.jointCount);
        }
        /**
         * Vectors in a flat array of size 3 times {@link jointCount}.
         *
         * Inverse bind scalings of the skin.
         */
        get inverseBindScalings() {
          return new Float32Array(HEAPF32.buffer, _wl_skin_inverse_bind_scalings(this._index), 3 * this.jointCount);
        }
      };
    }
  });

  // node_modules/@wonderlandengine/api/index.js
  var init_api = __esm({
    "node_modules/@wonderlandengine/api/index.js"() {
      init_esm2();
      init_wonderland();
    }
  });

  // js/pp/audio/audio_manager_component.js
  var audio_manager_component_exports = {};
  var init_audio_manager_component = __esm({
    "js/pp/audio/audio_manager_component.js"() {
      init_api();
      PP.myAudioManager = null;
      PP.AudioManagerComponent = class AudioManagerComponent extends Component {
        static TypeName = "pp-audio-manager";
        static Properties = {};
        init() {
          PP.myAudioManager = new PP.AudioManager();
        }
        start() {
        }
        update(dt) {
        }
      };
      WL.registerComponent(PP.AudioManagerComponent);
    }
  });

  // js/pp/audio/audio_manager.js
  var audio_manager_exports = {};
  var import_howler4;
  var init_audio_manager = __esm({
    "js/pp/audio/audio_manager.js"() {
      import_howler4 = __toESM(require_howler());
      PP.AudioManager = class AudioManager {
        constructor() {
          this._myAudioSetupMap = /* @__PURE__ */ new Map();
          this._myAudioPlayersForPreload = [];
        }
        createAudioPlayer(audioSetupID) {
          return new PP.AudioPlayer(this.getAudioSetup(audioSetupID));
        }
        getAudioSetup(id) {
          return this._myAudioSetupMap.get(id);
        }
        addAudioSetup(id, audioSetup, preload = true) {
          this._myAudioSetupMap.set(id, audioSetup);
          if (preload) {
            let preloadAudioSetup = audioSetup.clone();
            preloadAudioSetup.myPreload = true;
            this._myAudioPlayersForPreload.push(new PP.AudioPlayer(preloadAudioSetup));
          }
        }
        removeAudioSetup(id) {
          this._myAudioSetupMap.delete(id);
        }
        setVolume(volume) {
          import_howler4.Howler.volume(volume);
        }
        setMute(mute) {
          import_howler4.Howler.mute(mute);
        }
        stop() {
          import_howler4.Howler.stop();
        }
      };
    }
  });

  // js/pp/audio/audio_player.js
  var audio_player_exports = {};
  var import_howler5;
  var init_audio_player = __esm({
    "js/pp/audio/audio_player.js"() {
      import_howler5 = __toESM(require_howler());
      PP.AudioEvent = {
        END: "end",
        STOP: "stop",
        LOAD: "load",
        LOAD_ERROR: "loaderror",
        PLAY: "play",
        PLAY_ERROR: "playerror",
        PAUSE: "pause",
        MUTE: "mute",
        VOLUME: "volume",
        RATE: "rate",
        SEEK: "seek",
        FADE: "fade",
        UNLOCK: "unlock"
      };
      PP.AudioPlayer = class AudioPlayer {
        constructor(audioSetupOrAudioFilePath, createAudio = true) {
          if (audioSetupOrAudioFilePath == null) {
            this._myAudioSetup = new PP.AudioSetup();
          } else if (typeof audioSetupOrAudioFilePath === "string") {
            this._myAudioSetup = new PP.AudioSetup(audioSetupOrAudioFilePath);
          } else {
            this._myAudioSetup = audioSetupOrAudioFilePath.clone();
          }
          this._myAudio = null;
          if (createAudio) {
            this._myAudio = new import_howler5.Howl({
              src: [this._myAudioSetup.myAudioFilePath],
              loop: this._myAudioSetup.myLoop,
              volume: this._myAudioSetup.myVolume,
              autoplay: this._myAudioSetup.myAutoplay,
              rate: this._myAudioSetup.myRate,
              pool: this._myAudioSetup.myPool,
              refDistance: this._myAudioSetup.myReferenceDistance,
              preload: this._myAudioSetup.myPreload,
              onloaderror: function() {
                Global.sendAnalytics("event", "audio_load_error", {
                  "value": 1
                });
              }
            });
          }
          this._myLastAudioID = null;
          this._myCallbacks = /* @__PURE__ */ new Map();
          for (let eventKey in PP.AudioEvent) {
            this._myCallbacks.set(PP.AudioEvent[eventKey], /* @__PURE__ */ new Map());
          }
          if (createAudio) {
            this._addListeners();
          }
        }
        isValid() {
          return this._myAudio != null;
        }
        play() {
          if (import_howler5.Howler.state != "running" && this._myAudioSetup.myPreventPlayWhenAudioContextNotRunning) {
            return false;
          }
          let audioID = this._myAudio.play();
          if (audioID != null) {
            this._myLastAudioID = audioID;
            this.updatePosition(this._myAudioSetup.myPosition, true);
            this.updatePitch(this._myAudioSetup.myPitch, true);
            this.updateVolume(this._myAudioSetup.myVolume, true);
          }
          return audioID != null;
        }
        stop() {
          this._myAudio.stop();
        }
        pause() {
          this._myAudio.pause();
        }
        resume() {
          this._myAudio.play();
        }
        isPlaying(checkOnlyLast = false) {
          let isPlaying = false;
          if (checkOnlyLast) {
            isPlaying = this._myAudio.playing(this._myLastAudioID);
          } else {
            isPlaying = this._myAudio.playing();
          }
          return isPlaying;
        }
        isLoaded() {
          return this._myAudio.state() == "loaded";
        }
        fade(fromVolume, toVolume, duration, updateOnlyLast = false) {
          this.setVolume(toVolume);
          if (updateOnlyLast) {
            this._myAudio.fade(fromVolume, toVolume, duration * 1e3, this._myLastAudioID);
          } else {
            this._myAudio.fade(fromVolume, toVolume, duration * 1e3);
          }
        }
        updatePosition(position, updateOnlyLast = false) {
          this.setPosition(position);
          if (this._myAudioSetup.mySpatial && position) {
            if (updateOnlyLast) {
              this._myAudio.pos(position[0], position[1], position[2], this._myLastAudioID);
            } else {
              this._myAudio.pos(position[0], position[1], position[2]);
            }
          }
        }
        updatePitch(pitch, updateOnlyLast = false) {
          this.updateRate(pitch, updateOnlyLast);
        }
        updateRate(rate, updateOnlyLast = false) {
          this.setRate(rate);
          if (rate != null) {
            if (updateOnlyLast) {
              this._myAudio.rate(rate, this._myLastAudioID);
            } else {
              this._myAudio.rate(rate);
            }
          }
        }
        updateVolume(volume, updateOnlyLast = false) {
          this.setVolume(volume);
          if (volume != null) {
            if (updateOnlyLast) {
              this._myAudio.volume(volume, this._myLastAudioID);
            } else {
              this._myAudio.volume(volume);
            }
          }
        }
        setSpatial(spatial) {
          this._myAudioSetup.mySpatial = spatial;
        }
        setPosition(position) {
          this._myAudioSetup.myPosition = position;
        }
        setPitch(pitch) {
          this._myAudioSetup.myPitch = pitch;
        }
        setRate(rate) {
          this._myAudioSetup.myRate = rate;
        }
        setVolume(volume) {
          this._myAudioSetup.myVolume = volume;
        }
        getDuration() {
          return this._myAudio.duration();
        }
        getVolume() {
          return this._myAudioSetup.myVolume;
        }
        getPitch() {
          return this._myAudioSetup.myPitch;
        }
        getRate() {
          return this._myAudioSetup.myRate;
        }
        registerAudioEventListener(audioEvent, listenerID, callback) {
          this._myCallbacks.get(audioEvent).set(listenerID, callback);
        }
        unregisterAudioEventListener(audioEvent, listenerID) {
          this._myCallbacks.get(audioEvent).delete(listenerID);
        }
        _addListeners() {
          if (this._myAudio != null) {
            for (let eventKey in PP.AudioEvent) {
              let event = PP.AudioEvent[eventKey];
              this._myAudio.on(event, function(audioID) {
                let callbacks = this._myCallbacks.get(event);
                for (let callback of callbacks.values()) {
                  callback(audioID);
                }
              }.bind(this));
            }
          }
        }
      };
    }
  });

  // js/pp/audio/audio_setup.js
  var require_audio_setup = __commonJS({
    "js/pp/audio/audio_setup.js"() {
      PP.AudioSetup = class AudioSetup {
        constructor(audioFilePath = null) {
          this.myAudioFilePath = audioFilePath ? audioFilePath.slice(0) : null;
          this.myLoop = false;
          this.myAutoplay = false;
          this.myVolume = 1;
          this._myRate = 1;
          this.myPool = 5;
          this.myPreload = true;
          this.myPreventPlayWhenAudioContextNotRunning = false;
          this.myPosition = null;
          this.mySpatial = true;
          this.myReferenceDistance = 1;
        }
        clone() {
          let audioSetup = new PP.AudioSetup();
          audioSetup.myAudioFilePath = this.myAudioFilePath.slice(0);
          audioSetup.myLoop = this.myLoop;
          audioSetup.myAutoplay = this.myAutoplay;
          audioSetup.myVolume = this.myVolume;
          audioSetup.myPitch = this.myPitch;
          audioSetup.myRate = this.myRate;
          audioSetup.myPool = this.myPool;
          audioSetup.myPreload = this.myPreload;
          audioSetup.myPreventPlayWhenAudioContextNotRunning = this.myPreventPlayWhenAudioContextNotRunning;
          if (this.myPosition != null) {
            audioSetup.myPosition = this.myPosition.vec3_clone();
          } else {
            audioSetup.myPosition = null;
          }
          audioSetup.mySpatial = this.mySpatial;
          audioSetup.myReferenceDistance = this.myReferenceDistance;
          return audioSetup;
        }
        get myPitch() {
          return this._myRate;
        }
        get myRate() {
          return this._myRate;
        }
        set myPitch(pitch) {
          this._myRate = pitch;
        }
        set myRate(rate) {
          this._myRate = rate;
        }
      };
    }
  });

  // js/pp/audio/audio_utils.js
  var audio_utils_exports = {};
  var import_howler6;
  var init_audio_utils = __esm({
    "js/pp/audio/audio_utils.js"() {
      import_howler6 = __toESM(require_howler());
      PP.AudioUtils = {
        isAudioPlaybackBlocked: function() {
          let isBlocked = false;
          if (import_howler6.Howler != null && import_howler6.Howler.state != "running") {
            isBlocked = true;
          }
          return isBlocked;
        }
      };
    }
  });

  // js/pp/audio/mute_everything.js
  var mute_everything_exports = {};
  var import_howler7;
  var init_mute_everything = __esm({
    "js/pp/audio/mute_everything.js"() {
      import_howler7 = __toESM(require_howler());
      WL.registerComponent("pp-mute-everything", {}, {
        init: function() {
        },
        start: function() {
          import_howler7.Howler.mute(true);
        },
        update: function(dt) {
        }
      });
    }
  });

  // js/pp/audio/howler/howler_audio_player.js
  var require_howler_audio_player = __commonJS({
    "js/pp/audio/howler/howler_audio_player.js"() {
      PP.HowlerAudioPlayer = class HowlerAudioPlayer extends PP.AudioPlayer {
        constructor(howl, audioSetup = null) {
          super(audioSetup, false);
          this._myAudio = howl;
          if (audioSetup == null) {
            this._myAudioSetup.myAudioFilePath = this._myAudio._src;
            this._myAudioSetup.myLoop = this._myAudio._loop;
            this._myAudioSetup.myAutoplay = this._myAudio._autoplay;
            this._myAudioSetup.myVolume = this._myAudio._volume;
            this._myAudioSetup.myRate = this._myAudio._rate;
            this._myAudioSetup.myPool = this._myAudio._pool;
            this._myAudioSetup.myPreload = this._myAudio._preload;
            this._myAudioSetup.myPosition = this._myAudio._pos != null ? this._myAudio._pos.vec3_clone() : null;
            this._myAudioSetup.mySpatial = this._myAudio._pos != null;
            this._myAudioSetup.myReferenceDistance = this._myAudio._pannerAttr.refDistance;
          } else {
            this._myAudioSetup.myAudioFilePath = this._myAudio._src;
            this._myAudio.loop(this._myAudioSetup.myLoop);
            this._myAudio._autoplay = this._myAudioSetup.myAutoplay;
            this._myAudio.volume(this._myAudioSetup.myVolume);
            this._myAudio.rate(this._myAudioSetup.myRate);
            this._myAudio._pool = this._myAudioSetup.myPool;
            this._myAudio._preload = this._myAudioSetup.myPreload;
            this.updatePosition(this._myAudioSetup.myPosition);
            this._myAudio._pannerAttr.refDistance = this._myAudioSetup.myReferenceDistance;
            if (this._myAudioSetup.myAutoplay) {
              this._myAudio.play();
            }
          }
          this._addListeners();
        }
      };
    }
  });

  // js/pp/cauldron/benchmarks/max_physx.js
  var max_physx_exports = {};
  var init_max_physx = __esm({
    "js/pp/cauldron/benchmarks/max_physx.js"() {
      init_esm();
      WL.registerComponent("pp-benchmark-max-physx", {
        _myStaticDomeSize: { type: WL.Type.Float, default: 40 },
        _myStaticPhysXCount: { type: WL.Type.Int, default: 1e3 },
        _myDynamicDomeSize: { type: WL.Type.Float, default: 80 },
        _myDynamicPhysXCount: { type: WL.Type.Int, default: 250 },
        _myKinematicDomeSize: { type: WL.Type.Float, default: 120 },
        _myKinematicPhysXCount: { type: WL.Type.Int, default: 250 },
        _myRaycastCount: { type: WL.Type.Int, default: 100 },
        _myVisualizeRaycast: { type: WL.Type.Bool, default: false },
        _myVisualizeRaycastDelay: { type: WL.Type.Float, default: 0.5 },
        // you can use this to test with convex mesh, 
        // but u first need to add a physx with a convex mesh to the scene and read the shapeData index on the component to set it as _myShapeIndex
        _myUseConvexMesh: { type: WL.Type.Bool, default: false },
        _myShapeIndex: { type: WL.Type.Int, default: 0 },
        _myShapeScaleMultiplier: { type: WL.Type.Float, default: 1 },
        // used to adjust the scale of the convex mesh if too big or small based on how u imported it
        _myEnableLog: { type: WL.Type.Bool, default: true }
      }, {
        start: function() {
          this._myRootObject = WL.scene.addObject(this.object);
          this._myRaycastSetup = new PP.RaycastSetup();
          this._myRaycastResults = new PP.RaycastResults();
          this._myStaticPhysXObjects = [];
          this._myStaticPhysXComponents = [];
          this._myStaticPhysXCollectors = [];
          this._myDynamicPhysXObjects = [];
          this._myDynamicPhysXComponents = [];
          this._myDynamicPhysXCollectors = [];
          this._myKinematicPhysXObjects = [];
          this._myKinematicPhysXComponents = [];
          this._myKinematicPhysXCollectors = [];
          this._spawnDome(true, false);
          this._spawnDome(false, false);
          this._spawnDome(false, true);
          this._myStartTimer = new PP.Timer(1);
          this._myTimer = new PP.Timer(0);
          this._myDebugTimer = new PP.Timer(this._myVisualizeRaycastDelay);
          this._myEnableLogTimer = new PP.Timer(1);
          this._myFPSHistory = [];
          for (let i = 0; i < 7; i++) {
            this._myFPSHistory.push(0);
          }
          this._myAddVelocityDelay = 10;
          this._myTranslateVec3 = PP.vec3_create();
          this._myRotateVec3 = PP.vec3_create();
        },
        update: function(dt) {
          this._myStartTimer.update(dt);
          if (this._myStartTimer.isDone()) {
            this._myTimer.update(dt);
            this._myDebugTimer.update(dt);
            this._myEnableLogTimer.update(dt);
            if (this._myTimer.isDone()) {
              this._myTimer.start();
              let debugActive = false;
              if (this._myDebugTimer.isDone()) {
                this._myDebugTimer.start();
                debugActive = true;
              }
              debugActive = debugActive && this._myVisualizeRaycast;
              this._raycastTest(debugActive);
            }
            this._myFPSHistory.pop();
            this._myFPSHistory.unshift(Math.round(1 / dt));
            if (this._myEnableLog) {
              if (this._myEnableLogTimer.isDone()) {
                this._myEnableLogTimer.start();
                console.clear();
                console.log("Static PhysX Dome Size:", this._myStaticPhysXObjects.length);
                console.log("Dynamic PhysX Dome Size:", this._myDynamicPhysXObjects.length);
                console.log("Kinematic PhysX Dome Size:", this._myKinematicPhysXObjects.length);
                let staticCollisions = 0;
                for (let collector of this._myStaticPhysXCollectors) {
                  staticCollisions += collector.getCollisions().length;
                }
                let dynamicCollisions = 0;
                for (let collector of this._myDynamicPhysXCollectors) {
                  dynamicCollisions += collector.getCollisions().length;
                }
                let kinematicCollisions = 0;
                for (let collector of this._myKinematicPhysXCollectors) {
                  kinematicCollisions += collector.getCollisions().length;
                }
                let totalCollisions = (staticCollisions + dynamicCollisions + kinematicCollisions) / 2;
                console.log("Current Collisions Count:", totalCollisions);
                console.log("Raycast Count:", this._myRaycastCount);
                console.log("FPS History:");
                let fpsString = "";
                for (let fps of this._myFPSHistory) {
                  fpsString = fpsString.concat(fps, "\n");
                }
                console.log(fpsString);
              }
            }
          }
          if (this._myAddVelocityDelay > 0) {
            this._myAddVelocityDelay--;
            if (this._myAddVelocityDelay == 0) {
              for (let physX of this._myDynamicPhysXComponents) {
                physX.kinematic = false;
                let strength = 50;
                physX.linearVelocity = [Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength)];
                physX.angularVelocity = [Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength)];
              }
            }
          }
          for (let physX of this._myKinematicPhysXObjects) {
            let strength = 5 * dt;
            this._myTranslateVec3.vec3_set(Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength));
            physX.pp_translate(this._myTranslateVec3);
            let rotateStrength = 50 * dt;
            this._myRotateVec3.vec3_set(Math.pp_random(-rotateStrength, rotateStrength), Math.pp_random(-rotateStrength, rotateStrength), Math.pp_random(-rotateStrength, rotateStrength));
            physX.pp_rotate(this._myRotateVec3);
          }
        },
        _raycastTest(debugActive) {
          let raycastCount = this._myRaycastCount;
          let distance4 = 1e4;
          for (let i = 0; i < raycastCount; i++) {
            let origin = [Math.pp_random(1, 2) * Math.pp_randomSign(), Math.pp_random(1, 2) * Math.pp_randomSign(), Math.pp_random(1, 2) * Math.pp_randomSign()];
            let direction = [Math.pp_random(-1, 1), Math.pp_random(-1, 1), Math.pp_random(-1, 1)];
            direction.vec3_normalize(direction);
            this._myRaycastSetup.myOrigin.vec3_copy(origin);
            this._myRaycastSetup.myDirection.vec3_copy(direction);
            this._myRaycastSetup.myDistance = distance4;
            this._myRaycastSetup.myBlockLayerFlags.setMask(255);
            let raycastResults = PP.PhysicsUtils.raycast(this._myRaycastSetup, this._myRaycastResults);
            if (debugActive) {
              PP.myDebugVisualManager.drawRaycast(this._myDebugTimer.getDuration(), raycastResults, true, 5, 0.015);
            }
          }
        },
        _spawnDome(isStatic, isDynamic) {
          let maxCount = this._myStaticPhysXCount;
          let physXList = this._myStaticPhysXObjects;
          let cloves = Math.ceil(Math.sqrt(this._myStaticPhysXCount));
          if (!isStatic) {
            if (isDynamic) {
              cloves = Math.ceil(Math.sqrt(this._myDynamicPhysXCount));
              maxCount = this._myDynamicPhysXCount;
              physXList = this._myDynamicPhysXObjects;
            } else {
              cloves = Math.ceil(Math.sqrt(this._myKinematicPhysXCount));
              maxCount = this._myKinematicPhysXCount;
              physXList = this._myKinematicPhysXObjects;
            }
          }
          let angleForClove = Math.PI * 2 / cloves;
          let minDistance = Math.max(0, this._myStaticDomeSize - 20);
          let maxDistance = this._myStaticDomeSize + 20;
          if (!isStatic) {
            if (isDynamic) {
              minDistance = Math.max(0, this._myDynamicDomeSize - 20);
              maxDistance = this._myDynamicDomeSize + 20;
            } else {
              minDistance = Math.max(0, this._myKinematicDomeSize - 20);
              maxDistance = this._myKinematicDomeSize + 20;
            }
          }
          let minExtraRotation = 0;
          let maxExtraRotation = Math.pp_toRadians(10);
          let upDirection = PP.vec3_create(0, 1, 0);
          let horizontalDirection = PP.vec3_create(0, 0, -1);
          for (let i = 0; i < cloves / 2; i++) {
            let verticalDirection = PP.vec3_create(0, 1, 0);
            let rotationAxis = PP.vec3_create();
            vec3_exports.cross(rotationAxis, horizontalDirection, verticalDirection);
            vec3_exports.normalize(rotationAxis, rotationAxis);
            for (let j = 0; j < cloves; j++) {
              if (physXList.length < maxCount) {
                let distance4 = Math.random() * (maxDistance - minDistance) + minDistance;
                let extraAxisRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
                let extraUpRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
                let physXDirection = verticalDirection.slice(0);
                physXDirection.vec3_rotateAxisRadians(extraAxisRotation, rotationAxis, physXDirection);
                physXDirection.vec3_rotateAxisRadians(extraUpRotation, upDirection, physXDirection);
                vec3_exports.scale(physXDirection, physXDirection, distance4);
                this._addPhysX(physXDirection, isStatic, isDynamic);
              }
              verticalDirection.vec3_rotateAxisRadians(angleForClove / 2, rotationAxis, verticalDirection);
              if (physXList.length < maxCount) {
                let distance4 = Math.random() * (maxDistance - minDistance) + minDistance;
                let extraAxisRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
                let extraUpRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
                let physXDirection = verticalDirection.slice(0);
                physXDirection.vec3_rotateAxisRadians(extraAxisRotation, rotationAxis, physXDirection);
                physXDirection.vec3_rotateAxisRadians(extraUpRotation, upDirection, physXDirection);
                vec3_exports.scale(physXDirection, physXDirection, distance4);
                this._addPhysX(physXDirection, isStatic, isDynamic);
              }
              verticalDirection.vec3_rotateAxisRadians(angleForClove / 2, rotationAxis, verticalDirection);
            }
            horizontalDirection.vec3_rotateAxisRadians(angleForClove, upDirection, horizontalDirection);
          }
        },
        _addPhysX(physXDirection, isStatic, isDynamic) {
          let position = physXDirection;
          let scale8 = Math.pp_random(1, 10);
          let shape = Math.pp_randomPick(WL.Shape.Sphere, WL.Shape.Box);
          if (this._myUseConvexMesh) {
            shape = WL.Shape.ConvexMesh;
            scale8 *= this._myShapeScaleMultiplier;
          }
          let physX = WL.scene.addObject(this._myRootObject);
          physX.pp_setPosition(position);
          let physXComponent = physX.pp_addComponent("physx", {
            "shape": shape,
            "shapeData": { index: this._myShapeIndex },
            "extents": PP.vec3_create(scale8, scale8, scale8),
            "static": isStatic,
            "kinematic": !isDynamic,
            "mass": 1
          });
          if (isStatic) {
            this._myStaticPhysXObjects.push(physX);
            this._myStaticPhysXComponents.push(physXComponent);
            this._myStaticPhysXCollectors.push(new PP.PhysicsCollisionCollector(physXComponent));
          } else if (isDynamic) {
            this._myDynamicPhysXObjects.push(physX);
            this._myDynamicPhysXComponents.push(physXComponent);
            this._myDynamicPhysXCollectors.push(new PP.PhysicsCollisionCollector(physXComponent));
          } else {
            this._myKinematicPhysXObjects.push(physX);
            this._myKinematicPhysXComponents.push(physXComponent);
            this._myKinematicPhysXCollectors.push(new PP.PhysicsCollisionCollector(physXComponent));
          }
        }
      });
    }
  });

  // js/pp/cauldron/benchmarks/max_visible_triangles.js
  var require_max_visible_triangles = __commonJS({
    "js/pp/cauldron/benchmarks/max_visible_triangles.js"() {
      WL.registerComponent("pp-benchmark-max-visible-triangles", {
        _myTargetFrameRate: { type: WL.Type.Int, default: -1 },
        // -1 means it will auto detect it at start
        _myTargetFrameRateThreshold: { type: WL.Type.Int, default: 3 },
        _myStartPlaneCount: { type: WL.Type.Int, default: 1 },
        _myPlaneTriangles: { type: WL.Type.Int, default: 100 },
        _mySecondsBeforeDoubling: { type: WL.Type.Float, default: 0.5 },
        // higher gives a better frame rate evaluation
        _myDTHistoryToIgnorePercentage: { type: WL.Type.Float, default: 0.25 },
        _myCloneMaterial: { type: WL.Type.Bool, default: false },
        _myCloneMesh: { type: WL.Type.Bool, default: false },
        _myEnableLog: { type: WL.Type.Bool, default: true },
        _myPlaneMaterial: { type: WL.Type.Material },
        _myBackgroundMaterial: { type: WL.Type.Material },
        _myTextMaterial: { type: WL.Type.Material, default: null }
      }, {
        _start() {
          this._myBackgroundSize = 4;
          this._myBackgroundObject.pp_setActive(true);
          this._myBackgroundObject.pp_setScale(this._myBackgroundSize + 0.1);
          this._myBackgroundObject.pp_translate(PP.vec3_create(0, 0, -1e-3));
          this._myDoubleTimer = new PP.Timer(this._mySecondsBeforeDoubling);
          this._myIsDone = false;
          this._myCurrentPlanes = this._myStartPlaneCount;
          this._myDTHistory = [];
          this._myUpperLimit = -1;
          this._myLowerLimit = 0;
          this._myPlanes = [];
          this._mySkipNextFrames = 0;
          this._myMaxWaitFrames = 0;
          this._myMaxPlanesReached = false;
          this._myFirstTime = true;
        },
        _update(dt) {
          {
            if (dt < 1e-5) {
              return;
            }
            if (dt > 0.5 && this._myMaxWaitFrames > 0) {
              this._myMaxWaitFrames--;
              return;
            }
            this._myMaxWaitFrames = 10;
            if (this._mySkipNextFrames > 0) {
              this._mySkipNextFrames--;
              return;
            }
          }
          if (!this._myIsDone) {
            this._myDoubleTimer.update(dt);
            this._myDTHistory.push(dt);
            if (this._myDoubleTimer.isDone()) {
              this._myDoubleTimer.start();
              let frameRate = this._computeAverageFrameRate(false);
              if (this._myFirstTime) {
                this._myFirstTime = false;
              } else {
                let isLagging = false;
                if (frameRate < this._myStableFrameRate - this._myTargetFrameRateThreshold) {
                  this._myUpperLimit = this._myCurrentPlanes;
                  isLagging = true;
                  if (this._myUpperLimit == 1) {
                    this._myLowerLimit = 1;
                  }
                } else {
                  this._myLowerLimit = this._myCurrentPlanes;
                  if (this._myUpperLimit > 0) {
                    this._myUpperLimit = Math.max(this._myUpperLimit, this._myLowerLimit);
                  }
                }
                this._myTriangleTextComponent.text = "Triangles: " + this._myCurrentPlanes * this._myRealTrianglesAmount;
                this._myPlaneTextComponent.text = "Planes: " + this._myCurrentPlanes;
                this._myFPSTextComponent.text = "FPS: " + frameRate + " / " + this._myStableFrameRate;
                if (isLagging) {
                  this._myTriangleTextComponent.material.color = this._myLagColor;
                  this._myPlaneTextComponent.material.color = this._myLagColor;
                  this._myFPSTextComponent.material.color = this._myLagColor;
                } else {
                  this._myTriangleTextComponent.material.color = this._myNormalColor;
                  this._myPlaneTextComponent.material.color = this._myNormalColor;
                  this._myFPSTextComponent.material.color = this._myNormalColor;
                }
                let reset = false;
                if (this._myUpperLimit > 0 && (!isLagging && this._myUpperLimit - this._myLowerLimit <= Math.max(2, 1e3 / this._myRealTrianglesAmount)) || isLagging && this._myUpperLimit - this._myLowerLimit <= 1 || !isLagging && this._myMaxPlanesReached) {
                  if (frameRate < this._myStableFrameRate - this._myTargetFrameRateThreshold) {
                    this._myLowerLimit = Math.max(1, Math.floor(this._myUpperLimit / 2.5));
                    this._myUpperLimit = 0;
                    reset = true;
                    if (this._myEnableLog) {
                      console.log("Rst - Triangles:", this._myCurrentPlanes * this._myRealTrianglesAmount, "- Planes:", this._myCurrentPlanes, "- Frame Rate:", frameRate);
                    }
                  } else {
                    if (this._myMaxPlanesReached) {
                      if (this._myEnableLog) {
                        console.log("Aborted - Max Planes Reached");
                        this._myDoneTextComponent.text = "Aborted - Max Planes Reached";
                      }
                    } else {
                      this._displayPlanes(this._myLowerLimit);
                      if (this._myEnableLog) {
                        console.log("\nEnd - Triangles:", this._myLowerLimit * this._myRealTrianglesAmount, "- Planes:", this._myLowerLimit, "- Frame Rate:", frameRate);
                        console.log("Plane Triangles (Adjusted):", this._myRealTrianglesAmount);
                        console.log("Target Frame Rate:", this._myStableFrameRate, "- Threshold: ", this._myStableFrameRate - this._myTargetFrameRateThreshold);
                      }
                      this._myTriangleTextComponent.text = "Triangles: " + this._myLowerLimit * this._myRealTrianglesAmount;
                      this._myPlaneTextComponent.text = "Planes: " + this._myLowerLimit;
                      this._myFPSTextComponent.text = "FPS: " + frameRate + " / " + this._myStableFrameRate;
                      this._myDoneTextComponent.text = "End";
                    }
                    this._myIsDone = true;
                  }
                }
                if (isLagging && !reset) {
                  if (this._myEnableLog) {
                    console.log("Lag - Triangles:", this._myCurrentPlanes * this._myRealTrianglesAmount, "- Planes:", this._myCurrentPlanes, "- Frame Rate:", frameRate);
                  }
                }
                if (!this._myIsDone) {
                  if (this._myUpperLimit > 0) {
                    this._myCurrentPlanes = Math.floor((this._myUpperLimit + this._myLowerLimit) / 2);
                    this._myCurrentPlanes = Math.max(this._myCurrentPlanes, 1);
                  } else if (!reset) {
                    this._myCurrentPlanes = this._myLowerLimit * 2;
                  } else {
                    this._myCurrentPlanes = this._myLowerLimit;
                  }
                  if (this._myCurrentPlanes > 5e4) {
                    this._myCurrentPlanes = 5e4;
                    this._myMaxPlanesReached = true;
                  } else {
                    this._myMaxPlanesReached = false;
                  }
                }
              }
              if (!this._myIsDone) {
                this._displayPlanes(this._myCurrentPlanes);
                this._myElapsedTime = 0;
                this._myFrameCount = 0;
                this._mySkipNextFrames = 30;
              }
            }
          }
        },
        _displayPlanes(count) {
          while (this._myPlanes.length > count) {
            let plane = this._myPlanes.pop();
            this._myPlanePool.release(plane);
          }
          while (this._myPlanes.length < count) {
            let plane = this._myPlanePool.get();
            this._myPlanes.push(plane);
          }
          let gridSize = 1;
          while (gridSize * gridSize < count) {
            gridSize++;
          }
          let spaceBetween = 0.01;
          let totalSpaceBetween = spaceBetween * (gridSize - 1);
          let planeSize = (this._myBackgroundSize * 2 - totalSpaceBetween) / (gridSize * 2);
          let currentCount = count;
          for (let i = 0; i < gridSize && currentCount > 0; i++) {
            for (let j = 0; j < gridSize && currentCount > 0; j++) {
              let plane = this._myPlanes[currentCount - 1];
              plane.pp_setScale(planeSize);
              let position = [-this._myBackgroundSize + planeSize + j * planeSize * 2 + j * spaceBetween, this._myBackgroundSize - planeSize - i * planeSize * 2 - i * spaceBetween, 0];
              plane.pp_setPositionLocal(position);
              plane.pp_setActive(true);
              currentCount--;
            }
          }
        },
        start() {
          this._myLagColor = PP.vec4_create(0.5, 0, 0, 1);
          this._myNormalColor = PP.vec4_create(0, 0, 0, 1);
          this._myRealTrianglesAmount = 0;
          this._myTrianglesObject = WL.scene.addObject(this.object);
          this._myBackgroundObject = WL.scene.addObject(this._myTrianglesObject);
          {
            let meshComponent = this._myBackgroundObject.addComponent("mesh");
            meshComponent.mesh = PP.MeshUtils.createPlaneMesh();
            meshComponent.material = this._myBackgroundMaterial.clone();
          }
          this._myPlaneObject = WL.scene.addObject(this._myTrianglesObject);
          {
            let meshComponent = this._myPlaneObject.addComponent("mesh");
            meshComponent.mesh = this._createPlaneMesh(this._myPlaneTriangles);
            this._myRealTrianglesAmount = meshComponent.mesh.indexData.length / 3;
            meshComponent.material = this._myPlaneMaterial.clone();
          }
          let poolParams = new PP.ObjectPoolParams();
          if (!this._myCloneMesh) {
            poolParams.myInitialPoolSize = 3e4;
          } else {
            if (this._myRealTrianglesAmount <= 4) {
              poolParams.myInitialPoolSize = 15e3;
            } else if (this._myRealTrianglesAmount <= 8) {
              poolParams.myInitialPoolSize = 1e4;
            } else if (this._myRealTrianglesAmount <= 64) {
              poolParams.myInitialPoolSize = 7500;
            } else {
              poolParams.myInitialPoolSize = 5e3;
            }
          }
          poolParams.myPercentageToAddWhenEmpty = 0;
          poolParams.myAmountToAddWhenEmpty = 1e4;
          poolParams.myCloneParams = new PP.CloneParams();
          poolParams.myCloneParams.myDeepCloneParams.setDeepCloneComponentVariable("mesh", "material", this._myCloneMaterial);
          poolParams.myCloneParams.myDeepCloneParams.setDeepCloneComponentVariable("mesh", "mesh", this._myCloneMesh);
          this._myPlanePool = new PP.ObjectPool(this._myPlaneObject, poolParams);
          this._myBackgroundObject.pp_setActive(false);
          this._myPlaneObject.pp_setActive(false);
          this._myStartTimer = new PP.Timer(this._mySecondsBeforeDoubling * 2);
          this._mySessionStarted = false;
          this._myTextsObject = WL.scene.addObject(this._myTrianglesObject);
          this._myTriangleTextObject = WL.scene.addObject(this._myTextsObject);
          this._myTriangleTextComponent = this._myTriangleTextObject.addComponent("text");
          this._myTriangleTextComponent.alignment = WL.Alignment.Left;
          this._myTriangleTextComponent.justification = WL.Justification.Line;
          this._myTriangleTextComponent.material = this._myTextMaterial.clone();
          this._myTriangleTextComponent.material.color = this._myNormalColor;
          this._myTriangleTextComponent.text = " ";
          this._myPlaneTextObject = WL.scene.addObject(this._myTextsObject);
          this._myPlaneTextComponent = this._myPlaneTextObject.addComponent("text");
          this._myPlaneTextComponent.alignment = WL.Alignment.Left;
          this._myPlaneTextComponent.justification = WL.Justification.Line;
          this._myPlaneTextComponent.material = this._myTextMaterial.clone();
          this._myPlaneTextComponent.material.color = this._myNormalColor;
          this._myPlaneTextComponent.text = " ";
          this._myFPSTextObject = WL.scene.addObject(this._myTextsObject);
          this._myFPSTextComponent = this._myFPSTextObject.addComponent("text");
          this._myFPSTextComponent.alignment = WL.Alignment.Left;
          this._myFPSTextComponent.justification = WL.Justification.Line;
          this._myFPSTextComponent.material = this._myTextMaterial.clone();
          this._myFPSTextComponent.material.color = this._myNormalColor;
          this._myFPSTextComponent.text = " ";
          this._myDoneTextObject = WL.scene.addObject(this._myTrianglesObject);
          this._myDoneTextComponent = this._myDoneTextObject.addComponent("text");
          this._myDoneTextComponent.alignment = WL.Alignment.Center;
          this._myDoneTextComponent.justification = WL.Justification.Line;
          this._myDoneTextComponent.material = this._myTextMaterial.clone();
          this._myDoneTextComponent.material.color = this._myNormalColor;
          this._myDoneTextComponent.text = " ";
          this._myTextsObject.pp_setPositionLocal(PP.vec3_create(0, 4.3, 0));
          this._myTextsObject.pp_setScale(2.75);
          this._myTriangleTextObject.pp_setPositionLocal(PP.vec3_create(-1.4, 0, 0));
          this._myPlaneTextObject.pp_setPositionLocal(PP.vec3_create(0.55, 0, 0));
          this._myFPSTextObject.pp_setPositionLocal(PP.vec3_create(-0.315, 0, 0));
          this._myDoneTextObject.pp_setPositionLocal(PP.vec3_create(0, -4.6, 0));
          this._myDoneTextObject.pp_setScale(4);
          this._myDTHistory = [];
        },
        update(dt) {
          if (this._mySessionStarted) {
            if (this._myStartTimer.isRunning()) {
              this._myStartTimer.update(dt);
              this._myDTHistory.push(dt);
              if (this._myStartTimer.isDone()) {
                this._myStableFrameRate = this._computeAverageFrameRate(true);
                if (this._myTargetFrameRate > 0) {
                  this._myStableFrameRate = this._myTargetFrameRate;
                }
                if (this._myEnableLog) {
                  console.log("\nPlane Triangles (Adjusted):", this._myRealTrianglesAmount);
                  console.log("Target Frame Rate:", this._myStableFrameRate, "- Threshold: ", this._myStableFrameRate - this._myTargetFrameRateThreshold);
                  console.log("");
                }
                this._start();
              }
            } else {
              this._update(dt);
            }
          } else {
            this._mySessionStarted = WL.xrSession != null;
          }
        },
        _computeAverageFrameRate(isStart) {
          let frameRate = 0;
          this._myDTHistory.sort();
          let elementToRemove = Math.floor(this._myDTHistory.length) * Math.min(0.9, this._myDTHistoryToIgnorePercentage * (isStart ? 2 : 1));
          for (let i = 0; i < elementToRemove; i++) {
            this._myDTHistory.pop();
          }
          let averageDT = 0;
          for (let dt of this._myDTHistory) {
            averageDT += dt;
          }
          averageDT /= this._myDTHistory.length;
          frameRate = Math.round(1 / averageDT);
          this._myDTHistory = [];
          return frameRate;
        },
        _createPlaneMesh(trianglesAmount) {
          let squaresAmount = Math.ceil(trianglesAmount / 2);
          let row = 1;
          let column = 1;
          let closestSqrt = 1;
          while (closestSqrt * closestSqrt < squaresAmount) {
            closestSqrt++;
          }
          row = closestSqrt;
          column = closestSqrt;
          while (row > 1 && column > 1 && row * column > squaresAmount && (row - 1) * column >= squaresAmount) {
            row--;
          }
          let meshParams = new PP.MeshCreationParams();
          for (let i = 0; i < row + 1; i++) {
            for (let j = 0; j < column + 1; j++) {
              let x = 2 / column * j;
              let y = 2 / row * i;
              let vertexParams = new PP.MeshCreationVertexParams();
              vertexParams.myPosition = new PP.vec3_create();
              vertexParams.myPosition[0] = x - 1;
              vertexParams.myPosition[1] = y - 1;
              vertexParams.myPosition[2] = 0;
              vertexParams.myTextureCoordinates = new PP.vec2_create();
              vertexParams.myTextureCoordinates[0] = x / 2;
              vertexParams.myTextureCoordinates[1] = y / 2;
              vertexParams.myNormal = new PP.vec3_create();
              vertexParams.myNormal[0] = 0;
              vertexParams.myNormal[1] = 0;
              vertexParams.myNormal[2] = 1;
              meshParams.myVertexes.push(vertexParams);
            }
          }
          for (let i = 0; i < row; i++) {
            for (let j = 0; j < column; j++) {
              let firstTriangle = new PP.MeshCreationTriangleParams();
              firstTriangle.myIndexes[0] = i * (column + 1) + j;
              firstTriangle.myIndexes[1] = i * (column + 1) + j + 1;
              firstTriangle.myIndexes[2] = (i + 1) * (column + 1) + j;
              let secondTriangle = new PP.MeshCreationTriangleParams();
              secondTriangle.myIndexes[0] = (i + 1) * (column + 1) + j;
              secondTriangle.myIndexes[1] = i * (column + 1) + j + 1;
              secondTriangle.myIndexes[2] = (i + 1) * (column + 1) + j + 1;
              meshParams.myTriangles.push(firstTriangle);
              meshParams.myTriangles.push(secondTriangle);
            }
          }
          let mesh = PP.MeshUtils.createMesh(meshParams);
          return mesh;
        }
      });
    }
  });

  // js/pp/cauldron/cauldron/object_pool_manager.js
  var require_object_pool_manager = __commonJS({
    "js/pp/cauldron/cauldron/object_pool_manager.js"() {
      PP.ObjectPoolManager = class ObjectPoolManager {
        constructor() {
          this._myPools = /* @__PURE__ */ new Map();
        }
        addPool(poolID, poolObject, objectPoolParams = new PP.ObjectPoolParams()) {
          if (!this._myPools.has(poolID)) {
            let pool = new PP.ObjectPool(poolObject, objectPoolParams);
            this._myPools.set(poolID, pool);
          } else {
            console.error("Pool already created with this ID");
          }
        }
        increasePool(poolID, amount) {
          let pool = this._myPools.get(poolID);
          if (pool) {
            pool.increase(amount);
          }
        }
        increasePoolPercentage(poolID, percentage) {
          let pool = this._myPools.get(poolID);
          if (pool) {
            pool.increasePercentage(percentage);
          }
        }
        getPool(poolID) {
          return this._myPools.get(poolID);
        }
        hasPool(poolID) {
          return this._myPools.has(poolID);
        }
        getObject(poolID) {
          if (this._myPools.has(poolID)) {
            return this._myPools.get(poolID).get();
          }
          return null;
        }
        releaseObject(poolID, object) {
          this._myPools.get(poolID).release(object);
        }
      };
      PP.ObjectPoolParams = class ObjectPoolParams {
        constructor() {
          this.myInitialPoolSize = 0;
          this.myAmountToAddWhenEmpty = 0;
          this.myPercentageToAddWhenEmpty = 0;
          this.myCloneParams = void 0;
          this.myOptimizeObjectsAllocation = true;
          this.myCloneCallback = void 0;
          this.mySetActiveCallback = void 0;
          this.myEqualCallback = void 0;
          this.myOptimizeObjectsAllocationCallback = void 0;
          this.myEnableDebugLog = true;
        }
      };
      PP.ObjectPool = class ObjectPool {
        constructor(poolObject, objectPoolParams) {
          this._myObjectPoolParams = objectPoolParams;
          this._myPrototype = this._clone(poolObject);
          this._myAvailableObjects = [];
          this._myBusyObjects = [];
          this._addToPool(objectPoolParams.myInitialPoolSize, false);
        }
        get() {
          let object = this._myAvailableObjects.shift();
          if (object == null) {
            let amountToAdd = Math.ceil(this._myBusyObjects.length * this._myObjectPoolParams.myPercentageToAddWhenEmpty);
            amountToAdd += this._myObjectPoolParams.myAmountToAddWhenEmpty;
            this._addToPool(amountToAdd, this._myObjectPoolParams.myEnableDebugLog);
            object = this._myAvailableObjects.shift();
          }
          if (object != null) {
            this._myBusyObjects.push(object);
          }
          return object;
        }
        release(object) {
          let released = this._myBusyObjects.pp_remove(this._equals.bind(this, object));
          if (released) {
            this._setActive(released, false);
            this._myAvailableObjects.push(released);
          }
        }
        increase(amount) {
          this._addToPool(amount, false);
        }
        increasePercentage(percentage) {
          let amount = Math.ceil(this.getSize() * percentage);
          this._addToPool(amount, false);
        }
        getSize() {
          return this._myBusyObjects.length + this._myAvailableObjects.length;
        }
        getAvailableSize() {
          return this._myAvailableObjects.length;
        }
        getBusySize() {
          return this._myAvailableObjects.length;
        }
        _addToPool(size, log) {
          if (size <= 0) {
            return;
          }
          if (this._myObjectPoolParams.myOptimizeObjectsAllocation) {
            if (this._myObjectPoolParams.myOptimizeObjectsAllocationCallback) {
              this._myObjectPoolParams.myOptimizeObjectsAllocationCallback(this._myPrototype, size);
            } else if (this._myPrototype.pp_reserveObjectsHierarchy != null) {
              this._myPrototype.pp_reserveObjectsHierarchy(size);
            }
          }
          for (let i = 0; i < size; i++) {
            this._myAvailableObjects.push(this._clone(this._myPrototype));
          }
          if (log) {
            console.warn("Added new elements to the pool:", size);
          }
        }
        _clone(object) {
          let clone8 = null;
          if (this._myObjectPoolParams.myCloneCallback != null) {
            clone8 = this._myObjectPoolParams.myCloneCallback(object, this._myObjectPoolParams.myCloneParams);
          } else if (object.pp_clone != null) {
            clone8 = object.pp_clone(this._myObjectPoolParams.myCloneParams);
          } else if (object.clone != null) {
            clone8 = object.clone(this._myObjectPoolParams.myCloneParams);
          }
          if (clone8 == null) {
            console.error("Object not cloneable, pool will return null");
          } else {
            this._setActive(clone8, false);
          }
          return clone8;
        }
        _setActive(object, active) {
          if (this._myObjectPoolParams.mySetActiveCallback != null) {
            this._myObjectPoolParams.mySetActiveCallback(object, active);
          } else if (object.pp_setActive != null) {
            object.pp_setActive(active);
          } else if (object.setActive != null) {
            object.setActive(active);
          }
        }
        _equals(first, second) {
          let equals9 = false;
          if (this._myObjectPoolParams.myEqualCallback != null) {
            equals9 = this._myObjectPoolParams.myEqualCallback(first, second);
          } else if (first.pp_equals != null) {
            equals9 = first.pp_equals(second);
          } else if (first.equals != null) {
            equals9 = first.equals(second);
          } else {
            equals9 = first == second;
          }
          return equals9;
        }
      };
    }
  });

  // js/pp/cauldron/cauldron/save_manager.js
  var require_save_manager = __commonJS({
    "js/pp/cauldron/cauldron/save_manager.js"() {
      PP.SaveManager = class SaveManager {
        constructor(saveID, autoLoadSaves = true) {
          this._mySaveID = saveID;
          this._myCommitSavesDelayTimer = new PP.Timer(0, false);
          this._myDelaySavesCommit = true;
          this._myCommitSavesDirty = false;
          this._myCommitSavesDirtyClearOnFail = true;
          this._myCommitSavesWhenLoadSavesFailed = false;
          this._myResetSaveObjectOnLoadSavesFail = false;
          this._mySaveObject = {};
          this._myLoadSavesSucceded = false;
          this._myClearCallbacks = /* @__PURE__ */ new Map();
          this._myDeleteCallbacks = /* @__PURE__ */ new Map();
          this._myDeleteIDCallbacks = /* @__PURE__ */ new Map();
          this._mySaveCallbacks = /* @__PURE__ */ new Map();
          this._mySaveValueChangedCallbacks = /* @__PURE__ */ new Map();
          this._mySaveIDCallbacks = /* @__PURE__ */ new Map();
          this._mySaveValueChangedIDCallbacks = /* @__PURE__ */ new Map();
          this._myCommitSavesCallbacks = /* @__PURE__ */ new Map();
          this._myLoadCallbacks = /* @__PURE__ */ new Map();
          this._myLoadIDCallbacks = /* @__PURE__ */ new Map();
          this._myLoadSavesCallbacks = /* @__PURE__ */ new Map();
          if (autoLoadSaves) {
            this.loadSaves();
          }
          window.addEventListener("visibilitychange", function() {
            if (document.visibilityState != "visible") {
              this._onInterrupt();
            }
          }.bind(this));
          if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        }
        setCommitSavesDelay(delay) {
          this._myCommitSavesDelayTimer.start(delay);
        }
        setDelaySavesCommit(delayed) {
          this._myDelaySavesCommit = delayed;
        }
        setCommitSavesDirty(dirty, startDelayTimer = true) {
          this._myCommitSavesDirty = dirty;
          if (dirty && startDelayTimer) {
            if (!this.startDelayTimer.isRunning()) {
              this._myCommitSavesDelayTimer.start();
            }
          } else {
            this._myCommitSavesDelayTimer.reset();
          }
        }
        setCommitSavesDirtyClearOnFail(clearOnFail) {
          this._myCommitSavesDirtyClearOnFail = clearOnFail;
        }
        setCommitSavesWhenLoadSavesFailed(commitSavesWhenLoadSavesFailed) {
          this._myCommitSavesWhenLoadSavesFailed = commitSavesWhenLoadSavesFailed;
        }
        setResetSaveObjectOnLoadSavesFail(resetSaveObjectOnLoadSavesFail) {
          this._myResetSaveObjectOnLoadSavesFail = resetSaveObjectOnLoadSavesFail;
        }
        getCommitSavesDelay() {
          return this._myCommitSavesDelayTimer.getDuration();
        }
        isDelaySavesCommit() {
          return this._myDelaySavesCommit;
        }
        isCommitSavesDirty() {
          return this._myCommitSavesDirty;
        }
        isCommitSavesDirtyClearOnFail() {
          return this._myCommitSavesDirtyClearOnFail;
        }
        isCommitSavesWhenLoadSavesFailed() {
          return this._myCommitSavesWhenLoadSavesFailed;
        }
        isResetSaveObjectOnLoadSavesFail() {
          return this._myResetSaveObjectOnLoadSavesFail;
        }
        hasLoadSavesSucceded() {
          return this._myLoadSavesSucceded;
        }
        update(dt) {
          if (this._myCommitSavesDelayTimer.isRunning()) {
            this._myCommitSavesDelayTimer.update(dt);
            if (this._myCommitSavesDelayTimer.isDone()) {
              if (this._myCommitSavesDirty) {
                this._commitSaves();
              }
            }
          } else {
            if (this._myCommitSavesDirty) {
              this._commitSaves();
            }
          }
        }
        has(id) {
          return id in this._mySaveObject;
        }
        save(id, value, overrideDelaySavesCommit = null) {
          let sameValue = false;
          if (this.has(id)) {
            sameValue = this._mySaveObject[id] === value;
          }
          if (!sameValue) {
            this._mySaveObject[id] = value;
            if (this._myDelaySavesCommit && overrideDelaySavesCommit == null || overrideDelaySavesCommit != null && overrideDelaySavesCommit) {
              this._myCommitSavesDirty = true;
              if (!this._myCommitSavesDelayTimer.isRunning()) {
                this._myCommitSavesDelayTimer.start();
              }
            } else {
              this._commitSaves();
            }
          }
          if (this._mySaveCallbacks.size > 0) {
            this._mySaveCallbacks.forEach(function(callback) {
              callback(id, value);
            });
          }
          if (this._mySaveIDCallbacks.size > 0) {
            let callbackMap = this._mySaveIDCallbacks.get(id);
            if (callbackMap != null) {
              callbackMap.forEach(function(callback) {
                callback(id, value);
              });
            }
          }
          if (!sameValue) {
            if (this._mySaveValueChangedCallbacks.size > 0) {
              this._mySaveValueChangedCallbacks.forEach(function(callback) {
                callback(id, value);
              });
            }
            if (this._mySaveValueChangedIDCallbacks.size > 0) {
              let callbackMap = this._mySaveValueChangedIDCallbacks.get(id);
              if (callbackMap != null) {
                callbackMap.forEach(function(callback) {
                  callback(id, value);
                });
              }
            }
          }
        }
        delete(id, overrideDelaySavesCommit = null) {
          if (this.has(id)) {
            delete this._mySaveObject[id];
            if (this._myDelaySavesCommit && overrideDelaySavesCommit == null || overrideDelaySavesCommit != null && overrideDelaySavesCommit) {
              this._myCommitSavesDirty = true;
              if (!this._myCommitSavesDelayTimer.isRunning()) {
                this._myCommitSavesDelayTimer.start();
              }
            } else {
              this._commitSaves();
            }
          }
          if (this._myDeleteCallbacks.size > 0) {
            this._myDeleteCallbacks.forEach(function(callback) {
              callback(id);
            });
          }
          if (this._myDeleteIDCallbacks.size > 0) {
            let callbackMap = this._myDeleteIDCallbacks.get(id);
            if (callbackMap != null) {
              callbackMap.forEach(function(callback) {
                callback(id);
              });
            }
          }
        }
        clear(overrideDelaySavesCommit = null) {
          if (Object.keys(this._mySaveObject).length > 0) {
            this._mySaveObject = {};
            if (this._myDelaySavesCommit && overrideDelaySavesCommit == null || overrideDelaySavesCommit != null && overrideDelaySavesCommit) {
              this._myCommitSavesDirty = true;
              if (!this._myCommitSavesDelayTimer.isRunning()) {
                this._myCommitSavesDelayTimer.start();
              }
            } else {
              this._commitSaves();
            }
          }
          if (this._myClearCallbacks.size > 0) {
            this._myClearCallbacks.forEach(function(callback) {
              callback();
            });
          }
        }
        load(id, defaultValue) {
          let value = this._mySaveObject[id];
          if (value == null && defaultValue != null) {
            value = defaultValue;
          }
          if (this._myLoadCallbacks.size > 0) {
            this._myLoadCallbacks.forEach(function(callback) {
              callback(id, value);
            });
          }
          if (this._myLoadIDCallbacks.size > 0) {
            let callbackMap = this._myLoadIDCallbacks.get(id);
            if (callbackMap != null) {
              callbackMap.forEach(function(callback) {
                callback(id, value);
              });
            }
          }
          return value;
        }
        commitSaves(commitSavesOnlyIfDirty = true) {
          if (this._myCommitSavesDirty || !commitSavesOnlyIfDirty) {
            this._commitSaves();
          }
        }
        _commitSaves() {
          let succeded = true;
          if (this._myLoadSavesSucceded || this._myCommitSavesWhenLoadSavesFailed) {
            try {
              let saveObjectStringified = JSON.stringify(this._mySaveObject);
              PP.SaveUtils.save(this._mySaveID, saveObjectStringified);
            } catch (error) {
              succeded = false;
            }
          }
          if (succeded || this._myCommitSavesDirtyClearOnFail) {
            this._myCommitSavesDirty = false;
            this._myCommitSavesDelayTimer.reset();
          }
          if (this._myCommitSavesCallbacks.size > 0) {
            this._myCommitSavesCallbacks.forEach(function(callback) {
              callback(succeded);
            });
          }
          return succeded;
        }
        loadSaves() {
          let saveObject = {};
          let loadSavesSucceded = false;
          let saveObjectReset = false;
          let maxLoadObjectAttempts = 3;
          do {
            try {
              saveObject = PP.SaveUtils.loadObject(this._mySaveID, {});
              loadSavesSucceded = true;
            } catch (error) {
              maxLoadObjectAttempts--;
            }
          } while (maxLoadObjectAttempts > 0 && !loadSavesSucceded);
          if (loadSavesSucceded) {
            this._mySaveObject = saveObject;
            this._myLoadSavesSucceded = true;
          } else if (this._myResetSaveObjectOnLoadSavesFail) {
            this._mySaveObject = {};
            this._myLoadSavesSucceded = false;
            saveObjectReset = true;
          }
          if (this._myLoadSavesCallbacks.size > 0) {
            this._myLoadSavesCallbacks.forEach(function(callback) {
              callback(loadSavesSucceded, saveObjectReset);
            });
          }
          return loadSavesSucceded;
        }
        _onXRSessionStart(session) {
          session.addEventListener("visibilitychange", function(event) {
            if (event.session.visibilityState != "visible") {
              this._onInterrupt();
            }
          }.bind(this));
        }
        _onXRSessionEnd() {
          this._onInterrupt();
        }
        _onInterrupt() {
          if (this._myCommitSavesDirty) {
            this._commitSaves();
          }
        }
        registerClearEventListener(callbackID, callback) {
          this._myClearCallbacks.set(callbackID, callback);
        }
        unregisterClearEventListener(callbackID) {
          this._myClearCallbacks.delete(callbackID);
        }
        registerDeleteEventListener(callbackID, callback) {
          this._myDeleteCallbacks.set(callbackID, callback);
        }
        unregisterDeleteEventListener(callbackID) {
          this._myDeleteCallbacks.delete(callbackID);
        }
        registerDeleteIDEventListener(valueID, callbackID, callback) {
          let valueIDMap = this._myDeleteIDCallbacks.get(valueID);
          if (valueIDMap == null) {
            this._myDeleteIDCallbacks.set(valueID, /* @__PURE__ */ new Map());
            valueIDMap = this._myDeleteIDCallbacks.get(valueID);
          }
          valueIDMap.set(callbackID, callback);
        }
        unregisterDeleteIDEventListener(valueID, callbackID) {
          let valueIDMap = this._myDeleteIDCallbacks.get(valueID);
          if (valueIDMap != null) {
            valueIDMap.delete(callbackID);
          }
        }
        registerSaveEventListener(callbackID, callback) {
          this._mySaveCallbacks.set(callbackID, callback);
        }
        unregisterSaveEventListener(callbackID) {
          this._mySaveCallbacks.delete(callbackID);
        }
        registerSaveIDEventListener(valueID, callbackID, callback) {
          let valueIDMap = this._mySaveIDCallbacks.get(valueID);
          if (valueIDMap == null) {
            this._mySaveIDCallbacks.set(valueID, /* @__PURE__ */ new Map());
            valueIDMap = this._mySaveIDCallbacks.get(valueID);
          }
          valueIDMap.set(callbackID, callback);
        }
        unregisterSaveIDEventListener(valueID, callbackID) {
          let valueIDMap = this._mySaveIDCallbacks.get(valueID);
          if (valueIDMap != null) {
            valueIDMap.delete(callbackID);
          }
        }
        registerSaveValueChangedEventListener(callbackID, callback) {
          this._mySaveValueChangedCallbacks.set(callbackID, callback);
        }
        unregisterSaveValueChangedEventListener(callbackID) {
          this._mySaveValueChangedCallbacks.delete(callbackID);
        }
        registerSaveValueChangedIDEventListener(valueID, callbackID, callback) {
          let valueIDMap = this._mySaveValueChangedIDCallbacks.get(valueID);
          if (valueIDMap == null) {
            this._mySaveValueChangedIDCallbacks.set(valueID, /* @__PURE__ */ new Map());
            valueIDMap = this._mySaveValueChangedIDCallbacks.get(valueID);
          }
          valueIDMap.set(callbackID, callback);
        }
        unregisterSaveValueChangedIDEventListener(valueID, callbackID) {
          let valueIDMap = this._mySaveValueChangedIDCallbacks.get(valueID);
          if (valueIDMap != null) {
            valueIDMap.delete(callbackID);
          }
        }
        registerCommitSavesEventListener(callbackID, callback) {
          this._myCommitSavesCallbacks.set(callbackID, callback);
        }
        unregisterCommitSavesEventListener(callbackID) {
          this._myCommitSavesCallbacks.delete(callbackID);
        }
        registerLoadEventListener(callbackID, callback) {
          this._myLoadCallbacks.set(callbackID, callback);
        }
        unregisterLoadEventListener(callbackID) {
          this._myLoadCallbacks.delete(callbackID);
        }
        registerLoadIDEventListener(valueID, callbackID, callback) {
          let valueIDMap = this._myLoadIDCallbacks.get(valueID);
          if (valueIDMap == null) {
            this._myLoadIDCallbacks.set(valueID, /* @__PURE__ */ new Map());
            valueIDMap = this._myLoadIDCallbacks.get(valueID);
          }
          valueIDMap.set(callbackID, callback);
        }
        unregisterLoadIDEventListener(valueID, callbackID) {
          let valueIDMap = this._myLoadIDCallbacks.get(valueID);
          if (valueIDMap != null) {
            valueIDMap.delete(callbackID);
          }
        }
        registerLoadSavesEventListener(callbackID, callback) {
          this._myLoadSavesCallbacks.set(callbackID, callback);
        }
        unregisterLoadSavesEventListener(callbackID) {
          this._myLoadSavesCallbacks.delete(callbackID);
        }
      };
    }
  });

  // js/pp/cauldron/cauldron/timer.js
  var require_timer = __commonJS({
    "js/pp/cauldron/cauldron/timer.js"() {
      PP.Timer = class Timer {
        constructor(duration, autoStart = true) {
          this._myDuration = duration;
          this._myOnEndCallbacks = /* @__PURE__ */ new Map();
          this._myDone = false;
          this._myJustDone = false;
          this._myStarted = false;
          if (autoStart) {
            this.start();
          } else {
            this.reset();
          }
        }
        start(duration = null) {
          this.reset(duration);
          this._myStarted = true;
        }
        end() {
          this._done();
        }
        reset(duration = null) {
          if (duration != null) {
            this._myDuration = Math.max(0, duration);
          }
          this._myTimeLeft = this._myDuration;
          this._myDone = false;
          this._myJustDone = false;
          this._myStarted = false;
        }
        update(dt) {
          this._myJustDone = false;
          if (this.isRunning()) {
            this._myTimeLeft = Math.max(0, this._myTimeLeft - dt);
            if (this._myTimeLeft == 0) {
              this._done();
            }
          }
        }
        isDone() {
          return this._myDone;
        }
        isJustDone() {
          return this._myJustDone;
        }
        isStarted() {
          return this._myStarted;
        }
        isRunning() {
          return this.isStarted() && !this.isDone();
        }
        getDuration() {
          return this._myDuration;
        }
        setDuration(duration) {
          this._myDuration = Math.max(0, duration);
        }
        getTimeLeft() {
          return this._myTimeLeft;
        }
        getPercentage() {
          let percentage = 1;
          if (this._myTimeLeft > 0 && this._myDuration > 0) {
            percentage = (this._myDuration - this._myTimeLeft) / this._myDuration;
          }
          return Math.pp_clamp(percentage, 0, 1);
        }
        setPercentage(percentage) {
          if (this.isRunning()) {
            let durationPercentage = Math.pp_clamp(1 - percentage, 0, 1);
            this._myTimeLeft = this._myDuration * durationPercentage;
          }
        }
        onEnd(callback, id = null) {
          this._myOnEndCallbacks.set(id, callback);
        }
        unregisterOnEnd(id = null) {
          this._myOnEndCallbacks.delete(id);
        }
        _done() {
          this._myTimeLeft = 0;
          this._myDone = true;
          this._myJustDone = true;
          if (this._myOnEndCallbacks.size > 0) {
            for (let callback of this._myOnEndCallbacks.values()) {
              callback();
            }
          }
        }
      };
    }
  });

  // js/pp/cauldron/components/clear_console_on_xr_session_start.js
  var require_clear_console_on_xr_session_start = __commonJS({
    "js/pp/cauldron/components/clear_console_on_xr_session_start.js"() {
      WL.registerComponent("pp-clear-console-on-xr-session-start", {}, {
        init: function() {
        },
        start: function() {
          this._myFirstTime = true;
          WL.onXRSessionStart.push(function() {
            if (this._myFirstTime) {
              this._myFirstTime = false;
              console.clear();
            }
          }.bind(this));
        },
        update: function(dt) {
        }
      });
    }
  });

  // js/pp/cauldron/components/set_active.js
  var require_set_active = __commonJS({
    "js/pp/cauldron/components/set_active.js"() {
      WL.registerComponent("pp-set-active", {
        _myActive: { type: WL.Type.Bool, default: true },
        _mySetActiveOn: { type: WL.Type.Enum, values: ["self", "children", "descendants", "hierarchy"], default: "hierarchy" },
        _mySetActiveWhen: { type: WL.Type.Enum, values: ["init", "start", "first_update"], default: "init" }
      }, {
        init: function() {
          if (this.active && this._mySetActiveWhen == 0) {
            this._setActive();
          }
        },
        start: function() {
          if (this._mySetActiveWhen == 1) {
            this._setActive();
          }
          this._myFirst = true;
        },
        update: function(dt) {
          if (this._mySetActiveWhen == 2 && this._myFirst) {
            this._myFirst = false;
            this._setActive();
          }
        },
        _setActive() {
          if (this._mySetActiveOn == 0) {
            this.object.pp_setActiveSelf(this._myActive);
          } else if (this._mySetActiveOn == 1) {
            this.object.pp_setActiveChildren(this._myActive);
          } else if (this._mySetActiveOn == 2) {
            this.object.pp_setActiveDescendants(this._myActive);
          } else {
            this.object.pp_setActiveHierarchy(this._myActive);
          }
        }
      });
    }
  });

  // js/pp/cauldron/components/adjust_hierarchy_physx_scale.js
  var require_adjust_hierarchy_physx_scale = __commonJS({
    "js/pp/cauldron/components/adjust_hierarchy_physx_scale.js"() {
      WL.registerComponent("pp-adjust-hierarchy-physx-scale", {
        _myWhen: { type: WL.Type.Enum, values: ["init", "start", "first_update"], default: "start" }
      }, {
        init: function() {
          if (this.active && this._myWhen == 0) {
            this._adjustScale();
          }
        },
        start: function() {
          if (this._myWhen == 1) {
            this._adjustScale();
          }
          this._myFirst = true;
        },
        update: function(dt) {
          if (this._myWhen == 2 && this._myFirst) {
            this._myFirst = false;
            this._adjustScale();
          }
        },
        _adjustScale() {
          let scale8 = this.object.pp_getScale();
          let physXComponents = this.object.pp_getComponentsHierarchy("physx");
          for (let physX of physXComponents) {
            physX.extents[0] = physX.extents[0] * scale8[0];
            physX.extents[1] = physX.extents[1] * scale8[1];
            physX.extents[2] = physX.extents[2] * scale8[2];
            if (physX.active) {
              physX.active = false;
              physX.active = true;
            }
          }
        }
      });
    }
  });

  // js/pp/cauldron/components/get_player_objects.js
  var require_get_player_objects = __commonJS({
    "js/pp/cauldron/components/get_player_objects.js"() {
      WL.registerComponent("pp-get-player-objects", {
        _myPlayer: { type: WL.Type.Object },
        _myPlayerPivot: { type: WL.Type.Object },
        // if u don't have a pivot under the player you set this to null, by default will be the same as the player
        _myNonVRCamera: { type: WL.Type.Object },
        _myEyeLeft: { type: WL.Type.Object },
        _myEyeRight: { type: WL.Type.Object },
        _myHead: { type: WL.Type.Object },
        _myNonVRHead: { type: WL.Type.Object },
        _myVRHead: { type: WL.Type.Object },
        _myHandLeft: { type: WL.Type.Object },
        _myHandRight: { type: WL.Type.Object }
      }, {
        init: function() {
          PP.myPlayerObjects.myPlayer = this._myPlayer;
          PP.myPlayerObjects.myPlayerPivot = this._myPlayerPivot;
          PP.myPlayerObjects.myNonVRCamera = this._myNonVRCamera;
          PP.myPlayerObjects.myHead = this._myHead;
          PP.myPlayerObjects.myNonVRHead = this._myNonVRHead;
          PP.myPlayerObjects.myVRHead = this._myVRHead;
          PP.myPlayerObjects.myEyeLeft = this._myEyeLeft;
          PP.myPlayerObjects.myEyeRight = this._myEyeRight;
          PP.myPlayerObjects.myHandLeft = this._myHandLeft;
          PP.myPlayerObjects.myHandRight = this._myHandRight;
          PP.myPlayerObjects.myEyes = [];
          PP.myPlayerObjects.myEyes[PP.Handedness.LEFT] = this._myEyeLeft;
          PP.myPlayerObjects.myEyes[PP.Handedness.RIGHT] = this._myEyeRight;
          PP.myPlayerObjects.myHands = [];
          PP.myPlayerObjects.myHands[PP.Handedness.LEFT] = this._myHandLeft;
          PP.myPlayerObjects.myHands[PP.Handedness.RIGHT] = this._myHandRight;
          if (PP.myPlayerObjects.myPlayerPivot == null) {
            PP.myPlayerObjects.myPlayerPivot = PP.myPlayerObjects.myPlayer;
          }
        }
      });
      PP.myPlayerObjects = {
        myPlayer: null,
        myPlayerPivot: null,
        myNonVRCamera: null,
        myNonVRHead: null,
        myVRHead: null,
        myHead: null,
        myEyeLeft: null,
        myEyeRight: null,
        myEyes: [],
        myHandLeft: null,
        myHandRight: null,
        myHands: []
      };
    }
  });

  // js/pp/cauldron/components/get_default_resources.js
  var require_get_default_resources = __commonJS({
    "js/pp/cauldron/components/get_default_resources.js"() {
      WL.registerComponent("pp-get-default-resources", {
        _myPlane: { type: WL.Type.Mesh },
        _myCube: { type: WL.Type.Mesh },
        _mySphere: { type: WL.Type.Mesh },
        _myCone: { type: WL.Type.Mesh },
        _myCylinder: { type: WL.Type.Mesh },
        _myCircle: { type: WL.Type.Mesh },
        _myFlatOpaque: { type: WL.Type.Material },
        _myFlatTransparentNoDepth: { type: WL.Type.Material },
        _myPhongOpaque: { type: WL.Type.Material },
        _myText: { type: WL.Type.Material }
      }, {
        init() {
          PP.myDefaultResources.myMeshes.myPlane = PP.MeshUtils.cloneMesh(this._myPlane);
          PP.myDefaultResources.myMeshes.myCube = PP.MeshUtils.cloneMesh(this._myCube);
          PP.myDefaultResources.myMeshes.mySphere = PP.MeshUtils.cloneMesh(this._mySphere);
          PP.myDefaultResources.myMeshes.myCone = PP.MeshUtils.cloneMesh(this._myCone);
          PP.myDefaultResources.myMeshes.myCylinder = PP.MeshUtils.cloneMesh(this._myCylinder);
          PP.myDefaultResources.myMeshes.myCircle = PP.MeshUtils.cloneMesh(this._myCircle);
          PP.myDefaultResources.myMeshes.myInvertedCube = PP.MeshUtils.invertMesh(this._myCube);
          PP.myDefaultResources.myMeshes.myInvertedSphere = PP.MeshUtils.invertMesh(this._mySphere);
          PP.myDefaultResources.myMeshes.myInvertedCone = PP.MeshUtils.invertMesh(this._myCone);
          PP.myDefaultResources.myMeshes.myInvertedCylinder = PP.MeshUtils.invertMesh(this._myCylinder);
          if (this._myFlatOpaque != null) {
            PP.myDefaultResources.myMaterials.myFlatOpaque = this._myFlatOpaque.clone();
          }
          if (this._myFlatTransparentNoDepth != null) {
            PP.myDefaultResources.myMaterials.myFlatTransparentNoDepth = this._myFlatTransparentNoDepth.clone();
          }
          if (this._myPhongOpaque != null) {
            PP.myDefaultResources.myMaterials.myPhongOpaque = this._myPhongOpaque.clone();
          }
          if (this._myText != null) {
            PP.myDefaultResources.myMaterials.myText = this._myText.clone();
          }
        }
      });
      PP.myDefaultResources = {
        myMeshes: {
          myPlane: null,
          myCube: null,
          mySphere: null,
          myCone: null,
          myCylinder: null,
          myCircle: null,
          myInvertedCube: null,
          myInvertedSphere: null,
          myInvertedCone: null,
          myInvertedCylinder: null
        },
        myMaterials: {
          myFlatOpaque: null,
          myFlatTransparentNoDepth: null,
          // for now the pipeline needs to be the last one to make this work properly
          myPhongOpaque: null,
          myText: null
        }
      };
    }
  });

  // js/pp/cauldron/components/show_fps.js
  var require_show_fps = __commonJS({
    "js/pp/cauldron/components/show_fps.js"() {
      WL.registerComponent("pp-show-fps", {
        _myRefreshSeconds: { type: WL.Type.Float, default: 0.25 },
        _myTextMaterial: { type: WL.Type.Material }
      }, {
        init: function() {
        },
        start() {
          this._myTimer = new PP.Timer(this._myRefreshSeconds);
          this._myTotalDT = 0;
          this._myFrames = 0;
          this._myVisualFPSParent = this.object.pp_addObject();
          let visualParams = new PP.VisualTextParams();
          visualParams.myText = "0";
          visualParams.myTransform.mat4_setPositionRotationScale(PP.vec3_create(-0.115, -0.115, 0.35), PP.vec3_create(0, 180, 0), PP.vec3_create(0.3, 0.3, 0.3));
          if (this._myTextMaterial != null) {
            visualParams.myMaterial = this._myTextMaterial.clone();
          } else {
            visualParams.myMaterial = PP.myDefaultResources.myMaterials.myText.clone();
            visualParams.myMaterial.color = PP.vec4_create(0, 1, 0, 1);
          }
          visualParams.myParent = this._myVisualFPSParent;
          visualParams.myIsLocal = true;
          this._myVisualFPS = new PP.VisualText(visualParams);
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("FPS X", -0.25, 0.1, 3));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("FPS Y", -0.13, 0.1, 3));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("FPS Z", 0.35, 0.1, 3));
        },
        update: function() {
          let playerTransformQuat = PP.quat2_create();
          return function update(dt) {
            this._myTotalDT += dt;
            this._myFrames++;
            this._myTimer.update(dt);
            if (this._myTimer.isDone()) {
              this._myTimer.start();
              let fps = Math.round(this._myFrames / this._myTotalDT);
              let visualParams = this._myVisualFPS.getParams();
              if (PP.XRUtils.isSessionActive()) {
                visualParams.myTransform.mat4_setPositionRotationScale(PP.vec3_create(-0.115, -0.115, 0.35), PP.vec3_create(0, 180, 0), PP.vec3_create(0.3, 0.3, 0.3));
              } else {
                visualParams.myTransform.mat4_setPositionRotationScale(PP.vec3_create(-0.25, -0.13, 0.35), PP.vec3_create(0, 180, 0), PP.vec3_create(0.3, 0.3, 0.3));
              }
              visualParams.myText = fps.toFixed(0);
              this._myVisualFPS.paramsUpdated();
              this._myTotalDT = 0;
              this._myFrames = 0;
            }
            this._myVisualFPSParent.pp_setTransformQuat(PP.myPlayerObjects.myHead.pp_getTransformQuat(playerTransformQuat));
          };
        }()
      });
    }
  });

  // js/pp/cauldron/fsm/fsm.js
  var require_fsm = __commonJS({
    "js/pp/cauldron/fsm/fsm.js"() {
      PP.StateData = class StateData {
        constructor(stateID, stateObject) {
          this.myID = stateID;
          this.myObject = stateObject;
        }
      };
      PP.TransitionData = class TransitionData {
        constructor(transitionID, fromStateData, toStateData, transitionObject, skipStateFunction) {
          this.myID = transitionID;
          this.myFromState = fromStateData;
          this.myToState = toStateData;
          this.myObject = transitionObject;
          this.mySkipStateFunction = skipStateFunction;
        }
      };
      PP.PendingPerform = class PendingPerform {
        constructor(transitionID, ...args) {
          this.myID = transitionID;
          this.myArgs = args;
        }
      };
      PP.PerformMode = {
        IMMEDIATE: 0,
        DELAYED: 1
      };
      PP.PerformDelayedMode = {
        QUEUE: 0,
        KEEP_FIRST: 1,
        KEEP_LAST: 2
      };
      PP.SkipStateFunction = {
        NONE: 0,
        END: 1,
        START: 2,
        BOTH: 3
      };
      PP.FSM = class FSM {
        constructor(performMode = PP.PerformMode.IMMEDIATE, performDelayedMode = PP.PerformDelayedMode.QUEUE) {
          this._myCurrentStateData = null;
          this._myStates = /* @__PURE__ */ new Map();
          this._myTransitions = /* @__PURE__ */ new Map();
          this._myDebugLogActive = false;
          this._myDebugShowDelayedInfo = false;
          this._myDebugLogName = "FSM";
          this._myPerformMode = performMode;
          this._myPerformDelayedMode = performDelayedMode;
          this._myPendingPerforms = [];
          this._myCurrentlyPerformedTransition = null;
          this._myInitCallbacks = /* @__PURE__ */ new Map();
          this._myInitIDCallbacks = /* @__PURE__ */ new Map();
          this._myTransitionCallbacks = /* @__PURE__ */ new Map();
          this._myTransitionIDCallbacks = [];
        }
        addState(stateID, state = null) {
          let stateObject = null;
          if (!state || typeof state == "function") {
            stateObject = {};
            if (typeof state == "function") {
              stateObject.update = state;
            } else {
              stateObject.update = null;
            }
            stateObject.clone = function() {
              let cloneObject = {};
              cloneObject.update = this.update;
              cloneObject.clone = this.clone;
              return cloneObject;
            };
          } else {
            stateObject = state;
          }
          let stateData = new PP.StateData(stateID, stateObject);
          this._myStates.set(stateID, stateData);
          this._myTransitions.set(stateID, /* @__PURE__ */ new Map());
        }
        addTransition(fromStateID, toStateID, transitionID, transition = null, skipStateFunction = PP.SkipStateFunction.NONE) {
          let transitionObject = null;
          if (!transition || typeof transition == "function") {
            transitionObject = {};
            if (typeof transition == "function") {
              transitionObject.perform = transition;
            } else {
              transitionObject.perform = null;
            }
            transitionObject.clone = function() {
              let cloneObject = {};
              cloneObject.perform = this.perform;
              cloneObject.clone = this.clone;
              return cloneObject;
            };
          } else {
            transitionObject = transition;
          }
          if (this.hasState(fromStateID) && this.hasState(toStateID)) {
            let transitionsFromState = this._getTransitionsFromState(fromStateID);
            let transitionData = new PP.TransitionData(transitionID, this.getState(fromStateID), this.getState(toStateID), transitionObject, skipStateFunction);
            transitionsFromState.set(transitionID, transitionData);
          } else {
            if (!this.hasState(fromStateID) && !this.hasState(toStateID)) {
              console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID, "- to state not found:", toStateID);
            } else if (!this.hasState(fromStateID)) {
              console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID);
            } else if (!this.hasState(toStateID)) {
              console.error("Can't add transition:", transitionID, "- to state not found:", toStateID);
            }
          }
        }
        init(initStateID, initTransition = null, ...args) {
          let initTransitionObject = initTransition;
          if (initTransition && typeof initTransition == "function") {
            initTransitionObject = {};
            initTransitionObject.performInit = initTransition;
          }
          if (this.hasState(initStateID)) {
            let initStateData = this._myStates.get(initStateID);
            if (this._myDebugLogActive) {
              console.log(this._myDebugLogName, "- Init:", initStateID);
            }
            if (initTransitionObject && initTransitionObject.performInit) {
              initTransitionObject.performInit(this, initStateData, ...args);
            } else if (initStateData.myObject && initStateData.myObject.init) {
              initStateData.myObject.init(this, initStateData, ...args);
            }
            this._myCurrentStateData = initStateData;
            if (this._myInitCallbacks.size > 0) {
              this._myInitCallbacks.forEach(function(callback) {
                callback(this, initStateData, initTransitionObject, ...args);
              }.bind(this));
            }
            if (this._myInitIDCallbacks.size > 0) {
              let callbacks = this._myInitIDCallbacks.get(initStateID);
              if (callbacks != null) {
                callbacks.forEach(function(callback) {
                  callback(this, initStateData, initTransitionObject, ...args);
                }.bind(this));
              }
            }
          } else if (this._myDebugLogActive) {
            console.warn(this._myDebugLogName, "- Init state not found:", initStateID);
          }
        }
        update(dt, ...args) {
          if (this._myPendingPerforms.length > 0) {
            for (let i = 0; i < this._myPendingPerforms.length; i++) {
              this._perform(this._myPendingPerforms[i].myID, PP.PerformMode.DELAYED, ...this._myPendingPerforms[i].myArgs);
            }
            this._myPendingPerforms = [];
          }
          if (this._myCurrentStateData && this._myCurrentStateData.myObject && this._myCurrentStateData.myObject.update) {
            this._myCurrentStateData.myObject.update(dt, this, ...args);
          }
        }
        perform(transitionID, ...args) {
          if (this._myPerformMode == PP.PerformMode.DELAYED) {
            this.performDelayed(transitionID, ...args);
          } else {
            this.performImmediate(transitionID, ...args);
          }
        }
        performDelayed(transitionID, ...args) {
          let performDelayed = false;
          switch (this._myPerformDelayedMode) {
            case PP.PerformDelayedMode.QUEUE:
              this._myPendingPerforms.push(new PP.PendingPerform(transitionID, ...args));
              performDelayed = true;
              break;
            case PP.PerformDelayedMode.KEEP_FIRST:
              if (!this.hasPendingPerforms()) {
                this._myPendingPerforms.push(new PP.PendingPerform(transitionID, ...args));
                performDelayed = true;
              }
              break;
            case PP.PerformDelayedMode.KEEP_LAST:
              this.resetPendingPerforms();
              this._myPendingPerforms.push(new PP.PendingPerform(transitionID, ...args));
              performDelayed = true;
              break;
          }
          return performDelayed;
        }
        performImmediate(transitionID, ...args) {
          return this._perform(transitionID, PP.PerformMode.IMMEDIATE, ...args);
        }
        canPerform(transitionID) {
          return this.hasTransitionFromState(this._myCurrentStateData.myID, transitionID);
        }
        canGoTo(stateID, transitionID = null) {
          return this.hasTransitionFromStateToState(this._myCurrentStateData.myID, stateID, transitionID);
        }
        isInState(stateID) {
          return this._myCurrentStateData != null && this._myCurrentStateData.myID == stateID;
        }
        isPerformingTransition() {
          return this._myCurrentlyPerformedTransition != null;
        }
        getCurrentlyPerformedTransition() {
          return this._myCurrentlyPerformedTransition;
        }
        hasBeenInit() {
          return this._myCurrentStateData != null;
        }
        reset() {
          this.resetState();
          this.resetPendingPerforms();
        }
        resetState() {
          this._myCurrentStateData = null;
        }
        resetPendingPerforms() {
          this._myPendingPerforms = [];
        }
        getCurrentState() {
          return this._myCurrentStateData;
        }
        getCurrentTransitions() {
          return this.getTransitionsFromState(this._myCurrentStateData.myID);
        }
        getCurrentTransitionsToState(stateID) {
          return this.getTransitionsFromStateToState(this._myCurrentStateData.myID, stateID);
        }
        getState(stateID) {
          return this._myStates.get(stateID);
        }
        getStates() {
          return this._myStates.values();
        }
        getTransitions() {
          let transitions = [];
          for (let transitionsFromState of this._myTransitions.values()) {
            for (let transitionData of transitionsFromState.values()) {
              transitions.push(transitionData);
            }
          }
          return transitions;
        }
        getTransitionsFromState(fromStateID) {
          let transitionsFromState = this._getTransitionsFromState(fromStateID);
          return Array.from(transitionsFromState.values());
        }
        getTransitionsFromStateToState(fromStateID, toStateID) {
          let transitionsFromState = this._getTransitionsFromState(fromStateID);
          let transitionsToState = [];
          for (let transitionData of transitionsFromState.values()) {
            if (transitionData.myToState.myID == toStateID) {
              transitionsToState.push(transitionData);
            }
          }
          return transitionsToState;
        }
        removeState(stateID) {
          if (this.hasState(stateID)) {
            this._myStates.delete(stateID);
            this._myTransitions.delete(stateID);
            for (let transitionsFromState of this._myTransitions.values()) {
              let toDelete = [];
              for (let [transitionID, transitionData] of transitionsFromState.entries()) {
                if (transitionData.myToState.myID == stateID) {
                  toDelete.push(transitionID);
                }
              }
              for (let transitionID of toDelete) {
                transitionsFromState.delete(transitionID);
              }
            }
            return true;
          }
          return false;
        }
        removeTransitionFromState(fromStateID, transitionID) {
          let fromTransitions = this._getTransitionsFromState(fromStateID);
          if (fromTransitions) {
            return fromTransitions.delete(transitionID);
          }
          return false;
        }
        hasState(stateID) {
          return this._myStates.has(stateID);
        }
        hasTransitionFromState(fromStateID, transitionID) {
          let transitions = this.getTransitionsFromState(fromStateID);
          let transitionIndex = transitions.findIndex(function(transition) {
            return transition.myID == transitionID;
          });
          return transitionIndex >= 0;
        }
        hasTransitionFromStateToState(fromStateID, toStateID, transitionID = null) {
          let transitions = this.getTransitionsFromStateToState(fromStateID, toStateID);
          let hasTransition = false;
          if (transitionID) {
            let transitionIndex = transitions.findIndex(function(transition) {
              return transition.myID == transitionID;
            });
            hasTransition = transitionIndex >= 0;
          } else {
            hasTransition = transitions.length > 0;
          }
          return hasTransition;
        }
        setPerformMode(performMode) {
          this._myPerformMode = performMode;
        }
        getPerformMode() {
          return this._myPerformMode;
        }
        setPerformDelayedMode(performDelayedMode) {
          this._myPerformDelayedMode = performDelayedMode;
        }
        getPerformDelayedMode() {
          return this._myPerformDelayedMode;
        }
        hasPendingPerforms() {
          return this._myPendingPerforms.length > 0;
        }
        getPendingPerforms() {
          return this._myPendingPerforms.slice(0);
        }
        clone(deepClone = false) {
          if (!this.isCloneable(deepClone)) {
            return null;
          }
          let cloneFSM = new PP.FSM();
          cloneFSM._myDebugLogActive = this._myDebugLogActive;
          cloneFSM._myDebugShowDelayedInfo = this._myDebugShowDelayedInfo;
          cloneFSM._myDebugLogName = this._myDebugLogName.slice(0);
          cloneFSM._myPerformMode = this._myPerformMode;
          cloneFSM._myPerformDelayedMode = this._myPerformDelayedMode;
          cloneFSM._myPendingPerforms = this._myPendingPerforms.slice(0);
          for (let entry of this._myStates.entries()) {
            let stateData = null;
            if (deepClone) {
              stateData = new PP.StateData(entry[1].myID, entry[1].myObject.clone());
            } else {
              stateData = new PP.StateData(entry[1].myID, entry[1].myObject);
            }
            cloneFSM._myStates.set(stateData.myID, stateData);
          }
          for (let entry of this._myTransitions.entries()) {
            let transitionsFromState = /* @__PURE__ */ new Map();
            cloneFSM._myTransitions.set(entry[0], transitionsFromState);
            for (let transitonEntry of entry[1].entries()) {
              let transitionData = null;
              let fromState = cloneFSM.getState(transitonEntry[1].myFromState.myID);
              let toState = cloneFSM.getState(transitonEntry[1].myToState.myID);
              if (deepClone) {
                transitionData = new PP.TransitionData(transitonEntry[1].myID, fromState, toState, transitonEntry[1].myObject.clone(), transitonEntry[1].mySkipStateFunction);
              } else {
                transitionData = new PP.TransitionData(transitonEntry[1].myID, fromState, toState, transitonEntry[1].myObject, transitonEntry[1].mySkipStateFunction);
              }
              transitionsFromState.set(transitionData.myID, transitionData);
            }
          }
          if (this._myCurrentStateData) {
            cloneFSM._myCurrentStateData = cloneFSM.getState(this._myCurrentStateData.myID);
          }
          return cloneFSM;
        }
        isCloneable(deepClone = false) {
          if (!deepClone) {
            return true;
          }
          let isDeepCloneable = true;
          for (let entry of this._myStates.entries()) {
            isDeepCloneable = isDeepCloneable && entry[1].myObject.clone != null;
          }
          for (let entry of this._myTransitions.entries()) {
            for (let transitonEntry of entry[1].entries()) {
              isDeepCloneable = isDeepCloneable && transitonEntry[1].myObject.clone != null;
            }
          }
          return isDeepCloneable;
        }
        setDebugLogActive(active, debugLogName = null, showDelayedInfo = false) {
          this._myDebugLogActive = active;
          this._myDebugShowDelayedInfo = showDelayedInfo;
          if (debugLogName) {
            this._myDebugLogName = "FSM: ".concat(debugLogName);
          }
        }
        registerInitEventListener(callbackID, callback) {
          this._myInitCallbacks.set(callbackID, callback);
        }
        unregisterInitEventListener(callbackID) {
          this._myInitCallbacks.delete(callbackID);
        }
        registerInitIDEventListener(initStateID, callbackID, callback) {
          let initStateIDCallbacks = this._myInitIDCallbacks.get(initStateID);
          if (initStateIDCallbacks == null) {
            this._myInitIDCallbacks.set(initStateID, /* @__PURE__ */ new Map());
            initStateIDCallbacks = this._myInitIDCallbacks.get(initStateID);
          }
          initStateIDCallbacks.set(callbackID, callback);
        }
        unregisterInitIDEventListener(initStateID, callbackID) {
          let initStateIDCallbacks = this._myInitIDCallbacks.get(initStateID);
          if (initStateIDCallbacks != null) {
            initStateIDCallbacks.delete(callbackID);
            if (initStateIDCallbacks.size <= 0) {
              this._myInitIDCallbacks.delete(initStateID);
            }
          }
        }
        registerTransitionEventListener(callbackID, callback) {
          this._myTransitionCallbacks.set(callbackID, callback);
        }
        unregisterTransitionEventListener(callbackID) {
          this._myTransitionCallbacks.delete(callbackID);
        }
        //the fsm IDs can be null, that means that the callback is called whenever only the valid IDs match
        //this let you register to all the transitions with a specific ID and from of a specific state but to every state (toStateID == null)
        registerTransitionIDEventListener(fromStateID, toStateID, transitionID, callbackID, callback) {
          let internalTransitionIDCallbacks = null;
          for (let value of this._myTransitionIDCallbacks) {
            if (value[0] == fromStateID && value[1] == toStateID && value[2] == transitionID) {
              internalTransitionIDCallbacks = value[3];
              break;
            }
          }
          if (internalTransitionIDCallbacks == null) {
            let transitionIDCallbacks = [];
            transitionIDCallbacks[0] = fromStateID;
            transitionIDCallbacks[1] = toStateID;
            transitionIDCallbacks[2] = transitionID;
            transitionIDCallbacks[3] = /* @__PURE__ */ new Map();
            internalTransitionIDCallbacks = transitionIDCallbacks[3];
            this._myTransitionIDCallbacks.push(transitionIDCallbacks);
          }
          internalTransitionIDCallbacks.set(callbackID, callback);
        }
        unregisterTransitionIDEventListener(fromStateID, toStateID, transitionID, callbackID) {
          let internalTransitionIDCallbacks = null;
          for (let value of this._myTransitionIDCallbacks) {
            if (value[0] == fromStateID && value[1] == toStateID && value[2] == transitionID) {
              internalTransitionIDCallbacks = value[3];
              break;
            }
          }
          if (internalTransitionIDCallbacks != null) {
            internalTransitionIDCallbacks.delete(callbackID);
            if (internalTransitionIDCallbacks.size <= 0) {
              this._myTransitionIDCallbacks.pp_remove((element) => element[0] == fromStateID && element[1] == toStateID && element[2] == transitionID);
            }
          }
        }
        _perform(transitionID, performMode, ...args) {
          if (this.isPerformingTransition()) {
            let currentlyPerformedTransition = this.getCurrentlyPerformedTransition();
            let consoleArguments = [this._myDebugLogName, "- Trying to perform:", transitionID];
            if (this._myDebugShowDelayedInfo) {
              consoleArguments.push(performMode == PP.PerformMode.DELAYED ? "- Delayed" : "- Immediate");
            }
            consoleArguments.push("- But another transition is currently being performed -", currentlyPerformedTransition.myID);
            console.warn(...consoleArguments);
            return false;
          }
          if (this._myCurrentStateData) {
            if (this.canPerform(transitionID)) {
              let transitions = this._myTransitions.get(this._myCurrentStateData.myID);
              let transitionToPerform = transitions.get(transitionID);
              this._myCurrentlyPerformedTransition = transitionToPerform;
              let fromState = this._myCurrentStateData;
              let toState = this._myStates.get(transitionToPerform.myToState.myID);
              if (this._myDebugLogActive) {
                let consoleArguments = [this._myDebugLogName, "- From:", fromState.myID, "- To:", toState.myID, "- With:", transitionID];
                if (this._myDebugShowDelayedInfo) {
                  consoleArguments.push(performMode == PP.PerformMode.DELAYED ? "- Delayed" : "- Immediate");
                }
                console.log(...consoleArguments);
              }
              if (transitionToPerform.mySkipStateFunction != PP.SkipStateFunction.END && transitionToPerform.mySkipStateFunction != PP.SkipStateFunction.BOTH && fromState.myObject && fromState.myObject.end) {
                fromState.myObject.end(this, transitionToPerform, ...args);
              }
              if (transitionToPerform.myObject && transitionToPerform.myObject.perform) {
                transitionToPerform.myObject.perform(this, transitionToPerform, ...args);
              }
              if (transitionToPerform.mySkipStateFunction != PP.SkipStateFunction.START && transitionToPerform.mySkipStateFunction != PP.SkipStateFunction.BOTH && toState.myObject && toState.myObject.start) {
                toState.myObject.start(this, transitionToPerform, ...args);
              }
              this._myCurrentStateData = transitionToPerform.myToState;
              if (this._myTransitionCallbacks.size > 0) {
                this._myTransitionCallbacks.forEach(function(callback) {
                  callback(this, fromState, toState, transitionToPerform, performMode, ...args);
                }.bind(this));
              }
              if (this._myTransitionIDCallbacks.length > 0) {
                let internalTransitionIDCallbacks = [];
                for (let value of this._myTransitionIDCallbacks) {
                  if ((value[0] == null || value[0] == fromState.myID) && (value[1] == null || value[1] == toState.myID) && (value[2] == null || value[2] == transitionToPerform.myID)) {
                    internalTransitionIDCallbacks.push(value[3]);
                  }
                }
                for (let callbacks of this.internalTransitionIDCallbacks) {
                  callbacks.forEach(function(callback) {
                    callback(this, fromState, toState, transitionToPerform, performMode, ...args);
                  }.bind(this));
                }
              }
              this._myCurrentlyPerformedTransition = null;
              return true;
            } else if (this._myDebugLogActive) {
              let consoleArguments = [this._myDebugLogName, "- No Transition:", transitionID, "- From:", this._myCurrentStateData.myID];
              if (this._myDebugShowDelayedInfo) {
                consoleArguments.push(performMode == PP.PerformMode.DELAYED ? "- Delayed" : "- Immediate");
              }
              console.warn(...consoleArguments);
            }
          } else if (this._myDebugLogActive) {
            let consoleArguments = [this._myDebugLogName, "- FSM not initialized yet"];
            if (this._myDebugShowDelayedInfo) {
              consoleArguments.push(performMode == PP.PerformMode.DELAYED ? "- Delayed" : "- Immediate");
            }
            console.warn(...consoleArguments);
          }
          return false;
        }
        _getTransitionsFromState(fromStateID) {
          return this._myTransitions.get(fromStateID);
        }
      };
    }
  });

  // js/pp/cauldron/fsm/state.js
  var require_state = __commonJS({
    "js/pp/cauldron/fsm/state.js"() {
      PP.State = class State {
        //Called every frame if this is the current state
        //You can retrieve this state data by calling fsm.getCurrentState()
        update(dt, fsm, ...args) {
        }
        //Called when the fsm is started with this init state if no init transition object is specified or it does not have a performInit function
        //Since the state is set as the current one after the init, you can't use fsm.getCurrentState() to get it, so it is forwarded as a param if needed
        init(fsm, state, ...args) {
        }
        //Called when entering this state if no transition object is specified or it does not have a perform function
        //You can get this state data by accesing to the to state data inside the transition
        start(fsm, transition, ...args) {
        }
        //Called when exiting this state if no transition function is specified
        //You can get this state data by accesing to the from state data inside the transition
        end(fsm, transition, ...args) {
        }
      };
    }
  });

  // js/pp/cauldron/fsm/transition.js
  var require_transition = __commonJS({
    "js/pp/cauldron/fsm/transition.js"() {
      PP.Transition = class Transition {
        //Called if this is used as an init transition for the fsm
        performInit(fsm, initState, ...args) {
        }
        //Called when performing a transition
        //You can find the from and to states inside the transition params
        perform(fsm, transition, ...args) {
        }
      };
    }
  });

  // js/pp/cauldron/fsm/states/timer_state.js
  var require_timer_state = __commonJS({
    "js/pp/cauldron/fsm/states/timer_state.js"() {
      PP.TimerState = class TimerState extends PP.State {
        constructor(duration = 0, transitionToPerformOnEnd = null, ...transitionArgs) {
          super();
          this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
          this._myTransitionArgs = transitionArgs;
          this._myTimer = new PP.Timer(duration, false);
        }
        setDuration(duration) {
          this._myTimer.setDuration(duration);
        }
        setTransitionToPerformOnEnd(transitionToPerformOnEnd, ...transitionArgs) {
          this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
          this._myTransitionArgs = transitionArgs;
        }
        onEnd(callback, id = null) {
          this._myTimer.onEnd(callback, id);
        }
        unregisterOnEnd(id = null) {
          this._myTimer.unregisterOnEnd(id);
        }
        update(dt, fsm) {
          this._myTimer.update(dt);
          if (this._myTimer.isDone()) {
            if (this._myTransitionToPerformOnEnd != null) {
              fsm.perform(this._myTransitionToPerformOnEnd, ...this._myTransitionArgs);
            }
          }
        }
        start(fsm, transition, duration = null, transitionToPerformOnEnd = null, ...transitionArgs) {
          this._myTimer.start(duration);
          if (transitionToPerformOnEnd != null) {
            this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
            this._myTransitionArgs = transitionArgs;
          }
        }
        init(fsm, state, duration = null, transitionToPerformOnEnd = null, ...transitionArgs) {
          this._myTimer.start(duration);
          if (transitionToPerformOnEnd != null) {
            this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
            this._myTransitionArgs = transitionArgs;
          }
        }
      };
    }
  });

  // js/pp/cauldron/utils/color_utils.js
  var require_color_utils = __commonJS({
    "js/pp/cauldron/utils/color_utils.js"() {
      PP.ColorUtils = {
        //RGB is in [0,1], alpha is not changed
        rgbToHsv: function(rgb) {
          let hsv = rgb.pp_clone();
          let r = rgb[0];
          let g = rgb[1];
          let b = rgb[2];
          var max4 = Math.max(r, g, b), min4 = Math.min(r, g, b), d = max4 - min4, h, s = max4 === 0 ? 0 : d / max4, v = max4;
          switch (max4) {
            case min4:
              h = 0;
              break;
            case r:
              h = g - b + d * (g < b ? 6 : 0);
              h /= 6 * d;
              break;
            case g:
              h = b - r + d * 2;
              h /= 6 * d;
              break;
            case b:
              h = r - g + d * 4;
              h /= 6 * d;
              break;
          }
          hsv[0] = h;
          hsv[1] = s;
          hsv[2] = v;
          return hsv;
        },
        //alpha is not changed
        hsvToRgb: function(hsv) {
          let rgb = hsv.pp_clone();
          let h = hsv[0];
          let s = hsv[1];
          let v = hsv[2];
          let r, g, b, i, f, p, q, t;
          i = Math.floor(h * 6);
          f = h * 6 - i;
          p = v * (1 - s);
          q = v * (1 - f * s);
          t = v * (1 - (1 - f) * s);
          switch (i % 6) {
            case 0:
              r = v, g = t, b = p;
              break;
            case 1:
              r = q, g = v, b = p;
              break;
            case 2:
              r = p, g = v, b = t;
              break;
            case 3:
              r = p, g = q, b = v;
              break;
            case 4:
              r = t, g = p, b = v;
              break;
            case 5:
              r = v, g = p, b = q;
              break;
          }
          rgb[0] = r;
          rgb[1] = g;
          rgb[2] = b;
          return rgb;
        },
        rgbCodeToHuman(rgb) {
          return PP.ColorUtils.color1To255(rgb);
        },
        rgbHumanToCode(rgb) {
          return PP.ColorUtils.color255To1(rgb);
        },
        hsvCodeToHuman(hsv) {
          return PP.ColorUtils.color1To255(hsv);
        },
        hsvHumanToCode(hsv) {
          return PP.ColorUtils.color255To1(hsv);
        },
        color255To1(color) {
          let result = color.pp_clone();
          for (let i = 0; i < result.length; i++) {
            result[i] /= 255;
            result[i] = Math.pp_clamp(result[i], 0, 1);
          }
          return result;
        },
        color1To255(color) {
          let result = color.pp_clone();
          for (let i = 0; i < result.length; i++) {
            result[i] = Math.round(result[i] * 255);
            result[i] = Math.pp_clamp(result[i], 0, 255);
          }
          return result;
        }
      };
    }
  });

  // js/pp/cauldron/utils/material_utils.js
  var require_material_utils = __commonJS({
    "js/pp/cauldron/utils/material_utils.js"() {
      PP.MaterialUtils = {
        setAlpha: function() {
          let color = PP.vec4_create();
          return function setAlpha(material, alpha) {
            if (material.color != null) {
              color.vec4_copy(material.color);
              color[3] = alpha;
              material.color = color;
            }
            if (material.diffuseColor != null) {
              color.vec4_copy(material.diffuseColor);
              color[3] = alpha;
              material.diffuseColor = color;
            }
            if (material.ambientColor != null) {
              color.vec4_copy(material.ambientColor);
              color[3] = alpha;
              material.ambientColor = color;
            }
          };
        }(),
        setObjectAlpha: function(object, alpha) {
          let meshComponents = object.pp_getComponentsHierarchy("mesh");
          for (let meshComponent of meshComponents) {
            if (meshComponent.material != null) {
              PP.MaterialUtils.setAlpha(meshComponent.material, alpha);
            }
          }
        },
        setObjectMaterial: function(object, material, cloneMaterial = false) {
          let meshComponents = object.pp_getComponentsHierarchy("mesh");
          for (let meshComponent of meshComponents) {
            if (cloneMaterial) {
              meshComponent.material = material.clone();
            } else {
              meshComponent.material = material;
            }
          }
        },
        setObjectClonedMaterials: function(object) {
          let meshComponents = object.pp_getComponentsHierarchy("mesh");
          for (let meshComponent of meshComponents) {
            meshComponent.material = meshComponent.material.clone();
          }
        },
        setObjectSpecularColor: function(object, color) {
          let meshComponents = object.pp_getComponentsHierarchy("mesh");
          for (let meshComponent of meshComponents) {
            if (meshComponent.material.specularColor != null) {
              meshComponent.material.specularColor = color;
            }
          }
        },
        setObjectFogColor: function(object, color) {
          let meshComponents = object.pp_getComponentsHierarchy("mesh");
          for (let meshComponent of meshComponents) {
            if (meshComponent.material.fogColor != null) {
              meshComponent.material.fogColor = color;
            }
          }
        }
      };
    }
  });

  // js/pp/cauldron/utils/mesh_utils.js
  var require_mesh_utils = __commonJS({
    "js/pp/cauldron/utils/mesh_utils.js"() {
      PP.MeshCreationVertexParams = class MeshCreationVertexParams {
        constructor() {
          this.myPosition = null;
          this.myTextureCoordinates = null;
          this.myNormal = null;
          this.myColor = null;
        }
      };
      PP.MeshCreationTriangleParams = class MeshCreationTriangleParams {
        constructor() {
          this.myIndexes = new Uint32Array(3);
        }
      };
      PP.MeshCreationParams = class MeshCreationParams {
        constructor() {
          this.myVertexes = [];
          this.myTriangles = [];
        }
      };
      PP.MeshUtils = {
        createPlaneMesh: function() {
          let vertexCount = 4;
          let meshParams = new PP.MeshCreationParams();
          for (let i = 0; i < vertexCount; ++i) {
            let vertexParams = new PP.MeshCreationVertexParams();
            vertexParams.myPosition = new PP.vec3_create();
            vertexParams.myPosition[0] = -1 + (i & 1) * 2;
            vertexParams.myPosition[1] = -1 + ((i & 2) >> 1) * 2;
            vertexParams.myPosition[2] = 0;
            vertexParams.myTextureCoordinates = new PP.vec2_create();
            vertexParams.myTextureCoordinates[0] = i & 1;
            vertexParams.myTextureCoordinates[1] = (i & 2) >> 1;
            vertexParams.myNormal = new PP.vec3_create();
            vertexParams.myNormal[0] = 0;
            vertexParams.myNormal[1] = 0;
            vertexParams.myNormal[2] = 1;
            meshParams.myVertexes.push(vertexParams);
          }
          let firstTriangle = new PP.MeshCreationTriangleParams();
          firstTriangle.myIndexes[0] = 0;
          firstTriangle.myIndexes[1] = 1;
          firstTriangle.myIndexes[2] = 2;
          let secondTriangle = new PP.MeshCreationTriangleParams();
          secondTriangle.myIndexes[0] = 2;
          secondTriangle.myIndexes[1] = 1;
          secondTriangle.myIndexes[2] = 3;
          meshParams.myTriangles.push(firstTriangle);
          meshParams.myTriangles.push(secondTriangle);
          let mesh = PP.MeshUtils.createMesh(meshParams);
          return mesh;
        },
        createMesh: function(meshCreationParams) {
          let indexData = [];
          for (let triangle of meshCreationParams.myTriangles) {
            indexData.push(triangle.myIndexes[0]);
            indexData.push(triangle.myIndexes[1]);
            indexData.push(triangle.myIndexes[2]);
          }
          let indexDataUnsignedInt = new Uint32Array(indexData.length);
          indexDataUnsignedInt.pp_copy(indexData);
          let vertexCount = meshCreationParams.myVertexes.length;
          let mesh = new WL.Mesh({
            vertexCount,
            indexData: indexDataUnsignedInt,
            indexType: WL.MeshIndexType.UnsignedInt
          });
          let positionAttribute = null;
          let textureCoordinatesAttribute = null;
          let normalAttribute = null;
          let colorAttribute = null;
          try {
            positionAttribute = mesh.attribute(WL.MeshAttribute.Position);
          } catch (error) {
            positionAttribute = null;
          }
          try {
            textureCoordinatesAttribute = mesh.attribute(WL.MeshAttribute.TextureCoordinate);
          } catch (error) {
            textureCoordinatesAttribute = null;
          }
          try {
            normalAttribute = mesh.attribute(WL.MeshAttribute.Normal);
          } catch (error) {
            normalAttribute = null;
          }
          try {
            colorAttribute = mesh.attribute(WL.MeshAttribute.Color);
          } catch (error) {
            colorAttribute = null;
          }
          for (let i = 0; i < meshCreationParams.myVertexes.length; i++) {
            let vertex = meshCreationParams.myVertexes[i];
            if (positionAttribute != null && vertex.myPosition) {
              positionAttribute.set(i, vertex.myPosition);
            }
            if (textureCoordinatesAttribute != null && vertex.myTextureCoordinates) {
              textureCoordinatesAttribute.set(i, vertex.myTextureCoordinates);
            }
            if (normalAttribute != null && vertex.myNormal) {
              normalAttribute.set(i, vertex.myNormal);
            }
            if (colorAttribute != null && vertex.myColor) {
              colorAttribute.set(i, vertex.myColor);
            }
          }
          return mesh;
        },
        cloneMesh: function() {
          let position = PP.vec3_create();
          let textureCoordinates = PP.vec2_create();
          let normal = PP.vec3_create();
          let color = PP.vec4_create();
          return function cloneMesh(mesh) {
            if (mesh == null) {
              return null;
            }
            let clonedIndexData = new Uint32Array(mesh.indexData.length);
            for (let i = 0; i < mesh.indexData.length; i++) {
              clonedIndexData[i] = mesh.indexData[i];
            }
            let clonedMesh = new WL.Mesh({
              vertexCount: mesh.vertexCount,
              indexData: clonedIndexData,
              indexType: WL.MeshIndexType.UnsignedInt
            });
            let positionAttribute = null;
            let textureCoordinatesAttribute = null;
            let normalAttribute = null;
            let colorAttribute = null;
            let clonedPositionAttribute = null;
            let clonedTextureCoordinatesAttribute = null;
            let clonedNormalAttribute = null;
            let clonedColorAttribute = null;
            try {
              positionAttribute = mesh.attribute(WL.MeshAttribute.Position);
              clonedPositionAttribute = clonedMesh.attribute(WL.MeshAttribute.Position);
            } catch (error) {
              positionAttribute = null;
              clonedPositionAttribute = null;
            }
            try {
              textureCoordinatesAttribute = mesh.attribute(WL.MeshAttribute.TextureCoordinate);
              clonedTextureCoordinatesAttribute = clonedMesh.attribute(WL.MeshAttribute.TextureCoordinate);
            } catch (error) {
              textureCoordinatesAttribute = null;
              clonedTextureCoordinatesAttribute = null;
            }
            try {
              normalAttribute = mesh.attribute(WL.MeshAttribute.Normal);
              clonedNormalAttribute = clonedMesh.attribute(WL.MeshAttribute.Normal);
            } catch (error) {
              normalAttribute = null;
              clonedNormalAttribute = null;
            }
            try {
              colorAttribute = mesh.attribute(WL.MeshAttribute.Color);
              clonedColorAttribute = clonedMesh.attribute(WL.MeshAttribute.Color);
            } catch (error) {
              colorAttribute = null;
              clonedColorAttribute = null;
            }
            for (let i = 0; i < mesh.vertexCount; i++) {
              if (positionAttribute != null && clonedPositionAttribute != null) {
                clonedPositionAttribute.set(i, positionAttribute.get(i, position));
              }
              if (textureCoordinatesAttribute != null && clonedTextureCoordinatesAttribute != null) {
                clonedTextureCoordinatesAttribute.set(i, textureCoordinatesAttribute.get(i, textureCoordinates));
              }
              if (normalAttribute != null && clonedNormalAttribute != null) {
                clonedNormalAttribute.set(i, normalAttribute.get(i, normal));
              }
              if (colorAttribute != null && clonedColorAttribute != null) {
                clonedColorAttribute.set(i, colorAttribute.get(i, color));
              }
            }
            return clonedMesh;
          };
        }(),
        invertMesh: function() {
          let position = PP.vec3_create();
          let textureCoordinates = PP.vec2_create();
          let normal = PP.vec3_create();
          let color = PP.vec4_create();
          return function invertMesh(mesh) {
            if (mesh == null) {
              return null;
            }
            let invertedIndexData = new Uint32Array(mesh.indexData.length);
            for (let i = 0; i < mesh.indexData.length / 3; i++) {
              invertedIndexData[i * 3 + 0] = mesh.indexData[i * 3 + 2];
              invertedIndexData[i * 3 + 1] = mesh.indexData[i * 3 + 1];
              invertedIndexData[i * 3 + 2] = mesh.indexData[i * 3 + 0];
            }
            let invertedMesh = new WL.Mesh({
              vertexCount: mesh.vertexCount,
              indexData: invertedIndexData,
              indexType: WL.MeshIndexType.UnsignedInt
            });
            let positionAttribute = null;
            let textureCoordinatesAttribute = null;
            let normalAttribute = null;
            let colorAttribute = null;
            let invertedPositionAttribute = null;
            let invertedTextureCoordinatesAttribute = null;
            let invertedNormalAttribute = null;
            let invertedColorAttribute = null;
            try {
              positionAttribute = mesh.attribute(WL.MeshAttribute.Position);
              invertedPositionAttribute = invertedMesh.attribute(WL.MeshAttribute.Position);
            } catch (error) {
              positionAttribute = null;
              invertedPositionAttribute = null;
            }
            try {
              textureCoordinatesAttribute = mesh.attribute(WL.MeshAttribute.TextureCoordinate);
              invertedTextureCoordinatesAttribute = invertedMesh.attribute(WL.MeshAttribute.TextureCoordinate);
            } catch (error) {
              textureCoordinatesAttribute = null;
              invertedTextureCoordinatesAttribute = null;
            }
            try {
              normalAttribute = mesh.attribute(WL.MeshAttribute.Normal);
              invertedNormalAttribute = invertedMesh.attribute(WL.MeshAttribute.Normal);
            } catch (error) {
              normalAttribute = null;
              invertedNormalAttribute = null;
            }
            try {
              colorAttribute = mesh.attribute(WL.MeshAttribute.Color);
              invertedColorAttribute = invertedMesh.attribute(WL.MeshAttribute.Color);
            } catch (error) {
              colorAttribute = null;
              invertedColorAttribute = null;
            }
            for (let i = 0; i < mesh.vertexCount; i++) {
              if (positionAttribute != null && invertedPositionAttribute != null) {
                invertedPositionAttribute.set(i, positionAttribute.get(i, position));
              }
              if (textureCoordinatesAttribute != null && invertedTextureCoordinatesAttribute != null) {
                invertedTextureCoordinatesAttribute.set(i, textureCoordinatesAttribute.get(i, textureCoordinates));
              }
              if (normalAttribute != null && invertedNormalAttribute != null) {
                normalAttribute.get(i, normal);
                normal.vec3_negate(normal);
                invertedNormalAttribute.set(i, normal);
              }
              if (colorAttribute != null && invertedColorAttribute != null) {
                invertedColorAttribute.set(i, colorAttribute.get(i, color));
              }
            }
            return invertedMesh;
          };
        }()
      };
    }
  });

  // js/pp/cauldron/utils/save_utils.js
  var require_save_utils = __commonJS({
    "js/pp/cauldron/utils/save_utils.js"() {
      PP.SaveUtils = {
        save: function(id, value) {
          if (value != null) {
            localStorage.setItem(id, value);
          }
        },
        has: function(id) {
          return PP.SaveUtils.loadString(id, null) != null;
        },
        delete: function(id) {
          return localStorage.removeItem(id);
        },
        clear: function() {
          return localStorage.clear();
        },
        load: function(id, defaultValue = null) {
          return PP.SaveUtils.loadString(id, defaultValue);
        },
        loadString: function(id, defaultValue = null) {
          let item = localStorage.getItem(id);
          if (item != null) {
            return item;
          }
          return defaultValue;
        },
        loadNumber: function(id, defaultValue = null) {
          let item = PP.SaveUtils.loadString(id);
          if (item != null) {
            return Number(item);
          }
          return defaultValue;
        },
        loadBool: function(id, defaultValue = null) {
          let item = PP.SaveUtils.loadString(id);
          if (item == "true") {
            return true;
          } else if (item == "false") {
            return false;
          }
          return defaultValue;
        },
        loadObject: function(id, defaultValue = null) {
          let item = PP.SaveUtils.loadString(id);
          if (item != null) {
            try {
              const parsedValue = JSON.parse(item);
              if (parsedValue.constructor == Object) {
                return parsedValue;
              }
            } catch (error) {
            }
          }
          return defaultValue;
        }
      };
    }
  });

  // js/pp/cauldron/utils/text_utils.js
  var require_text_utils = __commonJS({
    "js/pp/cauldron/utils/text_utils.js"() {
      PP.TextUtils = {
        setClonedMaterials: function(object) {
          let textComponents = object.pp_getComponentsHierarchy("text");
          for (let textComponent of textComponents) {
            textComponent.material = textComponent.material.clone();
          }
        }
      };
    }
  });

  // js/pp/cauldron/utils/xr_utils.js
  var require_xr_utils = __commonJS({
    "js/pp/cauldron/utils/xr_utils.js"() {
      PP.XRUtils = {
        isDeviceEmulated: function() {
          let isEmulated = window.CustomWebXRPolyfill != null;
          return isEmulated;
        },
        isSessionActive: function() {
          return WL.xrSession != null;
        },
        isReferenceSpaceLocalFloor: function() {
          return !["local", "viewer"].includes(WebXR.refSpace);
        },
        openLink(url, newTab = true, exitXRSessionBeforeOpen = true, exitXRSessionOnSuccess = true, tryOpenLinkOnClickOnFailure = false, onSuccessCallback = null, onFailureCallback = null) {
          if (Global.myElementToClick != null)
            return;
          let element = document.createElement("a");
          element.style.display = "none";
          document.body.appendChild(element);
          element.addEventListener("click", function() {
            let targetPage = void 0;
            if (newTab) {
              targetPage = "_blank";
            } else {
              targetPage = "_top";
            }
            let result = window.open(url, targetPage);
            if (result != null) {
              if (!exitXRSessionBeforeOpen && exitXRSessionOnSuccess) {
                if (WL.xrSession) {
                  try {
                    WL.xrSession.end();
                  } catch (error) {
                  }
                }
              }
              if (onSuccessCallback != null) {
                onSuccessCallback();
              }
            } else {
              if (tryOpenLinkOnClickOnFailure) {
                setTimeout(function() {
                  PP.XRUtils.openLinkOnClick(url, newTab, exitXRSessionOnSuccess, onSuccessCallback, onFailureCallback);
                }, 100);
              } else if (onFailureCallback != null) {
                onFailureCallback();
              }
            }
          });
          if (exitXRSessionBeforeOpen) {
            if (WL.xrSession) {
              try {
                WL.xrSession.end();
              } catch (error) {
              }
            }
          }
          Global.myElementToClick = element;
          Global.myElementToClickCounter = 3;
        },
        openLinkOnClick(url, newTab = true, exitXRSessionOnSuccess = true, onSuccessCallback = null, onFailureCallback = null) {
          document.addEventListener("click", function() {
            let targetPage = void 0;
            if (newTab) {
              targetPage = "_blank";
            } else {
              targetPage = "_top";
            }
            let result = window.open(url, targetPage);
            if (result != null) {
              if (exitXRSessionOnSuccess) {
                if (WL.xrSession) {
                  try {
                    WL.xrSession.end();
                  } catch (error) {
                  }
                }
              }
              if (onSuccessCallback != null) {
                onSuccessCallback();
              }
            } else {
              if (onFailureCallback != null) {
                onFailureCallback();
              }
            }
          }, { once: true });
        }
      };
    }
  });

  // js/pp/cauldron/utils/browser_utils.js
  var require_browser_utils = __commonJS({
    "js/pp/cauldron/utils/browser_utils.js"() {
      PP.BrowserUtils = {
        isMobile: function() {
          return /Mobi/i.test(window.navigator.userAgent);
        },
        isDesktop: function() {
          return !PP.BrowserUtils.isMobile();
        }
      };
    }
  });

  // js/pp/cauldron/physics/physics_utils.js
  var require_physics_utils = __commonJS({
    "js/pp/cauldron/physics/physics_utils.js"() {
      PP.PhysicsUtils = {
        _myLayerFlagsAmount: 8,
        _myLayerFlagsNames: ["0", "1", "2", "3", "4", "5", "6", "7"],
        setLayerFlagsAmount: function(layerFlagsAmount) {
          PP.PhysicsUtils._myLayerFlagsAmount = layerFlagsAmount;
        },
        setLayerFlagsNames: function(layerFlagsNames) {
          PP.PhysicsUtils._myLayerFlagsNames = layerFlagsNames;
        },
        getLayerFlagsAmount: function() {
          return PP.PhysicsUtils._myLayerFlagsAmount;
        },
        getLayerFlagsNames: function() {
          return PP.PhysicsUtils._myLayerFlagsNames;
        },
        raycast: function() {
          let objectsEqualCallback = (first, second) => first.pp_equals(second);
          return function raycast(raycastSetup, raycastResults = new PP.RaycastResults()) {
            let internalRaycastResults = WL.physics.rayCast(raycastSetup.myOrigin, raycastSetup.myDirection, raycastSetup.myBlockLayerFlags.getMask(), raycastSetup.myDistance);
            raycastResults.myRaycastSetup = raycastSetup;
            let currentValidHitIndex = 0;
            let validHitsCount = 0;
            for (let i = 0; i < internalRaycastResults.hitCount; i++) {
              let isHitValid = true;
              isHitValid = isHitValid && (raycastSetup.myObjectsToIgnore.length == 0 || !raycastSetup.myObjectsToIgnore.pp_hasEqual(internalRaycastResults.objects[i], objectsEqualCallback));
              let isHitInsideCollision = isHitValid && internalRaycastResults.distances[i] == 0 && (raycastSetup.myOrigin.vec3_distance(internalRaycastResults.locations[i]) < 1e-5 && Math.abs(raycastSetup.myDirection.vec3_angle(internalRaycastResults.normals[i]) - 180) < 1e-5);
              isHitValid = isHitValid && (!raycastSetup.myIgnoreHitsInsideCollision || !isHitInsideCollision);
              if (isHitValid) {
                let hit = null;
                if (currentValidHitIndex < raycastResults.myHits.length) {
                  hit = raycastResults.myHits[currentValidHitIndex];
                } else if (raycastResults._myUnusedHits != null && raycastResults._myUnusedHits.length > 0) {
                  hit = raycastResults._myUnusedHits.pop();
                  raycastResults.myHits.push(hit);
                } else {
                  hit = new PP.RaycastHit();
                  raycastResults.myHits.push(hit);
                }
                hit.myPosition.vec3_copy(internalRaycastResults.locations[i]);
                hit.myNormal.vec3_copy(internalRaycastResults.normals[i]);
                hit.myDistance = internalRaycastResults.distances[i];
                hit.myObject = internalRaycastResults.objects[i];
                hit.myIsInsideCollision = isHitInsideCollision;
                validHitsCount++;
                currentValidHitIndex++;
              }
            }
            if (raycastResults.myHits.length > validHitsCount) {
              if (raycastResults._myUnusedHits == null) {
                raycastResults._myUnusedHits = [];
              }
              let hitsToRemove = raycastResults.myHits.length - validHitsCount;
              for (let i = 0; i < hitsToRemove; i++) {
                raycastResults._myUnusedHits.push(raycastResults.myHits.pop());
              }
            }
            return raycastResults;
          };
        }()
      };
    }
  });

  // js/pp/cauldron/physics/physics_raycast_data.js
  var require_physics_raycast_data = __commonJS({
    "js/pp/cauldron/physics/physics_raycast_data.js"() {
      PP.RaycastSetup = class RaycastSetup {
        constructor() {
          this.myOrigin = PP.vec3_create();
          this.myDirection = PP.vec3_create();
          this.myDistance = 0;
          this.myBlockLayerFlags = new PP.PhysicsLayerFlags();
          this.myObjectsToIgnore = [];
          this.myIgnoreHitsInsideCollision = false;
        }
        copy(setup) {
          this.myOrigin.vec3_copy(setup.myOrigin);
          this.myDirection.vec3_copy(setup.myDirection);
          this.myDistance = setup.myDistance;
          this.myBlockLayerFlags.copy(setup.myBlockLayerFlags);
          this.myObjectsToIgnore.pp_copy(setup.myObjectsToIgnore);
          this.myIgnoreHitsInsideCollision = setup.myIgnoreHitsInsideCollision;
        }
      };
      PP.RaycastResults = class RaycastResult {
        constructor() {
          this.myRaycastSetup = null;
          this.myHits = [];
          this._myUnusedHits = null;
        }
        isColliding(ignoreHitsInsideCollision = false) {
          return ignoreHitsInsideCollision ? this.getFirstHitOutsideCollision() != null : this.myHits.length > 0;
        }
        getFirstHitInsideCollision() {
          let firstHit = null;
          for (let hit of this.myHits) {
            if (hit.myIsInsideCollision) {
              firstHit = hit;
              break;
            }
          }
          return firstHit;
        }
        getFirstHitOutsideCollision() {
          let firstHit = null;
          for (let hit of this.myHits) {
            if (!hit.myIsInsideCollision) {
              firstHit = hit;
              break;
            }
          }
          return firstHit;
        }
        getHitsInsideCollision() {
          let hits = [];
          for (let hit of this.myHits) {
            if (hit.myIsInsideCollision) {
              hits.push(hit);
            }
          }
          return hits;
        }
        getHitsOutsideCollision() {
          let hits = [];
          for (let hit of this.myHits) {
            if (!hit.myIsInsideCollision) {
              hits.push(hit);
            }
          }
          return hits;
        }
        removeHit(hitIndex) {
          let removedHit = this.myHits.pp_removeIndex(hitIndex);
          if (removedHit != null) {
            if (this._myUnusedHits == null) {
              this._myUnusedHits = [];
            }
            this._myUnusedHits.push(removedHit);
          }
          return removedHit;
        }
        copy(result) {
        }
      };
      PP.RaycastHit = class RaycastHit {
        constructor() {
          this.myPosition = PP.vec3_create();
          this.myNormal = PP.vec3_create();
          this.myDistance = 0;
          this.myObject = null;
          this.myIsInsideCollision = false;
        }
        isValid() {
          return this.myObject != null;
        }
        copy(hit) {
          this.myPosition.vec3_copy(hit.myPosition);
          this.myNormal.vec3_copy(hit.myNormal);
          this.myDistance = hit.myDistance;
          this.myObject = hit.myObject;
          this.myIsInsideCollision = hit.myIsInsideCollision;
        }
        reset() {
          this.myPosition.vec3_zero();
          this.myNormal.vec3_zero();
          this.myDistance = 0;
          this.myObject = null;
          this.myIsInsideCollision = false;
        }
      };
      PP.RaycastResults.prototype.copy = function() {
        let copyHitCallback = function(currentElement, elementToCopy) {
          if (currentElement == null) {
            currentElement = new PP.RaycastHit();
          }
          currentElement.copy(elementToCopy);
          return currentElement;
        };
        return function copy8(result) {
          if (result.myRaycastSetup == null) {
            this.myRaycastSetup = null;
          } else {
            if (this.myRaycastSetup == null) {
              this.myRaycastSetup = new PP.RaycastSetup();
            }
            this.myRaycastSetup.copy(result.myRaycastSetup);
          }
          if (this.myHits.length > result.myHits.length) {
            if (this._myUnusedHits == null) {
              this._myUnusedHits = [];
            }
            for (let i = 0; i < this.myHits.length - result.myHits.length; i++) {
              this._myUnusedHits.push(this.myHits.pop());
            }
          } else if (this.myHits.length < result.myHits.length) {
            if (this._myUnusedHits != null) {
              let length6 = Math.min(this._myUnusedHits.length, result.myHits.length - this.myHits.length);
              for (let i = 0; i < length6; i++) {
                this.myHits.push(this._myUnusedHits.pop());
              }
            }
          }
          this.myHits.pp_copy(result.myHits, copyHitCallback);
        };
      }();
      Object.defineProperty(PP.RaycastResults.prototype, "copy", { enumerable: false });
    }
  });

  // js/pp/cauldron/physics/physics_layer_flags.js
  var require_physics_layer_flags = __commonJS({
    "js/pp/cauldron/physics/physics_layer_flags.js"() {
      PP.PhysicsLayerFlags = class PhysicsLayerFlags {
        constructor() {
          this._myLayerMask = 0;
        }
        setFlagActive(indexOrName, active) {
          let index = indexOrName;
          if (isNaN(indexOrName)) {
            index = PP.PhysicsUtils.getLayerFlagsNames().pp_findIndexEqual(indexOrName);
          }
          if (index >= 0 && index < PP.PhysicsUtils.getLayerFlagsAmount()) {
            let mask = 1 << index;
            if (active) {
              this._myLayerMask = this._myLayerMask | mask;
            } else {
              this._myLayerMask = this._myLayerMask & ~mask;
            }
          }
        }
        isFlagActive(indexOrName) {
          let index = indexOrName;
          if (isNaN(indexOrName)) {
            index = PP.PhysicsUtils.getLayerFlagsNames().pp_findIndexEqual(indexOrName);
          }
          let isActive = false;
          if (index >= 0 && index < PP.PhysicsUtils.getLayerFlagsAmount()) {
            let mask = 1 << index;
            isActive = !!(this._myLayerMask & mask);
          }
          return isActive;
        }
        setAllFlagsActive(active) {
          if (!active) {
            this._myLayerMask = 0;
          } else {
            this._myLayerMask = Math.pow(2, PP.PhysicsUtils.getLayerFlagsAmount()) - 1;
          }
        }
        add(layerFlags) {
          this._myLayerMask = this._myLayerMask | layerFlags.getMask();
        }
        remove(layerFlags) {
          this._myLayerMask = this._myLayerMask & ~layerFlags.getMask();
        }
        intersect(layerFlags) {
          this._myLayerMask = this._myLayerMask & layerFlags.getMask();
        }
        copy(layerFlags) {
          this._myLayerMask = layerFlags._myLayerMask;
        }
        getMask() {
          return this._myLayerMask;
        }
        setMask(layerMask) {
          this._myLayerMask = layerMask;
        }
      };
    }
  });

  // js/pp/cauldron/physics/physics_collision_collector.js
  var require_physics_collision_collector = __commonJS({
    "js/pp/cauldron/physics/physics_collision_collector.js"() {
      PP.PhysicsCollisionCollector = class PhysicsCollisionCollector {
        constructor(physXComponent, isTrigger = false) {
          this._myPhysX = physXComponent;
          this._myIsTrigger = isTrigger;
          this._myCollisions = [];
          this._myCollisionsStart = [];
          this._myCollisionsEnd = [];
          this._myUpdateActive = false;
          this._myCollisionsStartToProcess = [];
          this._myCollisionsEndToProcess = [];
          this._myCollisionCallbackID = null;
          this._myIsActive = false;
          this.setActive(true);
          this._myDebugActive = false;
          this._myTriggerDesyncFixDelay = new PP.Timer(0.1);
          this._myCollisionCallbacks = /* @__PURE__ */ new Map();
          this._myCollisionStartCallbacks = /* @__PURE__ */ new Map();
          this._myCollisionEndCallbacks = /* @__PURE__ */ new Map();
        }
        getPhysX() {
          return this._myPhysX;
        }
        getCollisions() {
          return this._myCollisions;
        }
        getCollisionsStart() {
          return this._myCollisionsStart;
        }
        getCollisionsEnd() {
          return this._myCollisionsEnd;
        }
        setActive(active) {
          if (this._myIsActive != active) {
            this._myIsActive = active;
            this._myCollisions = [];
            this._myCollisionsStart = [];
            this._myCollisionsEnd = [];
            this._myUpdateActive = false;
            this._myCollisionsStartToProcess = [];
            this._myCollisionsEndToProcess = [];
            if (this._myIsActive) {
              this._myCollisionCallbackID = this._myPhysX.onCollision(this._onCollision.bind(this));
            } else if (this._myCollisionCallbackID != null) {
              this._myPhysX.removeCollisionCallback(this._myCollisionCallbackID);
              this._myCollisionCallbackID = null;
            }
          }
        }
        //Set to true only if u are going to actually update this object and don't want to lose any collision start/end events prior to updating the first time after activation
        setUpdateActive(active) {
          this._myUpdateActive = active;
        }
        //Update is not mandatory, use it only if u want to access collisions start and end
        update(dt) {
          if (!this._myIsActive) {
            return;
          }
          this._myUpdateActive = true;
          this._myCollisionsStart = this._myCollisionsStartToProcess;
          this._myCollisionsStartToProcess = [];
          this._myCollisionsEnd = this._myCollisionsEndToProcess;
          this._myCollisionsEndToProcess = [];
          if (this._myIsTrigger) {
            this._triggerDesyncFix(dt);
          }
        }
        destroy() {
          if (this._myCollisionCallbackID != null) {
            this._myPhysX.removeCollisionCallback(this._myCollisionCallbackID);
            this._myCollisionCallbackID = null;
          }
        }
        setDebugActive(active) {
          this._myDebugActive = active;
        }
        registerCollisionEventListener(callbackID, callback) {
          this._myCollisionCallbacks.set(callbackID, callback);
        }
        unregisterCollisionEventListener(callbackID) {
          this._myCollisionCallbacks.delete(callbackID);
        }
        registerCollisionStartEventListener(callbackID, callback) {
          this._myCollisionStartCallbacks.set(callbackID, callback);
        }
        unregisterCollisionStartEventListener(callbackID) {
          this._myCollisionStartCallbacks.delete(callbackID);
        }
        registerCollisionEndEventListener(callbackID, callback) {
          this._myCollisionEndCallbacks.set(callbackID, callback);
        }
        unregisterCollisionEndEventListener(callbackID) {
          this._myCollisionEndCallbacks.delete(callbackID);
        }
        _onCollision(type, physXComponent) {
          if (type == WL.CollisionEventType.Touch || type == WL.CollisionEventType.TriggerTouch) {
            this._onCollisionStart(type, physXComponent);
          } else if (type == WL.CollisionEventType.TouchLost || type == WL.CollisionEventType.TriggerTouchLost) {
            this._onCollisionEnd(type, physXComponent);
          }
          if (this._myCollisionCallbacks.size > 0) {
            this._myCollisionCallbacks.forEach(function(callback) {
              callback(this._myPhysX, physXComponent, type);
            });
          }
        }
        _onCollisionStart(type, physXComponent) {
          if (this._myDebugActive) {
            let objectFound = false;
            for (let object of this._myCollisions) {
              if (object.pp_equals(physXComponent.object)) {
                objectFound = true;
                break;
              }
            }
            if (objectFound) {
              console.error("Collision Start on object already collected");
            }
          }
          this._myCollisions.push(physXComponent.object);
          if (this._myUpdateActive) {
            this._myCollisionsStartToProcess.push(physXComponent.object);
            this._myCollisionsEndToProcess.pp_removeAll(function(element) {
              return element.pp_equals(physXComponent.object);
            });
          }
          if (this._myDebugActive) {
            console.log("Collision Start -", this._myCollisions.length);
          }
          if (this._myCollisionStartCallbacks.size > 0) {
            this._myCollisionStartCallbacks.forEach(function(callback) {
              callback(this._myPhysX, physXComponent, type);
            });
          }
        }
        _onCollisionEnd(type, physXComponent) {
          if (this._myDebugActive) {
            let objectFound = false;
            for (let object of this._myCollisions) {
              if (object.pp_equals(physXComponent.object)) {
                objectFound = true;
                break;
              }
            }
            if (!objectFound) {
              console.error("Collision End on object not collected");
            }
          }
          this._myCollisions.pp_removeAll(function(element) {
            return element.pp_equals(physXComponent.object);
          });
          if (this._myUpdateActive) {
            this._myCollisionsEndToProcess.push(physXComponent.object);
            this._myCollisionsStartToProcess.pp_removeAll(function(element) {
              return element.pp_equals(physXComponent.object);
            });
          }
          if (this._myDebugActive) {
            console.log("Collision End -", this._myCollisions.length);
          }
          if (this._myCollisionEndCallbacks.size > 0) {
            this._myCollisionEndCallbacks.forEach(function(callback) {
              callback(this._myPhysX, physXComponent, type);
            });
          }
        }
        _triggerDesyncFix(dt) {
          this._myTriggerDesyncFixDelay.update(dt);
          if (this._myTriggerDesyncFixDelay.isDone()) {
            this._myTriggerDesyncFixDelay.start();
            let collisionsToEnd = this._myCollisions.pp_findAll(function(element) {
              let physX = element.pp_getComponentSelf("physx");
              return physX == null || !physX.active;
            });
            if (collisionsToEnd.length > 0) {
              for (let collision of collisionsToEnd) {
                let physX = collision.pp_getComponentSelf("physx");
                if (physX) {
                  this._onCollisionEnd(WL.CollisionEventType.TriggerTouchLost, physX);
                } else {
                  console.error("NO PHYSX, HOW?");
                }
              }
            }
          }
        }
      };
    }
  });

  // js/pp/cauldron/visual/visual_manager.js
  var require_visual_manager = __commonJS({
    "js/pp/cauldron/visual/visual_manager.js"() {
      PP.VisualManager = class VisualManager {
        constructor() {
          this._myVisualElementPrototypeCreationCallbacks = /* @__PURE__ */ new Map();
          this._myVisualElementsTypeMap = /* @__PURE__ */ new Map();
          this._myVisualElementLastID = 0;
          this._myVisualElementsPool = new PP.ObjectPoolManager();
          this._myVisualElementsToShow = [];
          this._myActive = true;
          this._addStandardVisualElementTypes();
        }
        setActive(active) {
          if (this._myActive != active) {
            this._myActive = active;
            if (!this._myActive) {
              this.clearDraw();
            }
          }
        }
        isActive() {
          return this._myActive;
        }
        start() {
        }
        update(dt) {
          this._updateDraw(dt);
        }
        //lifetimeSeconds can be null, in that case the element will be drawn until cleared
        draw(visualElementParams, lifetimeSeconds = 0, idToReuse = null) {
          if (!this._myActive) {
            return 0;
          }
          let visualElement = null;
          let idReused = false;
          if (idToReuse != null) {
            if (this._myVisualElementsTypeMap.has(visualElementParams.myType)) {
              let visualElements2 = this._myVisualElementsTypeMap.get(visualElementParams.myType);
              if (visualElements2.has(idToReuse)) {
                visualElement = visualElements2.get(idToReuse)[0];
                visualElement.setParams(visualElementParams);
                visualElement.setVisible(false);
                idReused = true;
              }
            }
          }
          if (visualElement == null) {
            visualElement = this._getVisualElement(visualElementParams);
          }
          if (visualElement == null) {
            console.error("Couldn't create the requested visual element");
            return null;
          }
          if (!this._myVisualElementsTypeMap.has(visualElementParams.myType)) {
            this._myVisualElementsTypeMap.set(visualElementParams.myType, /* @__PURE__ */ new Map());
          }
          let visualElements = this._myVisualElementsTypeMap.get(visualElementParams.myType);
          let elementID = null;
          if (!idReused) {
            elementID = this._myVisualElementLastID + 1;
            this._myVisualElementLastID = elementID;
            visualElements.set(elementID, [visualElement, new PP.Timer(lifetimeSeconds, lifetimeSeconds != null)]);
          } else {
            elementID = idToReuse;
            let visualElementPair = visualElements.get(elementID);
            visualElementPair[0] = visualElement;
            visualElementPair[1].reset(lifetimeSeconds);
            if (lifetimeSeconds != null) {
              visualElementPair[1].start();
            }
          }
          this._myVisualElementsToShow.push(visualElement);
          return elementID;
        }
        getDraw(elementID) {
          let visualElement = null;
          for (let visualElements of this._myVisualElementsTypeMap.values()) {
            if (visualElements.has(elementID)) {
              let visualElementPair = visualElements.get(elementID);
              visualElement = visualElementPair[0];
              break;
            }
          }
          return visualElement;
        }
        clearDraw(elementID = null) {
          if (elementID == null) {
            for (let visualElements of this._myVisualElementsTypeMap.values()) {
              for (let visualElement of visualElements.values()) {
                this._myVisualElementsPool.releaseObject(visualElement[0].getParams().myType, visualElement[0]);
              }
            }
            this._myVisualElementsToShow = [];
            this._myVisualElementsTypeMap = /* @__PURE__ */ new Map();
            this._myVisualElementLastID = 0;
          } else {
            for (let visualElements of this._myVisualElementsTypeMap.values()) {
              if (visualElements.has(elementID)) {
                let visualElementPair = visualElements.get(elementID);
                this._myVisualElementsPool.releaseObject(visualElementPair[0].getParams().myType, visualElementPair[0]);
                visualElements.delete(elementID);
                this._myVisualElementsToShow.pp_removeEqual(visualElementPair[0]);
                break;
              }
            }
          }
        }
        allocateDraw(visualElementType, amount) {
          if (!this._myVisualElementsPool.hasPool(visualElementType)) {
            this._addVisualElementTypeToPool(visualElementType);
          }
          let pool = this._myVisualElementsPool.getPool(visualElementType);
          let difference = pool.getAvailableSize() - amount;
          if (difference < 0) {
            pool.increase(-difference);
          }
        }
        addVisualElementType(visualElementType, visuaElementPrototypeCreationCallback) {
          this._myVisualElementPrototypeCreationCallbacks.set(visualElementType, visuaElementPrototypeCreationCallback);
        }
        removeVisualElementType(visualElementType) {
          this._myVisualElementPrototypeCreationCallbacks.delete(visualElementType);
        }
        _updateDraw(dt) {
          for (let visualElement of this._myVisualElementsToShow) {
            visualElement.setVisible(true);
          }
          this._myVisualElementsToShow = [];
          for (let visualElements of this._myVisualElementsTypeMap.values()) {
            let idsToRemove = [];
            for (let visualElementsEntry of visualElements.entries()) {
              let visualElement = visualElementsEntry[1];
              if (visualElement[1].isDone()) {
                this._myVisualElementsPool.releaseObject(visualElement[0].getParams().myType, visualElement[0]);
                idsToRemove.push(visualElementsEntry[0]);
              }
              visualElement[1].update(dt);
            }
            for (let id of idsToRemove) {
              visualElements.delete(id);
            }
          }
        }
        _getVisualElement(params) {
          let element = null;
          if (!this._myVisualElementsPool.hasPool(params.myType)) {
            this._addVisualElementTypeToPool(params.myType);
          }
          element = this._myVisualElementsPool.getObject(params.myType);
          if (element != null) {
            element.setParams(params);
          }
          return element;
        }
        _addVisualElementTypeToPool(type) {
          let objectPoolParams = new PP.ObjectPoolParams();
          objectPoolParams.myInitialPoolSize = 10;
          objectPoolParams.myAmountToAddWhenEmpty = 0;
          objectPoolParams.myPercentageToAddWhenEmpty = 0.5;
          objectPoolParams.myEnableDebugLog = false;
          objectPoolParams.mySetActiveCallback = function(object, active) {
            object.setVisible(active);
          };
          let visualElementPrototype = null;
          if (this._myVisualElementPrototypeCreationCallbacks.has(type)) {
            visualElementPrototype = this._myVisualElementPrototypeCreationCallbacks.get(type)();
          }
          if (visualElementPrototype != null) {
            visualElementPrototype.setVisible(false);
            visualElementPrototype.setAutoRefresh(true);
            this._myVisualElementsPool.addPool(type, visualElementPrototype, objectPoolParams);
          } else {
            console.error("Visual element type not supported");
          }
        }
        _addStandardVisualElementTypes() {
          this.addVisualElementType(PP.VisualElementType.LINE, () => new PP.VisualLine());
          this.addVisualElementType(PP.VisualElementType.MESH, () => new PP.VisualMesh());
          this.addVisualElementType(PP.VisualElementType.POINT, () => new PP.VisualPoint());
          this.addVisualElementType(PP.VisualElementType.ARROW, () => new PP.VisualArrow());
          this.addVisualElementType(PP.VisualElementType.TEXT, () => new PP.VisualText());
          this.addVisualElementType(PP.VisualElementType.TRANSFORM, () => new PP.VisualTransform());
          this.addVisualElementType(PP.VisualElementType.RAYCAST, () => new PP.VisualRaycast());
          this.addVisualElementType(PP.VisualElementType.TORUS, () => new PP.VisualTorus());
        }
      };
    }
  });

  // js/pp/cauldron/visual/elements/visual_element_types.js
  var require_visual_element_types = __commonJS({
    "js/pp/cauldron/visual/elements/visual_element_types.js"() {
      PP.VisualElementType = {
        MESH: 0,
        LINE: 1,
        POINT: 2,
        TEXT: 3,
        ARROW: 4,
        TRANSFORM: 5,
        RAYCAST: 6,
        TORUS: 7
      };
    }
  });

  // js/pp/cauldron/visual/elements/visual_line.js
  var require_visual_line = __commonJS({
    "js/pp/cauldron/visual/elements/visual_line.js"() {
      PP.VisualLineParams = class VisualLineParams {
        constructor() {
          this.myStart = PP.vec3_create();
          this.myDirection = PP.vec3_create(0, 0, 1);
          this.myLength = 0;
          this.myThickness = 5e-3;
          this.myMesh = null;
          this.myMaterial = null;
          this.myColor = null;
          this.myParent = PP.myVisualData.myRootObject;
          this.myIsLocal = false;
          this.myType = PP.VisualElementType.LINE;
        }
        setStartEnd(start, end) {
          end.vec3_sub(start, this.myDirection);
          this.myLength = this.myDirection.vec3_length();
          this.myDirection.vec3_normalize(this.myDirection);
          this.myStart.vec3_copy(start);
          return this;
        }
      };
      PP.VisualLine = class VisualLine {
        constructor(params = new PP.VisualLineParams()) {
          this._myParams = params;
          this._myVisible = false;
          this._myAutoRefresh = true;
          this._myDirty = false;
          this._myLineRootObject = null;
          this._myLineObject = null;
          this._myLineMeshComponent = null;
          this._myFlatOpaqueMaterial = null;
          this._build();
          this.forceRefresh();
          this.setVisible(true);
        }
        setVisible(visible) {
          if (this._myVisible != visible) {
            this._myVisible = visible;
            this._myLineRootObject.pp_setActive(visible);
          }
        }
        setAutoRefresh(autoRefresh) {
          this._myAutoRefresh = autoRefresh;
        }
        getParams() {
          return this._myParams;
        }
        setParams(params) {
          this._myParams = params;
          this._markDirty();
        }
        paramsUpdated() {
          this._markDirty();
        }
        refresh() {
          this.update(0);
        }
        forceRefresh() {
          this._refresh();
        }
        update(dt) {
          if (this._myDirty) {
            this._refresh();
            this._myDirty = false;
          }
        }
        _build() {
          this._myLineRootObject = WL.scene.addObject(null);
          this._myLineObject = WL.scene.addObject(this._myLineRootObject);
          this._myLineMeshComponent = this._myLineObject.addComponent("mesh");
        }
        _markDirty() {
          this._myDirty = true;
          if (this._myAutoRefresh) {
            this.update(0);
          }
        }
        clone() {
          let clonedParams = new PP.VisualLineParams();
          clonedParams.myStart.vec3_copy(this._myParams.myStart);
          clonedParams.myDirection.vec3_copy(this._myParams.myDirection);
          clonedParams.myLength = this._myParams.myLength;
          clonedParams.myThickness = this._myParams.myThickness;
          clonedParams.myMesh = this._myParams.myMesh;
          if (this._myParams.myMaterial != null) {
            clonedParams.myMaterial = this._myParams.myMaterial.clone();
          } else {
            clonedParams.myMaterial = null;
          }
          if (this._myParams.myColor != null) {
            clonedParams.myColor.vec4_copy(this._myParams.myColor);
          } else {
            clonedParams.myColor = null;
          }
          clonedParams.myParent = this._myParams.myParent;
          clonedParams.myIsLocal = this._myParams.myIsLocal;
          let clone8 = new PP.VisualLine(clonedParams);
          clone8.setAutoRefresh(this._myAutoRefresh);
          clone8.setVisible(this._myVisible);
          clone8._myDirty = this._myDirty;
          return clone8;
        }
      };
      PP.VisualLine.prototype._refresh = function() {
        let scaleLine = PP.vec3_create();
        let translateLine = PP.vec3_create();
        let forward = PP.vec3_create(0, 1, 0);
        return function _refresh() {
          this._myLineRootObject.pp_setParent(this._myParams.myParent, false);
          if (this._myParams.myIsLocal) {
            this._myLineRootObject.pp_setPositionLocal(this._myParams.myStart);
          } else {
            this._myLineRootObject.pp_setPosition(this._myParams.myStart);
          }
          scaleLine.vec3_set(this._myParams.myThickness / 2, this._myParams.myLength / 2, this._myParams.myThickness / 2);
          if (this._myParams.myIsLocal) {
            this._myLineObject.pp_setScaleLocal(scaleLine);
          } else {
            this._myLineObject.pp_setScale(scaleLine);
          }
          if (this._myParams.myIsLocal) {
            this._myLineObject.pp_setUpLocal(this._myParams.myDirection, forward);
          } else {
            this._myLineObject.pp_setUp(this._myParams.myDirection, forward);
          }
          this._myLineObject.pp_resetPositionLocal();
          translateLine.vec3_set(0, this._myParams.myLength / 2, 0);
          this._myLineObject.pp_translateObject(translateLine);
          if (this._myParams.myMesh != null) {
            this._myLineMeshComponent.mesh = this._myParams.myMesh;
          } else {
            this._myLineMeshComponent.mesh = PP.myDefaultResources.myMeshes.myCylinder;
          }
          if (this._myParams.myMaterial == null) {
            if (this._myParams.myColor == null) {
              this._myLineMeshComponent.material = PP.myVisualData.myDefaultMaterials.myDefaultMeshMaterial;
            } else {
              if (this._myFlatOpaqueMaterial == null) {
                this._myFlatOpaqueMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
              }
              this._myLineMeshComponent.material = this._myFlatOpaqueMaterial;
              this._myFlatOpaqueMaterial.color = this._myParams.myColor;
            }
          } else {
            this._myLineMeshComponent.material = this._myParams.myMaterial;
          }
        };
      }();
      Object.defineProperty(PP.VisualLine.prototype, "_refresh", { enumerable: false });
    }
  });

  // js/pp/cauldron/visual/elements/visual_mesh.js
  var require_visual_mesh = __commonJS({
    "js/pp/cauldron/visual/elements/visual_mesh.js"() {
      PP.VisualMeshParams = class VisualMeshParams {
        constructor() {
          this.myTransform = PP.mat4_create();
          this.myMesh = null;
          this.myMaterial = null;
          this.myParent = PP.myVisualData.myRootObject;
          this.myIsLocal = false;
          this.myType = PP.VisualElementType.MESH;
        }
      };
      PP.VisualMesh = class VisualMesh {
        constructor(params = new PP.VisualMeshParams()) {
          this._myParams = params;
          this._myVisible = false;
          this._myAutoRefresh = true;
          this._myDirty = false;
          this._myMeshObject = null;
          this._myMeshComponent = null;
          this._build();
          this.forceRefresh();
          this.setVisible(true);
        }
        setVisible(visible) {
          if (this._myVisible != visible) {
            this._myVisible = visible;
            this._myMeshObject.pp_setActive(visible);
          }
        }
        setAutoRefresh(autoRefresh) {
          this._myAutoRefresh = autoRefresh;
        }
        getParams() {
          return this._myParams;
        }
        setParams(params) {
          this._myParams = params;
          this._markDirty();
        }
        paramsUpdated() {
          this._markDirty();
        }
        refresh() {
          this.update(0);
        }
        forceRefresh() {
          this._refresh();
        }
        update(dt) {
          if (this._myDirty) {
            this._refresh();
            this._myDirty = false;
          }
        }
        _refresh() {
          this._myMeshObject.pp_setParent(this._myParams.myParent, false);
          if (this._myParams.myIsLocal) {
            this._myMeshObject.pp_setTransformLocal(this._myParams.myTransform);
          } else {
            this._myMeshObject.pp_setTransform(this._myParams.myTransform);
          }
          if (this._myParams.myMesh == null) {
            this._myMeshComponent.mesh = PP.myDefaultResources.myMeshes.mySphere;
          } else {
            this._myMeshComponent.mesh = this._myParams.myMesh;
          }
          if (this._myParams.myMaterial == null) {
            this._myMeshComponent.material = PP.myVisualData.myDefaultMaterials.myDefaultMeshMaterial;
          } else {
            this._myMeshComponent.material = this._myParams.myMaterial;
          }
        }
        _build() {
          this._myMeshObject = WL.scene.addObject(null);
          this._myMeshComponent = this._myMeshObject.addComponent("mesh");
        }
        _markDirty() {
          this._myDirty = true;
          if (this._myAutoRefresh) {
            this.update(0);
          }
        }
        clone() {
          let clonedParams = new PP.VisualMeshParams();
          clonedParams.myTransform.pp_copy(this._myParams.myTransform);
          if (this._myParams.myMesh != null) {
            clonedParams.myMesh = this._myParams.myMesh;
          } else {
            clonedParams.myMesh = null;
          }
          if (this._myParams.myMaterial != null) {
            clonedParams.myMaterial = this._myParams.myMaterial.clone();
          } else {
            clonedParams.myMaterial = null;
          }
          clonedParams.myParent = this._myParams.myParent;
          clonedParams.myIsLocal = this._myParams.myIsLocal;
          let clone8 = new PP.VisualMesh(clonedParams);
          clone8.setAutoRefresh(this._myAutoRefresh);
          clone8.setVisible(this._myVisible);
          clone8._myDirty = this._myDirty;
          return clone8;
        }
      };
    }
  });

  // js/pp/cauldron/visual/elements/visual_point.js
  var require_visual_point = __commonJS({
    "js/pp/cauldron/visual/elements/visual_point.js"() {
      PP.VisualPointParams = class VisualPointParams {
        constructor() {
          this.myPosition = PP.vec3_create();
          this.myRadius = 5e-3;
          this.myMesh = null;
          this.myMaterial = null;
          this.myColor = null;
          this.myParent = PP.myVisualData.myRootObject;
          this.myIsLocal = false;
          this.myType = PP.VisualElementType.POINT;
        }
      };
      PP.VisualPoint = class VisualPoint {
        constructor(params = new PP.VisualPointParams()) {
          this._myParams = params;
          this._myVisible = false;
          this._myAutoRefresh = true;
          this._myDirty = false;
          this._myPointObject = null;
          this._myPointMeshComponent = null;
          this._myFlatOpaqueMaterial = null;
          this._build();
          this.forceRefresh();
          this.setVisible(true);
        }
        setVisible(visible) {
          if (this._myVisible != visible) {
            this._myVisible = visible;
            this._myPointObject.pp_setActive(visible);
          }
        }
        setAutoRefresh(autoRefresh) {
          this._myAutoRefresh = autoRefresh;
        }
        getParams() {
          return this._myParams;
        }
        setParams(params) {
          this._myParams = params;
          this._markDirty();
        }
        paramsUpdated() {
          this._markDirty();
        }
        refresh() {
          this.update(0);
        }
        forceRefresh() {
          this._refresh();
        }
        update(dt) {
          if (this._myDirty) {
            this._refresh();
            this._myDirty = false;
          }
        }
        _build() {
          this._myPointObject = WL.scene.addObject(null);
          this._myPointMeshComponent = this._myPointObject.addComponent("mesh");
        }
        _markDirty() {
          this._myDirty = true;
          if (this._myAutoRefresh) {
            this.update(0);
          }
        }
        clone() {
          let clonedParams = new PP.VisualPointParams();
          clonedParams.myPosition.vec3_copy(this._myParams.myPosition);
          clonedParams.myRadius = this._myParams.myRadius;
          clonedParams.myMesh = this._myParams.myMesh;
          if (this._myParams.myMaterial != null) {
            clonedParams.myMaterial = this._myParams.myMaterial.clone();
          } else {
            clonedParams.myMaterial = null;
          }
          if (this._myParams.myColor != null) {
            clonedParams.myColor.vec4_copy(this._myParams.myColor);
          } else {
            clonedParams.myColor = null;
          }
          clonedParams.myParent = this._myParams.myParent;
          clonedParams.myIsLocal = this._myParams.myIsLocal;
          let clone8 = new PP.VisualPoint(clonedParams);
          clone8.setAutoRefresh(this._myAutoRefresh);
          clone8.setVisible(this._myVisible);
          clone8._myDirty = this._myDirty;
          return clone8;
        }
      };
      PP.VisualPoint.prototype._refresh = function() {
        let rotation = PP.vec3_create(0, 0, 0);
        return function _refresh() {
          this._myPointObject.pp_setParent(this._myParams.myParent, false);
          if (this._myParams.myIsLocal) {
            this._myPointObject.pp_setPositionLocal(this._myParams.myPosition);
            this._myPointObject.pp_setRotationLocal(rotation);
            this._myPointObject.pp_setScaleLocal(this._myParams.myRadius);
          } else {
            this._myPointObject.pp_setPosition(this._myParams.myPosition);
            this._myPointObject.pp_setRotation(rotation);
            this._myPointObject.pp_setScale(this._myParams.myRadius);
          }
          if (this._myParams.myMesh != null) {
            this._myPointMeshComponent.mesh = this._myParams.myMesh;
          } else {
            this._myPointMeshComponent.mesh = PP.myDefaultResources.myMeshes.mySphere;
          }
          if (this._myParams.myMaterial == null) {
            if (this._myParams.myColor == null) {
              this._myPointMeshComponent.material = PP.myVisualData.myDefaultMaterials.myDefaultMeshMaterial;
            } else {
              if (this._myFlatOpaqueMaterial == null) {
                this._myFlatOpaqueMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
              }
              this._myPointMeshComponent.material = this._myFlatOpaqueMaterial;
              this._myFlatOpaqueMaterial.color = this._myParams.myColor;
            }
          } else {
            this._myPointMeshComponent.material = this._myParams.myMaterial;
          }
        };
      }();
      Object.defineProperty(PP.VisualPoint.prototype, "_refresh", { enumerable: false });
    }
  });

  // js/pp/cauldron/visual/elements/visual_arrow.js
  var require_visual_arrow = __commonJS({
    "js/pp/cauldron/visual/elements/visual_arrow.js"() {
      PP.VisualArrowParams = class VisualArrowParams {
        constructor() {
          this.myStart = PP.vec3_create();
          this.myDirection = PP.vec3_create(0, 0, 1);
          this.myLength = 0;
          this.myThickness = 5e-3;
          this.myLineMesh = null;
          this.myArrowMesh = null;
          this.myMaterial = null;
          this.myColor = null;
          this.myParent = PP.myVisualData.myRootObject;
          this.myIsLocal = false;
          this.myType = PP.VisualElementType.ARROW;
        }
        setStartEnd(start, end) {
          end.vec3_sub(start, this.myDirection);
          this.myLength = this.myDirection.vec3_length();
          this.myDirection.vec3_normalize(this.myDirection);
          this.myStart.vec3_copy(start);
          return this;
        }
      };
      PP.VisualArrow = class VisualArrow {
        constructor(params = new PP.VisualArrowParams()) {
          this._myParams = params;
          this._myVisible = false;
          this._myAutoRefresh = true;
          this._myDirty = false;
          this._myVisualLine = new PP.VisualLine();
          this._myVisualLine.setAutoRefresh(false);
          this._myArrowRootObject = null;
          this._myArrowObject = null;
          this._myArrowMeshComponent = null;
          this._myFlatOpaqueMaterial = null;
          this._build();
          this.forceRefresh();
          this.setVisible(true);
        }
        setVisible(visible) {
          if (this._myVisible != visible) {
            this._myVisible = visible;
            this._myVisualLine.setVisible(visible);
            this._myArrowRootObject.pp_setActive(visible);
          }
        }
        setAutoRefresh(autoRefresh) {
          this._myAutoRefresh = autoRefresh;
        }
        getParams() {
          return this._myParams;
        }
        setParams(params) {
          this._myParams = params;
          this._markDirty();
        }
        paramsUpdated() {
          this._markDirty();
        }
        refresh() {
          this.update(0);
        }
        forceRefresh() {
          this._refresh();
          this._myVisualLine.forceRefresh();
        }
        update(dt) {
          if (this._myDirty) {
            this._refresh();
            this._myDirty = false;
          }
          this._myVisualLine.update(dt);
        }
        _build() {
          this._myArrowRootObject = WL.scene.addObject(null);
          this._myArrowObject = WL.scene.addObject(this._myArrowRootObject);
          this._myArrowMeshComponent = this._myArrowObject.addComponent("mesh");
        }
        _markDirty() {
          this._myDirty = true;
          if (this._myAutoRefresh) {
            this.update(0);
          }
        }
        clone() {
          let clonedParams = new PP.VisualArrowParams();
          clonedParams.myStart.vec3_copy(this._myParams.myStart);
          clonedParams.myDirection.vec3_copy(this._myParams.myDirection);
          clonedParams.myLength = this._myParams.myLength;
          clonedParams.myThickness = this._myParams.myThickness;
          clonedParams.myArrowMesh = this._myParams.myArrowMesh;
          clonedParams.myLineMesh = this._myParams.myLineMesh;
          if (this._myParams.myMaterial != null) {
            clonedParams.myMaterial = this._myParams.myMaterial.clone();
          } else {
            clonedParams.myMaterial = null;
          }
          if (this._myParams.myColor != null) {
            clonedParams.myColor.vec4_copy(this._myParams.myColor);
          } else {
            clonedParams.myColor = null;
          }
          clonedParams.myParent = this._myParams.myParent;
          clonedParams.myIsLocal = this._myParams.myIsLocal;
          let clone8 = new PP.VisualArrow(clonedParams);
          clone8.setAutoRefresh(this._myAutoRefresh);
          clone8.setVisible(this._myVisible);
          clone8._myDirty = this._myDirty;
          return clone8;
        }
      };
      PP.VisualArrow.prototype._refresh = function() {
        let end = PP.vec3_create();
        let translateRoot = PP.vec3_create();
        let scaleArrow = PP.vec3_create();
        let direction = PP.vec3_create();
        let forward = PP.vec3_create(0, 1, 0);
        return function _refresh() {
          this._myArrowRootObject.pp_setParent(this._myParams.myParent, false);
          this._myParams.myDirection.vec3_scale(Math.max(1e-3, this._myParams.myLength - this._myParams.myThickness * 4), end);
          end.vec3_add(this._myParams.myStart, end);
          if (this._myParams.myIsLocal) {
            this._myArrowRootObject.pp_setPositionLocal(end);
            this._myArrowRootObject.pp_setUpLocal(this._myParams.myDirection, forward);
          } else {
            this._myArrowRootObject.pp_setPosition(end);
            this._myArrowRootObject.pp_setUp(this._myParams.myDirection, forward);
          }
          translateRoot.vec3_set(0, this._myParams.myThickness * 2 - 1e-5, 0);
          this._myArrowRootObject.pp_translateObject(translateRoot);
          scaleArrow.vec3_set(this._myParams.myThickness * 1.25, this._myParams.myThickness * 2, this._myParams.myThickness * 1.25);
          if (this._myParams.myIsLocal) {
            this._myArrowObject.pp_setScaleLocal(scaleArrow);
          } else {
            this._myArrowObject.pp_setScale(scaleArrow);
          }
          if (this._myParams.myArrowMesh != null) {
            this._myArrowMeshComponent.mesh = this._myParams.myArrowMesh;
          } else {
            this._myArrowMeshComponent.mesh = PP.myDefaultResources.myMeshes.myCone;
          }
          if (this._myParams.myMaterial == null) {
            if (this._myParams.myColor == null) {
              this._myArrowMeshComponent.material = PP.myVisualData.myDefaultMaterials.myDefaultMeshMaterial;
            } else {
              if (this._myFlatOpaqueMaterial == null) {
                this._myFlatOpaqueMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
              }
              this._myArrowMeshComponent.material = this._myFlatOpaqueMaterial;
              this._myFlatOpaqueMaterial.color = this._myParams.myColor;
            }
          } else {
            this._myArrowMeshComponent.material = this._myParams.myMaterial;
          }
          direction = end.vec3_sub(this._myParams.myStart, direction);
          let visualLineParams = this._myVisualLine.getParams();
          visualLineParams.myStart.vec3_copy(this._myParams.myStart);
          visualLineParams.myDirection = direction.vec3_normalize(visualLineParams.myDirection);
          visualLineParams.myLength = direction.vec3_length();
          visualLineParams.myThickness = this._myParams.myThickness;
          visualLineParams.myMesh = this._myParams.myLineMesh;
          visualLineParams.myMaterial = this._myArrowMeshComponent.material;
          visualLineParams.myParent = this._myParams.myParent;
          visualLineParams.myIsLocal = this._myParams.myIsLocal;
          this._myVisualLine.paramsUpdated();
        };
      }();
      Object.defineProperty(PP.VisualArrow.prototype, "_refresh", { enumerable: false });
    }
  });

  // js/pp/cauldron/visual/elements/visual_text.js
  var require_visual_text = __commonJS({
    "js/pp/cauldron/visual/elements/visual_text.js"() {
      PP.VisualTextParams = class VisualTextParams {
        constructor() {
          this.myText = "";
          this.myAlignment = WL.Alignment.Center;
          this.myJustification = WL.Justification.Middle;
          this.myTransform = PP.mat4_create();
          this.myMaterial = null;
          this.myColor = null;
          this.myParent = PP.myVisualData.myRootObject;
          this.myIsLocal = false;
          this.myType = PP.VisualElementType.TEXT;
        }
      };
      PP.VisualText = class VisualText {
        constructor(params = new PP.VisualTextParams()) {
          this._myParams = params;
          this._myVisible = false;
          this._myAutoRefresh = true;
          this._myDirty = false;
          this._myTextObject = null;
          this._myTextComponent = null;
          this._myTextMaterial = null;
          this._build();
          this.forceRefresh();
          this.setVisible(true);
        }
        setVisible(visible) {
          if (this._myVisible != visible) {
            this._myVisible = visible;
            this._myTextObject.pp_setActive(visible);
          }
        }
        setAutoRefresh(autoRefresh) {
          this._myAutoRefresh = autoRefresh;
        }
        getParams() {
          return this._myParams;
        }
        setParams(params) {
          this._myParams = params;
          this._markDirty();
        }
        paramsUpdated() {
          this._markDirty();
        }
        refresh() {
          this.update(0);
        }
        forceRefresh() {
          this._refresh();
        }
        update(dt) {
          if (this._myDirty) {
            this._refresh();
            this._myDirty = false;
          }
        }
        _refresh() {
          this._myTextObject.pp_setParent(this._myParams.myParent, false);
          if (this._myParams.myIsLocal) {
            this._myTextObject.pp_setTransformLocal(this._myParams.myTransform);
          } else {
            this._myTextObject.pp_setTransform(this._myParams.myTransform);
          }
          if (this._myParams.myMaterial == null) {
            if (this._myParams.myColor == null) {
              this._myTextComponent.material = PP.myVisualData.myDefaultMaterials.myDefaultTextMaterial;
            } else {
              if (this._myTextMaterial == null) {
                this._myTextMaterial = PP.myDefaultResources.myMaterials.myText.clone();
              }
              this._myTextComponent.material = this._myTextMaterial;
              this._myTextMaterial.color = this._myParams.myColor;
            }
          } else {
            this._myTextComponent.material = this._myParams.myMaterial;
          }
          this._myTextComponent.text = this._myParams.myText;
          this._myTextComponent.alignment = this._myParams.myAlignment;
          this._myTextComponent.justification = this._myParams.myJustification;
          this._myDirty = false;
        }
        _build() {
          this._myTextObject = WL.scene.addObject(null);
          this._myTextComponent = this._myTextObject.addComponent("text");
        }
        _markDirty() {
          this._myDirty = true;
          if (this._myAutoRefresh) {
            this.update(0);
          }
        }
        clone() {
          let clonedParams = new PP.VisualTextParams();
          clonedParams.myText = this._myParams.myText;
          clonedParams.myAlignment = this._myParams.myAlignment;
          clonedParams.myJustification = this._myParams.myJustification;
          clonedParams.myTransform.mat4_copy(this._myParams.myTransform);
          if (this._myParams.myMaterial != null) {
            clonedParams.myMaterial = this._myParams.myMaterial.clone();
          } else {
            clonedParams.myMaterial = null;
          }
          if (this._myParams.myColor != null) {
            clonedParams.myColor.vec4_copy(this._myParams.myColor);
          } else {
            clonedParams.myColor = null;
          }
          clonedParams.myParent = this._myParams.myParent;
          clonedParams.myIsLocal = this._myParams.myIsLocal;
          let clone8 = new PP.VisualText(clonedParams);
          clone8.setAutoRefresh(this._myAutoRefresh);
          clone8.setVisible(this._myVisible);
          clone8._myDirty = this._myDirty;
          return clone8;
        }
      };
    }
  });

  // js/pp/cauldron/visual/elements/visual_transform.js
  var require_visual_transform = __commonJS({
    "js/pp/cauldron/visual/elements/visual_transform.js"() {
      PP.VisualTransformParams = class VisualTransformParams {
        constructor() {
          this.myTransform = PP.mat4_create();
          this.myLength = 0.2;
          this.myThickness = 5e-3;
          this.myForwardMaterial = null;
          this.myUpMaterial = null;
          this.myRightMaterial = null;
          this.myParent = PP.myVisualData.myRootObject;
          this.myIsLocal = false;
          this.myType = PP.VisualElementType.TRANSFORM;
        }
      };
      PP.VisualTransform = class VisualTransform {
        constructor(params = new PP.VisualTransformParams()) {
          this._myParams = params;
          this._myVisible = false;
          this._myAutoRefresh = true;
          this._myDirty = false;
          this._myVisualRight = new PP.VisualArrow();
          this._myVisualUp = new PP.VisualArrow();
          this._myVisualForward = new PP.VisualArrow();
          this._myVisualRight.setAutoRefresh(false);
          this._myVisualUp.setAutoRefresh(false);
          this._myVisualForward.setAutoRefresh(false);
          this.forceRefresh();
          this.setVisible(true);
        }
        setVisible(visible) {
          if (this._myVisible != visible) {
            this._myVisible = visible;
            this._myVisualRight.setVisible(visible);
            this._myVisualUp.setVisible(visible);
            this._myVisualForward.setVisible(visible);
          }
        }
        setAutoRefresh(autoRefresh) {
          this._myAutoRefresh = autoRefresh;
        }
        getParams() {
          return this._myParams;
        }
        setParams(params) {
          this._myParams = params;
          this._markDirty();
        }
        paramsUpdated() {
          this._markDirty();
        }
        refresh() {
          this.update(0);
        }
        forceRefresh() {
          this._refresh();
          this._myVisualRight.forceRefresh();
          this._myVisualUp.forceRefresh();
          this._myVisualForward.forceRefresh();
        }
        update(dt) {
          if (this._myDirty) {
            this._refresh();
            this._myDirty = false;
          }
          this._myVisualRight.update(dt);
          this._myVisualUp.update(dt);
          this._myVisualForward.update(dt);
        }
        _markDirty() {
          this._myDirty = true;
          if (this._myAutoRefresh) {
            this.update(0);
          }
        }
        clone() {
          let clonedParams = new PP.VisualTransformParams();
          clonedParams.myTransform.mat4_copy(this._myParams.myTransform);
          clonedParams.myLength = this._myParams.myLength;
          clonedParams.myThickness = this._myParams.myThickness;
          if (this._myParams.myRightMaterial != null) {
            clonedParams.myRightMaterial = this._myParams.myRightMaterial.clone();
          } else {
            clonedParams.myRightMaterial = null;
          }
          if (this._myParams.myUpMaterial != null) {
            clonedParams.myUpMaterial = this._myParams.myUpMaterial.clone();
          } else {
            clonedParams.myUpMaterial = null;
          }
          if (this._myParams.myForwardMaterial != null) {
            clonedParams.myForwardMaterial = this._myParams.myForwardMaterial.clone();
          } else {
            clonedParams.myForwardMaterial = null;
          }
          clonedParams.myParent = this._myParams.myParent;
          clonedParams.myIsLocal = this._myParams.myIsLocal;
          let clone8 = new PP.VisualTransform(clonedParams);
          clone8.setAutoRefresh(this._myAutoRefresh);
          clone8.setVisible(this._myVisible);
          clone8._myDirty = this._myDirty;
          return clone8;
        }
      };
      PP.VisualTransform.prototype._refresh = function() {
        let axes = [PP.vec3_create(), PP.vec3_create(), PP.vec3_create()];
        let scale8 = PP.vec3_create();
        let position = PP.vec3_create();
        return function _refresh() {
          axes = this._myParams.myTransform.mat4_getAxes(axes);
          scale8 = this._myParams.myTransform.mat4_getScale(scale8);
          let maxValue = 0;
          for (let value of scale8) {
            maxValue = Math.max(value, maxValue);
          }
          if (maxValue == 0) {
            scale8[0] = 1;
            scale8[1] = 1;
            scale8[2] = 1;
          } else {
            scale8[0] = scale8[0] / maxValue;
            scale8[1] = scale8[1] / maxValue;
            scale8[2] = scale8[2] / maxValue;
          }
          position = this._myParams.myTransform.mat4_getPosition(position);
          {
            let visualArrowParams = this._myVisualRight.getParams();
            visualArrowParams.myStart.vec3_copy(position);
            visualArrowParams.myDirection = axes[0].vec3_negate(visualArrowParams.myDirection).vec3_normalize(visualArrowParams.myDirection);
            visualArrowParams.myLength = Math.max(this._myParams.myLength * scale8[0], 1e-3);
            visualArrowParams.myThickness = this._myParams.myThickness;
            if (this._myParams.myRightMaterial == null) {
              visualArrowParams.myMaterial = PP.myVisualData.myDefaultMaterials.myDefaultRightMaterial;
            } else {
              visualArrowParams.myMaterial = this._myParams.myRightMaterial;
            }
            visualArrowParams.myParent = this._myParams.myParent;
            visualArrowParams.myIsLocal = this._myParams.myIsLocal;
            this._myVisualRight.paramsUpdated();
          }
          {
            let visualArrowParams = this._myVisualUp.getParams();
            visualArrowParams.myStart.vec3_copy(position);
            visualArrowParams.myDirection = axes[1].vec3_normalize(visualArrowParams.myDirection);
            visualArrowParams.myLength = Math.max(this._myParams.myLength * scale8[1], 1e-3);
            visualArrowParams.myThickness = this._myParams.myThickness;
            if (this._myParams.myUpMaterial == null) {
              visualArrowParams.myMaterial = PP.myVisualData.myDefaultMaterials.myDefaultUpMaterial;
            } else {
              visualArrowParams.myMaterial = this._myParams.myUpMaterial;
            }
            visualArrowParams.myParent = this._myParams.myParent;
            visualArrowParams.myIsLocal = this._myParams.myIsLocal;
            this._myVisualUp.paramsUpdated();
          }
          {
            let visualArrowParams = this._myVisualForward.getParams();
            visualArrowParams.myStart.vec3_copy(position);
            visualArrowParams.myDirection = axes[2].vec3_normalize(visualArrowParams.myDirection);
            visualArrowParams.myLength = Math.max(this._myParams.myLength * scale8[2], 1e-3);
            visualArrowParams.myThickness = this._myParams.myThickness;
            if (this._myParams.myForwardMaterial == null) {
              visualArrowParams.myMaterial = PP.myVisualData.myDefaultMaterials.myDefaultForwardMaterial;
            } else {
              visualArrowParams.myMaterial = this._myParams.myForwardMaterial;
            }
            visualArrowParams.myParent = this._myParams.myParent;
            visualArrowParams.myIsLocal = this._myParams.myIsLocal;
            this._myVisualForward.paramsUpdated();
          }
        };
      }();
      Object.defineProperty(PP.VisualTransform.prototype, "_refresh", { enumerable: false });
    }
  });

  // js/pp/cauldron/visual/elements/visual_raycast.js
  var require_visual_raycast = __commonJS({
    "js/pp/cauldron/visual/elements/visual_raycast.js"() {
      PP.VisualRaycastParams = class VisualRaycastParams {
        constructor() {
          this._myRaycastResults = new PP.RaycastResults();
          this.myHitNormalLength = 0.2;
          this.myThickness = 5e-3;
          this.myShowOnlyFirstHit = true;
          this.myRayMaterial = null;
          this.myHitNormalMaterial = null;
          this.myParent = PP.myVisualData.myRootObject;
          this.myIsLocal = false;
          this.myType = PP.VisualElementType.RAYCAST;
        }
        get myRaycastResults() {
          return this._myRaycastResults;
        }
        set myRaycastResults(result) {
          this._myRaycastResults.copy(result);
        }
      };
      PP.VisualRaycast = class VisualRaycast {
        constructor(params = new PP.VisualRaycastParams()) {
          this._myParams = params;
          this._myVisible = false;
          this._myAutoRefresh = true;
          this._myDirty = false;
          this._myVisualRaycast = new PP.VisualArrow();
          this._myVisualRaycast.setAutoRefresh(false);
          this._myVisualRaycastHitList = [];
          this._addVisualRaycastHit();
          this.forceRefresh();
          this.setVisible(true);
        }
        setVisible(visible) {
          if (this._myVisible != visible) {
            this._myVisible = visible;
            if (this._myVisible) {
              if (this._myParams.myRaycastResults.myRaycastSetup != null) {
                this._myVisualRaycast.setVisible(true);
              }
              if (this._myParams.myRaycastResults.myHits.length > 0) {
                let hitsToShow = Math.min(this._myParams.myRaycastResults.myHits.length, this._myVisualRaycastHitList.length);
                for (let i = 0; i < hitsToShow; i++) {
                  let visualRaycastHit = this._myVisualRaycastHitList[i];
                  visualRaycastHit.setVisible(true);
                }
              }
            } else {
              this._myVisualRaycast.setVisible(false);
              for (let visualRaycastHit of this._myVisualRaycastHitList) {
                visualRaycastHit.setVisible(false);
              }
            }
          }
        }
        setAutoRefresh(autoRefresh) {
          this._myAutoRefresh = autoRefresh;
        }
        getParams() {
          return this._myParams;
        }
        setParams(params) {
          this._myParams = params;
          this._markDirty();
        }
        paramsUpdated() {
          this._markDirty();
        }
        refresh() {
          this.update(0);
        }
        forceRefresh() {
          this._refresh();
          this._myVisualRaycast.forceRefresh();
          if (this._myParams.myRaycastResults.myHits.length > 0) {
            let hitsToRefresh = Math.min(this._myParams.myRaycastResults.myHits.length, this._myVisualRaycastHitList.length);
            for (let i = 0; i < hitsToRefresh; i++) {
              let visualRaycastHit = this._myVisualRaycastHitList[i];
              visualRaycastHit.forceRefresh();
            }
          }
        }
        update(dt) {
          if (this._myDirty) {
            this._refresh();
            this._myDirty = false;
          }
          this._myVisualRaycast.update(dt);
          for (let visualRaycastHit of this._myVisualRaycastHitList) {
            visualRaycastHit.update(dt);
          }
        }
        _refresh() {
          for (let visualRaycastHit of this._myVisualRaycastHitList) {
            visualRaycastHit.setVisible(false);
          }
          if (this._myParams.myRaycastResults.myHits.length > 0) {
            let raycastDistance = this._myParams.myShowOnlyFirstHit ? this._myParams.myRaycastResults.myHits.pp_first().myDistance : this._myParams.myRaycastResults.myHits.pp_last().myDistance;
            {
              let visualRaycastParams = this._myVisualRaycast.getParams();
              visualRaycastParams.myStart.vec3_copy(this._myParams.myRaycastResults.myRaycastSetup.myOrigin);
              visualRaycastParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myRaycastSetup.myDirection);
              visualRaycastParams.myLength = raycastDistance;
              visualRaycastParams.myThickness = this._myParams.myThickness;
              if (this._myParams.myRayMaterial == null) {
                visualRaycastParams.myMaterial = PP.myVisualData.myDefaultMaterials.myDefaultRayMaterial;
              } else {
                visualRaycastParams.myMaterial = this._myParams.myRayMaterial;
              }
              visualRaycastParams.myParent = this._myParams.myParent;
              visualRaycastParams.myIsLocal = this._myParams.myIsLocal;
              this._myVisualRaycast.paramsUpdated();
              this._myVisualRaycast.setVisible(this._myVisible);
            }
            let hitsToShow = this._myParams.myShowOnlyFirstHit ? 1 : this._myParams.myRaycastResults.myHits.length;
            while (hitsToShow > this._myVisualRaycastHitList.length) {
              this._addVisualRaycastHit();
            }
            for (let i = 0; i < hitsToShow; i++) {
              let visualRaycastHit = this._myVisualRaycastHitList[i];
              {
                let visualRaycastHitParams = visualRaycastHit.getParams();
                visualRaycastHitParams.myStart.vec3_copy(this._myParams.myRaycastResults.myHits[i].myPosition);
                visualRaycastHitParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myHits[i].myNormal);
                visualRaycastHitParams.myLength = this._myParams.myHitNormalLength;
                visualRaycastHitParams.myThickness = this._myParams.myThickness;
                if (this._myParams.myHitNormalMaterial == null) {
                  visualRaycastHitParams.myMaterial = PP.myVisualData.myDefaultMaterials.myDefaultHitNormalMaterial;
                } else {
                  visualRaycastHitParams.myMaterial = this._myParams.myHitNormalMaterial;
                }
                visualRaycastHitParams.myParent = this._myParams.myParent;
                visualRaycastHitParams.myIsLocal = this._myParams.myIsLocal;
                visualRaycastHit.paramsUpdated();
                visualRaycastHit.setVisible(this._myVisible);
              }
            }
          } else if (this._myParams.myRaycastResults.myRaycastSetup != null) {
            {
              let visualRaycastParams = this._myVisualRaycast.getParams();
              visualRaycastParams.myStart.vec3_copy(this._myParams.myRaycastResults.myRaycastSetup.myOrigin);
              visualRaycastParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myRaycastSetup.myDirection);
              visualRaycastParams.myLength = this._myParams.myRaycastResults.myRaycastSetup.myDistance;
              visualRaycastParams.myThickness = this._myParams.myThickness;
              if (this._myParams.myRayMaterial == null) {
                visualRaycastParams.myMaterial = PP.myVisualData.myDefaultMaterials.myDefaultRayMaterial;
              } else {
                visualRaycastParams.myMaterial = this._myParams.myRayMaterial;
              }
              visualRaycastParams.myParent = this._myParams.myParent;
              visualRaycastParams.myIsLocal = this._myParams.myIsLocal;
              this._myVisualRaycast.paramsUpdated();
              this._myVisualRaycast.setVisible(this._myVisible);
            }
          } else {
            this._myVisualRaycast.setVisible(false);
          }
        }
        _markDirty() {
          this._myDirty = true;
          if (this._myAutoRefresh) {
            this.update(0);
          }
        }
        clone() {
          let clonedParams = new PP.VisualRaycastParams();
          clonedParams.myRaycastResults = this._myParams.myRaycastResults;
          clonedParams.myHitNormalLength = this._myParams.myHitNormalLength;
          clonedParams.myThickness = this._myParams.myThickness;
          clonedParams.myShowOnlyFirstHit = this._myParams.myShowOnlyFirstHit;
          if (this._myParams.myRayMaterial != null) {
            clonedParams.myRayMaterial = this._myParams.myRayMaterial.clone();
          } else {
            clonedParams.myRayMaterial = null;
          }
          if (this._myParams.myHitNormalMaterial != null) {
            clonedParams.myHitNormalMaterial = this._myParams.myHitNormalMaterial.clone();
          } else {
            clonedParams.myHitNormalMaterial = null;
          }
          clonedParams.myParent = this._myParams.myParent;
          clonedParams.myIsLocal = this._myParams.myIsLocal;
          let clone8 = new PP.VisualRaycast(clonedParams);
          clone8.setAutoRefresh(this._myAutoRefresh);
          clone8.setVisible(this._myVisible);
          clone8._myDirty = this._myDirty;
          return clone8;
        }
        _addVisualRaycastHit() {
          let visualRaycastHit = new PP.VisualArrow();
          visualRaycastHit.setAutoRefresh(false);
          visualRaycastHit.setVisible(false);
          this._myVisualRaycastHitList.push(visualRaycastHit);
        }
      };
    }
  });

  // js/pp/cauldron/visual/elements/visual_torus.js
  var require_visual_torus = __commonJS({
    "js/pp/cauldron/visual/elements/visual_torus.js"() {
      PP.VisualTorusParams = class VisualTorusParams {
        constructor() {
          this.myTransform = PP.mat4_create();
          this.myRadius = 0;
          this.mySegmentsAmount = 12;
          this.mySegmentThickness = 0.05;
          this.mySegmentMesh = null;
          this.myMaterial = null;
          this.myColor = null;
          this.myParent = PP.myVisualData.myRootObject;
          this.myIsLocal = false;
          this.myType = PP.VisualElementType.TORUS;
        }
      };
      PP.VisualTorus = class VisualTorus {
        constructor(params = new PP.VisualTorusParams()) {
          this._myParams = params;
          this._myVisible = false;
          this._myAutoRefresh = true;
          this._myDirty = false;
          this._myTorusRootObject = null;
          this._myVisualSegmentList = [];
          this._myFlatOpaqueMaterial = null;
          this._build();
          this.forceRefresh();
          this.setVisible(true);
        }
        setVisible(visible) {
          if (this._myVisible != visible) {
            this._myVisible = visible;
            if (this._myVisible) {
              let segmentToShow = Math.min(this._myParams.mySegmentsAmount, this._myVisualSegmentList.length);
              for (let i = 0; i < segmentToShow; i++) {
                let visualSegment = this._myVisualSegmentList[i];
                visualSegment.setVisible(true);
              }
            } else {
              for (let visualSegment of this._myVisualSegmentList) {
                visualSegment.setVisible(false);
              }
            }
          }
        }
        setAutoRefresh(autoRefresh) {
          this._myAutoRefresh = autoRefresh;
        }
        getParams() {
          return this._myParams;
        }
        setParams(params) {
          this._myParams = params;
          this._markDirty();
        }
        paramsUpdated() {
          this._markDirty();
        }
        refresh() {
          this.update(0);
        }
        forceRefresh() {
          this._refresh();
          let segmentToRefresh = Math.min(this._myParams.mySegmentsAmount, this._myVisualSegmentList.length);
          for (let i = 0; i < segmentToRefresh; i++) {
            let visualSegment = this._myVisualSegmentList[i];
            visualSegment.forceRefresh();
          }
        }
        update(dt) {
          if (this._myDirty) {
            this._refresh();
            this._myDirty = false;
          }
          for (let visualSegment of this._myVisualSegmentList) {
            visualSegment.update(dt);
          }
        }
        _build() {
          this._myTorusRootObject = WL.scene.addObject(null);
          this._fillSegmentList();
        }
        _markDirty() {
          this._myDirty = true;
          if (this._myAutoRefresh) {
            this.update(0);
          }
        }
        _fillSegmentList() {
          while (this._myVisualSegmentList.length < this._myParams.mySegmentsAmount) {
            let visualSegment = new PP.VisualLine();
            visualSegment.setAutoRefresh(false);
            visualSegment.setVisible(false);
            visualSegment.getParams().myParent = this._myTorusRootObject;
            visualSegment.getParams().myIsLocal = true;
            this._myVisualSegmentList.push(visualSegment);
          }
        }
        clone() {
          let clonedParams = new PP.VisualTorusParams();
          clonedParams.myRadius = this._myParams.myRadius;
          clonedParams.mySegmentsAmount = this._myParams.mySegmentsAmount;
          clonedParams.mySegmentThickness = this._myParams.mySegmentThickness;
          clonedParams.myTransform.mat4_copy(this._myParams.myTransform);
          clonedParams.mySegmentMesh = this._myParams.mySegmentMesh;
          if (this._myParams.myMaterial != null) {
            clonedParams.myMaterial = this._myParams.myMaterial.clone();
          } else {
            clonedParams.myMaterial = null;
          }
          if (this._myParams.myColor != null) {
            clonedParams.myColor.vec4_copy(this._myParams.myColor);
          } else {
            clonedParams.myColor = null;
          }
          clonedParams.myParent = this._myParams.myParent;
          clonedParams.myIsLocal = this._myParams.myIsLocal;
          let clone8 = new PP.VisualTorus(clonedParams);
          clone8.setAutoRefresh(this._myAutoRefresh);
          clone8.setVisible(this._myVisible);
          clone8._myDirty = this._myDirty;
          return clone8;
        }
      };
      PP.VisualTorus.prototype._refresh = function() {
        let segmentStart = PP.vec3_create();
        let segmentEnd = PP.vec3_create();
        let segmentDirection = PP.vec3_create();
        let fixedSegmentStart = PP.vec3_create();
        let fixedSegmentEnd = PP.vec3_create();
        let up = PP.vec3_create(0, 1, 0);
        return function _refresh() {
          this._fillSegmentList();
          for (let visualSegment of this._myVisualSegmentList) {
            visualSegment.setVisible(false);
          }
          this._myTorusRootObject.pp_setParent(this._myParams.myParent, false);
          if (this._myParams.myIsLocal) {
            this._myTorusRootObject.pp_setTransformLocal(this._myParams.myTransform);
          } else {
            this._myTorusRootObject.pp_setTransform(this._myParams.myTransform);
          }
          let sliceAngle = 2 * Math.PI / this._myParams.mySegmentsAmount;
          segmentStart.vec3_set(this._myParams.myRadius, 0, 0);
          for (let i = 0; i < this._myParams.mySegmentsAmount; i++) {
            segmentEnd = segmentStart.vec3_rotateAxisRadians(sliceAngle, up, segmentEnd);
            segmentDirection = segmentEnd.vec3_sub(segmentStart, segmentDirection).vec3_normalize(segmentDirection);
            let extraLength = Math.tan(sliceAngle / 2) * this._myParams.mySegmentThickness / 2;
            fixedSegmentStart = segmentStart.vec3_sub(segmentDirection.vec3_scale(extraLength, fixedSegmentStart), fixedSegmentStart);
            fixedSegmentEnd = segmentEnd.vec3_add(segmentDirection.vec3_scale(extraLength, fixedSegmentEnd), fixedSegmentEnd);
            let visualSegment = this._myVisualSegmentList[i];
            let visualSegmentParams = visualSegment.getParams();
            visualSegmentParams.setStartEnd(fixedSegmentStart, fixedSegmentEnd);
            visualSegmentParams.myThickness = this._myParams.mySegmentThickness;
            visualSegmentParams.myMesh = this._myParams.mySegmentMesh;
            if (this._myParams.myMaterial == null) {
              if (this._myParams.myColor == null) {
                visualSegmentParams.myMaterial = PP.myVisualData.myDefaultMaterials.myDefaultMeshMaterial;
              } else {
                if (this._myFlatOpaqueMaterial == null) {
                  this._myFlatOpaqueMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
                }
                visualSegmentParams.myMaterial = this._myFlatOpaqueMaterial;
                this._myFlatOpaqueMaterial.color = this._myParams.myColor;
              }
            } else {
              visualSegmentParams.myMaterial = this._myParams.myMaterial;
            }
            visualSegment.paramsUpdated();
            visualSegment.setVisible(this._myVisible);
            segmentStart.vec3_copy(segmentEnd);
          }
        };
      }();
      Object.defineProperty(PP.VisualTorus.prototype, "_refresh", { enumerable: false });
    }
  });

  // js/pp/cauldron/visual/components/visual_manager_component.js
  var require_visual_manager_component = __commonJS({
    "js/pp/cauldron/visual/components/visual_manager_component.js"() {
      WL.registerComponent("pp-visual-manager", {}, {
        init: function() {
          if (this.active) {
            PP.myVisualData.myRootObject = WL.scene.addObject(null);
            PP.myVisualManager = new PP.VisualManager();
          }
        },
        start() {
          PP.myVisualData.myDefaultMaterials.myDefaultMeshMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
          PP.myVisualData.myDefaultMaterials.myDefaultTextMaterial = PP.myDefaultResources.myMaterials.myText.clone();
          PP.myVisualData.myDefaultMaterials.myDefaultRightMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
          PP.myVisualData.myDefaultMaterials.myDefaultRightMaterial.color = PP.vec4_create(1, 0, 0, 1);
          PP.myVisualData.myDefaultMaterials.myDefaultUpMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
          PP.myVisualData.myDefaultMaterials.myDefaultUpMaterial.color = PP.vec4_create(0, 1, 0, 1);
          PP.myVisualData.myDefaultMaterials.myDefaultForwardMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
          PP.myVisualData.myDefaultMaterials.myDefaultForwardMaterial.color = PP.vec4_create(0, 0, 1, 1);
          PP.myVisualData.myDefaultMaterials.myDefaultRayMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
          PP.myVisualData.myDefaultMaterials.myDefaultRayMaterial.color = PP.vec4_create(0, 1, 0, 1);
          PP.myVisualData.myDefaultMaterials.myDefaultHitNormalMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
          PP.myVisualData.myDefaultMaterials.myDefaultHitNormalMaterial.color = PP.vec4_create(1, 0, 0, 1);
          PP.myVisualManager.start();
        },
        update(dt) {
          PP.myVisualManager.update(dt);
        }
      });
      PP.myVisualManager = null;
      PP.myVisualData = {
        myRootObject: null,
        myDefaultMaterials: {
          myDefaultMeshMaterial: null,
          myDefaultTextMaterial: null,
          myDefaultRightMaterial: null,
          myDefaultUpMaterial: null,
          myDefaultForwardMaterial: null,
          myDefaultRayMaterial: null,
          myDefaultHitNormalMaterial: null
        }
      };
    }
  });

  // js/pp/debug/debug_manager.js
  var require_debug_manager = __commonJS({
    "js/pp/debug/debug_manager.js"() {
      PP.DebugManager = class DebugManager {
        constructor() {
          this._myDebugVisualManager = new PP.DebugVisualManager();
        }
        getDebugVisualManager() {
          return this._myDebugVisualManager;
        }
        start() {
          this._myDebugVisualManager.start();
        }
        update(dt) {
          this._myDebugVisualManager.update(dt);
        }
      };
    }
  });

  // js/pp/debug/debug_visual_manager.js
  var require_debug_visual_manager = __commonJS({
    "js/pp/debug/debug_visual_manager.js"() {
      PP.DebugVisualManager = class DebugVisualManager extends PP.VisualManager {
        drawLine(lifetimeSeconds, start, direction, length6, color = PP.vec4_create(0, 1, 0, 1), thickness = 5e-3) {
          let visualParams = new PP.VisualLineParams();
          visualParams.myStart.vec3_copy(start);
          visualParams.myDirection.vec3_copy(direction);
          visualParams.myLength = length6;
          visualParams.myThickness = thickness;
          visualParams.myColor = PP.vec4_create();
          visualParams.myColor.vec4_copy(color);
          this.draw(visualParams, lifetimeSeconds);
        }
        drawLineEnd(lifetimeSeconds, start, end, color = PP.vec4_create(0, 1, 0, 1), thickness = 5e-3) {
        }
        drawArrow(lifetimeSeconds, start, direction, length6, color = PP.vec4_create(0, 1, 0, 1), thickness = 5e-3) {
          let visualParams = new PP.VisualArrowParams();
          visualParams.myStart.vec3_copy(start);
          visualParams.myDirection.vec3_copy(direction);
          visualParams.myLength = length6;
          visualParams.myThickness = thickness;
          visualParams.myColor = PP.vec4_create();
          visualParams.myColor.vec4_copy(color);
          this.draw(visualParams, lifetimeSeconds);
        }
        drawArrowEnd(lifetimeSeconds, start, end, color = PP.vec4_create(0, 1, 0, 1), thickness = 5e-3) {
        }
        drawPoint(lifetimeSeconds, position, color = PP.vec4_create(0, 1, 0, 1), radius = 5e-3) {
          let visualParams = new PP.VisualPointParams();
          visualParams.myPosition.vec3_copy(position);
          visualParams.myRadius = radius;
          visualParams.myColor = PP.vec4_create();
          visualParams.myColor.vec4_copy(color);
          this.draw(visualParams, lifetimeSeconds);
        }
        drawText(lifetimeSeconds, text, transform, color = PP.vec4_create(0, 1, 0, 1), alignment = WL.Alignment.Center, justification = WL.Justification.Middle) {
          let visualParams = new PP.VisualTextParams();
          visualParams.myText = text;
          visualParams.myAlignment = alignment;
          visualParams.myJustification = justification;
          visualParams.myTransform.mat4_copy(transform);
          visualParams.myColor = PP.vec4_create();
          visualParams.myColor.vec4_copy(color);
          this.draw(visualParams, lifetimeSeconds);
        }
        drawRaycast(lifetimeSeconds, raycastResult, showOnlyFirstHit = true, hitNormalLength = 0.2, thickness = 5e-3) {
          let visualParams = new PP.VisualRaycastParams();
          visualParams.myRaycastResults = raycastResult;
          visualParams.myShowOnlyFirstHit = showOnlyFirstHit;
          visualParams.myHitNormalLength = hitNormalLength;
          visualParams.myThickness = thickness;
          this.draw(visualParams, lifetimeSeconds);
        }
        drawTransform(lifetimeSeconds, transform, length6 = 0.2, thickness = 5e-3) {
          let visualParams = new PP.VisualTransformParams();
          visualParams.myTransform.mat4_copy(transform);
          visualParams.myLength = length6;
          visualParams.myThickness = thickness;
          this.draw(visualParams, lifetimeSeconds);
        }
      };
      PP.DebugVisualManager.prototype.drawLineEnd = function() {
        let direction = PP.vec3_create();
        return function drawLineEnd(lifetimeSeconds, start, end, color = PP.vec4_create(0, 1, 0, 1), thickness = 5e-3) {
          direction = end.vec3_sub(start, direction);
          let length6 = direction.vec3_length();
          direction.vec3_normalize(direction);
          this.drawLine(lifetimeSeconds, start, direction, length6, color, thickness);
        };
      }();
      PP.DebugVisualManager.prototype.drawArrowEnd = function() {
        let direction = PP.vec3_create();
        return function drawArrowEnd(lifetimeSeconds, start, end, color = PP.vec4_create(0, 1, 0, 1), thickness = 5e-3) {
          direction = end.vec3_sub(start, direction);
          let length6 = direction.vec3_length();
          direction.vec3_normalize(direction);
          this.drawArrow(lifetimeSeconds, start, direction, length6, color, thickness);
        };
      }();
      Object.defineProperty(PP.DebugVisualManager.prototype, "drawLineEnd", { enumerable: false });
      Object.defineProperty(PP.DebugVisualManager.prototype, "drawArrowEnd", { enumerable: false });
    }
  });

  // js/pp/debug/components/debug_transform_component.js
  var require_debug_transform_component = __commonJS({
    "js/pp/debug/components/debug_transform_component.js"() {
      WL.registerComponent("pp-debug-transform", {
        _myLength: { type: WL.Type.Float, default: 0.1 },
        _myThickness: { type: WL.Type.Float, default: 5e-3 }
      }, {
        init: function() {
        },
        start: function() {
          this._myDebugTransformParams = new PP.VisualTransformParams();
          this._myDebugTransformParams.myLength = this._myLength;
          this._myDebugTransformParams.myThickness = this._myThickness;
          this._myDebugVisualTransform = new PP.VisualTransform(this._myDebugTransformParams);
        },
        update: function(dt) {
          this.object.pp_getTransform(this._myDebugTransformParams.myTransform);
          this._myDebugVisualTransform.paramsUpdated();
        }
      });
    }
  });

  // js/pp/debug/components/debug_manager_component.js
  var require_debug_manager_component = __commonJS({
    "js/pp/debug/components/debug_manager_component.js"() {
      WL.registerComponent("pp-debug-manager", {}, {
        init: function() {
          if (this.active) {
            PP.myDebugManager = new PP.DebugManager();
            PP.myDebugVisualManager = PP.myDebugManager.getDebugVisualManager();
          }
        },
        start() {
          PP.myDebugManager.start();
        },
        update(dt) {
          PP.myDebugManager.update(dt);
        }
      });
      PP.myDebugManager = null;
      PP.myDebugVisualManager = null;
    }
  });

  // js/pp/gameplay/cauldron/cauldron/direction_2D_to_3D_converter.js
  var require_direction_2D_to_3D_converter = __commonJS({
    "js/pp/gameplay/cauldron/cauldron/direction_2D_to_3D_converter.js"() {
      PP.Direction2DTo3DConverterParams = class Direction2DTo3DConverterParams {
        constructor() {
          this.myStartFlyingForward = false;
          this.myStartFlyingRight = false;
          this.myAutoUpdateFlyForward = false;
          this.myAutoUpdateFlyRight = false;
          this.myResetFlyForwardWhenZero = false;
          this.myResetFlyRightWhenZero = false;
          this.myMinAngleToFlyForwardUp = 90;
          this.myMinAngleToFlyForwardDown = 90;
          this.myMinAngleToFlyRightUp = 90;
          this.myMinAngleToFlyRightDown = 90;
          this.myAdjustForwardWhenCloseToUp = true;
          this.myAdjustRightWhenCloseToUp = true;
          this.myAdjustForwardWhenCloseToUpAngleThreshold = 10;
          this.myAdjustRightWhenCloseToUpAngleThreshold = 10;
          this.myInvertForwardWhenUpsideDown = false;
          this.myInvertRightWhenUpsideDown = false;
          this.myAdjustLastValidFlatForwardOverConversionReferenceRotation = true;
          this.myAdjustLastValidFlatRightOverConversionReferenceRotation = true;
        }
      };
      PP.Direction2DTo3DConverter = class Direction2DTo3DConverter {
        constructor(params = new PP.Direction2DTo3DConverterParams()) {
          this._myParams = params;
          this._myFlyingForward = this._myParams.myStartFlyingForward;
          this._myFlyingRight = this._myParams.myStartFlyingRight;
          this._myLastConvertRotationQuat = PP.quat_create();
          this._myLastConvertRotationQuatValid = false;
          this._myLastValidFlatForward = PP.vec3_create();
          this._myLastValidFlatRight = PP.vec3_create();
        }
        // @direction3DUp can be used to flat the direction if the @conversionTransform is not aligned with it
        // It's also needed to specify the fly axis, if different from the @conversionTransform up
        // If @direction3DUp is null, @conversionTransform up is used
        convert(direction2D, conversionTransform, direction3DUp = null, outDirection3D = PP.vec3_create()) {
          return this.convertTransform(direction2D, conversionTransform, direction3DUp, outDirection3D);
        }
        isFlying() {
          return this._myFlyingForward || this._myFlyingRight;
        }
        isFlyingForward() {
          return this._myFlyingForward;
        }
        isFlyingRight() {
          return this._myFlyingRight;
        }
        startFlying() {
          this._myFlyingForward = true;
          this._myFlyingRight = true;
        }
        startFlyingForward() {
          this._myFlyingForward = true;
        }
        startFlyingRight() {
          this._myFlyingRight = true;
        }
        stopFlying() {
          this._myFlyingForward = false;
          this._myFlyingRight = false;
        }
        stopFlyingForward() {
          this._myFlyingForward = false;
        }
        stopFlyingRight() {
          this._myFlyingRight = false;
        }
        resetFly() {
          this.resetFlyForward();
          this.resetFlyRight();
        }
        resetFlyForward() {
          if (this._myParams.myStartFlyingForward) {
            this.startFlyingForward();
          } else {
            this.stopFlyingForward();
          }
        }
        resetFlyRight() {
          if (this._myParams.myStartFlyingRight) {
            this.startFlyingRight();
          } else {
            this.stopFlyingRight();
          }
        }
        resetLastValidFlatDirections() {
          this._myLastValidFlatForward.vec3_zero();
          this._myLastValidFlatRight.vec3_zero();
        }
        resetLastValidFlatForward() {
          this._myLastValidFlatForward.vec3_zero();
        }
        resetLastValidFlatRight() {
          this._myLastValidFlatRight.vec3_zero();
        }
        resetLastConvertTransform() {
          this._myLastConvertRotationQuatValid = false;
          this._myLastConvertRotationQuat.quat_identity();
        }
        // Convert Alternatives
        // If @direction3DUp is null, PP.vec3_create(0, 1, 0) is used
        // Does not work properly if @conversionForward is aligned with @direction3DUp
        convertForward(direction2D, conversionForward, direction3DUp = null, outDirection3D = PP.vec3_create()) {
        }
        // @direction3DUp can be used to flat the direction if the @conversionTransform is not aligned with it
        // It's also needed to specify the fly axis, if different from the @conversionTransform up
        // If @direction3DUp is null, conversionTransform up is used
        convertTransform(direction2D, conversionTransform, direction3DUp = null, outDirection3D = PP.vec3_create()) {
          return this.convertTransformMatrix(direction2D, conversionTransform, direction3DUp, outDirection3D);
        }
        convertTransformMatrix(direction2D, conversionTransformMatrix, direction3DUp = null, outDirection3D = PP.vec3_create()) {
        }
        convertTransformQuat(direction2D, conversionTransformQuat, direction3DUp = null, outDirection3D = PP.vec3_create()) {
        }
        convertRotationQuat(direction2D, conversionRotationQuat, direction3DUp = null, outDirection3D = PP.vec3_create()) {
        }
      };
      PP.Direction2DTo3DConverter.prototype.convertForward = function() {
        let rotationQuat = PP.quat_create();
        return function convertForward(direction2D, conversionForward, direction3DUp = null, outDirection3D = PP.vec3_create()) {
          rotationQuat.quat_identity();
          rotationQuat.quat_setForward(conversionForward, direction3DUp);
          return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
        };
      }();
      PP.Direction2DTo3DConverter.prototype.convertTransformMatrix = function() {
        let rotationQuat = PP.quat_create();
        return function convertTransformMatrix(direction2D, conversionTransformMatrix, direction3DUp = null, outDirection3D = PP.vec3_create()) {
          rotationQuat = conversionTransformMatrix.mat4_getRotationQuat(rotationQuat);
          return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
        };
      }();
      PP.Direction2DTo3DConverter.prototype.convertTransformQuat = function() {
        let rotationQuat = PP.quat_create();
        return function convertTransformQuat(direction2D, conversionTransformQuat, direction3DUp = null, outDirection3D = PP.vec3_create()) {
          rotationQuat = conversionTransformQuat.quat2_getRotationQuat(rotationQuat);
          return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
        };
      }();
      PP.Direction2DTo3DConverter.prototype.convertRotationQuat = function() {
        let forward = PP.vec3_create();
        let right = PP.vec3_create();
        let up = PP.vec3_create();
        let direction3DUpNegate = PP.vec3_create();
        let forwardScaled = PP.vec3_create();
        let rightScaled = PP.vec3_create();
        let rotationToNewConvertPivoted = PP.quat_create();
        return function convertRotationQuat(direction2D, conversionRotationQuat, direction3DUp = null, outDirection3D = PP.vec3_create()) {
          outDirection3D.vec3_zero();
          if (this._myParams.myAdjustLastValidFlatForwardOverConversionReferenceRotation || this._myParams.myAdjustLastValidFlatRightOverConversionReferenceRotation) {
            if (direction3DUp != null) {
              if (this._myLastConvertRotationQuatValid) {
                rotationToNewConvertPivoted = this._myLastConvertRotationQuat.quat_rotationToQuat(conversionRotationQuat, rotationToNewConvertPivoted).quat_getTwist(direction3DUp, rotationToNewConvertPivoted);
                if (Math.pp_angleClamp(rotationToNewConvertPivoted.quat_getAngle(), true) > Math.PP_EPSILON_DEGREES) {
                  if (this._myParams.myAdjustLastValidFlatForwardOverConversionReferenceRotation) {
                    this._myLastValidFlatForward.vec3_rotateQuat(rotationToNewConvertPivoted, this._myLastValidFlatForward);
                  }
                  if (this._myParams.myAdjustLastValidFlatRightOverConversionReferenceRotation) {
                    this._myLastValidFlatRight.vec3_rotateQuat(rotationToNewConvertPivoted, this._myLastValidFlatRight);
                  }
                }
              }
            }
          }
          if (direction2D.vec2_isZero()) {
            let resetFlyForward = this._myParams.myAutoUpdateFlyForward && this._myParams.myResetFlyForwardWhenZero;
            if (resetFlyForward) {
              this.resetFlyForward();
            }
            let resetFlyRight = this._myParams.myAutoUpdateFlyRight && this._myParams.myResetFlyRightWhenZero;
            if (resetFlyRight) {
              this.resetFlyRight();
            }
          } else {
            forward = conversionRotationQuat.quat_getForward(forward);
            right = conversionRotationQuat.quat_getRight(right);
            up = conversionRotationQuat.quat_getUp(up);
            if (direction3DUp != null) {
              let upsideDown = !direction3DUp.vec3_isConcordant(up);
              direction3DUpNegate = direction3DUp.vec3_negate(direction3DUpNegate);
              if (this._myParams.myAutoUpdateFlyForward) {
                let angleForwardWithDirectionUp = forward.vec3_angle(direction3DUp);
                this._myFlyingForward = this._myFlyingForward || (angleForwardWithDirectionUp < 90 - this._myParams.myMinAngleToFlyForwardUp || angleForwardWithDirectionUp > 90 + this._myParams.myMinAngleToFlyForwardDown);
              }
              if (this._myParams.myAutoUpdateFlyRight) {
                let angleRightWithDirectionUp = right.vec3_angle(direction3DUp);
                this._myFlyingRight = this._myFlyingRight || (angleRightWithDirectionUp < 90 - this._myParams.myMinAngleToFlyRightUp || angleRightWithDirectionUp > 90 + this._myParams.myMinAngleToFlyRightDown);
              }
              if (!this._myFlyingForward) {
                if (this._myParams.myAdjustForwardWhenCloseToUp && !this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON) && (forward.vec3_angle(direction3DUp) < this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold || forward.vec3_angle(direction3DUpNegate) < this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold)) {
                  forward.pp_copy(this._myLastValidFlatForward);
                } else if (upsideDown && this._myParams.myInvertForwardWhenUpsideDown) {
                  forward.vec3_negate(forward);
                }
                forward = forward.vec3_removeComponentAlongAxis(direction3DUp, forward);
                forward.vec3_normalize(forward);
                if (forward.vec3_isZero(Math.PP_EPSILON)) {
                  if (!this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON)) {
                    forward.pp_copy(this._myLastValidFlatForward);
                  } else {
                    forward.vec3_set(0, 0, 1);
                  }
                }
              }
              if (!this._myFlyingRight) {
                if (this._myParams.myAdjustRightWhenCloseToUp && !this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON) && (right.vec3_angle(direction3DUp) < this._myParams.myAdjustRightWhenCloseToUpAngleThreshold || right.vec3_angle(direction3DUpNegate) < this._myParams.myAdjustRightWhenCloseToUpAngleThreshold)) {
                  right.pp_copy(this._myLastValidFlatRight);
                } else if (upsideDown && this._myParams.myInvertRightWhenUpsideDown) {
                  right.vec3_negate(right);
                }
                right = right.vec3_removeComponentAlongAxis(direction3DUp, right);
                right.vec3_normalize(right);
                if (right.vec3_isZero(Math.PP_EPSILON)) {
                  if (!this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON)) {
                    right.pp_copy(this._myLastValidFlatRight);
                  } else {
                    right.vec3_set(-1, 0, 0);
                  }
                }
              }
              if (forward.vec3_angle(direction3DUp) >= this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold && forward.vec3_angle(direction3DUpNegate) >= this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold || direction2D[1] != 0 && this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON)) {
                this._myLastValidFlatForward = forward.vec3_removeComponentAlongAxis(direction3DUp, this._myLastValidFlatForward);
                this._myLastValidFlatForward.vec3_normalize(this._myLastValidFlatForward);
              }
              if (right.vec3_angle(direction3DUp) >= this._myParams.myAdjustRightWhenCloseToUpAngleThreshold && right.vec3_angle(direction3DUpNegate) >= this._myParams.myAdjustRightWhenCloseToUpAngleThreshold || direction2D[0] != 0 && this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON)) {
                this._myLastValidFlatRight = right.vec3_removeComponentAlongAxis(direction3DUp, this._myLastValidFlatRight);
                this._myLastValidFlatRight.vec3_normalize(this._myLastValidFlatRight);
              }
            }
            outDirection3D = right.vec3_scale(direction2D[0], rightScaled).vec3_add(forward.vec3_scale(direction2D[1], forwardScaled), outDirection3D);
            if (direction3DUp != null && !this._myFlyingForward && !this._myFlyingRight) {
              outDirection3D = outDirection3D.vec3_removeComponentAlongAxis(direction3DUp, outDirection3D);
            }
            outDirection3D.vec3_normalize(outDirection3D);
          }
          this._myLastConvertRotationQuat.quat_copy(conversionRotationQuat);
          this._myLastConvertRotationQuatValid = true;
          return outDirection3D;
        };
      }();
    }
  });

  // js/pp/gameplay/cauldron/cauldron/number_over_value.js
  var require_number_over_value = __commonJS({
    "js/pp/gameplay/cauldron/cauldron/number_over_value.js"() {
      Number.prototype.get = function() {
        return this.valueOf();
      };
      Object.defineProperty(Number.prototype, "get", { enumerable: false });
      PP.NumberOverValue = class NumberOverValue {
        constructor(startNumber, endNumber = null, startInterpolationValue = 0, endInterpolationValue = 0, easingFunction = PP.EasingFunction.linear, roundingFunction = null) {
          if (endNumber == null) {
            endNumber = startNumber;
          }
          this._myStartNumber = startNumber;
          this._myEndNumber = endNumber;
          this._myStartInterpolationValue = startInterpolationValue;
          this._myEndInterpolationValue = endInterpolationValue;
          this._myEasingFunction = easingFunction;
          this._myRoundingFunction = roundingFunction;
        }
        get(interpolationValue) {
          let lerpInterpolationValue = this._myEasingFunction(Math.pp_mapToRange(interpolationValue, this._myStartInterpolationValue, this._myEndInterpolationValue, 0, 1));
          let lerpNumber = Math.pp_lerp(this._myStartNumber, this._myEndNumber, lerpInterpolationValue);
          if (this._myRoundingFunction) {
            lerpNumber = this._myRoundingFunction(lerpNumber, this._myStartNumber, this._myEndNumber);
          }
          return lerpNumber;
        }
        getAverage(interpolationValue) {
          return this.get(interpolationValue);
        }
        getRange(interpolationValue) {
          let number = this.get(interpolationValue);
          return [number, number];
        }
        getMax(interpolationValue) {
          return this.get(interpolationValue);
        }
        getMin(interpolationValue) {
          return this.get(interpolationValue);
        }
        isInside(number, interpolationValue) {
          let currentNumber = this.get(interpolationValue);
          return currentNumber == number;
        }
        isInsideAngleRange(number, interpolationValue) {
          return this.isInsideAngleRangeDegrees(number, interpolationValue);
        }
        isInsideAngleRangeDegrees(number, interpolationValue) {
          let currentNumber = this.get(interpolationValue);
          let clampedNumber = Math.pp_angleClampDegrees(number);
          let clampedCurrentNumber = Math.pp_angleClampDegrees(currentNumber);
          return clampedNumber == clampedCurrentNumber;
        }
        isInsideAngleRangeRadians(number, interpolationValue) {
          let currentNumber = this.get(interpolationValue);
          let clampedNumber = Math.pp_angleClampRadians(number);
          let clampedCurrentNumber = Math.pp_angleClampRadians(currentNumber);
          return clampedNumber == clampedCurrentNumber;
        }
      };
      PP.IntOverValue = class IntOverValue extends PP.NumberOverValue {
        constructor(startNumber, endNumber, startInterpolationValue, endInterpolationValue, easingFunction = PP.EasingFunction.linear, roundingFunction = null) {
          if (roundingFunction == null) {
            roundingFunction = function(numberToRound, startNumber2, endNumber2) {
              let roundedNumber = null;
              let useFloor = startNumber2 <= endNumber2;
              if (useFloor) {
                roundedNumber = Math.floor(numberToRound);
              } else {
                roundedNumber = Math.ceil(numberToRound);
              }
              return roundedNumber;
            };
          }
          super(startNumber, endNumber, startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);
        }
      };
      PP.NumberRangeOverValue = class NumberRangeOverValue {
        constructor(startRange, endRange = null, startInterpolationValue = 0, endInterpolationValue = 0, easingFunction = PP.EasingFunction.linear, roundingFunction = null) {
          if (endRange == null) {
            endRange = startRange;
          }
          this._myStartNumberOverValue = new PP.NumberOverValue(startRange[0], endRange[0], startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);
          this._myEndNumberOverValue = new PP.NumberOverValue(startRange[1], endRange[1], startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);
          this._myRoundingFunction = roundingFunction;
        }
        get(interpolationValue) {
          let startNumber = this._myStartNumberOverValue.get(interpolationValue);
          let endNumber = this._myEndNumberOverValue.get(interpolationValue);
          let randomValue = null;
          if (this._myRoundingFunction) {
            randomValue = Math.pp_randomInt(startNumber, endNumber);
          } else {
            randomValue = Math.pp_random(startNumber, endNumber);
          }
          return randomValue;
        }
        getAverage(interpolationValue) {
          let startNumber = this._myStartNumberOverValue.get(interpolationValue);
          let endNumber = this._myEndNumberOverValue.get(interpolationValue);
          let average = (startNumber + endNumber) / 2;
          if (this._myRoundingFunction) {
            average = this._myRoundingFunction(average, startNumber, endNumber);
          }
          return average;
        }
        getRange(interpolationValue) {
          let startNumber = this._myStartNumberOverValue.get(interpolationValue);
          let endNumber = this._myEndNumberOverValue.get(interpolationValue);
          return [startNumber, endNumber];
        }
        getMax(interpolationValue) {
          let startNumber = this._myStartNumberOverValue.get(interpolationValue);
          let endNumber = this._myEndNumberOverValue.get(interpolationValue);
          return Math.max(startNumber, endNumber);
        }
        getMin(interpolationValue) {
          let startNumber = this._myStartNumberOverValue.get(interpolationValue);
          let endNumber = this._myEndNumberOverValue.get(interpolationValue);
          return Math.min(startNumber, endNumber);
        }
        isInside(number, interpolationValue) {
          let startNumber = this._myStartNumberOverValue.get(interpolationValue);
          let endNumber = this._myEndNumberOverValue.get(interpolationValue);
          let min4 = Math.min(startNumber, endNumber);
          let max4 = Math.max(startNumber, endNumber);
          return number >= min4 && number <= max4;
        }
        isInsideAngleRange(number, interpolationValue) {
          return this.isInsideAngleRangeDegrees(number, interpolationValue);
        }
        isInsideAngleRangeDegrees(number, interpolationValue) {
          let startNumber = this._myStartNumberOverValue.get(interpolationValue);
          let endNumber = this._myEndNumberOverValue.get(interpolationValue);
          return Math.pp_isInsideAngleRangeDegrees(number, startNumber, endNumber);
        }
        isInsideAngleRangeRadians(number, interpolationValue) {
          let startNumber = this._myStartNumberOverValue.get(interpolationValue);
          let endNumber = this._myEndNumberOverValue.get(interpolationValue);
          return Math.pp_isInsideAngleRangeRadians(number, startNumber, endNumber);
        }
      };
      PP.IntRangeOverValue = class IntRangeOverValue extends PP.NumberRangeOverValue {
        constructor(startRange, endRange, startInterpolationValue, endInterpolationValue, easingFunction = PP.EasingFunction.linear, roundingFunction = null) {
          if (roundingFunction == null) {
            roundingFunction = function(numberToRound, startNumber, endNumber) {
              let roundedNumber = null;
              let useFloor = startNumber <= endNumber;
              if (useFloor) {
                roundedNumber = Math.floor(numberToRound);
              } else {
                roundedNumber = Math.ceil(numberToRound);
              }
              return roundedNumber;
            };
          }
          super(startRange, endRange, startInterpolationValue, endInterpolationValue, easingFunction, roundingFunction);
        }
      };
    }
  });

  // js/pp/gameplay/cauldron/player/player_head_controller.js
  var require_player_head_controller = __commonJS({
    "js/pp/gameplay/cauldron/player/player_head_controller.js"() {
      PP.PlayerHeadController = class PlayerHeadController {
        constructor() {
        }
      };
    }
  });

  // js/pp/gameplay/cauldron/player/player_occlusion.js
  var require_player_occlusion = __commonJS({
    "js/pp/gameplay/cauldron/player/player_occlusion.js"() {
      PP.PlayerOcclusion = class PlayerOcclusion {
        constructor() {
        }
      };
    }
  });

  // js/pp/gameplay/cauldron/player/components/player_head_controller_component.js
  var player_head_controller_component_exports = {};
  var init_player_head_controller_component = __esm({
    "js/pp/gameplay/cauldron/player/components/player_head_controller_component.js"() {
      init_api();
      PP.PlayerHeadControllerComponent = class PlayerHeadControllerComponent extends Component {
        static TypeName = "pp-player-head-controller";
        static Properties = {};
        init() {
        }
        start() {
          this._myPlayerHeadController = new PP.PlayerHeadController();
        }
        update(dt) {
          this._myPlayerHeadController.update(dt);
        }
        getPlayerHeadController() {
          return this._myPlayerHeadController;
        }
      };
      WL.registerComponent(PP.PlayerHeadControllerComponent);
    }
  });

  // js/pp/gameplay/cauldron/player/components/player_occlusion_component.js
  var player_occlusion_component_exports = {};
  var init_player_occlusion_component = __esm({
    "js/pp/gameplay/cauldron/player/components/player_occlusion_component.js"() {
      init_api();
      PP.PlayerOcclusionComponent = class PlayerOcclusionComponent extends Component {
        static TypeName = "pp-player-occlusion";
        static Properties = {};
        init() {
        }
        start() {
          this._myPlayerOcclusion = new PP.PlayerOcclusion();
        }
        update(dt) {
          this._myPlayerOcclusion.update(dt);
        }
        getPlayerOcclusion() {
          return this._myPlayerOcclusion;
        }
      };
      WL.registerComponent(PP.PlayerOcclusionComponent);
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_params.js
  var require_collision_params = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_params.js"() {
      CollisionCheckParams = class CollisionCheckParams {
        constructor() {
          this.mySplitMovementEnabled = false;
          this.mySplitMovementMaxLength = 0;
          this.mySplitMovementMaxStepsEnabled = false;
          this.mySplitMovementMaxSteps = 0;
          this.mySplitMovementStepEqualLength = false;
          this.mySplitMovementStepEqualLengthMinLength = 0;
          this.mySplitMovementStopWhenHorizontalMovementCanceled = false;
          this.mySplitMovementStopWhenVerticalMovementCanceled = false;
          this.mySplitMovementStopCallback = null;
          this.mySplitMovementStopReturnPrevious = false;
          this.myRadius = 0;
          this.myDistanceFromFeetToIgnore = 0;
          this.myDistanceFromHeadToIgnore = 0;
          this.myPositionOffsetLocal = PP.vec3_create();
          this.myRotationOffsetLocalQuat = PP.quat_create();
          this.myHorizontalMovementCheckEnabled = false;
          this.myHorizontalMovementStepEnabled = false;
          this.myHorizontalMovementStepMaxLength = 0;
          this.myHorizontalMovementRadialStepAmount = 0;
          this.myHorizontalMovementCheckDiagonalOutward = false;
          this.myHorizontalMovementCheckDiagonalInward = false;
          this.myHorizontalMovementCheckStraight = false;
          this.myHorizontalMovementCheckHorizontalBorder = false;
          this.myHorizontalMovementCheckVerticalStraight = false;
          this.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = false;
          this.myHorizontalMovementCheckVerticalDiagonalUpwardInward = false;
          this.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = false;
          this.myHorizontalMovementCheckVerticalDiagonalDownwardInward = false;
          this.myHorizontalMovementCheckVerticalStraightDiagonalUpward = false;
          this.myHorizontalMovementCheckVerticalStraightDiagonalDownward = false;
          this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = false;
          this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = false;
          this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
          this.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
          this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
          this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
          this.myHorizontalPositionCheckEnabled = false;
          this.myHalfConeAngle = 0;
          this.myHalfConeSliceAmount = 0;
          this.myCheckConeBorder = false;
          this.myCheckConeRay = false;
          this.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = true;
          this.myHorizontalPositionCheckVerticalDirectionType = 0;
          this.myCheckHorizontalFixedForwardEnabled = false;
          this.myCheckHorizontalFixedForward = PP.vec3_create();
          this.myVerticalMovementCheckEnabled = false;
          this.myVerticalPositionCheckEnabled = false;
          this.myFeetRadius = 0;
          this.myAdjustVerticalMovementWithGroundAngleDownhill = false;
          this.myAdjustVerticalMovementWithGroundAngleUphill = false;
          this.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = null;
          this.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = null;
          this.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = null;
          this.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = null;
          this.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
          this.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = null;
          this.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
          this.myAdjustVerticalMovementWithCeilingAngleUphill = false;
          this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = null;
          this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = null;
          this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = null;
          this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = null;
          this.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
          this.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = null;
          this.myCheckVerticalFixedForwardEnabled = false;
          this.myCheckVerticalFixedForward = PP.vec3_create();
          this.myCheckVerticalBothDirection = false;
          this.mySnapOnGroundEnabled = false;
          this.mySnapOnGroundExtraDistance = 0;
          this.mySnapOnCeilingEnabled = false;
          this.mySnapOnCeilingExtraDistance = 0;
          this.myGroundPopOutEnabled = false;
          this.myGroundPopOutExtraDistance = 0;
          this.myCeilingPopOutEnabled = false;
          this.myCeilingPopOutExtraDistance = 0;
          this.myVerticalMovementReduceEnabled = false;
          this.myGroundCircumferenceAddCenter = false;
          this.myGroundCircumferenceSliceAmount = 0;
          this.myGroundCircumferenceStepAmount = 0;
          this.myGroundCircumferenceRotationPerStep = 0;
          this.myVerticalAllowHitInsideCollisionIfOneOk = false;
          this.myCheckHeight = false;
          this.myCheckHeightVerticalMovement = false;
          this.myCheckHeightVerticalPosition = false;
          this.myCheckHeightTopMovement = false;
          this.myCheckHeightTopPosition = false;
          this.myCheckHeightConeOnCollision = false;
          this.myCheckHeightConeOnCollisionKeepHit = false;
          this.myHeightCheckStepAmountMovement = 0;
          this.myHeightCheckStepAmountPosition = 0;
          this.myCheckVerticalStraight = false;
          this.myCheckVerticalDiagonalRayOutward = false;
          this.myCheckVerticalDiagonalRayInward = false;
          this.myCheckVerticalDiagonalBorderOutward = false;
          this.myCheckVerticalDiagonalBorderInward = false;
          this.myCheckVerticalDiagonalBorderRayOutward = false;
          this.myCheckVerticalDiagonalBorderRayInward = false;
          this.myCheckVerticalSearchFartherVerticalHit = false;
          this.myGroundAngleToIgnore = 0;
          this.myGroundAngleToIgnoreWithPerceivedAngle = null;
          this.myCeilingAngleToIgnore = 0;
          this.myCeilingAngleToIgnoreWithPerceivedAngle = null;
          this.myHorizontalMovementGroundAngleIgnoreHeight = null;
          this.myHorizontalMovementCeilingAngleIgnoreHeight = null;
          this.myHorizontalPositionGroundAngleIgnoreHeight = null;
          this.myHorizontalPositionCeilingAngleIgnoreHeight = null;
          this.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = null;
          this.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = null;
          this.myHeight = 0;
          this.myComputeGroundInfoEnabled = false;
          this.myComputeCeilingInfoEnabled = false;
          this.myDistanceToBeOnGround = 0;
          this.myDistanceToComputeGroundInfo = 0;
          this.myDistanceToBeOnCeiling = 0;
          this.myDistanceToComputeCeilingInfo = 0;
          this.myVerticalFixToBeOnGround = 0;
          this.myVerticalFixToComputeGroundInfo = 0;
          this.myVerticalFixToBeOnCeiling = 0;
          this.myVerticalFixToComputeCeilingInfo = 0;
          this.myGroundIsBaseInsideCollisionCheckEnabled = false;
          this.myCeilingIsBaseInsideCollisionCheckEnabled = false;
          this.myIsOnGroundIfInsideHit = false;
          this.myIsOnCeilingIfInsideHit = false;
          this.myIsOnGroundMaxSurfaceAngle = null;
          this.myIsOnCeilingMaxSurfaceAngle = null;
          this.myFindGroundDistanceMaxOutsideDistance = 0;
          this.myFindGroundDistanceMaxInsideDistance = 0;
          this.myFindCeilingDistanceMaxOutsideDistance = 0;
          this.myFindCeilingDistanceMaxInsideDistance = 0;
          this.myAllowGroundSteepFix = false;
          this.myAllowCeilingSteepFix = false;
          this.myMustStayOnGround = false;
          this.myMustStayOnCeiling = false;
          this.myMustStayOnValidGroundAngleDownhill = false;
          this.myMustStayOnValidCeilingAngleDownhill = false;
          this.myRegatherGroundInfoOnSurfaceCheckFail = false;
          this.myRegatherCeilingInfoOnSurfaceCheckFail = false;
          this.myMustStayBelowIgnorableGroundAngleDownhill = false;
          this.myMustStayBelowIgnorableCeilingAngleDownhill = false;
          this.myMustStayBelowGroundAngleDownhill = null;
          this.myMustStayBelowCeilingAngleDownhill = null;
          this.myMovementMustStayOnGroundHitAngle = null;
          this.myMovementMustStayOnCeilingHitAngle = null;
          this.myTeleportMustBeOnIgnorableGroundAngle = false;
          this.myCheckTransformMustBeOnIgnorableGroundAngle = false;
          this.myTeleportMustBeOnIgnorableCeilingAngle = false;
          this.myCheckTransformMustBeOnIgnorableCeilingAngle = false;
          this.myTeleportMustBeOnGroundAngle = null;
          this.myCheckTransformMustBeOnGroundAngle = null;
          this.myTeleportMustBeOnCeilingAngle = null;
          this.myCheckTransformMustBeOnCeilingAngle = null;
          this.myTeleportMustBeOnGround = false;
          this.myCheckTransformMustBeOnGround = false;
          this.myTeleportMustBeOnCeiling = false;
          this.myCheckTransformMustBeOnCeiling = false;
          this.mySlidingEnabled = false;
          this.mySlidingHorizontalMovementCheckBetterNormal = false;
          this.mySlidingMaxAttempts = 0;
          this.mySlidingCheckBothDirections = false;
          this.mySlidingFlickeringPreventionType = 0;
          this.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = false;
          this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
          this.mySlidingAdjustSign90Degrees = false;
          this.myHorizontalBlockLayerFlags = new PP.PhysicsLayerFlags();
          this.myHorizontalObjectsToIgnore = [];
          this.myVerticalBlockLayerFlags = new PP.PhysicsLayerFlags();
          this.myVerticalObjectsToIgnore = [];
          this.myExtraMovementCheckCallback = null;
          this.myExtraTeleportCheckCallback = null;
          this.myExtraCheckTransformCheckCallback = null;
          this.myDebugActive = false;
          this.myDebugHorizontalMovementActive = false;
          this.myDebugHorizontalPositionActive = false;
          this.myDebugVerticalMovementActive = false;
          this.myDebugVerticalPositionActive = false;
          this.myDebugSlidingActive = false;
          this.myDebugGroundInfoActive = false;
          this.myDebugCeilingInfoActive = false;
          this.myDebugRuntimeParamsActive = false;
          this.myDebugMovementActive = false;
        }
        copy(other) {
          this.mySplitMovementEnabled = other.mySplitMovementEnabled;
          this.mySplitMovementMaxLength = other.mySplitMovementMaxLength;
          this.mySplitMovementMaxStepsEnabled = other.mySplitMovementMaxStepsEnabled;
          this.mySplitMovementMaxSteps = other.mySplitMovementMaxSteps;
          this.mySplitMovementStepEqualLength = other.mySplitMovementStepEqualLength;
          this.mySplitMovementStepEqualLengthMinLength = other.mySplitMovementStepEqualLengthMinLength;
          this.mySplitMovementStopWhenHorizontalMovementCanceled = other.mySplitMovementStopWhenHorizontalMovementCanceled;
          this.mySplitMovementStopWhenVerticalMovementCanceled = other.mySplitMovementStopWhenVerticalMovementCanceled;
          this.mySplitMovementStopCallback = other.mySplitMovementStopCallback;
          this.mySplitMovementStopReturnPrevious = other.mySplitMovementStopReturnPrevious;
          this.myRadius = other.myRadius;
          this.myDistanceFromFeetToIgnore = other.myDistanceFromFeetToIgnore;
          this.myDistanceFromHeadToIgnore = other.myDistanceFromHeadToIgnore;
          this.myPositionOffsetLocal.vec3_copy(other.myPositionOffsetLocal);
          this.myRotationOffsetLocalQuat.quat_copy(other.myRotationOffsetLocalQuat);
          this.myHorizontalMovementCheckEnabled = other.myHorizontalMovementCheckEnabled;
          this.myHorizontalMovementStepEnabled = other.myHorizontalMovementStepEnabled;
          this.myHorizontalMovementStepMaxLength = other.myHorizontalMovementStepMaxLength;
          this.myHorizontalMovementRadialStepAmount = other.myHorizontalMovementRadialStepAmount;
          this.myHorizontalMovementCheckDiagonalOutward = other.myHorizontalMovementCheckDiagonalOutward;
          this.myHorizontalMovementCheckDiagonalInward = other.myHorizontalMovementCheckDiagonalInward;
          this.myHorizontalMovementCheckStraight = other.myHorizontalMovementCheckStraight;
          this.myHorizontalMovementCheckHorizontalBorder = other.myHorizontalMovementCheckHorizontalBorder;
          this.myHorizontalMovementCheckVerticalStraight = other.myHorizontalMovementCheckVerticalStraight;
          this.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = other.myHorizontalMovementCheckVerticalDiagonalUpwardOutward;
          this.myHorizontalMovementCheckVerticalDiagonalUpwardInward = other.myHorizontalMovementCheckVerticalDiagonalUpwardInward;
          this.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = other.myHorizontalMovementCheckVerticalDiagonalDownwardOutward;
          this.myHorizontalMovementCheckVerticalDiagonalDownwardInward = other.myHorizontalMovementCheckVerticalDiagonalDownwardInward;
          this.myHorizontalMovementCheckVerticalStraightDiagonalUpward = other.myHorizontalMovementCheckVerticalStraightDiagonalUpward;
          this.myHorizontalMovementCheckVerticalStraightDiagonalDownward = other.myHorizontalMovementCheckVerticalStraightDiagonalDownward;
          this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = other.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward;
          this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = other.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward;
          this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = other.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
          this.myHorizontalMovementVerticalStraightCentralCheckEnabled = other.myHorizontalMovementVerticalStraightCentralCheckEnabled;
          this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
          this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
          this.myHorizontalPositionCheckEnabled = other.myHorizontalPositionCheckEnabled;
          this.myHalfConeAngle = other.myHalfConeAngle;
          this.myHalfConeSliceAmount = other.myHalfConeSliceAmount;
          this.myCheckConeBorder = other.myCheckConeBorder;
          this.myCheckConeRay = other.myCheckConeRay;
          this.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = other.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision;
          this.myHorizontalPositionCheckVerticalDirectionType = other.myHorizontalPositionCheckVerticalDirectionType;
          this.myVerticalMovementCheckEnabled = other.myVerticalMovementCheckEnabled;
          this.myVerticalPositionCheckEnabled = other.myVerticalPositionCheckEnabled;
          this.myFeetRadius = other.myFeetRadius;
          this.myAdjustVerticalMovementWithGroundAngleDownhill = other.myAdjustVerticalMovementWithGroundAngleDownhill;
          this.myAdjustVerticalMovementWithGroundAngleUphill = other.myAdjustVerticalMovementWithGroundAngleUphill;
          this.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle;
          this.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = other.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle;
          this.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = other.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle;
          this.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = other.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle;
          this.myAdjustHorizontalMovementWithGroundAngleDownhill = other.myAdjustHorizontalMovementWithGroundAngleDownhill;
          this.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = other.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle;
          this.myAdjustVerticalMovementWithCeilingAngleDownhill = other.myAdjustVerticalMovementWithCeilingAngleDownhill;
          this.myAdjustVerticalMovementWithCeilingAngleUphill = other.myAdjustVerticalMovementWithCeilingAngleUphill;
          this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle;
          this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle;
          this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle;
          this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle;
          this.myAdjustHorizontalMovementWithCeilingAngleDownhill = other.myAdjustHorizontalMovementWithCeilingAngleDownhill;
          this.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = other.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle;
          this.myCheckVerticalFixedForwardEnabled = other.myCheckVerticalFixedForwardEnabled;
          this.myCheckVerticalFixedForward.vec3_copy(other.myCheckVerticalFixedForward);
          this.myCheckVerticalBothDirection = other.myCheckVerticalBothDirection;
          this.mySnapOnGroundEnabled = other.mySnapOnGroundEnabled;
          this.mySnapOnGroundExtraDistance = other.mySnapOnGroundExtraDistance;
          this.mySnapOnCeilingEnabled = other.mySnapOnCeilingEnabled;
          this.mySnapOnCeilingExtraDistance = other.mySnapOnCeilingExtraDistance;
          this.myGroundPopOutEnabled = other.myGroundPopOutEnabled;
          this.myGroundPopOutExtraDistance = other.myGroundPopOutExtraDistance;
          this.myCeilingPopOutEnabled = other.myCeilingPopOutEnabled;
          this.myCeilingPopOutExtraDistance = other.myCeilingPopOutExtraDistance;
          this.myVerticalMovementReduceEnabled = other.myVerticalMovementReduceEnabled;
          this.myGroundCircumferenceAddCenter = other.myGroundCircumferenceAddCenter;
          this.myGroundCircumferenceSliceAmount = other.myGroundCircumferenceSliceAmount;
          this.myGroundCircumferenceStepAmount = other.myGroundCircumferenceStepAmount;
          this.myGroundCircumferenceRotationPerStep = other.myGroundCircumferenceRotationPerStep;
          this.myVerticalAllowHitInsideCollisionIfOneOk = other.myVerticalAllowHitInsideCollisionIfOneOk;
          this.myCheckHeight = other.myCheckHeight;
          this.myCheckHeightVerticalMovement = other.myCheckHeightVerticalMovement;
          this.myCheckHeightVerticalPosition = other.myCheckHeightVerticalPosition;
          this.myCheckHeightTopMovement = other.myCheckHeightTopMovement;
          this.myCheckHeightTopPosition = other.myCheckHeightTopPosition;
          this.myCheckHeightConeOnCollision = other.myCheckHeightConeOnCollision;
          this.myCheckHeightConeOnCollisionKeepHit = other.myCheckHeightConeOnCollisionKeepHit;
          this.myHeightCheckStepAmountMovement = other.myHeightCheckStepAmountMovement;
          this.myHeightCheckStepAmountPosition = other.myHeightCheckStepAmountPosition;
          this.myCheckVerticalStraight = other.myCheckVerticalStraight;
          this.myCheckVerticalDiagonalRayOutward = other.myCheckVerticalDiagonalRayOutward;
          this.myCheckVerticalDiagonalRayInward = other.myCheckVerticalDiagonalRayInward;
          this.myCheckVerticalDiagonalBorderOutward = other.myCheckVerticalDiagonalBorderOutward;
          this.myCheckVerticalDiagonalBorderInward = other.myCheckVerticalDiagonalBorderInward;
          this.myCheckVerticalDiagonalBorderRayOutward = other.myCheckVerticalDiagonalBorderRayOutward;
          this.myCheckVerticalDiagonalBorderRayInward = other.myCheckVerticalDiagonalBorderRayInward;
          this.myCheckVerticalSearchFartherVerticalHit = other.myCheckVerticalSearchFartherVerticalHit;
          this.myGroundAngleToIgnore = other.myGroundAngleToIgnore;
          this.myGroundAngleToIgnoreWithPerceivedAngle = other.myGroundAngleToIgnoreWithPerceivedAngle;
          this.myCeilingAngleToIgnore = other.myCeilingAngleToIgnore;
          this.myCeilingAngleToIgnoreWithPerceivedAngle = other.myCeilingAngleToIgnoreWithPerceivedAngle;
          this.myHorizontalMovementGroundAngleIgnoreHeight = other.myHorizontalMovementGroundAngleIgnoreHeight;
          this.myHorizontalMovementCeilingAngleIgnoreHeight = other.myHorizontalMovementCeilingAngleIgnoreHeight;
          this.myHorizontalPositionGroundAngleIgnoreHeight = other.myHorizontalPositionGroundAngleIgnoreHeight;
          this.myHorizontalPositionCeilingAngleIgnoreHeight = other.myHorizontalPositionCeilingAngleIgnoreHeight;
          this.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = other.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
          this.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = other.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft;
          this.myHeight = other.myHeight;
          this.myComputeGroundInfoEnabled = other.myComputeGroundInfoEnabled;
          this.myComputeCeilingInfoEnabled = other.myComputeCeilingInfoEnabled;
          this.myDistanceToBeOnGround = other.myDistanceToBeOnGround;
          this.myDistanceToComputeGroundInfo = other.myDistanceToComputeGroundInfo;
          this.myDistanceToBeOnCeiling = other.myDistanceToBeOnCeiling;
          this.myDistanceToComputeCeilingInfo = other.myDistanceToComputeCeilingInfo;
          this.myVerticalFixToBeOnGround = other.myVerticalFixToBeOnGround;
          this.myVerticalFixToComputeGroundInfo = other.myVerticalFixToComputeGroundInfo;
          this.myVerticalFixToBeOnCeiling = other.myVerticalFixToBeOnCeiling;
          this.myVerticalFixToComputeCeilingInfo = other.myVerticalFixToComputeCeilingInfo;
          this.myGroundIsBaseInsideCollisionCheckEnabled = other.myGroundIsBaseInsideCollisionCheckEnabled;
          this.myCeilingIsBaseInsideCollisionCheckEnabled = other.myCeilingIsBaseInsideCollisionCheckEnabled;
          this.myIsOnGroundIfInsideHit = other.myIsOnGroundIfInsideHit;
          this.myIsOnCeilingIfInsideHit = other.myIsOnCeilingIfInsideHit;
          this.myIsOnGroundMaxSurfaceAngle = other.myIsOnGroundMaxSurfaceAngle;
          this.myIsOnCeilingMaxSurfaceAngle = other.myIsOnCeilingMaxSurfaceAngle;
          this.myFindGroundDistanceMaxOutsideDistance = other.myFindGroundDistanceMaxOutsideDistance;
          this.myFindGroundDistanceMaxInsideDistance = other.myFindGroundDistanceMaxInsideDistance;
          this.myFindCeilingDistanceMaxOutsideDistance = other.myFindCeilingDistanceMaxOutsideDistance;
          this.myFindCeilingDistanceMaxInsideDistance = other.myFindCeilingDistanceMaxInsideDistance;
          this.myAllowGroundSteepFix = other.myAllowGroundSteepFix;
          this.myAllowCeilingSteepFix = other.myAllowCeilingSteepFix;
          this.myMustStayOnGround = other.myMustStayOnGround;
          this.myMustStayOnCeiling = other.myMustStayOnCeiling;
          this.myMustStayOnValidGroundAngleDownhill = other.myMustStayOnValidGroundAngleDownhill;
          this.myMustStayOnValidCeilingAngleDownhill = other.myMustStayOnValidCeilingAngleDownhill;
          this.myRegatherGroundInfoOnSurfaceCheckFail = other.myRegatherGroundInfoOnSurfaceCheckFail;
          this.myRegatherCeilingInfoOnSurfaceCheckFail = other.myRegatherCeilingInfoOnSurfaceCheckFail;
          this.myMustStayBelowGroundAngleDownhill = other.myMustStayBelowGroundAngleDownhill;
          this.myMustStayBelowCeilingAngleDownhill = other.myMustStayBelowCeilingAngleDownhill;
          this.myMustStayBelowIgnorableGroundAngleDownhill = other.myMustStayBelowIgnorableGroundAngleDownhill;
          this.myMustStayBelowIgnorableCeilingAngleDownhill = other.myMustStayBelowIgnorableCeilingAngleDownhill;
          this.myMovementMustStayOnGroundHitAngle = other.myMovementMustStayOnGroundHitAngle;
          this.myMovementMustStayOnCeilingHitAngle = other.myMovementMustStayOnCeilingHitAngle;
          this.myTeleportMustBeOnIgnorableGroundAngle = other.myTeleportMustBeOnIgnorableGroundAngle;
          this.myCheckTransformMustBeOnIgnorableGroundAngle = other.myCheckTransformMustBeOnIgnorableGroundAngle;
          this.myTeleportMustBeOnIgnorableCeilingAngle = other.myTeleportMustBeOnIgnorableCeilingAngle;
          this.myCheckTransformMustBeOnIgnorableCeilingAngle = other.myCheckTransformMustBeOnIgnorableCeilingAngle;
          this.myTeleportMustBeOnGroundAngle = other.myTeleportMustBeOnGroundAngle;
          this.myCheckTransformMustBeOnGroundAngle = other.myCheckTransformMustBeOnGroundAngle;
          this.myTeleportMustBeOnCeilingAngle = other.myTeleportMustBeOnCeilingAngle;
          this.myCheckTransformMustBeOnCeilingAngle = other.myCheckTransformMustBeOnCeilingAngle;
          this.myTeleportMustBeOnGround = other.myTeleportMustBeOnGround;
          this.myCheckTransformMustBeOnGround = other.myCheckTransformMustBeOnGround;
          this.myTeleportMustBeOnCeiling = other.myTeleportMustBeOnCeiling;
          this.myCheckTransformMustBeOnCeiling = other.myCheckTransformMustBeOnCeiling;
          this.mySlidingEnabled = other.mySlidingEnabled;
          this.mySlidingHorizontalMovementCheckBetterNormal = other.mySlidingHorizontalMovementCheckBetterNormal;
          this.mySlidingMaxAttempts = other.mySlidingMaxAttempts;
          this.mySlidingCheckBothDirections = other.mySlidingCheckBothDirections;
          this.mySlidingFlickeringPreventionType = other.mySlidingFlickeringPreventionType;
          this.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = other.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding;
          this.mySlidingFlickerPreventionCheckAnywayCounter = other.mySlidingFlickerPreventionCheckAnywayCounter;
          this.mySlidingAdjustSign90Degrees = other.mySlidingAdjustSign90Degrees;
          this.myHorizontalBlockLayerFlags.copy(other.myHorizontalBlockLayerFlags);
          this.myHorizontalObjectsToIgnore.pp_copy(other.myHorizontalObjectsToIgnore);
          this.myVerticalBlockLayerFlags.copy(other.myVerticalBlockLayerFlags);
          this.myVerticalObjectsToIgnore.pp_copy(other.myVerticalObjectsToIgnore);
          this.myExtraMovementCheckCallback = other.myExtraMovementCheckCallback;
          this.myExtraTeleportCheckCallback = other.myExtraTeleportCheckCallback;
          this.myExtraCheckTransformCheckCallback = other.myExtraCheckTransformCheckCallback;
          this.myDebugActive = other.myDebugActive;
          this.myDebugHorizontalMovementActive = other.myDebugHorizontalMovementActive;
          this.myDebugHorizontalPositionActive = other.myDebugHorizontalPositionActive;
          this.myDebugVerticalMovementActive = other.myDebugVerticalMovementActive;
          this.myDebugVerticalPositionActive = other.myDebugVerticalPositionActive;
          this.myDebugSlidingActive = other.myDebugSlidingActive;
          this.myDebugGroundInfoActive = other.myDebugGroundInfoActive;
          this.myDebugCeilingInfoActive = other.myDebugCeilingInfoActive;
          this.myDebugRuntimeParamsActive = other.myDebugRuntimeParamsActive;
          this.myDebugMovementActive = other.myDebugMovementActive;
        }
      };
      CollisionRuntimeParams = class CollisionRuntimeParams {
        constructor() {
          this.myOriginalPosition = PP.vec3_create();
          this.myNewPosition = PP.vec3_create();
          this.myOriginalHeight = 0;
          this.myOriginalForward = PP.vec3_create();
          this.myOriginalUp = PP.vec3_create();
          this.myOriginalMovement = PP.vec3_create();
          this.myFixedMovement = PP.vec3_create();
          this.myLastValidOriginalHorizontalMovement = PP.vec3_create();
          this.myLastValidOriginalVerticalMovement = PP.vec3_create();
          this.myLastValidSurfaceAdjustedHorizontalMovement = PP.vec3_create();
          this.myLastValidSurfaceAdjustedVerticalMovement = PP.vec3_create();
          this.myLastValidEndHorizontalMovement = PP.vec3_create();
          this.myLastValidEndVerticalMovement = PP.vec3_create();
          this.myIsOnGround = false;
          this.myGroundAngle = 0;
          this.myGroundPerceivedAngle = 0;
          this.myGroundNormal = PP.vec3_create();
          this.myGroundHitMaxAngle = 0;
          this.myGroundHitMaxNormal = PP.vec3_create();
          this.myGroundDistance = null;
          this.myGroundIsBaseInsideCollision = false;
          this.myIsOnCeiling = false;
          this.myCeilingAngle = 0;
          this.myCeilingPerceivedAngle = 0;
          this.myCeilingNormal = PP.vec3_create();
          this.myCeilingHitMaxAngle = 0;
          this.myCeilingHitMaxNormal = PP.vec3_create();
          this.myCeilingDistance = null;
          this.myCeilingIsBaseInsideCollision = false;
          this.myHorizontalMovementCanceled = false;
          this.myIsCollidingHorizontally = false;
          this.myHorizontalCollisionHit = new PP.RaycastHit();
          this.myVerticalMovementCanceled = false;
          this.myIsCollidingVertically = false;
          this.myVerticalCollisionHit = new PP.RaycastHit();
          this.myHasSnappedOnGround = false;
          this.myHasSnappedOnCeiling = false;
          this.myHasPoppedOutGround = false;
          this.myHasPoppedOutCeiling = false;
          this.myHasReducedVerticalMovement = false;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = false;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = false;
          this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = false;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = false;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = false;
          this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = false;
          this.myIsSliding = false;
          this.myIsSlidingIntoOppositeDirection = false;
          this.myIsSlidingFlickerPrevented = false;
          this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
          this.mySlidingMovementAngle = 0;
          this.mySlidingCollisionAngle = 0;
          this.mySlidingCollisionHit = new PP.RaycastHit();
          this.mySlidingWallNormal = new PP.vec3_create();
          this.mySliding90DegreesSign = 0;
          this.mySlidingRecompute90DegreesSign = true;
          this.myLastValidIsSliding = false;
          this.mySlidingPreviousHorizontalMovement = PP.vec3_create();
          this.myOriginalTeleportPosition = PP.vec3_create();
          this.myFixedTeleportPosition = PP.vec3_create();
          this.myOriginalPositionCheckPosition = PP.vec3_create();
          this.myFixedPositionCheckPosition = PP.vec3_create();
          this.myTeleportCanceled = false;
          this.myIsPositionOk = false;
          this.myIsTeleport = false;
          this.myIsMove = false;
          this.myIsPositionCheck = false;
          this.myIsPositionCheckAllowAdjustments = false;
          this.mySplitMovementSteps = 0;
          this.mySplitMovementStepsPerformed = 0;
          this.mySplitMovementStop = false;
          this.mySplitMovementMovementChecked = PP.vec3_create();
          this.myRealIsOnGround = false;
          this.myRealIsOnCeiling = false;
        }
        reset() {
          this.myOriginalPosition.vec3_zero();
          this.myNewPosition.vec3_zero();
          this.myOriginalHeight = 0;
          this.myOriginalForward.vec3_zero();
          this.myOriginalUp.vec3_zero();
          this.myOriginalMovement.vec3_zero();
          this.myFixedMovement.vec3_zero();
          this.myLastValidOriginalHorizontalMovement.vec3_zero();
          this.myLastValidOriginalVerticalMovement.vec3_zero();
          this.myLastValidSurfaceAdjustedHorizontalMovement.vec3_zero();
          this.myLastValidSurfaceAdjustedVerticalMovement.vec3_zero();
          this.myLastValidEndHorizontalMovement.vec3_zero();
          this.myLastValidEndVerticalMovement.vec3_zero();
          this.myIsOnGround = false;
          this.myGroundAngle = 0;
          this.myGroundPerceivedAngle = 0;
          this.myGroundNormal.vec3_zero();
          this.myGroundHitMaxAngle = 0;
          this.myGroundHitMaxNormal.vec3_zero();
          this.myGroundDistance = null;
          this.myGroundIsBaseInsideCollision = false;
          this.myIsOnCeiling = false;
          this.myCeilingAngle = 0;
          this.myCeilingPerceivedAngle = 0;
          this.myCeilingNormal.vec3_zero();
          this.myCeilingHitMaxAngle = 0;
          this.myCeilingHitMaxNormal.vec3_zero();
          this.myCeilingDistance = null;
          this.myCeilingIsBaseInsideCollision = false;
          this.myHorizontalMovementCanceled = false;
          this.myIsCollidingHorizontally = false;
          this.myHorizontalCollisionHit.reset();
          this.myVerticalMovementCanceled = false;
          this.myIsCollidingVertically = false;
          this.myVerticalCollisionHit.reset();
          this.myHasSnappedOnGround = false;
          this.myHasSnappedOnCeiling = false;
          this.myHasPoppedOutGround = false;
          this.myHasPoppedOutCeiling = false;
          this.myHasReducedVerticalMovement = false;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = false;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = false;
          this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = false;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = false;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = false;
          this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = false;
          this.myIsSliding = false;
          this.myIsSlidingIntoOppositeDirection = false;
          this.myIsSlidingFlickerPrevented = false;
          this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
          this.mySlidingMovementAngle = 0;
          this.mySlidingCollisionAngle = 0;
          this.mySlidingCollisionHit.reset();
          this.mySliding90DegreesSign = 0;
          this.mySlidingRecompute90DegreesSign = true;
          this.myLastValidIsSliding = false;
          this.mySlidingPreviousHorizontalMovement.vec3_zero();
          this.mySlidingWallNormal.vec3_zero();
          this.myOriginalTeleportPosition.vec3_zero();
          this.myFixedTeleportPosition.vec3_zero();
          this.myOriginalPositionCheckPosition.vec3_zero();
          this.myFixedPositionCheckPosition.vec3_zero();
          this.myTeleportCanceled = false;
          this.myIsPositionOk = false;
          this.myIsTeleport = false;
          this.myIsMove = false;
          this.myIsPositionCheck = false;
          this.myIsPositionCheckAllowAdjustments = false;
          this.mySplitMovementSteps = 0;
          this.mySplitMovementStepsPerformed = 0;
          this.mySplitMovementStop = false;
          this.mySplitMovementMovementChecked.vec3_zero();
          this.myRealIsOnGround = false;
          this.myRealIsOnCeiling = false;
        }
        copy(other) {
          this.myOriginalPosition.vec3_copy(other.myOriginalPosition);
          this.myNewPosition.vec3_copy(other.myNewPosition);
          this.myOriginalHeight = other.myOriginalHeight;
          this.myOriginalForward.vec3_copy(other.myOriginalForward);
          this.myOriginalUp.vec3_copy(other.myOriginalUp);
          this.myOriginalMovement.vec3_copy(other.myOriginalMovement);
          this.myFixedMovement.vec3_copy(other.myFixedMovement);
          this.myLastValidOriginalHorizontalMovement.vec3_copy(other.myLastValidOriginalHorizontalMovement);
          this.myLastValidOriginalVerticalMovement.vec3_copy(other.myLastValidOriginalVerticalMovement);
          this.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(other.myLastValidSurfaceAdjustedHorizontalMovement);
          this.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(other.myLastValidSurfaceAdjustedVerticalMovement);
          this.myLastValidEndHorizontalMovement.vec3_copy(other.myLastValidEndHorizontalMovement);
          this.myLastValidEndVerticalMovement.vec3_copy(other.myLastValidEndVerticalMovement);
          this.myIsOnGround = other.myIsOnGround;
          this.myGroundAngle = other.myGroundAngle;
          this.myGroundPerceivedAngle = other.myGroundPerceivedAngle;
          this.myGroundNormal.vec3_copy(other.myGroundNormal);
          this.myGroundHitMaxAngle = other.myGroundHitMaxAngle;
          this.myGroundHitMaxNormal.vec3_copy(other.myGroundHitMaxNormal);
          this.myGroundDistance = other.myGroundDistance;
          this.myGroundIsBaseInsideCollision = other.myGroundIsBaseInsideCollision;
          this.myIsOnCeiling = other.myIsOnCeiling;
          this.myCeilingAngle = other.myCeilingAngle;
          this.myCeilingPerceivedAngle = other.myCeilingPerceivedAngle;
          this.myCeilingNormal.vec3_copy(other.myCeilingNormal);
          this.myCeilingHitMaxAngle = other.myCeilingHitMaxAngle;
          this.myCeilingHitMaxNormal.vec3_copy(other.myCeilingHitMaxNormal);
          this.myCeilingDistance = other.myCeilingDistance;
          this.myCeilingIsBaseInsideCollision = other.myCeilingIsBaseInsideCollision;
          this.myHorizontalMovementCanceled = other.myHorizontalMovementCanceled;
          this.myIsCollidingHorizontally = other.myIsCollidingHorizontally;
          this.myHorizontalCollisionHit.copy(other.myHorizontalCollisionHit);
          this.myVerticalMovementCanceled = other.myVerticalMovementCanceled;
          this.myIsCollidingVertically = other.myIsCollidingVertically;
          this.myVerticalCollisionHit.copy(other.myVerticalCollisionHit);
          this.myHasSnappedOnGround = other.myHasSnappedOnGround;
          this.myHasSnappedOnCeiling = other.myHasSnappedOnCeiling;
          this.myHasPoppedOutGround = other.myHasPoppedOutGround;
          this.myHasPoppedOutCeiling = other.myHasPoppedOutCeiling;
          this.myHasReducedVerticalMovement = other.myHasReducedVerticalMovement;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = other.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = other.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill;
          this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = other.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = other.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill;
          this.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = other.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill;
          this.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = other.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill;
          this.myIsSliding = other.myIsSliding;
          this.myIsSlidingIntoOppositeDirection = other.myIsSlidingIntoOppositeDirection;
          this.myIsSlidingFlickerPrevented = other.myIsSlidingFlickerPrevented;
          this.mySlidingFlickerPreventionCheckAnywayCounter = other.mySlidingFlickerPreventionCheckAnywayCounter;
          this.mySlidingMovementAngle = other.mySlidingMovementAngle;
          this.mySlidingCollisionAngle = other.mySlidingCollisionAngle;
          this.mySlidingCollisionHit.copy(other.mySlidingCollisionHit);
          this.mySliding90DegreesSign = other.mySliding90DegreesSign;
          this.mySlidingRecompute90DegreesSign = other.mySlidingRecompute90DegreesSign;
          this.myLastValidIsSliding = other.myLastValidIsSliding;
          this.mySlidingPreviousHorizontalMovement.vec3_copy(other.mySlidingPreviousHorizontalMovement);
          this.mySlidingWallNormal.vec3_copy(other.mySlidingWallNormal);
          this.myOriginalTeleportPosition.vec3_copy(other.myOriginalTeleportPosition);
          this.myFixedTeleportPosition.vec3_copy(other.myFixedTeleportPosition);
          this.myTeleportCanceled = other.myTeleportCanceled;
          this.myIsPositionOk = other.myIsPositionOk;
          this.myOriginalPositionCheckPosition.vec3_copy(other.myOriginalPositionCheckPosition);
          this.myFixedPositionCheckPosition.vec3_copy(other.myFixedPositionCheckPosition);
          this.myIsTeleport = other.myIsTeleport;
          this.myIsMove = other.myIsMove;
          this.myIsPositionCheck = other.myIsPositionCheck;
          this.myIsPositionCheckAllowAdjustments = other.myIsPositionCheckAllowAdjustments;
          this.mySplitMovementSteps = other.mySplitMovementSteps;
          this.mySplitMovementStepsPerformed = other.mySplitMovementStepsPerformed;
          this.mySplitMovementStop = other.mySplitMovementStop;
          this.mySplitMovementMovementChecked.vec3_copy(other.mySplitMovementMovementChecked);
          this.myRealIsOnGround = other.myRealIsOnGround;
          this.myRealIsOnCeiling = other.myRealIsOnCeiling;
        }
      };
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_check.js
  var require_collision_check = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_check.js"() {
      _myTotalRaycasts = 0;
      _myTotalRaycastsMax = 0;
      CollisionCheckUtils = {
        generate360TeleportParamsFromMovementParams: function(movementParams, outTeleportParams = new CollisionCheckParams()) {
          outTeleportParams.copy(movementParams);
          outTeleportParams.myHalfConeAngle = 180;
          outTeleportParams.myHalfConeSliceAmount = Math.round(outTeleportParams.myHalfConeAngle / movementParams.myHalfConeAngle * movementParams.myHalfConeSliceAmount);
          outTeleportParams.myCheckHorizontalFixedForwardEnabled = true;
          outTeleportParams.myCheckHorizontalFixedForward = PP.vec3_create(0, 0, 1);
          return outTeleportParams;
        }
      };
      CollisionCheck = class CollisionCheck {
        constructor() {
          this._myRaycastSetup = new PP.RaycastSetup();
          this._myRaycastResult = new PP.RaycastResults();
          this._myFixRaycastResult = new PP.RaycastResults();
          this._myBackupRaycastHit = new PP.RaycastHit();
          this._myPrevCollisionRuntimeParams = new CollisionRuntimeParams();
          this._mySlidingCollisionRuntimeParams = new CollisionRuntimeParams();
          this._myCheckBetterSlidingNormalCollisionRuntimeParams = new CollisionRuntimeParams();
          this._myInternalSlidingCollisionRuntimeParams = new CollisionRuntimeParams();
          this._mySlidingFlickeringFixCollisionRuntimeParams = new CollisionRuntimeParams();
          this._mySlidingFlickeringFixSlidingCollisionRuntimeParams = new CollisionRuntimeParams();
          this._mySlidingOppositeDirectionCollisionRuntimeParams = new CollisionRuntimeParams();
          this._mySlidingOnVerticalCheckCollisionRuntimeParams = new CollisionRuntimeParams();
          this._myDebugActive = false;
          _myTotalRaycasts = 0;
          _myTotalRaycastsMax = 0;
        }
        move(movement, transformQuat3, collisionCheckParams, collisionRuntimeParams) {
          this._move(movement, transformQuat3, collisionCheckParams, collisionRuntimeParams);
        }
        //#TODO add teleport position/transform and return originalteleportransform
        // instead of position old transform / new transform
        teleport(position, transformQuat3, collisionCheckParams, collisionRuntimeParams) {
          this._teleport(position, transformQuat3, collisionCheckParams, collisionRuntimeParams);
        }
        positionCheck(allowFix, transformQuat3, collisionCheckParams, collisionRuntimeParams) {
          this._positionCheck(allowFix, transformQuat3, collisionCheckParams, collisionRuntimeParams);
        }
        updateSurfaceInfo(transformQuat3, collisionCheckParams, collisionRuntimeParams) {
          this._updateSurfaceInfo(transformQuat3, collisionCheckParams, collisionRuntimeParams);
        }
        _debugMovement(movement, fixedMovement, feetPosition, up, collisionCheckParams) {
          let originalHorizontalMovement = movement.vec3_removeComponentAlongAxis(up);
          let horizontalMovement = fixedMovement.vec3_removeComponentAlongAxis(up);
          let verticalMovement = fixedMovement.vec3_componentAlongAxis(up);
          let feetPositionPlusOffset = feetPosition.vec3_add(up.vec3_scale(collisionCheckParams.myDistanceFromFeetToIgnore + 1e-3));
          if (!originalHorizontalMovement.vec3_isZero()) {
            originalHorizontalMovement.vec3_normalize(originalHorizontalMovement);
            PP.myDebugVisualManager.drawArrow(0, feetPositionPlusOffset, originalHorizontalMovement, 0.2, PP.vec4_create(0.5, 0.5, 1, 1));
          }
          if (!horizontalMovement.vec3_isZero()) {
            horizontalMovement.vec3_normalize(horizontalMovement);
            PP.myDebugVisualManager.drawArrow(0, feetPositionPlusOffset, horizontalMovement, 0.2, PP.vec4_create(0, 0, 1, 1));
          }
          if (!verticalMovement.vec3_isZero()) {
            verticalMovement.vec3_normalize(verticalMovement);
            PP.myDebugVisualManager.drawArrow(0, feetPosition, verticalMovement, 0.2, PP.vec4_create(0, 0, 1, 1));
          }
        }
        _debugRuntimeParams(collisionRuntimeParams) {
          if (collisionRuntimeParams.myHorizontalCollisionHit.isValid()) {
            PP.myDebugVisualManager.drawArrow(
              0,
              collisionRuntimeParams.myHorizontalCollisionHit.myPosition,
              collisionRuntimeParams.myHorizontalCollisionHit.myNormal,
              0.2,
              PP.vec4_create(1, 0, 0, 1)
            );
          }
          if (collisionRuntimeParams.mySlidingCollisionHit.isValid()) {
            PP.myDebugVisualManager.drawArrow(
              0,
              collisionRuntimeParams.mySlidingCollisionHit.myPosition,
              collisionRuntimeParams.mySlidingCollisionHit.myNormal,
              0.2,
              PP.vec4_create(1, 0, 0, 1)
            );
          }
          if (collisionRuntimeParams.myVerticalCollisionHit.isValid()) {
            PP.myDebugVisualManager.drawArrow(
              0,
              collisionRuntimeParams.myVerticalCollisionHit.myPosition,
              collisionRuntimeParams.myVerticalCollisionHit.myNormal,
              0.2,
              PP.vec4_create(1, 0, 0, 1)
            );
          }
        }
      };
      CollisionCheck.prototype._raycastAndDebug = function() {
        return function _raycastAndDebug(origin, direction, distance4, ignoreHitsInsideCollision, isHorizontal, collisionCheckParams, collisionRuntimeParams) {
          this._myRaycastSetup.myOrigin.vec3_copy(origin);
          this._myRaycastSetup.myDirection.vec3_copy(direction);
          this._myRaycastSetup.myDistance = distance4;
          if (isHorizontal) {
            this._myRaycastSetup.myBlockLayerFlags.copy(collisionCheckParams.myHorizontalBlockLayerFlags);
            this._myRaycastSetup.myObjectsToIgnore = collisionCheckParams.myHorizontalObjectsToIgnore;
          } else {
            this._myRaycastSetup.myBlockLayerFlags.copy(collisionCheckParams.myVerticalBlockLayerFlags);
            this._myRaycastSetup.myObjectsToIgnore = collisionCheckParams.myVerticalObjectsToIgnore;
          }
          this._myRaycastSetup.myIgnoreHitsInsideCollision = ignoreHitsInsideCollision;
          let raycastResult = PP.PhysicsUtils.raycast(this._myRaycastSetup, this._myRaycastResult);
          _myTotalRaycasts++;
          if (this._myDebugActive) {
            PP.myDebugVisualManager.drawRaycast(0, raycastResult);
          }
          return raycastResult;
        };
      }();
      Object.defineProperty(CollisionCheck.prototype, "_raycastAndDebug", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_movement_check.js
  var require_collision_movement_check = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_movement_check.js"() {
      CollisionCheck.prototype._move = function() {
        let transformUp = PP.vec3_create();
        let transformForward = PP.vec3_create();
        let feetPosition = PP.vec3_create();
        let transformOffsetLocalQuat = PP.quat2_create();
        let offsetTransformQuat = PP.quat2_create();
        let horizontalMovement = PP.vec3_create();
        let verticalMovement = PP.vec3_create();
        let movementStep = PP.vec3_create();
        let currentMovementStep = PP.vec3_create();
        let movementChecked = PP.vec3_create();
        let fixedMovement = PP.vec3_create();
        let newFeetPosition = PP.vec3_create();
        let fixedMovementStep = PP.vec3_create();
        let previousCollisionRuntimeParams = new CollisionRuntimeParams();
        let previousFixedMovement = PP.vec3_create();
        let previousMovementChecked = PP.vec3_create();
        return function _move(movement, transformQuat3, collisionCheckParams, collisionRuntimeParams) {
          transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
          offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat3, offsetTransformQuat);
          if (transformQuat3.vec_equals(offsetTransformQuat, 1e-5)) {
            offsetTransformQuat.quat2_copy(transformQuat3);
          }
          transformUp = offsetTransformQuat.quat2_getUp(transformUp);
          transformForward = offsetTransformQuat.quat2_getForward(transformForward);
          feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
          let height = collisionCheckParams.myHeight;
          height = height - 1e-5;
          if (height < 1e-5) {
            height = 0;
          }
          horizontalMovement = movement.vec3_removeComponentAlongAxis(transformUp, horizontalMovement);
          verticalMovement = movement.vec3_componentAlongAxis(transformUp, verticalMovement);
          let movementStepAmount = 1;
          movementStep.vec3_copy(movement);
          if (!movement.vec3_isZero(1e-5) && collisionCheckParams.mySplitMovementEnabled) {
            let equalStepLength = movement.vec3_length() / collisionCheckParams.mySplitMovementMaxSteps;
            if (!collisionCheckParams.mySplitMovementStepEqualLength || equalStepLength < collisionCheckParams.mySplitMovementStepEqualLengthMinLength) {
              let maxLength = collisionCheckParams.mySplitMovementStepEqualLength ? collisionCheckParams.mySplitMovementStepEqualLengthMinLength : collisionCheckParams.mySplitMovementMaxLength;
              movementStepAmount = Math.ceil(movement.vec3_length() / maxLength);
              if (movementStepAmount > 1) {
                movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(maxLength, movementStep);
                movementStepAmount = collisionCheckParams.mySplitMovementMaxStepsEnabled ? Math.min(movementStepAmount, collisionCheckParams.mySplitMovementMaxSteps) : movementStepAmount;
              }
              movementStepAmount = Math.max(1, movementStepAmount);
              if (movementStepAmount == 1) {
                movementStep.vec3_copy(movement);
              }
            } else {
              movementStepAmount = collisionCheckParams.mySplitMovementMaxSteps;
              if (movementStepAmount > 1) {
                movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(equalStepLength, movementStep);
              }
            }
          }
          fixedMovement.vec3_zero();
          movementChecked.vec3_zero();
          previousCollisionRuntimeParams.copy(collisionRuntimeParams);
          previousFixedMovement.vec3_copy(fixedMovement);
          previousMovementChecked.vec3_copy(movementChecked);
          let stepsPerformed = 0;
          let splitMovementStop = false;
          for (let i = 0; i < movementStepAmount; i++) {
            if (movementStepAmount == 1 || i != movementStepAmount - 1) {
              currentMovementStep.vec3_copy(movementStep);
            } else {
              currentMovementStep = movement.vec3_sub(movementChecked, currentMovementStep);
            }
            newFeetPosition = feetPosition.vec3_add(fixedMovement, newFeetPosition);
            fixedMovementStep.vec3_zero();
            fixedMovementStep = this._moveStep(currentMovementStep, newFeetPosition, transformUp, transformForward, height, true, collisionCheckParams, collisionRuntimeParams, fixedMovementStep);
            fixedMovement.vec3_add(fixedMovementStep, fixedMovement);
            movementChecked = movementChecked.vec3_add(movementStep, movementChecked);
            stepsPerformed = i + 1;
            if (collisionRuntimeParams.myHorizontalMovementCanceled && collisionRuntimeParams.myVerticalMovementCanceled || collisionRuntimeParams.myHorizontalMovementCanceled && collisionCheckParams.mySplitMovementStopWhenHorizontalMovementCanceled || collisionRuntimeParams.myVerticalMovementCanceled && collisionCheckParams.mySplitMovementStopWhenVerticalMovementCanceled || collisionCheckParams.mySplitMovementStopCallback != null && collisionCheckParams.mySplitMovementStopCallback(collisionRuntimeParams)) {
              if (collisionCheckParams.mySplitMovementStopReturnPrevious) {
                collisionRuntimeParams.copy(previousCollisionRuntimeParams);
                fixedMovement.vec3_copy(previousFixedMovement);
                movementChecked.vec3_copy(previousMovementChecked);
                stepsPerformed -= 1;
              }
              splitMovementStop = true;
              break;
            }
            previousCollisionRuntimeParams.copy(collisionRuntimeParams);
            previousFixedMovement.vec3_copy(fixedMovement);
            previousMovementChecked.vec3_copy(movementChecked);
          }
          collisionRuntimeParams.mySplitMovementSteps = movementStepAmount;
          collisionRuntimeParams.mySplitMovementStepsPerformed = stepsPerformed;
          collisionRuntimeParams.mySplitMovementStop = splitMovementStop;
          collisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(movementChecked);
          collisionRuntimeParams.myOriginalUp = transformQuat3.quat2_getUp(collisionRuntimeParams.myOriginalUp);
          collisionRuntimeParams.myOriginalForward = transformQuat3.quat2_getForward(collisionRuntimeParams.myOriginalForward);
          collisionRuntimeParams.myOriginalPosition = transformQuat3.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
          collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
          collisionRuntimeParams.myOriginalMovement.vec3_copy(movement);
          collisionRuntimeParams.myFixedMovement.vec3_copy(fixedMovement);
          collisionRuntimeParams.myNewPosition = collisionRuntimeParams.myOriginalPosition.vec3_add(collisionRuntimeParams.myFixedMovement, collisionRuntimeParams.myNewPosition);
          collisionRuntimeParams.myIsMove = true;
        };
      }();
      CollisionCheck.prototype._moveStep = function() {
        let horizontalMovement = PP.vec3_create();
        let verticalMovement = PP.vec3_create();
        let fixedHorizontalMovement = PP.vec3_create();
        let fixedVerticalMovement = PP.vec3_create();
        let horizontalDirection = PP.vec3_create();
        let forwardForHorizontal = PP.vec3_create();
        let forwardForVertical = PP.vec3_create();
        let forwardForPerceivedAngle = PP.vec3_create();
        let newFeetPosition = PP.vec3_create();
        let surfaceAdjustedVerticalMovement = PP.vec3_create();
        let surfaceAdjustedHorizontalMovement = PP.vec3_create();
        let fixedMovement = PP.vec3_create();
        let zAxis = PP.vec3_create(0, 0, 1);
        let xAxis = PP.vec3_create(1, 0, 0);
        return function _moveStep(movement, feetPosition, transformUp, transformForward, height, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
          horizontalMovement = movement.vec3_removeComponentAlongAxis(transformUp, horizontalMovement);
          if (horizontalMovement.vec3_isZero(1e-6)) {
            horizontalMovement.vec3_zero();
          }
          verticalMovement = movement.vec3_componentAlongAxis(transformUp, verticalMovement);
          if (verticalMovement.vec3_isZero(1e-6)) {
            verticalMovement.vec3_zero();
          }
          if (horizontalMovement.vec3_isZero()) {
          }
          this._myPrevCollisionRuntimeParams.copy(collisionRuntimeParams);
          collisionRuntimeParams.reset();
          surfaceAdjustedHorizontalMovement = this._adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, surfaceAdjustedHorizontalMovement);
          if (surfaceAdjustedHorizontalMovement.vec3_isZero(1e-5)) {
            surfaceAdjustedHorizontalMovement.vec3_zero();
          }
          this._syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams);
          {
            forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
            if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
              if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
                forwardForHorizontal = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForHorizontal);
              } else if (!horizontalMovement.vec3_isZero()) {
                forwardForHorizontal = horizontalMovement.vec3_normalize(forwardForHorizontal);
              } else {
                forwardForHorizontal.vec3_copy(transformForward);
              }
            } else {
              if (collisionCheckParams.myCheckHorizontalFixedForward.vec3_isOnAxis(transformUp)) {
                if (zAxis.vec3_isOnAxis(transformUp)) {
                  forwardForHorizontal.vec3_copy(xAxis);
                } else {
                  forwardForHorizontal.vec3_copy(zAxis);
                }
              }
              forwardForHorizontal = forwardForHorizontal.vec3_removeComponentAlongAxis(transformUp, forwardForHorizontal);
              forwardForHorizontal = forwardForHorizontal.vec3_normalize(forwardForHorizontal);
              if (forwardForHorizontal.vec_equals(collisionCheckParams.myCheckHorizontalFixedForward, 1e-5)) {
                forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
              }
            }
            fixedHorizontalMovement.vec3_zero();
            if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
              fixedHorizontalMovement = this._horizontalCheck(surfaceAdjustedHorizontalMovement, feetPosition, height, transformUp, forwardForHorizontal, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, false, fixedHorizontalMovement);
              if (collisionCheckParams.mySlidingEnabled && collisionRuntimeParams.myIsCollidingHorizontally && this._isSlidingNormalValid(surfaceAdjustedHorizontalMovement, transformUp, collisionRuntimeParams)) {
                fixedHorizontalMovement = this._horizontalSlide(surfaceAdjustedHorizontalMovement, feetPosition, height, transformUp, forwardForHorizontal, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, fixedHorizontalMovement);
              } else {
              }
            }
            if (fixedHorizontalMovement.vec3_isZero(1e-6)) {
              fixedHorizontalMovement.vec3_zero();
            }
            if (!surfaceAdjustedHorizontalMovement.vec3_isZero() && fixedHorizontalMovement.vec3_isZero()) {
              collisionRuntimeParams.myHorizontalMovementCanceled = true;
            }
          }
          {
            forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
            if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
              if (fixedHorizontalMovement.vec3_isZero()) {
                if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
                  forwardForVertical = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForVertical);
                } else if (!horizontalMovement.vec3_isZero()) {
                  forwardForVertical = horizontalMovement.vec3_normalize(forwardForVertical);
                } else {
                  forwardForVertical.vec3_copy(transformForward);
                }
              } else {
                forwardForVertical = fixedHorizontalMovement.vec3_normalize(forwardForVertical);
              }
            } else {
              if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
                if (zAxis.vec3_isOnAxis(transformUp)) {
                  forwardForVertical.vec3_copy(xAxis);
                } else {
                  forwardForVertical.vec3_copy(zAxis);
                }
              }
              forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
              forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
              if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
                forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
              }
            }
            surfaceAdjustedVerticalMovement = this._adjustVerticalMovementWithSurface(fixedHorizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, surfaceAdjustedVerticalMovement);
            newFeetPosition = feetPosition.vec3_add(fixedHorizontalMovement, newFeetPosition);
            let originalMovementSign = Math.pp_sign(verticalMovement.vec3_lengthSigned(transformUp), 0);
            fixedVerticalMovement.vec3_zero();
            fixedVerticalMovement = this._verticalCheck(surfaceAdjustedVerticalMovement, originalMovementSign, newFeetPosition, height, transformUp, forwardForVertical, collisionCheckParams, collisionRuntimeParams, fixedVerticalMovement);
            if (fixedVerticalMovement.vec3_isZero(1e-6)) {
              fixedVerticalMovement.vec3_zero();
            }
          }
          outFixedMovement.vec3_zero();
          if (!collisionRuntimeParams.myIsCollidingVertically) {
            outFixedMovement = fixedHorizontalMovement.vec3_add(fixedVerticalMovement, outFixedMovement);
          } else {
            collisionRuntimeParams.myHorizontalMovementCanceled = true;
            collisionRuntimeParams.myVerticalMovementCanceled = true;
            fixedHorizontalMovement.vec3_zero();
            fixedVerticalMovement.vec3_zero();
            if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
              if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
                forwardForVertical = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForVertical);
              } else if (!horizontalMovement.vec3_isZero()) {
                forwardForVertical = horizontalMovement.vec3_normalize(forwardForVertical);
              } else {
                forwardForVertical.vec3_copy(transformForward);
              }
            }
          }
          newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
          forwardForPerceivedAngle.vec3_copy(transformForward);
          if (!fixedHorizontalMovement.vec3_isZero()) {
            forwardForPerceivedAngle = fixedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
          } else if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
            forwardForPerceivedAngle = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
          } else if (!horizontalMovement.vec3_isZero()) {
            forwardForPerceivedAngle = horizontalMovement.vec3_normalize(forwardForPerceivedAngle);
          }
          if (collisionCheckParams.myComputeGroundInfoEnabled) {
            this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
          }
          if (collisionCheckParams.myComputeCeilingInfoEnabled) {
            this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
          }
          if (!surfaceAdjustedHorizontalMovement.vec3_isZero() && !collisionRuntimeParams.myHorizontalMovementCanceled) {
            let surfaceCheckOk = this._postSurfaceCheck(fixedHorizontalMovement, fixedVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams);
            if (!surfaceCheckOk) {
              collisionRuntimeParams.myHorizontalMovementCanceled = true;
              collisionRuntimeParams.myVerticalMovementCanceled = true;
              fixedHorizontalMovement.vec3_zero();
              fixedVerticalMovement.vec3_zero();
              outFixedMovement.vec3_zero();
              newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
              if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
                forwardForPerceivedAngle = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
              } else if (!horizontalMovement.vec3_isZero()) {
                forwardForPerceivedAngle = horizontalMovement.vec3_normalize(forwardForPerceivedAngle);
              } else {
                forwardForPerceivedAngle.vec3_copy(transformForward);
              }
              if (collisionCheckParams.myComputeGroundInfoEnabled && collisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail) {
                this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
              } else {
                collisionRuntimeParams.myIsOnGround = this._myPrevCollisionRuntimeParams.myIsOnGround;
                collisionRuntimeParams.myGroundAngle = this._myPrevCollisionRuntimeParams.myGroundAngle;
                collisionRuntimeParams.myGroundPerceivedAngle = this._myPrevCollisionRuntimeParams.myGroundPerceivedAngle;
                collisionRuntimeParams.myGroundNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundNormal);
              }
              if (collisionCheckParams.myComputeCeilingInfoEnabled && collisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail) {
                this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
              } else {
                collisionRuntimeParams.myIsOnCeiling = this._myPrevCollisionRuntimeParams.myIsOnCeiling;
                collisionRuntimeParams.myCeilingAngle = this._myPrevCollisionRuntimeParams.myCeilingAngle;
                collisionRuntimeParams.myCeilingPerceivedAngle = this._myPrevCollisionRuntimeParams.myCeilingPerceivedAngle;
                collisionRuntimeParams.myCeilingNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingNormal);
              }
            }
          }
          if (collisionCheckParams.myExtraMovementCheckCallback != null) {
            fixedMovement.vec3_copy(outFixedMovement);
            outFixedMovement = collisionCheckParams.myExtraMovementCheckCallback(
              movement,
              fixedMovement,
              feetPosition,
              transformUp,
              transformForward,
              height,
              collisionCheckParams,
              this._myPrevCollisionRuntimeParams,
              collisionRuntimeParams,
              outFixedMovement
            );
            fixedHorizontalMovement = outFixedMovement.vec3_removeComponentAlongAxis(transformUp, fixedHorizontalMovement);
            fixedVerticalMovement = outFixedMovement.vec3_componentAlongAxis(transformUp, fixedVerticalMovement);
          }
          {
            if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
              if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myIsSliding && !fixedHorizontalMovement.vec3_isZero()) {
                collisionRuntimeParams.mySlidingRecompute90DegreesSign = true;
              }
            }
            if (!horizontalMovement.vec3_isZero()) {
              collisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(horizontalMovement);
            }
            if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
              collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(surfaceAdjustedHorizontalMovement);
            }
            if (!verticalMovement.vec3_isZero()) {
              collisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(verticalMovement);
            }
            if (!surfaceAdjustedVerticalMovement.vec3_isZero()) {
              collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(surfaceAdjustedVerticalMovement);
            }
            if (!fixedHorizontalMovement.vec3_isZero(1e-6)) {
              collisionRuntimeParams.myLastValidIsSliding = collisionRuntimeParams.myIsSliding;
              collisionRuntimeParams.myIsSlidingFlickerPrevented = false;
              collisionRuntimeParams.myLastValidEndHorizontalMovement.vec3_copy(fixedHorizontalMovement);
              if (!collisionRuntimeParams.myIsSliding) {
              } else {
              }
            } else {
            }
            if (!fixedVerticalMovement.vec3_isZero(1e-6)) {
              collisionRuntimeParams.myLastValidEndVerticalMovement.vec3_copy(fixedVerticalMovement);
            }
          }
          let moveStepFixed = false;
          if (!collisionRuntimeParams.myHorizontalMovementCanceled && !fixedHorizontalMovement.vec3_isZero(1e-6)) {
            horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
            let surfaceTooSteepResults = this._surfaceTooSteep(transformUp, horizontalDirection, collisionCheckParams, this._myPrevCollisionRuntimeParams);
            if (surfaceTooSteepResults[0] || surfaceTooSteepResults[1]) {
              horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
              let newSurfaceTooSteepResults = this._surfaceTooSteep(transformUp, horizontalDirection, collisionCheckParams, collisionRuntimeParams);
              if (surfaceTooSteepResults[0] && newSurfaceTooSteepResults[0] || surfaceTooSteepResults[1] && newSurfaceTooSteepResults[1] || !allowSurfaceSteepFix || surfaceTooSteepResults[0] && !collisionCheckParams.myAllowGroundSteepFix || surfaceTooSteepResults[1] && !collisionCheckParams.myAllowCeilingSteepFix) {
                outFixedMovement.vec3_zero();
                collisionRuntimeParams.copy(this._myPrevCollisionRuntimeParams);
                this._moveStep(movement, feetPosition, transformUp, transformForward, height, false, collisionCheckParams, collisionRuntimeParams, outFixedMovement);
                moveStepFixed = true;
              }
            }
          }
          if (!moveStepFixed) {
            if (collisionCheckParams.myDebugActive && collisionCheckParams.myDebugMovementActive) {
              this._debugMovement(movement, outFixedMovement, newFeetPosition, transformUp, collisionCheckParams);
            }
            if (collisionCheckParams.myDebugActive && collisionCheckParams.myDebugRuntimeParamsActive) {
              this._debugRuntimeParams(collisionRuntimeParams);
            }
          }
          return outFixedMovement;
        };
      }();
      CollisionCheck.prototype._syncCollisionRuntimeParamsWithPrevious = function() {
        let previousFixedHorizontalMovement = PP.vec3_create();
        return function _syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
          collisionRuntimeParams.myIsSlidingFlickerPrevented = previousCollisionRuntimeParams.myIsSlidingFlickerPrevented;
          collisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidOriginalHorizontalMovement);
          collisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidOriginalVerticalMovement);
          collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement);
          collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement);
          collisionRuntimeParams.myLastValidIsSliding = previousCollisionRuntimeParams.myLastValidIsSliding;
          collisionRuntimeParams.mySliding90DegreesSign = previousCollisionRuntimeParams.mySliding90DegreesSign;
          collisionRuntimeParams.mySlidingRecompute90DegreesSign = previousCollisionRuntimeParams.mySlidingRecompute90DegreesSign;
          if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
            let angleWithPreviousThreshold = 0.5;
            if (!previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_isZero() && !surfaceAdjustedHorizontalMovement.vec3_isZero() && surfaceAdjustedHorizontalMovement.vec3_angle(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement) > angleWithPreviousThreshold) {
              if (!previousCollisionRuntimeParams.myLastValidIsSliding) {
                let angleSigned = surfaceAdjustedHorizontalMovement.vec3_angleSigned(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement, up);
                let angleSignedThreshold = 10;
                if (Math.abs(angleSigned) < 180 - angleSignedThreshold) {
                  collisionRuntimeParams.mySliding90DegreesSign = Math.pp_sign(angleSigned);
                }
              }
              collisionRuntimeParams.mySlidingRecompute90DegreesSign = true;
            }
          }
          previousFixedHorizontalMovement = previousCollisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis(up, previousFixedHorizontalMovement);
          if (previousFixedHorizontalMovement.vec3_isZero(1e-6)) {
            collisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.mySlidingPreviousHorizontalMovement);
          } else {
            collisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(previousFixedHorizontalMovement);
          }
        };
      }();
      Object.defineProperty(CollisionCheck.prototype, "_move", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_moveStep", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_syncCollisionRuntimeParamsWithPrevious", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_teleport_check.js
  var require_collision_teleport_check = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_teleport_check.js"() {
      CollisionCheck.prototype._teleport = function() {
        let transformUp = PP.vec3_create();
        let transformForward = PP.vec3_create();
        let feetPosition = PP.vec3_create();
        let originalFeetPosition = PP.vec3_create();
        let transformOffsetLocalQuat = PP.quat2_create();
        let offsetTransformQuat = PP.quat2_create();
        let feetPositionOffsetToOriginal = PP.vec3_create();
        let offsetTeleportPosition = PP.vec3_create();
        let zero4 = PP.vec3_create();
        let forwardForHorizontal = PP.vec3_create();
        let forwardForVertical = PP.vec3_create();
        let forwardForPerceivedAngle = PP.vec3_create();
        let fixedHorizontalMovement = PP.vec3_create();
        let fixedVerticalMovement = PP.vec3_create();
        let newFeetPosition = PP.vec3_create();
        let endPosition = PP.vec3_create();
        let zAxis = PP.vec3_create(0, 0, 1);
        let xAxis = PP.vec3_create(1, 0, 0);
        return function _teleport(teleportPosition, transformQuat3, collisionCheckParams, collisionRuntimeParams, isPositionCheck = false) {
          transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
          offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat3, offsetTransformQuat);
          if (transformQuat3.vec_equals(offsetTransformQuat, 1e-5)) {
            offsetTransformQuat.quat2_copy(transformQuat3);
          }
          transformUp = offsetTransformQuat.quat2_getUp(transformUp);
          transformForward = offsetTransformQuat.quat2_getForward(transformForward);
          feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
          offsetTeleportPosition.vec3_copy(teleportPosition);
          originalFeetPosition = transformQuat3.quat2_getPosition(originalFeetPosition);
          feetPositionOffsetToOriginal = originalFeetPosition.vec3_sub(feetPosition, feetPositionOffsetToOriginal);
          if (feetPositionOffsetToOriginal.vec3_isZero(1e-5)) {
            feetPositionOffsetToOriginal.vec3_zero();
          } else {
            offsetTeleportPosition = offsetTeleportPosition.vec3_sub(feetPositionOffsetToOriginal, offsetTeleportPosition);
          }
          let height = collisionCheckParams.myHeight;
          height = height - 1e-5;
          if (height < 1e-5) {
            height = 0;
          }
          this._myPrevCollisionRuntimeParams.copy(collisionRuntimeParams);
          collisionRuntimeParams.reset();
          forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
          if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
            forwardForHorizontal.vec3_copy(transformForward);
          } else {
            if (collisionCheckParams.myCheckHorizontalFixedForward.vec3_isOnAxis(transformUp)) {
              if (zAxis.vec3_isOnAxis(transformUp)) {
                forwardForHorizontal.vec3_copy(xAxis);
              } else {
                forwardForHorizontal.vec3_copy(zAxis);
              }
            }
            forwardForHorizontal = forwardForHorizontal.vec3_removeComponentAlongAxis(transformUp, forwardForHorizontal);
            forwardForHorizontal = forwardForHorizontal.vec3_normalize(forwardForHorizontal);
            if (forwardForHorizontal.vec_equals(collisionCheckParams.myCheckHorizontalFixedForward, 1e-5)) {
              forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
            }
          }
          fixedHorizontalMovement = this._horizontalCheck(zero4, offsetTeleportPosition, height, transformUp, forwardForHorizontal, false, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, false, fixedHorizontalMovement);
          if (!collisionRuntimeParams.myIsCollidingHorizontally) {
            newFeetPosition = offsetTeleportPosition.vec3_add(fixedHorizontalMovement, newFeetPosition);
            forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
            if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
              forwardForVertical.vec3_copy(transformForward);
            } else {
              if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
                if (zAxis.vec3_isOnAxis(transformUp)) {
                  forwardForVertical.vec3_copy(xAxis);
                } else {
                  forwardForVertical.vec3_copy(zAxis);
                }
              }
              forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
              forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
              if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
                forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
              }
            }
            let downward = -1;
            fixedVerticalMovement = this._verticalCheck(zero4, downward, newFeetPosition, height, transformUp, forwardForVertical, collisionCheckParams, collisionRuntimeParams, fixedVerticalMovement);
            if (!collisionRuntimeParams.myIsCollidingVertically) {
              newFeetPosition = newFeetPosition.vec3_add(fixedVerticalMovement, newFeetPosition);
              forwardForPerceivedAngle.vec3_copy(transformForward);
              if (collisionCheckParams.myComputeGroundInfoEnabled) {
                this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
              }
              if (collisionCheckParams.myComputeCeilingInfoEnabled) {
                this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
              }
              if (!collisionRuntimeParams.myIsOnGround) {
                if (collisionCheckParams.myTeleportMustBeOnGround && !isPositionCheck || collisionCheckParams.myCheckTransformMustBeOnGround && isPositionCheck) {
                  collisionRuntimeParams.myTeleportCanceled = true;
                }
              }
              if (!collisionRuntimeParams.myIsOnCeiling) {
                if (collisionCheckParams.myTeleportMustBeOnCeiling && !isPositionCheck || collisionCheckParams.myCheckTransformMustBeOnCeiling && isPositionCheck) {
                  collisionRuntimeParams.myTeleportCanceled = true;
                }
              }
              if (collisionRuntimeParams.myIsOnGround) {
                let minAngle = null;
                if (!isPositionCheck) {
                  if (collisionCheckParams.myTeleportMustBeOnIgnorableGroundAngle) {
                    minAngle = collisionCheckParams.myGroundAngleToIgnore;
                  }
                  if (collisionCheckParams.myTeleportMustBeOnGroundAngle != null) {
                    minAngle = Math.min(minAngle, collisionCheckParams.myTeleportMustBeOnGroundAngle);
                  }
                } else {
                  if (collisionCheckParams.myCheckTransformMustBeOnIgnorableGroundAngle) {
                    minAngle = collisionCheckParams.myGroundAngleToIgnore;
                  }
                  if (collisionCheckParams.myCheckTransformMustBeOnGroundAngle != null) {
                    minAngle = Math.min(minAngle, collisionCheckParams.myCheckTransformMustBeOnGroundAngle);
                  }
                }
                if (minAngle != null && collisionRuntimeParams.myGroundAngle > minAngle + 1e-4) {
                  collisionRuntimeParams.myTeleportCanceled = true;
                }
              }
              if (collisionRuntimeParams.myIsOnCeiling) {
                let minAngle = null;
                if (!isPositionCheck) {
                  if (collisionCheckParams.myTeleportMustBeOnIgnorableCeilingAngle) {
                    minAngle = collisionCheckParams.myCeilingAngleToIgnore;
                  }
                  if (collisionCheckParams.myTeleportMustBeOnCeilingAngle != null) {
                    minAngle = Math.min(minAngle, collisionCheckParams.myTeleportMustBeOnCeilingAngle);
                  }
                } else {
                  if (collisionCheckParams.myCheckTransformMustBeOnIgnorableCeilingAngle) {
                    minAngle = collisionCheckParams.myCeilingAngleToIgnore;
                  }
                  if (collisionCheckParams.myCheckTransformMustBeOnCeilingAngle != null) {
                    minAngle = Math.min(minAngle, collisionCheckParams.myCheckTransformMustBeOnCeilingAngle);
                  }
                }
                if (minAngle != null && collisionRuntimeParams.myCeilingAngle > minAngle + 1e-4) {
                  collisionRuntimeParams.myTeleportCanceled = true;
                }
              }
              if (collisionRuntimeParams.myTeleportCanceled) {
                if (collisionCheckParams.myComputeGroundInfoEnabled && collisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail) {
                  this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
                } else {
                  collisionRuntimeParams.myIsOnGround = this._myPrevCollisionRuntimeParams.myIsOnGround;
                  collisionRuntimeParams.myGroundAngle = this._myPrevCollisionRuntimeParams.myGroundAngle;
                  collisionRuntimeParams.myGroundPerceivedAngle = this._myPrevCollisionRuntimeParams.myGroundPerceivedAngle;
                  collisionRuntimeParams.myGroundNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundNormal);
                }
                if (collisionCheckParams.myComputeCeilingInfoEnabled && collisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail) {
                  this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
                } else {
                  collisionRuntimeParams.myIsOnCeiling = this._myPrevCollisionRuntimeParams.myIsOnCeiling;
                  collisionRuntimeParams.myCeilingAngle = this._myPrevCollisionRuntimeParams.myCeilingAngle;
                  collisionRuntimeParams.myCeilingPerceivedAngle = this._myPrevCollisionRuntimeParams.myCeilingPerceivedAngle;
                  collisionRuntimeParams.myCeilingNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingNormal);
                }
              }
            } else {
              collisionRuntimeParams.myTeleportCanceled = true;
            }
          } else {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
          if (!isPositionCheck) {
            if (collisionCheckParams.myExtraTeleportCheckCallback != null) {
              endPosition.vec3_copy(newFeetPosition);
              newFeetPosition = collisionCheckParams.myExtraTeleportCheckCallback(
                offsetTeleportPosition,
                endPosition,
                feetPosition,
                transformUp,
                transformForward,
                height,
                collisionCheckParams,
                this._myPrevCollisionRuntimeParams,
                collisionRuntimeParams,
                newFeetPosition
              );
            }
          } else {
            if (collisionCheckParams.myExtraCheckTransformCheckCallback != null) {
              endPosition.vec3_copy(newFeetPosition);
              newFeetPosition = collisionCheckParams.myExtraCheckTransformCheckCallback(
                endPosition,
                feetPosition,
                transformUp,
                transformForward,
                height,
                collisionCheckParams,
                this._myPrevCollisionRuntimeParams,
                collisionRuntimeParams,
                newFeetPosition
              );
            }
          }
          collisionRuntimeParams.myOriginalUp = transformQuat3.quat2_getUp(collisionRuntimeParams.myOriginalUp);
          collisionRuntimeParams.myOriginalForward = transformQuat3.quat2_getForward(collisionRuntimeParams.myOriginalForward);
          collisionRuntimeParams.myOriginalPosition = transformQuat3.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
          collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
          collisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(teleportPosition);
          if (!collisionRuntimeParams.myTeleportCanceled) {
            collisionRuntimeParams.myFixedTeleportPosition.vec3_copy(newFeetPosition);
            if (!feetPositionOffsetToOriginal.vec3_isZero(1e-5)) {
              collisionRuntimeParams.myFixedTeleportPosition = collisionRuntimeParams.myFixedTeleportPosition.vec3_add(feetPositionOffsetToOriginal, collisionRuntimeParams.myFixedTeleportPosition);
            }
            collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
          } else {
            collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myOriginalPosition);
          }
          collisionRuntimeParams.myIsTeleport = true;
          if (collisionCheckParams.myDebugActive && collisionCheckParams.myDebugRuntimeParamsActive) {
            this._debugRuntimeParams(collisionRuntimeParams);
          }
        };
      }();
      Object.defineProperty(CollisionCheck.prototype, "_teleport", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_position_check.js
  var require_collision_position_check = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_position_check.js"() {
      CollisionCheck.prototype._positionCheck = function() {
        let feetPosition = PP.vec3_create();
        return function _positionCheck(allowAdjustments, transformQuat3, collisionCheckParams, collisionRuntimeParams) {
          feetPosition = transformQuat3.quat2_getPosition(feetPosition);
          this._teleport(feetPosition, transformQuat3, collisionCheckParams, collisionRuntimeParams, true);
          collisionRuntimeParams.myIsPositionOk = !collisionRuntimeParams.myTeleportCanceled;
          collisionRuntimeParams.myIsPositionCheck = true;
          collisionRuntimeParams.myOriginalPositionCheckPosition.vec3_copy(collisionRuntimeParams.myOriginalTeleportPosition);
          collisionRuntimeParams.myFixedPositionCheckPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
          collisionRuntimeParams.myIsPositionCheckAllowAdjustments = allowAdjustments;
          if (!allowAdjustments) {
            collisionRuntimeParams.myIsPositionOk = collisionRuntimeParams.myIsPositionOk && collisionRuntimeParams.myOriginalPositionCheckPosition.vec_equals(collisionRuntimeParams.myFixedPositionCheckPosition, 1e-5);
          }
          collisionRuntimeParams.myOriginalTeleportPosition.vec3_zero();
          collisionRuntimeParams.myFixedTeleportPosition.vec3_zero();
          collisionRuntimeParams.myTeleportCanceled = false;
          collisionRuntimeParams.myIsTeleport = false;
        };
      }();
      Object.defineProperty(CollisionCheck.prototype, "_positionCheck", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/horizontal_collision_check.js
  var require_horizontal_collision_check = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/horizontal_collision_check.js"() {
      CollisionCheck.prototype._horizontalCheck = function() {
        let fixedFeetPosition = PP.vec3_create();
        let newFixedFeetPosition = PP.vec3_create();
        let newFeetPosition = PP.vec3_create();
        let horizontalDirection = PP.vec3_create();
        return function _horizontalCheck(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, avoidSlidingExtraCheck, outFixedMovement) {
          collisionRuntimeParams.myIsCollidingHorizontally = false;
          collisionRuntimeParams.myHorizontalCollisionHit.reset();
          outFixedMovement.vec3_zero();
          horizontalDirection = movement.vec3_normalize(horizontalDirection);
          let surfaceTooSteepResults = this._surfaceTooSteep(up, horizontalDirection, collisionCheckParams, previousCollisionRuntimeParams);
          if (movement.vec3_isZero(1e-6) || (!surfaceTooSteepResults[0] || allowSurfaceSteepFix && collisionCheckParams.myAllowGroundSteepFix) && (!surfaceTooSteepResults[1] || allowSurfaceSteepFix && collisionCheckParams.myAllowCeilingSteepFix)) {
            fixedFeetPosition = feetPosition.vec3_add(up.vec3_scale(collisionCheckParams.myDistanceFromFeetToIgnore + 1e-4, fixedFeetPosition), fixedFeetPosition);
            let fixedHeight = Math.max(0, height - collisionCheckParams.myDistanceFromFeetToIgnore - collisionCheckParams.myDistanceFromHeadToIgnore - 1e-4 * 2);
            let canMove = true;
            if (collisionCheckParams.myHorizontalMovementCheckEnabled && !movement.vec3_isZero(1e-6)) {
              canMove = this._horizontalMovementCheck(movement, feetPosition, height, fixedFeetPosition, fixedHeight, up, collisionCheckParams, collisionRuntimeParams);
            }
            if (canMove) {
              if (collisionCheckParams.myHorizontalPositionCheckEnabled) {
                newFixedFeetPosition = fixedFeetPosition.vec3_add(movement, newFixedFeetPosition);
                newFeetPosition = feetPosition.vec3_add(movement, newFeetPosition);
                let canStay = this._horizontalPositionCheck(newFeetPosition, height, newFixedFeetPosition, fixedHeight, up, forward, collisionCheckParams, collisionRuntimeParams);
                if (canStay) {
                  outFixedMovement.vec3_copy(movement);
                }
                if (outFixedMovement.vec3_isZero(1e-6)) {
                  outFixedMovement.vec3_zero();
                }
              } else {
                outFixedMovement.vec3_copy(movement);
              }
            } else if (!avoidSlidingExtraCheck && collisionCheckParams.mySlidingEnabled && collisionCheckParams.mySlidingHorizontalMovementCheckBetterNormal) {
              this._horizontalCheckBetterSlideNormal(movement, feetPosition, height, fixedFeetPosition, fixedHeight, up, forward, collisionCheckParams, collisionRuntimeParams);
            }
          }
          return outFixedMovement;
        };
      }();
      CollisionCheck.prototype._horizontalCheckRaycast = function() {
        let direction = PP.vec3_create();
        let fixedFeetPosition = PP.vec3_create();
        let fixedHitPosition = PP.vec3_create();
        return function _horizontalCheckRaycast(startPosition, endPosition, movementDirection, up, ignoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, fixHitOnCollision, collisionCheckParams, collisionRuntimeParams, checkAllHits = false, ignoreHitsInsideCollisionIfObjectToIgnore = false) {
          let origin = startPosition;
          direction = endPosition.vec3_sub(origin, direction);
          if (movementDirection != null && !direction.vec3_isConcordant(movementDirection)) {
            direction.vec3_negate(direction);
            origin = endPosition;
          }
          let distance4 = direction.vec3_length();
          direction.vec3_normalize(direction);
          let raycastResult = this._raycastAndDebug(origin, direction, distance4, ignoreHitsInsideCollision, true, collisionCheckParams, collisionRuntimeParams);
          let isOk = true;
          if (raycastResult.isColliding()) {
            let hitsToControl = checkAllHits ? raycastResult.myHits.length : 1;
            let validHitIndex = 0;
            for (let i = 0; i < hitsToControl; i++) {
              let hit = raycastResult.myHits[i];
              if ((ignoreGroundAngleCallback == null || !ignoreGroundAngleCallback(hit, ignoreHitsInsideCollisionIfObjectToIgnore)) && (ignoreCeilingAngleCallback == null || !ignoreCeilingAngleCallback(hit, ignoreHitsInsideCollisionIfObjectToIgnore))) {
                isOk = false;
                validHitIndex = i;
                break;
              }
            }
            if (!isOk && validHitIndex > 0) {
              for (let i = 0; i < validHitIndex; i++) {
                raycastResult.removeHit(0);
              }
            }
          }
          if (!isOk && fixHitOnCollision) {
            let hitPosition = raycastResult.myHits[0].myPosition;
            fixedFeetPosition = feetPosition.vec3_copyComponentAlongAxis(hitPosition, up, fixedFeetPosition);
            fixedHitPosition.vec3_copy(hitPosition);
            let directionOffsetEpsilonValue = 1e-4;
            direction = direction.vec3_componentAlongAxis(up, direction);
            if (!direction.vec3_isZero(1e-6)) {
              direction.vec3_normalize(direction);
              direction.vec3_scale(directionOffsetEpsilonValue, direction);
              fixedFeetPosition.vec3_add(direction, fixedFeetPosition);
              fixedHitPosition.vec3_add(direction, fixedHitPosition);
            }
            direction = fixedHitPosition.vec3_sub(fixedFeetPosition, direction);
            direction.vec3_normalize(direction);
            direction.vec3_scale(directionOffsetEpsilonValue, direction);
            fixedHitPosition = fixedHitPosition.vec3_add(direction, fixedHitPosition);
            let swapRaycastResult = this._myRaycastResult;
            this._myRaycastResult = this._myFixRaycastResult;
            isOk = this._horizontalCheckRaycast(
              fixedFeetPosition,
              fixedHitPosition,
              null,
              up,
              false,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              false,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (this._myRaycastResult.isColliding()) {
              this._myFixRaycastResult = swapRaycastResult;
            } else {
              isOk = false;
              this._myRaycastResult = swapRaycastResult;
            }
          }
          return isOk;
        };
      }();
      CollisionCheck.prototype._ignoreSurfaceAngle = function() {
        let objectsEqualCallback = (first, second) => first.pp_equals(second);
        let movementDirection = PP.vec3_create();
        let hitDirection = PP.vec3_create();
        let hitMovement = PP.vec3_create();
        let projectAlongAxis = PP.vec3_create();
        return function _ignoreSurfaceAngle(feetPosition, height, movementOrForward, objectsToIgnore, outIgnoredObjects, isGround, isMovementCheck, up, collisionCheckParams, hit, ignoreHitsInsideCollisionIfObjectToIgnore) {
          let isIgnorable = false;
          let surfaceIgnoreHeight = null;
          let groundIgnoreHeight = isMovementCheck ? collisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight : collisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight;
          let ceilingIgnoreHeight = isMovementCheck ? collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreHeight : collisionCheckParams.myHorizontalPositionCeilingAngleIgnoreHeight;
          if (isGround && groundIgnoreHeight != null) {
            surfaceIgnoreHeight = Math.pp_clamp(groundIgnoreHeight + 2e-4, 0, height);
          } else if (!isGround && ceilingIgnoreHeight != null) {
            surfaceIgnoreHeight = Math.pp_clamp(height - ceilingIgnoreHeight - 2e-4, 0, height);
          }
          let surfaceIgnoreMaxMovementLeft = null;
          if (isMovementCheck) {
            if (isGround && collisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft != null) {
              surfaceIgnoreMaxMovementLeft = collisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
            } else if (!isGround && collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft != null) {
              surfaceIgnoreMaxMovementLeft = collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft;
            }
          }
          if (!hit.myIsInsideCollision) {
            movementDirection = movementOrForward.vec3_normalize(movementDirection);
            let surfaceAngle = hit.myNormal.vec3_angle(up);
            if (!isGround) {
              surfaceAngle = 180 - surfaceAngle;
            }
            if (isGround && collisionCheckParams.myGroundAngleToIgnore > 0 && surfaceAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
              if (collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && surfaceAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
                let perceivedAngle = this.computeSurfacePerceivedAngle(
                  hit.myNormal,
                  movementDirection,
                  up,
                  true
                );
                surfaceAngle = Math.abs(perceivedAngle);
              }
            } else if (!isGround && collisionCheckParams.myCeilingAngleToIgnore > 0 && surfaceAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
              if (collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && surfaceAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
                let perceivedAngle = this.computeSurfacePerceivedAngle(
                  hit.myNormal,
                  movementDirection,
                  up,
                  false
                );
                surfaceAngle = Math.abs(perceivedAngle);
              }
            }
            if (isGround && (collisionCheckParams.myGroundAngleToIgnore > 0 && surfaceAngle <= collisionCheckParams.myGroundAngleToIgnore + 1e-4) || !isGround && (collisionCheckParams.myCeilingAngleToIgnore > 0 && surfaceAngle <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4)) {
              if (objectsToIgnore == null || objectsToIgnore.pp_hasEqual(hit.myObject, objectsEqualCallback)) {
                let surfaceHeightCheckOk = true;
                let maxMovementLeftCheckOk = true;
                if (surfaceIgnoreHeight != null) {
                  surfaceHeightCheckOk = false;
                  let feetPositionUp = feetPosition.vec3_valueAlongAxis(up);
                  let hitUp = hit.myPosition.vec3_valueAlongAxis(up);
                  let hitHeight = hitUp - feetPositionUp;
                  if (isGround && hitHeight <= surfaceIgnoreHeight || !isGround && hitHeight >= surfaceIgnoreHeight) {
                    surfaceHeightCheckOk = true;
                  } else {
                  }
                }
                if (surfaceHeightCheckOk && isMovementCheck) {
                  if (surfaceIgnoreMaxMovementLeft != null) {
                    let movementLength = movementOrForward.vec3_length();
                    if (movementLength > surfaceIgnoreMaxMovementLeft) {
                      maxMovementLeftCheckOk = false;
                      let hitPosition = hit.myPosition;
                      let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
                      hitDirection = hitPosition.vec3_sub(feetPosition, hitDirection);
                      if (hitDirection.vec3_isToTheRight(movementDirection, up)) {
                        projectAlongAxis = movementDirection.vec3_rotateAxis(-halfConeAngle, up, projectAlongAxis);
                      } else {
                        projectAlongAxis = movementDirection.vec3_rotateAxis(halfConeAngle, up, projectAlongAxis);
                      }
                      hitMovement = hitDirection.vec3_projectOnAxisAlongAxis(movementDirection, projectAlongAxis, hitMovement);
                      let hitMovementLength = hitMovement.vec3_length();
                      let movementLeft = movementLength - hitMovementLength;
                      if (movementLeft <= surfaceIgnoreMaxMovementLeft) {
                        maxMovementLeftCheckOk = true;
                      } else {
                      }
                    }
                  }
                }
                if (surfaceHeightCheckOk && maxMovementLeftCheckOk) {
                  isIgnorable = true;
                }
              }
            }
          } else if (ignoreHitsInsideCollisionIfObjectToIgnore) {
            if (objectsToIgnore == null || objectsToIgnore.pp_hasEqual(hit.myObject, objectsEqualCallback)) {
              isIgnorable = true;
            }
          }
          if (isIgnorable) {
            if (outIgnoredObjects != null) {
              outIgnoredObjects.pp_pushUnique(hit.myObject, objectsEqualCallback);
            }
          }
          return isIgnorable;
        };
      }();
      Object.defineProperty(CollisionCheck.prototype, "_horizontalCheck", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_horizontalCheckRaycast", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_ignoreSurfaceAngle", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/horizontal_collision_sliding.js
  var require_horizontal_collision_sliding = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/horizontal_collision_sliding.js"() {
      CollisionCheck.prototype._horizontalSlide = function() {
        let previousHorizontalMovement = PP.vec3_create();
        return function _horizontalSlide(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
          if (movement.vec3_isZero(1e-5)) {
            return outSlideMovement.vec3_zero();
          }
          this._mySlidingCollisionRuntimeParams.copy(collisionRuntimeParams);
          previousHorizontalMovement.vec3_copy(collisionRuntimeParams.mySlidingPreviousHorizontalMovement);
          outSlideMovement = this._internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams, false, outSlideMovement);
          if (collisionCheckParams.mySlidingCheckBothDirections) {
            this._horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, this._myPrevCollisionRuntimeParams.myIsSliding, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement);
          }
          if (this._mySlidingCollisionRuntimeParams.myIsSliding && collisionCheckParams.mySlidingFlickeringPreventionType > 0) {
            let isFlickering = this._horizontalSlideFlickerCheck(movement, outSlideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams);
            this._mySlidingCollisionRuntimeParams.myIsSliding = !isFlickering;
          }
          if (this._mySlidingCollisionRuntimeParams.myIsSliding) {
            let backupFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented;
            collisionRuntimeParams.copy(this._mySlidingCollisionRuntimeParams);
            collisionRuntimeParams.myIsSlidingFlickerPrevented = backupFlickerPrevented || this._mySlidingCollisionRuntimeParams.myIsSlidingFlickerPrevented;
          } else {
            collisionRuntimeParams.myIsSlidingFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented || this._mySlidingCollisionRuntimeParams.myIsSlidingFlickerPrevented;
            outSlideMovement.vec3_zero();
          }
          return outSlideMovement;
        };
      }();
      CollisionCheck.prototype._horizontalSlideCheckOpposite = function() {
        let horizontalCollisionNormal = PP.vec3_create();
        let oppositeSlideMovement = PP.vec3_create();
        return function _horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, previousIsSliding, allowSurfaceSteepFix, collisionCheckParams, preSlideCollisionRuntimeParams, postSlideCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
          horizontalCollisionNormal = preSlideCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, horizontalCollisionNormal);
          horizontalCollisionNormal.vec3_normalize(horizontalCollisionNormal);
          let angleNormalWithMovementThreshold = 20;
          if (horizontalCollisionNormal.vec3_angle(movement) > 180 - angleNormalWithMovementThreshold) {
            return;
          } else if (previousIsSliding && postSlideCollisionRuntimeParams.myIsSliding && outSlideMovement.vec3_isConcordant(previousHorizontalMovement)) {
            return;
          } else {
          }
          this._mySlidingOppositeDirectionCollisionRuntimeParams.copy(preSlideCollisionRuntimeParams);
          oppositeSlideMovement = this._internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingOppositeDirectionCollisionRuntimeParams, previousCollisionRuntimeParams, true, oppositeSlideMovement);
          if (this._mySlidingOppositeDirectionCollisionRuntimeParams.myIsSliding) {
            let isOppositeBetter = false;
            if (postSlideCollisionRuntimeParams.myIsSliding) {
              if (movement.vec3_angle(oppositeSlideMovement) < movement.vec3_angle(outSlideMovement) - 1e-4) {
                isOppositeBetter = true;
              } else {
                if (Math.abs(movement.vec3_angle(oppositeSlideMovement) - movement.vec3_angle(outSlideMovement)) <= 1e-4) {
                  if (previousHorizontalMovement.vec3_angle(oppositeSlideMovement) < previousHorizontalMovement.vec3_angle(outSlideMovement) - 1e-4) {
                    let angleNormalWithMovementThreshold2 = 5;
                    if (horizontalCollisionNormal.vec3_angle(movement) < 90 + angleNormalWithMovementThreshold2) {
                      isOppositeBetter = true;
                    }
                  }
                }
              }
            } else {
              let angleEpsilon = 1e-3;
              if (movement.vec3_isConcordant(oppositeSlideMovement) && movement.vec3_angle(oppositeSlideMovement) < 90 - angleEpsilon) {
                isOppositeBetter = true;
              } else {
              }
            }
            if (isOppositeBetter) {
              outSlideMovement.vec3_copy(oppositeSlideMovement);
              postSlideCollisionRuntimeParams.copy(this._mySlidingOppositeDirectionCollisionRuntimeParams);
            } else {
            }
          } else {
          }
        };
      }();
      CollisionCheck.prototype._horizontalSlideFlickerCheck = function() {
        let previousHorizontalMovement = PP.vec3_create();
        let newFeetPosition = PP.vec3_create();
        let fixedMovement = PP.vec3_create();
        let flickerFixSlideMovement = PP.vec3_create();
        return function _horizontalSlideFlickerCheck(movement, slideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
          let isFlickering = false;
          previousHorizontalMovement.vec3_copy(collisionRuntimeParams.mySlidingPreviousHorizontalMovement);
          let shouldCheckFlicker = this._myPrevCollisionRuntimeParams.myIsSlidingFlickerPrevented || previousHorizontalMovement.vec3_isZero(1e-5);
          if (!shouldCheckFlicker) {
            if (this._myPrevCollisionRuntimeParams.myIsSliding || !collisionCheckParams.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding) {
              let flickerCollisionAngle = 90;
              let flickerMovementAngle = 85;
              switch (collisionCheckParams.mySlidingFlickeringPreventionType) {
                case 1:
                  shouldCheckFlicker = previousHorizontalMovement.vec3_signTo(movement, up, 0) != slideMovement.vec3_signTo(movement, up, 0);
                  break;
                case 2:
                  shouldCheckFlicker = collisionCheckParams.mySlidingCheckBothDirections && collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
                  shouldCheckFlicker = shouldCheckFlicker || Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) > flickerCollisionAngle + 1e-5;
                  break;
                case 3:
                  shouldCheckFlicker = collisionCheckParams.mySlidingCheckBothDirections && collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
                  shouldCheckFlicker = shouldCheckFlicker || Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) > flickerCollisionAngle + 1e-5;
                  shouldCheckFlicker = shouldCheckFlicker || Math.abs(Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) - flickerCollisionAngle) < 1e-5 && Math.abs(collisionRuntimeParams.mySlidingMovementAngle) > flickerMovementAngle + 1e-5;
                  break;
                case 4:
                  shouldCheckFlicker = true;
                  break;
              }
            }
          }
          if (shouldCheckFlicker || this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter > 0) {
            if (shouldCheckFlicker) {
              collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = collisionCheckParams.mySlidingFlickerPreventionCheckAnywayCounter;
            } else {
              collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = Math.max(0, this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter - 1);
            }
            if ((collisionCheckParams.mySlidingFlickeringPreventionType != 1 || collisionRuntimeParams.myIsSlidingFlickerPrevented || this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter > 0) && (this._myPrevCollisionRuntimeParams.myIsSliding && previousHorizontalMovement.vec3_signTo(movement, up, 0) != slideMovement.vec3_signTo(movement, up, 0))) {
              isFlickering = true;
              collisionRuntimeParams.myIsSlidingFlickerPrevented = true;
            } else {
              this._mySlidingFlickeringFixCollisionRuntimeParams.reset();
              this._mySlidingFlickeringFixCollisionRuntimeParams.mySliding90DegreesSign = collisionRuntimeParams.mySliding90DegreesSign;
              this._mySlidingFlickeringFixCollisionRuntimeParams.mySlidingRecompute90DegreesSign = false;
              newFeetPosition = feetPosition.vec3_add(slideMovement, newFeetPosition);
              let backupDebugActive = collisionCheckParams.myDebugActive;
              collisionCheckParams.myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugSlidingActive;
              fixedMovement.vec3_zero();
              fixedMovement = this._horizontalCheck(movement, newFeetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixCollisionRuntimeParams, previousCollisionRuntimeParams, false, fixedMovement);
              collisionCheckParams.myDebugActive = backupDebugActive;
              if (fixedMovement.vec3_isZero(1e-5)) {
                this._mySlidingFlickeringFixSlidingCollisionRuntimeParams.copy(this._mySlidingFlickeringFixCollisionRuntimeParams);
                flickerFixSlideMovement = this._internalHorizontalSlide(movement, newFeetPosition, height, up, forward, slideMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, false, flickerFixSlideMovement);
                if (collisionCheckParams.mySlidingCheckBothDirections) {
                  this._horizontalSlideCheckOpposite(movement, newFeetPosition, height, up, forward, slideMovement, true, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixCollisionRuntimeParams, this._mySlidingFlickeringFixSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, flickerFixSlideMovement);
                }
                if (this._mySlidingFlickeringFixSlidingCollisionRuntimeParams.myIsSliding) {
                  if (slideMovement.vec3_signTo(movement, up, 0) != flickerFixSlideMovement.vec3_signTo(movement, up, 0)) {
                    isFlickering = true;
                    collisionRuntimeParams.myIsSlidingFlickerPrevented = true;
                  }
                }
              }
            }
          } else {
          }
          if (isFlickering) {
          } else {
          }
          return isFlickering;
        };
      }();
      CollisionCheck.prototype._internalHorizontalSlide = function() {
        let invertedNormal = PP.vec3_create();
        let slidingMovement = PP.vec3_create();
        let movement90 = PP.vec3_create();
        let currentMovement = PP.vec3_create();
        let slideMovementForward = PP.vec3_create();
        let fixedMovement = PP.vec3_create();
        return function _internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, checkOppositeDirection, outSlideMovement) {
          if (movement.vec3_isZero(1e-5)) {
            return outSlideMovement.vec3_zero();
          }
          invertedNormal = collisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_negate(invertedNormal);
          invertedNormal.vec3_removeComponentAlongAxis(up, invertedNormal);
          invertedNormal[0] = Math.abs(invertedNormal[0]) < 0.01 ? 0 : invertedNormal[0];
          invertedNormal[2] = Math.abs(invertedNormal[2]) < 0.01 ? 0 : invertedNormal[2];
          invertedNormal.vec3_normalize(invertedNormal);
          collisionRuntimeParams.mySlidingCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
          collisionRuntimeParams.mySlidingWallNormal.vec3_copy(collisionRuntimeParams.myHorizontalCollisionHit.myNormal);
          outSlideMovement.vec3_zero();
          slidingMovement.vec3_copy(invertedNormal);
          if (checkOppositeDirection) {
            slidingMovement.vec3_copy(movement);
            slidingMovement.vec3_normalize(slidingMovement);
          }
          if (!slidingMovement.vec3_isZero(1e-5)) {
            slidingMovement.vec3_scale(movement.vec3_length(), slidingMovement);
            let slidingSign = invertedNormal.vec3_signTo(movement, up);
            if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
              let angleThreshold = 0.1;
              if (invertedNormal.vec3_angle(movement) < angleThreshold && collisionRuntimeParams.mySliding90DegreesSign != 0) {
                slidingSign = collisionRuntimeParams.mySliding90DegreesSign;
              } else if (collisionRuntimeParams.mySliding90DegreesSign == 0 || collisionRuntimeParams.mySlidingRecompute90DegreesSign) {
                collisionRuntimeParams.mySliding90DegreesSign = slidingSign;
              } else {
              }
              collisionRuntimeParams.mySlidingRecompute90DegreesSign = false;
            }
            if (checkOppositeDirection) {
              slidingSign *= -1;
            }
            let currentAngle = 90 * slidingSign;
            let maxAngle = Math.pp_angleClamp(slidingMovement.vec3_angleSigned(movement.vec3_rotateAxis(90 * slidingSign, up, movement90), up) * slidingSign, true) * slidingSign;
            let minAngle = Math.pp_angleClamp(slidingMovement.vec3_angleSigned(movement, up) * slidingSign, true) * slidingSign;
            if (checkOppositeDirection) {
              maxAngle = currentAngle;
              minAngle = 0;
            } else {
              if (Math.abs(maxAngle) < Math.abs(minAngle)) {
                minAngle = 0;
              }
              if (Math.abs(Math.abs(maxAngle) - Math.abs(minAngle)) < 1e-4) {
                minAngle = maxAngle;
              }
              if (Math.abs(maxAngle) < Math.abs(currentAngle) || Math.abs(Math.abs(maxAngle) - Math.abs(currentAngle)) < 1e-4) {
                currentAngle = maxAngle;
              }
              if (Math.abs(currentAngle) < Math.abs(minAngle) || Math.abs(Math.abs(minAngle) - Math.abs(currentAngle)) < 1e-4) {
                currentAngle = minAngle;
              }
            }
            if (checkOppositeDirection && !previousHorizontalMovement.vec3_isZero(1e-6)) {
              let angleWithPrevious = movement.vec3_angleSigned(previousHorizontalMovement, up);
              if (Math.pp_sign(angleWithPrevious) == Math.pp_sign(maxAngle) && Math.abs(maxAngle) > Math.abs(angleWithPrevious)) {
                currentAngle = angleWithPrevious;
              }
            }
            currentMovement.vec3_zero();
            let backupDebugActive = collisionCheckParams.myDebugActive;
            collisionCheckParams.myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugSlidingActive;
            for (let i = 0; i < collisionCheckParams.mySlidingMaxAttempts; i++) {
              this._myInternalSlidingCollisionRuntimeParams.copy(collisionRuntimeParams);
              currentMovement = slidingMovement.vec3_rotateAxis(currentAngle, up, currentMovement);
              slideMovementForward.vec3_copy(forward);
              if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
                if (!currentMovement.vec3_isZero()) {
                  slideMovementForward = currentMovement.vec3_normalize(slideMovementForward);
                }
              }
              fixedMovement.vec3_zero();
              fixedMovement = this._horizontalCheck(currentMovement, feetPosition, height, up, slideMovementForward, allowSurfaceSteepFix, collisionCheckParams, this._myInternalSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, true, fixedMovement);
              if (!fixedMovement.vec3_isZero(1e-5)) {
                outSlideMovement.vec3_copy(currentMovement);
                collisionRuntimeParams.copy(this._myInternalSlidingCollisionRuntimeParams);
                collisionRuntimeParams.myIsSliding = true;
                collisionRuntimeParams.myIsSlidingIntoOppositeDirection = checkOppositeDirection;
                collisionRuntimeParams.mySlidingMovementAngle = movement.vec3_angleSigned(currentMovement, up);
                collisionRuntimeParams.mySlidingCollisionAngle = invertedNormal.vec3_angleSigned(currentMovement, up);
                maxAngle = currentAngle;
                currentAngle = (maxAngle + minAngle) / 2;
              } else {
                if (currentAngle != maxAngle) {
                  minAngle = currentAngle;
                }
                if (i == 0 && currentAngle != maxAngle) {
                  currentAngle = maxAngle;
                } else {
                  currentAngle = (minAngle + maxAngle) / 2;
                }
              }
              if (Math.abs(Math.abs(maxAngle) - Math.abs(minAngle)) < 1e-4) {
                break;
              }
            }
            collisionCheckParams.myDebugActive = backupDebugActive;
          }
          if (!collisionRuntimeParams.myIsSliding) {
            collisionRuntimeParams.mySlidingCollisionHit.reset();
          } else {
          }
          return outSlideMovement;
        };
      }();
      CollisionCheck.prototype._horizontalCheckBetterSlideNormal = function() {
        let movementDirection = PP.vec3_create();
        let hitDirection = PP.vec3_create();
        let projectAlongAxis = PP.vec3_create();
        let fixedMovement = PP.vec3_create();
        let newFixedFeetPosition = PP.vec3_create();
        let newFeetPosition = PP.vec3_create();
        return function _horizontalCheckBetterSlideNormal(movement, originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
          movementDirection = movement.vec3_normalize(movementDirection);
          let hitPosition = collisionRuntimeParams.myHorizontalCollisionHit.myPosition;
          let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
          hitDirection = hitPosition.vec3_sub(feetPosition, hitDirection);
          if (hitDirection.vec3_isToTheRight(movementDirection, up)) {
            projectAlongAxis = movementDirection.vec3_rotateAxis(-halfConeAngle, up, projectAlongAxis);
          } else {
            projectAlongAxis = movementDirection.vec3_rotateAxis(halfConeAngle, up, projectAlongAxis);
          }
          fixedMovement = hitDirection.vec3_projectOnAxisAlongAxis(movementDirection, projectAlongAxis, fixedMovement);
          if (fixedMovement.vec3_isConcordant(movementDirection)) {
            fixedMovement = movementDirection.vec3_scale(Math.min(fixedMovement.vec3_length(), movement.vec3_length()), fixedMovement);
          } else {
            fixedMovement.vec3_zero();
          }
          if (collisionCheckParams.myDebugActive && collisionCheckParams.myDebugHorizontalMovementActive) {
            PP.myDebugVisualManager.drawArrow(0, feetPosition, movementDirection, fixedMovement.vec3_length(), PP.vec4_create(1, 0, 1, 1));
          }
          this._myCheckBetterSlidingNormalCollisionRuntimeParams.copy(collisionRuntimeParams);
          this._myCheckBetterSlidingNormalCollisionRuntimeParams.myIsCollidingHorizontally = false;
          this._myCheckBetterSlidingNormalCollisionRuntimeParams.myHorizontalCollisionHit.reset();
          newFixedFeetPosition = feetPosition.vec3_add(fixedMovement, newFixedFeetPosition);
          newFeetPosition = feetPosition.vec3_add(fixedMovement, newFeetPosition);
          let backupDebugActive = collisionCheckParams.myDebugActive;
          collisionCheckParams.myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugSlidingActive;
          if (collisionCheckParams.myHorizontalPositionCheckEnabled) {
            this._horizontalPositionCheck(originalFeetPosition, originalHeight, newFixedFeetPosition, height, up, forward, collisionCheckParams, this._myCheckBetterSlidingNormalCollisionRuntimeParams);
          }
          collisionCheckParams.myDebugActive = backupDebugActive;
          if (this._myCheckBetterSlidingNormalCollisionRuntimeParams.myIsCollidingHorizontally && !this._myCheckBetterSlidingNormalCollisionRuntimeParams.myHorizontalCollisionHit.myIsInsideCollision) {
            collisionRuntimeParams.copy(this._myCheckBetterSlidingNormalCollisionRuntimeParams);
          }
        };
      }();
      CollisionCheck.prototype._isSlidingNormalValid = function() {
        let flatNormal = PP.vec3_create();
        return function _isSlidingNormalValid(movement, up, collisionRuntimeParams) {
          let isValid = false;
          flatNormal = collisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatNormal);
          flatNormal.vec3_normalize(flatNormal);
          if (!flatNormal.vec3_isZero(1e-6)) {
            isValid = true;
          }
          return isValid;
        };
      }();
      Object.defineProperty(CollisionCheck.prototype, "_horizontalSlide", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_horizontalSlideCheckOpposite", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_horizontalSlideFlickerCheck", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_internalHorizontalSlide", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_horizontalCheckBetterSlideNormal", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_isSlidingNormalValid", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/horizontal_collision_movement_check.js
  var require_horizontal_collision_movement_check = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/horizontal_collision_movement_check.js"() {
      CollisionCheck.prototype._horizontalMovementCheck = function() {
        let checkPositions = [];
        let cachedCheckPositions = [];
        let currentCachedCheckPositionIndex = 0;
        let _localGetCachedCheckPosition = function() {
          let item = null;
          while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
            cachedCheckPositions.push(PP.vec3_create());
          }
          item = cachedCheckPositions[currentCachedCheckPositionIndex];
          currentCachedCheckPositionIndex++;
          return item;
        };
        let _localGroundObjectsToIgnore = [];
        let _localCeilingObjectsToIgnore = [];
        let _localGroundCeilingObjectsToIgnore = [];
        let objectsEqualCallback = (first, second) => first.pp_equals(second);
        let movementDirection = PP.vec3_create();
        let heightOffset = PP.vec3_create();
        let heightStep = PP.vec3_create();
        let currentHeightOffset = PP.vec3_create();
        let leftRadialDirection = PP.vec3_create();
        let rightRadialDirection = PP.vec3_create();
        return function _horizontalMovementCheck(movement, originalFeetPosition, originalHeight, feetPosition, height, up, collisionCheckParams, collisionRuntimeParams) {
          this._myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugHorizontalMovementActive;
          let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
          movementDirection = movement.vec3_normalize(movementDirection);
          checkPositions.length = 0;
          currentCachedCheckPositionIndex = 0;
          let steplength = collisionCheckParams.myRadius / collisionCheckParams.myHorizontalMovementRadialStepAmount;
          {
            let tempCheckPosition = _localGetCachedCheckPosition();
            tempCheckPosition.vec3_copy(feetPosition);
            checkPositions.push(tempCheckPosition);
          }
          {
            leftRadialDirection = movementDirection.vec3_rotateAxis(halfConeAngle, up, leftRadialDirection);
            rightRadialDirection = movementDirection.vec3_rotateAxis(-halfConeAngle, up, rightRadialDirection);
            for (let i = 1; i <= collisionCheckParams.myHorizontalMovementRadialStepAmount; i++) {
              {
                let currentStep = i * steplength;
                let tempCheckPosition = _localGetCachedCheckPosition();
                let currentRadialPosition = leftRadialDirection.vec3_scale(currentStep, tempCheckPosition);
                let currentCheckPosition = currentRadialPosition.vec3_add(feetPosition, currentRadialPosition);
                checkPositions.push(currentCheckPosition);
              }
              {
                let currentStep = i * steplength;
                let tempCheckPosition = _localGetCachedCheckPosition();
                let currentRadialPosition = rightRadialDirection.vec3_scale(currentStep, tempCheckPosition);
                let currentCheckPosition = currentRadialPosition.vec3_add(feetPosition, currentRadialPosition);
                checkPositions.push(currentCheckPosition);
              }
            }
          }
          let groundObjectsToIgnore = null;
          let ceilingObjectsToIgnore = null;
          let groundCeilingObjectsToIgnore = null;
          if (collisionCheckParams.myGroundAngleToIgnore > 0) {
            groundObjectsToIgnore = _localGroundObjectsToIgnore;
            groundObjectsToIgnore.length = 0;
            groundCeilingObjectsToIgnore = _localGroundCeilingObjectsToIgnore;
            groundCeilingObjectsToIgnore.length = 0;
            let ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, groundObjectsToIgnore, true, true, up, collisionCheckParams);
            let ignoreCeilingAngleCallback = null;
            if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
              ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, groundCeilingObjectsToIgnore, false, true, up, collisionCheckParams);
            }
            heightOffset.vec3_zero();
            this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
          }
          if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
            if (!collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeight) {
              ceilingObjectsToIgnore = _localCeilingObjectsToIgnore;
              ceilingObjectsToIgnore.length = 0;
              let ignoreGroundAngleCallback = null;
              if (collisionCheckParams.myGroundAngleToIgnore > 0) {
                ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, groundObjectsToIgnore, null, true, true, up, collisionCheckParams);
              }
              let ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, ceilingObjectsToIgnore, false, true, up, collisionCheckParams);
              heightOffset = up.vec3_scale(height, heightOffset);
              this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
            }
          }
          if (!collisionRuntimeParams.myIsCollidingHorizontally) {
            let groundCeilingCheckIsFine = true;
            if (groundCeilingObjectsToIgnore != null) {
              for (let object of groundCeilingObjectsToIgnore) {
                if (!ceilingObjectsToIgnore.pp_hasEqual(object, objectsEqualCallback)) {
                  groundCeilingCheckIsFine = false;
                  break;
                }
              }
            }
            let ignoreGroundAngleCallback = null;
            let ignoreCeilingAngleCallback = null;
            if (collisionCheckParams.myGroundAngleToIgnore > 0) {
              ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, groundObjectsToIgnore, null, true, true, up, collisionCheckParams);
            }
            if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
              ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, ceilingObjectsToIgnore, null, false, true, up, collisionCheckParams);
            }
            let heightStepAmount = 0;
            if (collisionCheckParams.myCheckHeight && collisionCheckParams.myHeightCheckStepAmountMovement > 0 && height > 1e-6) {
              heightStepAmount = collisionCheckParams.myHeightCheckStepAmountMovement;
              heightStep = up.vec3_scale(height / heightStepAmount, heightStep);
            }
            for (let i = 0; i <= heightStepAmount; i++) {
              currentHeightOffset = heightStep.vec3_scale(i, currentHeightOffset);
              if (collisionCheckParams.myCheckHeightTopMovement || i == 0) {
                if (i != 0 && i != heightStepAmount || i == 0 && !groundCeilingCheckIsFine || i == 0 && collisionCheckParams.myGroundAngleToIgnore == 0 || i == heightStepAmount && collisionCheckParams.myCeilingAngleToIgnore == 0) {
                  this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, currentHeightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                  if (collisionRuntimeParams.myIsCollidingHorizontally) {
                    break;
                  }
                }
              }
              if (i > 0) {
                if (collisionCheckParams.myCheckHeightVerticalMovement) {
                  this._horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, currentHeightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                }
                if (collisionRuntimeParams.myIsCollidingHorizontally) {
                  break;
                }
              }
            }
          }
          return !collisionRuntimeParams.myIsCollidingHorizontally;
        };
      }();
      CollisionCheck.prototype._horizontalMovementVerticalCheck = function() {
        let movementStep = PP.vec3_create();
        let movementDirection = PP.vec3_create();
        let firstPosition = PP.vec3_create();
        let secondPosition = PP.vec3_create();
        let firstMovementPosition = PP.vec3_create();
        let secondMovementPosition = PP.vec3_create();
        let firstHeightPosition = PP.vec3_create();
        let secondHeightPosition = PP.vec3_create();
        let firstHeightMovementPosition = PP.vec3_create();
        let secondHeightMovementPosition = PP.vec3_create();
        return function _horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, heightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
          let isHorizontalCheckOk = true;
          let movementStepAmount = 1;
          movementStep.vec3_copy(movement);
          if (collisionCheckParams.myHorizontalMovementStepEnabled) {
            movementStepAmount = Math.max(1, Math.ceil(movement.vec3_length() / collisionCheckParams.myHorizontalMovementStepMaxLength));
            movement.vec3_scale(1 / movementStepAmount, movementStep);
          }
          movementDirection = movement.vec3_normalize(movementDirection);
          for (let m = 0; m < movementStepAmount; m++) {
            for (let j = 0; j < checkPositions.length; j++) {
              firstPosition = checkPositions[j].vec3_add(movementStep.vec3_scale(m, firstPosition), firstPosition).vec3_add(heightOffset, firstPosition);
              if (j > 0) {
                let secondIndex = Math.max(0, j - 2);
                secondPosition = checkPositions[secondIndex].vec3_add(movementStep.vec3_scale(m, secondPosition), secondPosition).vec3_add(heightOffset, secondPosition);
                if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardOutward) {
                  firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
                  secondHeightPosition = secondPosition.vec3_sub(heightStep, secondHeightPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    secondHeightPosition,
                    firstMovementPosition,
                    movementDirection,
                    up,
                    true,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    true,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
                if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardInward) {
                  secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
                  firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    firstHeightPosition,
                    secondMovementPosition,
                    movementDirection,
                    up,
                    true,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    true,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
                if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardOutward) {
                  firstHeightMovementPosition = firstPosition.vec3_add(movementStep, firstHeightMovementPosition);
                  firstHeightMovementPosition = firstHeightMovementPosition.vec3_sub(heightStep, firstHeightMovementPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    secondPosition,
                    firstHeightMovementPosition,
                    movementDirection,
                    up,
                    true,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    true,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
                if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardInward) {
                  secondHeightMovementPosition = secondPosition.vec3_add(movementStep, secondHeightMovementPosition);
                  secondHeightMovementPosition = secondHeightMovementPosition.vec3_sub(heightStep, secondHeightMovementPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    firstPosition,
                    secondHeightMovementPosition,
                    movementDirection,
                    up,
                    true,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    true,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
                if (m == 0) {
                  if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward) {
                    secondHeightPosition = secondPosition.vec3_sub(heightStep, secondHeightPosition);
                    isHorizontalCheckOk = this._horizontalCheckRaycast(
                      secondHeightPosition,
                      firstPosition,
                      movementDirection,
                      up,
                      true,
                      ignoreGroundAngleCallback,
                      ignoreCeilingAngleCallback,
                      feetPosition,
                      true,
                      collisionCheckParams,
                      collisionRuntimeParams
                    );
                    if (!isHorizontalCheckOk)
                      break;
                  }
                  if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward) {
                    let firstHeightPosition2 = firstPosition.vec3_sub(heightStep);
                    isHorizontalCheckOk = this._horizontalCheckRaycast(
                      firstHeightPosition2,
                      secondPosition,
                      movementDirection,
                      up,
                      true,
                      ignoreGroundAngleCallback,
                      ignoreCeilingAngleCallback,
                      feetPosition,
                      true,
                      collisionCheckParams,
                      collisionRuntimeParams
                    );
                    if (!isHorizontalCheckOk)
                      break;
                  }
                }
                if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward) {
                  firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
                  secondHeightMovementPosition = secondPosition.vec3_sub(heightStep, secondHeightMovementPosition).vec3_add(movementStep, secondHeightMovementPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    secondHeightMovementPosition,
                    firstMovementPosition,
                    movementDirection,
                    up,
                    true,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    true,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
                if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward) {
                  secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
                  firstHeightMovementPosition = firstPosition.vec3_sub(heightStep, firstHeightMovementPosition).vec3_add(movementStep, firstHeightMovementPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    firstHeightMovementPosition,
                    secondMovementPosition,
                    movementDirection,
                    up,
                    true,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    true,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
              }
              if (collisionCheckParams.myHorizontalMovementCheckVerticalStraight || collisionCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled && j == 0) {
                if (m == 0) {
                  firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    firstHeightPosition,
                    firstPosition,
                    movementDirection,
                    up,
                    true,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    true,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
                {
                  firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
                  firstHeightMovementPosition = firstMovementPosition.vec3_sub(heightStep, firstHeightMovementPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    firstHeightMovementPosition,
                    firstMovementPosition,
                    movementDirection,
                    up,
                    true,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    true,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
              }
              if (collisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalUpward || collisionCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled && j == 0) {
                firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
                firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
                isHorizontalCheckOk = this._horizontalCheckRaycast(
                  firstHeightPosition,
                  firstMovementPosition,
                  movementDirection,
                  up,
                  true,
                  ignoreGroundAngleCallback,
                  ignoreCeilingAngleCallback,
                  feetPosition,
                  true,
                  collisionCheckParams,
                  collisionRuntimeParams
                );
                if (!isHorizontalCheckOk)
                  break;
              }
              if (collisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalDownward || collisionCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled && j == 0) {
                firstHeightMovementPosition = firstPosition.vec3_sub(heightStep, firstHeightMovementPosition).vec3_add(movementStep, firstHeightMovementPosition);
                isHorizontalCheckOk = this._horizontalCheckRaycast(
                  firstPosition,
                  firstHeightMovementPosition,
                  movementDirection,
                  up,
                  true,
                  ignoreGroundAngleCallback,
                  ignoreCeilingAngleCallback,
                  feetPosition,
                  true,
                  collisionCheckParams,
                  collisionRuntimeParams
                );
                if (!isHorizontalCheckOk)
                  break;
              }
              if (!isHorizontalCheckOk) {
                collisionRuntimeParams.myIsCollidingHorizontally = true;
                collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                break;
              }
            }
          }
          return isHorizontalCheckOk;
        };
      }();
      CollisionCheck.prototype._horizontalMovementHorizontalCheck = function() {
        let movementStep = PP.vec3_create();
        let movementDirection = PP.vec3_create();
        let firstPosition = PP.vec3_create();
        let secondPosition = PP.vec3_create();
        let firstMovementPosition = PP.vec3_create();
        let secondMovementPosition = PP.vec3_create();
        return function _horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
          let isHorizontalCheckOk = true;
          let movementStepAmount = 1;
          movementStep.vec3_copy(movement);
          if (collisionCheckParams.myHorizontalMovementStepEnabled) {
            movementStepAmount = Math.max(1, Math.ceil(movement.vec3_length() / collisionCheckParams.myHorizontalMovementStepMaxLength));
            movement.vec3_scale(1 / movementStepAmount, movementStep);
          }
          movementDirection = movement.vec3_normalize(movementDirection);
          for (let m = 0; m < movementStepAmount; m++) {
            for (let j = 0; j < checkPositions.length; j++) {
              firstPosition = checkPositions[j].vec3_add(movementStep.vec3_scale(m, firstPosition), firstPosition).vec3_add(heightOffset, firstPosition);
              if (j > 0) {
                let secondIndex = Math.max(0, j - 2);
                secondPosition = checkPositions[secondIndex].vec3_add(movementStep.vec3_scale(m, secondPosition), secondPosition).vec3_add(heightOffset, secondPosition);
                if (collisionCheckParams.myHorizontalMovementCheckDiagonalOutward) {
                  firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    secondPosition,
                    firstMovementPosition,
                    movementDirection,
                    up,
                    true,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    true,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
                if (collisionCheckParams.myHorizontalMovementCheckDiagonalInward) {
                  secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    firstPosition,
                    secondMovementPosition,
                    movementDirection,
                    up,
                    true,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    true,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
                if (collisionCheckParams.myHorizontalMovementCheckHorizontalBorder) {
                  if (m == 0) {
                    isHorizontalCheckOk = this._horizontalCheckRaycast(
                      secondPosition,
                      firstPosition,
                      movementDirection,
                      up,
                      true,
                      ignoreGroundAngleCallback,
                      ignoreCeilingAngleCallback,
                      feetPosition,
                      true,
                      collisionCheckParams,
                      collisionRuntimeParams
                    );
                    if (!isHorizontalCheckOk)
                      break;
                  }
                  {
                    firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
                    secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
                    isHorizontalCheckOk = this._horizontalCheckRaycast(
                      secondMovementPosition,
                      firstMovementPosition,
                      movementDirection,
                      up,
                      true,
                      ignoreGroundAngleCallback,
                      ignoreCeilingAngleCallback,
                      feetPosition,
                      true,
                      collisionCheckParams,
                      collisionRuntimeParams
                    );
                    if (!isHorizontalCheckOk)
                      break;
                  }
                }
              }
              if (collisionCheckParams.myHorizontalMovementCheckStraight || collisionCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled && j == 0) {
                firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
                isHorizontalCheckOk = this._horizontalCheckRaycast(
                  firstPosition,
                  firstMovementPosition,
                  null,
                  up,
                  true,
                  ignoreGroundAngleCallback,
                  ignoreCeilingAngleCallback,
                  feetPosition,
                  true,
                  collisionCheckParams,
                  collisionRuntimeParams
                );
                if (!isHorizontalCheckOk)
                  break;
              }
            }
            if (!isHorizontalCheckOk) {
              collisionRuntimeParams.myIsCollidingHorizontally = true;
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
              break;
            }
          }
          return isHorizontalCheckOk;
        };
      }();
      Object.defineProperty(CollisionCheck.prototype, "_horizontalMovementCheck", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_horizontalMovementVerticalCheck", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_horizontalMovementHorizontalCheck", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/horizontal_collision_position_check.js
  var require_horizontal_collision_position_check = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/horizontal_collision_position_check.js"() {
      CollisionCheck.prototype._horizontalPositionCheck = function() {
        let checkPositions = [];
        let cachedCheckPositions = [];
        let currentCachedCheckPositionIndex = 0;
        let _localGetCachedCheckPosition = function() {
          let item = null;
          while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
            cachedCheckPositions.push(PP.vec3_create());
          }
          item = cachedCheckPositions[currentCachedCheckPositionIndex];
          currentCachedCheckPositionIndex++;
          return item;
        };
        let _localGroundObjectsToIgnore = [];
        let _localCeilingObjectsToIgnore = [];
        let _localGroundCeilingObjectsToIgnore = [];
        let objectsEqualCallback = (first, second) => first.pp_equals(second);
        let heightOffset = PP.vec3_create();
        let heightStep = PP.vec3_create();
        let currentHeightOffset = PP.vec3_create();
        let hitHeightOffset = PP.vec3_create();
        let hitHeightOffsetEpsilon = PP.vec3_create();
        let downwardHeightOffset = PP.vec3_create();
        let downwardHeightStep = PP.vec3_create();
        let verticalDirection = PP.vec3_create();
        let vertilCheckHit = new PP.RaycastHit();
        return function _horizontalPositionCheck(originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
          this._myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugHorizontalPositionActive;
          checkPositions.length = 0;
          currentCachedCheckPositionIndex = 0;
          let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 180);
          let sliceAngle = halfConeAngle / collisionCheckParams.myHalfConeSliceAmount;
          let tempCheckPosition = _localGetCachedCheckPosition();
          checkPositions.push(feetPosition.vec3_add(forward.vec3_scale(collisionCheckParams.myRadius, tempCheckPosition), tempCheckPosition));
          for (let i = 1; i <= collisionCheckParams.myHalfConeSliceAmount; i++) {
            let currentAngle = i * sliceAngle;
            tempCheckPosition = _localGetCachedCheckPosition();
            let radialDirection = forward.vec3_rotateAxis(-currentAngle, up, tempCheckPosition);
            checkPositions.push(feetPosition.vec3_add(radialDirection.vec3_scale(collisionCheckParams.myRadius, radialDirection), radialDirection));
            tempCheckPosition = _localGetCachedCheckPosition();
            radialDirection = forward.vec3_rotateAxis(currentAngle, up, tempCheckPosition);
            checkPositions.push(feetPosition.vec3_add(radialDirection.vec3_scale(collisionCheckParams.myRadius, radialDirection), radialDirection));
          }
          let groundObjectsToIgnore = null;
          let ceilingObjectsToIgnore = null;
          let groundCeilingObjectsToIgnore = null;
          if (collisionCheckParams.myGroundAngleToIgnore > 0) {
            groundObjectsToIgnore = _localGroundObjectsToIgnore;
            groundObjectsToIgnore.length = 0;
            groundCeilingObjectsToIgnore = _localGroundCeilingObjectsToIgnore;
            groundCeilingObjectsToIgnore.length = 0;
            let ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, groundObjectsToIgnore, true, false, up, collisionCheckParams);
            let ignoreCeilingAngleCallback = null;
            if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
              ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, groundCeilingObjectsToIgnore, false, false, up, collisionCheckParams);
            }
            heightOffset.vec3_zero();
            this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
          }
          if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
            if (!collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeight) {
              ceilingObjectsToIgnore = _localCeilingObjectsToIgnore;
              ceilingObjectsToIgnore.length = 0;
              let ignoreGroundAngleCallback = null;
              if (collisionCheckParams.myGroundAngleToIgnore > 0) {
                ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, groundObjectsToIgnore, null, true, false, up, collisionCheckParams);
              }
              let ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, ceilingObjectsToIgnore, false, false, up, collisionCheckParams);
              heightOffset = up.vec3_scale(height, heightOffset);
              this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
            }
          }
          if (!collisionRuntimeParams.myIsCollidingHorizontally) {
            let groundCeilingCheckIsFine = true;
            if (groundCeilingObjectsToIgnore != null) {
              for (let object of groundCeilingObjectsToIgnore) {
                if (!ceilingObjectsToIgnore.pp_hasEqual(object, objectsEqualCallback)) {
                  groundCeilingCheckIsFine = false;
                  break;
                }
              }
            }
            let ignoreGroundAngleCallback = null;
            let ignoreCeilingAngleCallback = null;
            if (collisionCheckParams.myGroundAngleToIgnore > 0) {
              ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, groundObjectsToIgnore, null, true, false, up, collisionCheckParams);
            }
            if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
              ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, ceilingObjectsToIgnore, null, false, false, up, collisionCheckParams);
            }
            let heightStepAmount = 0;
            if (collisionCheckParams.myCheckHeight && collisionCheckParams.myHeightCheckStepAmountPosition > 0 && height > 0) {
              heightStepAmount = collisionCheckParams.myHeightCheckStepAmountPosition;
              up.vec3_scale(height / heightStepAmount, heightStep);
            }
            for (let i = 0; i <= heightStepAmount; i++) {
              currentHeightOffset = heightStep.vec3_scale(i, currentHeightOffset);
              if (collisionCheckParams.myCheckHeightTopPosition || i == 0) {
                if (i != 0 && i != heightStepAmount || i == 0 && !groundCeilingCheckIsFine || i == 0 && collisionCheckParams.myGroundAngleToIgnore == 0 || i != 0 && i == heightStepAmount && collisionCheckParams.myCeilingAngleToIgnore == 0) {
                  this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, currentHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                  if (collisionRuntimeParams.myIsCollidingHorizontally) {
                    break;
                  }
                }
              }
              if (i > 0) {
                if (collisionCheckParams.myCheckHeightVerticalPosition) {
                  let hitHeightOffsetEpsilonValue = 1e-4;
                  if (collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 0 || collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 2) {
                    verticalDirection.vec3_copy(up);
                    this._horizontalPositionVerticalCheck(feetPosition, checkPositions, currentHeightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                    if (collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeightConeOnCollision) {
                      hitHeightOffset = collisionRuntimeParams.myHorizontalCollisionHit.myPosition.vec3_sub(feetPosition, hitHeightOffset).vec3_componentAlongAxis(up, hitHeightOffset);
                      hitHeightOffset.vec3_add(verticalDirection.vec3_scale(hitHeightOffsetEpsilonValue, hitHeightOffsetEpsilon), hitHeightOffset);
                      collisionRuntimeParams.myIsCollidingHorizontally = false;
                      if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                        vertilCheckHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
                      }
                      collisionRuntimeParams.myHorizontalCollisionHit.reset();
                      this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, hitHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                      if (collisionRuntimeParams.myIsCollidingHorizontally) {
                        break;
                      } else if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                        collisionRuntimeParams.myIsCollidingHorizontally = true;
                        collisionRuntimeParams.myHorizontalCollisionHit.copy(vertilCheckHit);
                        break;
                      }
                    }
                  }
                  if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                    if (collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 1 || collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 2) {
                      verticalDirection = up.vec3_negate(verticalDirection);
                      downwardHeightOffset = currentHeightOffset.vec3_sub(heightStep, downwardHeightOffset);
                      downwardHeightStep = heightStep.vec3_negate(downwardHeightStep);
                      this._horizontalPositionVerticalCheck(feetPosition, checkPositions, downwardHeightOffset, downwardHeightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                    }
                    if (collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeightConeOnCollision) {
                      hitHeightOffset = collisionRuntimeParams.myHorizontalCollisionHit.myPosition.vec3_sub(feetPosition, hitHeightOffset).vec3_componentAlongAxis(up, hitHeightOffset);
                      hitHeightOffset.vec3_add(verticalDirection.vec3_scale(hitHeightOffsetEpsilonValue, hitHeightOffsetEpsilon), hitHeightOffset);
                      collisionRuntimeParams.myIsCollidingHorizontally = false;
                      if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                        vertilCheckHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
                      }
                      collisionRuntimeParams.myHorizontalCollisionHit.reset();
                      this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, hitHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                      if (collisionRuntimeParams.myIsCollidingHorizontally) {
                        break;
                      } else if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                        collisionRuntimeParams.myIsCollidingHorizontally = true;
                        collisionRuntimeParams.myHorizontalCollisionHit.copy(vertilCheckHit);
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          return !collisionRuntimeParams.myIsCollidingHorizontally;
        };
      }();
      CollisionCheck.prototype._horizontalPositionHorizontalCheck = function() {
        let basePosition = PP.vec3_create();
        let forwardNegate = PP.vec3_create();
        let currentRadialPosition = PP.vec3_create();
        let previousRadialPosition = PP.vec3_create();
        return function _horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
          let isHorizontalCheckOk = true;
          basePosition = feetPosition.vec3_add(heightOffset, basePosition);
          let halfRadialPositions = Math.floor(checkPositions.length / 2) + 1;
          for (let j = 0; j < halfRadialPositions; j++) {
            if (j > 0) {
              let leftIndex = Math.max(0, j * 2);
              let rightIndex = Math.max(0, j * 2 - 1);
              let leftAndRightEqual = checkPositions[leftIndex].vec_equals(checkPositions[rightIndex], 1e-6);
              if (collisionCheckParams.myCheckConeBorder) {
                for (let r = 0; r < 2; r++) {
                  let currentIndex = r == 0 ? leftIndex : rightIndex;
                  currentRadialPosition = checkPositions[currentIndex].vec3_add(heightOffset, currentRadialPosition);
                  let previousIndex = Math.max(0, currentIndex - 2);
                  previousRadialPosition = checkPositions[previousIndex].vec3_add(heightOffset, previousRadialPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    previousRadialPosition,
                    currentRadialPosition,
                    forward.vec3_negate(forwardNegate),
                    up,
                    true,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    true,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
              }
              if (collisionCheckParams.myCheckConeRay && isHorizontalCheckOk) {
                for (let r = 0; r < 2; r++) {
                  if (r == 1 && leftAndRightEqual) {
                    break;
                  }
                  let currentIndex = r == 0 ? leftIndex : rightIndex;
                  currentRadialPosition = checkPositions[currentIndex].vec3_add(heightOffset, currentRadialPosition);
                  isHorizontalCheckOk = this._horizontalCheckRaycast(
                    basePosition,
                    currentRadialPosition,
                    null,
                    up,
                    false,
                    ignoreGroundAngleCallback,
                    ignoreCeilingAngleCallback,
                    feetPosition,
                    false,
                    collisionCheckParams,
                    collisionRuntimeParams
                  );
                  if (!isHorizontalCheckOk)
                    break;
                }
              }
            } else {
              if (collisionCheckParams.myCheckConeRay) {
                currentRadialPosition = checkPositions[j].vec3_add(heightOffset, currentRadialPosition);
                isHorizontalCheckOk = this._horizontalCheckRaycast(
                  basePosition,
                  currentRadialPosition,
                  null,
                  up,
                  false,
                  ignoreGroundAngleCallback,
                  ignoreCeilingAngleCallback,
                  feetPosition,
                  false,
                  collisionCheckParams,
                  collisionRuntimeParams
                );
                if (!isHorizontalCheckOk)
                  break;
              }
            }
            if (!isHorizontalCheckOk) {
              break;
            }
          }
          if (!isHorizontalCheckOk) {
            collisionRuntimeParams.myIsCollidingHorizontally = true;
            collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          }
          return isHorizontalCheckOk;
        };
      }();
      CollisionCheck.prototype._horizontalPositionVerticalCheck = function() {
        let basePosition = PP.vec3_create();
        let previousBasePosition = PP.vec3_create();
        let currentRadialPosition = PP.vec3_create();
        let previousRadialPosition = PP.vec3_create();
        let previousCurrentRadialPosition = PP.vec3_create();
        let previousPreviousRadialPosition = PP.vec3_create();
        return function _horizontalPositionVerticalCheck(feetPosition, checkPositions, heightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
          let isHorizontalCheckOk = true;
          basePosition = feetPosition.vec3_add(heightOffset, basePosition);
          previousBasePosition = basePosition.vec3_sub(heightStep, previousBasePosition);
          for (let j = 0; j <= checkPositions.length; j++) {
            let previousCheckPositionIsEqual = false;
            if (j == checkPositions.length) {
              currentRadialPosition.vec3_copy(basePosition);
              previousRadialPosition.vec3_copy(previousBasePosition);
            } else {
              currentRadialPosition = checkPositions[j].vec3_add(heightOffset, currentRadialPosition);
              previousRadialPosition = currentRadialPosition.vec3_sub(heightStep, previousRadialPosition);
              if (j > 0) {
                previousCheckPositionIsEqual = checkPositions[j].vec_equals(checkPositions[j - 1], 1e-6);
              }
            }
            if (collisionCheckParams.myCheckVerticalStraight && !previousCheckPositionIsEqual) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                previousRadialPosition,
                currentRadialPosition,
                null,
                up,
                collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams,
                true,
                true
              );
              if (!isHorizontalCheckOk) {
                if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                }
                if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                  break;
                }
              }
            }
            if (j < checkPositions.length) {
              if ((collisionCheckParams.myCheckVerticalDiagonalRayOutward || collisionCheckParams.myCheckVerticalDiagonalBorderRayOutward && (j == checkPositions.length - 2 || j == checkPositions.length - 1)) && !previousCheckPositionIsEqual) {
                isHorizontalCheckOk = this._horizontalCheckRaycast(
                  previousBasePosition,
                  currentRadialPosition,
                  null,
                  up,
                  collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
                  ignoreGroundAngleCallback,
                  ignoreCeilingAngleCallback,
                  feetPosition,
                  true,
                  collisionCheckParams,
                  collisionRuntimeParams,
                  true,
                  true
                );
                if (!isHorizontalCheckOk) {
                  if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                    collisionRuntimeParams.myIsCollidingHorizontally = true;
                    collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                  } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                    collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                  }
                  if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                    break;
                  }
                }
              }
              if ((collisionCheckParams.myCheckVerticalDiagonalRayInward || collisionCheckParams.myCheckVerticalDiagonalBorderRayInward && (j == checkPositions.length - 2 || j == checkPositions.length - 1)) && !previousCheckPositionIsEqual) {
                isHorizontalCheckOk = this._horizontalCheckRaycast(
                  previousRadialPosition,
                  basePosition,
                  null,
                  up,
                  collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
                  ignoreGroundAngleCallback,
                  ignoreCeilingAngleCallback,
                  feetPosition,
                  true,
                  collisionCheckParams,
                  collisionRuntimeParams,
                  true,
                  true
                );
                if (!isHorizontalCheckOk) {
                  if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                    collisionRuntimeParams.myIsCollidingHorizontally = true;
                    collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                  } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                    collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                  }
                  if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                    break;
                  }
                }
              }
              if (j > 0) {
                if (collisionCheckParams.myCheckVerticalDiagonalBorderOutward || collisionCheckParams.myCheckVerticalDiagonalBorderInward) {
                  let previousIndex = Math.max(0, j - 2);
                  previousCurrentRadialPosition = checkPositions[previousIndex].vec3_add(heightOffset, previousCurrentRadialPosition);
                  previousPreviousRadialPosition = previousCurrentRadialPosition.vec3_sub(heightStep, previousPreviousRadialPosition);
                  if (collisionCheckParams.myCheckVerticalDiagonalBorderOutward) {
                    isHorizontalCheckOk = this._horizontalCheckRaycast(
                      previousPreviousRadialPosition,
                      currentRadialPosition,
                      null,
                      up,
                      collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
                      ignoreGroundAngleCallback,
                      ignoreCeilingAngleCallback,
                      feetPosition,
                      true,
                      collisionCheckParams,
                      collisionRuntimeParams,
                      true,
                      true
                    );
                    if (!isHorizontalCheckOk) {
                      if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                        collisionRuntimeParams.myIsCollidingHorizontally = true;
                        collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                      } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                        collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                      }
                      if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                        break;
                      }
                    }
                  }
                  if (collisionCheckParams.myCheckVerticalDiagonalBorderInward) {
                    isHorizontalCheckOk = this._horizontalCheckRaycast(
                      previousRadialPosition,
                      previousCurrentRadialPosition,
                      null,
                      up,
                      collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
                      ignoreGroundAngleCallback,
                      ignoreCeilingAngleCallback,
                      feetPosition,
                      true,
                      collisionCheckParams,
                      collisionRuntimeParams,
                      true,
                      true
                    );
                    if (!isHorizontalCheckOk) {
                      if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                        collisionRuntimeParams.myIsCollidingHorizontally = true;
                        collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                      } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                        collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                      }
                      if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          return !collisionRuntimeParams.myIsCollidingHorizontally;
        };
      }();
      Object.defineProperty(CollisionCheck.prototype, "_horizontalPositionCheck", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_horizontalPositionHorizontalCheck", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_horizontalPositionVerticalCheck", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/vertical_collision_check.js
  var require_vertical_collision_check = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/vertical_collision_check.js"() {
      CollisionCheck.prototype._verticalCheck = function() {
        let newFeetPosition = PP.vec3_create();
        let additionalFixedMovement = PP.vec3_create();
        let zero4 = PP.vec3_create();
        zero4.vec3_zero();
        return function _verticalCheck(verticalMovement, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
          collisionRuntimeParams.myIsCollidingVertically = false;
          collisionRuntimeParams.myVerticalCollisionHit.reset();
          let movementSign = Math.pp_sign(verticalMovement.vec3_lengthSigned(up), -1);
          let isMovementDownward = movementSign < 0;
          outFixedMovement.vec3_copy(verticalMovement);
          if (collisionCheckParams.myVerticalMovementCheckEnabled) {
            outFixedMovement = this._verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement);
            if (collisionCheckParams.myCheckVerticalBothDirection && (outFixedMovement.vec_equals(verticalMovement, 1e-5) || originalMovementSign == 0 || movementSign != originalMovementSign)) {
              newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
              let isOppositeMovementDownward = !isMovementDownward;
              additionalFixedMovement = this._verticalMovementAdjustment(zero4, isOppositeMovementDownward, originalMovementSign, newFeetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, additionalFixedMovement);
              outFixedMovement.vec3_add(additionalFixedMovement, outFixedMovement);
              isMovementDownward = !isMovementDownward;
            }
          }
          if (collisionCheckParams.myVerticalPositionCheckEnabled) {
            newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
            let canStay = this._verticalPositionCheck(newFeetPosition, isMovementDownward, height, up, forward, collisionCheckParams, collisionRuntimeParams);
            if (!canStay) {
              outFixedMovement.vec3_zero();
              collisionRuntimeParams.myHasSnappedOnGround = false;
              collisionRuntimeParams.myHasSnappedOnCeiling = false;
              collisionRuntimeParams.myHasPoppedOutGround = false;
              collisionRuntimeParams.myHasPoppedOutCeiling = false;
              collisionRuntimeParams.myHasReducedVerticalMovement = false;
            }
          }
          return outFixedMovement;
        };
      }();
      CollisionCheck.prototype._verticalMovementAdjustment = function() {
        let startOffset = PP.vec3_create();
        let endOffset = PP.vec3_create();
        let tempVector = PP.vec3_create();
        let furtherDirection = PP.vec3_create();
        let furtherDirectionPosition = PP.vec3_create();
        let upNegate = PP.vec3_create();
        let origin = PP.vec3_create();
        let direction = PP.vec3_create();
        return function _verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
          this._myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugVerticalMovementActive;
          startOffset.vec3_zero();
          endOffset.vec3_zero();
          let popOutEnabled = false;
          let snapEnabled = false;
          if (isMovementDownward) {
            startOffset.vec3_zero();
            endOffset.vec3_copy(verticalMovement);
            if (collisionCheckParams.myGroundPopOutExtraDistance > 0 && collisionCheckParams.myGroundPopOutEnabled) {
              startOffset.vec3_add(up.vec3_scale(collisionCheckParams.myGroundPopOutExtraDistance + 1e-5, tempVector), startOffset);
              popOutEnabled = true;
            }
          } else {
            startOffset = up.vec3_scale(height, startOffset);
            endOffset = up.vec3_scale(height, endOffset).vec3_add(verticalMovement, endOffset);
            if (collisionCheckParams.myCeilingPopOutExtraDistance > 0 && collisionCheckParams.myCeilingPopOutEnabled) {
              startOffset.vec3_add(up.vec3_scale(-collisionCheckParams.myCeilingPopOutExtraDistance - 1e-5, tempVector), startOffset);
              popOutEnabled = true;
            }
          }
          if (isMovementDownward && originalMovementSign <= 0 && this._myPrevCollisionRuntimeParams.myIsOnGround && collisionCheckParams.mySnapOnGroundEnabled && collisionCheckParams.mySnapOnGroundExtraDistance > 0) {
            endOffset.vec3_add(up.vec3_scale(-collisionCheckParams.mySnapOnGroundExtraDistance - 1e-5, tempVector), endOffset);
            snapEnabled = true;
          } else if (!isMovementDownward && this._myPrevCollisionRuntimeParams.myIsOnCeiling && collisionCheckParams.mySnapOnCeilingEnabled && collisionCheckParams.mySnapOnCeilingExtraDistance > 0 && (originalMovementSign > 0 || originalMovementSign == 0 && (!this._myPrevCollisionRuntimeParams.myIsOnGround || !collisionCheckParams.mySnapOnGroundEnabled))) {
            endOffset.vec3_add(up.vec3_scale(collisionCheckParams.mySnapOnCeilingExtraDistance + 1e-5, tempVector), endOffset);
            snapEnabled = true;
          }
          outFixedMovement.vec3_zero();
          if (startOffset.vec3_distance(endOffset) > 1e-5) {
            let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams);
            furtherDirection.vec3_copy(up);
            if (!isMovementDownward) {
              furtherDirection.vec3_negate(furtherDirection);
            }
            let furtherDirectionPositionSet = false;
            for (let i = 0; i < checkPositions.length; i++) {
              let currentPosition = checkPositions[i];
              origin = currentPosition.vec3_add(startOffset, origin);
              direction = currentPosition.vec3_add(endOffset, direction).vec3_sub(origin, direction);
              let distance4 = direction.vec3_length();
              direction.vec3_normalize(direction);
              let raycastResult = this._raycastAndDebug(origin, direction, distance4, true, false, collisionCheckParams, collisionRuntimeParams);
              if (raycastResult.myHits.length > 0) {
                if (furtherDirectionPositionSet) {
                  if (raycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(furtherDirectionPosition, furtherDirection)) {
                    furtherDirectionPosition.vec3_copy(raycastResult.myHits[0].myPosition);
                  }
                } else {
                  furtherDirectionPositionSet = true;
                  furtherDirectionPosition.vec3_copy(raycastResult.myHits[0].myPosition);
                }
              }
            }
            if (furtherDirectionPositionSet) {
              upNegate = up.vec3_negate(upNegate);
              if (isMovementDownward) {
                outFixedMovement = furtherDirectionPosition.vec3_sub(feetPosition, outFixedMovement).vec3_componentAlongAxis(up, outFixedMovement);
                if (snapEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, upNegate)) {
                  collisionRuntimeParams.myHasSnappedOnGround = true;
                } else if (popOutEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, up)) {
                  if (!outFixedMovement.vec3_isZero(1e-5) && (verticalMovement.vec3_isZero(1e-5) || !outFixedMovement.vec3_isConcordant(verticalMovement))) {
                    collisionRuntimeParams.myHasPoppedOutGround = true;
                  } else {
                    collisionRuntimeParams.myHasReducedVerticalMovement = true;
                  }
                } else {
                  collisionRuntimeParams.myHasReducedVerticalMovement = true;
                }
              } else {
                outFixedMovement = furtherDirectionPosition.vec3_sub(feetPosition.vec3_add(up.vec3_scale(height, outFixedMovement), outFixedMovement), outFixedMovement).vec3_componentAlongAxis(up, outFixedMovement);
                if (snapEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, up)) {
                  collisionRuntimeParams.myHasSnappedOnCeiling = true;
                } else if (popOutEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, upNegate)) {
                  if (!outFixedMovement.vec3_isZero(1e-5) && (verticalMovement.vec3_isZero(1e-5) || !outFixedMovement.vec3_isConcordant(verticalMovement))) {
                    collisionRuntimeParams.myHasPoppedOutCeiling = true;
                  } else {
                    collisionRuntimeParams.myHasReducedVerticalMovement = true;
                  }
                } else {
                  collisionRuntimeParams.myHasReducedVerticalMovement = true;
                }
              }
              if (!popOutEnabled && !outFixedMovement.vec3_isConcordant(verticalMovement)) {
                outFixedMovement.vec3_zero();
              }
              if (!collisionCheckParams.myVerticalMovementReduceEnabled && collisionRuntimeParams.myHasReducedVerticalMovement) {
                outFixedMovement.vec3_copy(verticalMovement);
                collisionRuntimeParams.myHasReducedVerticalMovement = false;
              }
            } else {
              outFixedMovement.vec3_copy(verticalMovement);
            }
          } else {
            outFixedMovement.vec3_copy(verticalMovement);
          }
          if (outFixedMovement.vec3_length() < 1e-5) {
            outFixedMovement.vec3_zero();
          }
          return outFixedMovement;
        };
      }();
      CollisionCheck.prototype._verticalPositionCheck = function() {
        let smallHeightFixOffset = PP.vec3_create();
        let heightOffset = PP.vec3_create();
        let startPosition = PP.vec3_create();
        let endPosition = PP.vec3_create();
        let direction = PP.vec3_create();
        return function _verticalPositionCheck(feetPosition, checkUpward, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
          if (height < 1e-5) {
            return true;
          }
          this._myDebugActive = collisionCheckParams.myDebugActive && collisionCheckParams.myDebugVerticalPositionActive;
          let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams);
          let isVerticalPositionOk = true;
          let atLeastOneIsOk = false;
          let adjustmentEpsilon = 1e-5;
          smallHeightFixOffset = up.vec3_scale(adjustmentEpsilon, smallHeightFixOffset);
          heightOffset = up.vec3_scale(height - adjustmentEpsilon, heightOffset);
          if (height - adjustmentEpsilon < adjustmentEpsilon * 10) {
            heightOffset = up.vec3_scale(adjustmentEpsilon * 10, heightOffset);
          }
          let insideHitSet = false;
          for (let i = 0; i < checkPositions.length; i++) {
            let currentPosition = checkPositions[i];
            if (checkUpward) {
              startPosition = currentPosition.vec3_add(smallHeightFixOffset, startPosition);
              endPosition = currentPosition.vec3_add(heightOffset, endPosition);
            } else {
              startPosition = currentPosition.vec3_add(heightOffset, startPosition);
              endPosition = currentPosition.vec3_add(smallHeightFixOffset, endPosition);
            }
            let origin = startPosition;
            direction = endPosition.vec3_sub(origin, direction);
            let distance4 = direction.vec3_length();
            direction.vec3_normalize(direction);
            let raycastResult = this._raycastAndDebug(origin, direction, distance4, false, false, collisionCheckParams, collisionRuntimeParams);
            if (raycastResult.isColliding()) {
              let firstHitOutsideCollision = raycastResult.getFirstHitOutsideCollision();
              if (firstHitOutsideCollision != null) {
                isVerticalPositionOk = false;
                collisionRuntimeParams.myVerticalCollisionHit.copy(firstHitOutsideCollision);
                break;
              } else if (!insideHitSet) {
                insideHitSet = true;
                collisionRuntimeParams.myVerticalCollisionHit.copy(raycastResult.myHits[0]);
                if (!collisionCheckParams.myVerticalAllowHitInsideCollisionIfOneOk) {
                  isVerticalPositionOk = false;
                  break;
                }
              }
            } else {
              atLeastOneIsOk = true;
            }
          }
          collisionRuntimeParams.myIsCollidingVertically = !isVerticalPositionOk || !atLeastOneIsOk;
          return !collisionRuntimeParams.myIsCollidingVertically;
        };
      }();
      CollisionCheck.prototype._getVerticalCheckPositions = function() {
        let checkPositions = [];
        let cachedCheckPositions = [];
        let currentCachedCheckPositionIndex = 0;
        let _localGetCachedCheckPosition = function() {
          let item = null;
          while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
            cachedCheckPositions.push(PP.vec3_create());
          }
          item = cachedCheckPositions[currentCachedCheckPositionIndex];
          currentCachedCheckPositionIndex++;
          return item;
        };
        let currentDirection = PP.vec3_create();
        return function _getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams) {
          checkPositions.length = 0;
          currentCachedCheckPositionIndex = 0;
          if (collisionCheckParams.myGroundCircumferenceAddCenter) {
            let tempCheckPosition = _localGetCachedCheckPosition();
            tempCheckPosition.vec3_copy(feetPosition);
            checkPositions.push(tempCheckPosition);
          }
          let radiusStep = collisionCheckParams.myFeetRadius / collisionCheckParams.myGroundCircumferenceStepAmount;
          let sliceAngle = 360 / collisionCheckParams.myGroundCircumferenceSliceAmount;
          let currentStepRotation = 0;
          for (let i = 0; i < collisionCheckParams.myGroundCircumferenceStepAmount; i++) {
            let currentRadius = radiusStep * (i + 1);
            currentDirection = forward.vec3_rotateAxis(currentStepRotation, up, currentDirection);
            for (let j = 0; j < collisionCheckParams.myGroundCircumferenceSliceAmount; j++) {
              let tempCheckPosition = _localGetCachedCheckPosition();
              let sliceDirection = currentDirection.vec3_rotateAxis(sliceAngle * j, up, tempCheckPosition);
              checkPositions.push(feetPosition.vec3_add(sliceDirection.vec3_scale(currentRadius, sliceDirection), sliceDirection));
            }
            currentStepRotation += collisionCheckParams.myGroundCircumferenceRotationPerStep;
          }
          return checkPositions;
        };
      }();
      Object.defineProperty(CollisionCheck.prototype, "_verticalCheck", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_verticalMovementAdjustment", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_verticalPositionCheck", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_getVerticalCheckPositions", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_surface_check.js
  var require_collision_surface_check = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check/collision_surface_check.js"() {
      CollisionCheck.prototype._updateSurfaceInfo = function() {
        let transformUp = PP.vec3_create();
        let transformForward = PP.vec3_create();
        let feetPosition = PP.vec3_create();
        let transformOffsetLocalQuat = PP.quat2_create();
        let offsetTransformQuat = PP.quat2_create();
        let forwardForPerceivedAngle = PP.vec3_create();
        let forwardForVertical = PP.vec3_create();
        let zAxis = PP.vec3_create(0, 0, 1);
        let xAxis = PP.vec3_create(1, 0, 0);
        return function _updateSurfaceInfo(transformQuat3, collisionCheckParams, collisionRuntimeParams) {
          transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
          offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat3, offsetTransformQuat);
          if (transformQuat3.vec_equals(offsetTransformQuat, 1e-5)) {
            offsetTransformQuat.quat2_copy(transformQuat3);
          }
          transformUp = offsetTransformQuat.quat2_getUp(transformUp);
          transformForward = offsetTransformQuat.quat2_getForward(transformForward);
          feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
          let height = collisionCheckParams.myHeight;
          height = height - 1e-5;
          if (height < 1e-5) {
            height = 0;
          }
          forwardForPerceivedAngle.vec3_copy(transformForward);
          forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
          if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
            forwardForVertical.vec3_copy(transformForward);
          } else {
            if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
              if (zAxis.vec3_isOnAxis(transformUp)) {
                forwardForVertical.vec3_copy(xAxis);
              } else {
                forwardForVertical.vec3_copy(zAxis);
              }
            }
            forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
            forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
            if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
              forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
            }
          }
          if (collisionCheckParams.myComputeGroundInfoEnabled) {
            this._gatherSurfaceInfo(feetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
          }
          if (collisionCheckParams.myComputeCeilingInfoEnabled) {
            this._gatherSurfaceInfo(feetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
          }
        };
      }();
      CollisionCheck.prototype._postSurfaceCheck = function() {
        let horizontalDirection = PP.vec3_create();
        return function _postSurfaceCheck(fixedHorizontalMovement, originalVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
          let isVerticalMovementZero = originalVerticalMovement.vec3_isZero(1e-5);
          let isVerticalMovemenDownward = Math.pp_sign(originalVerticalMovement.vec3_lengthSigned(transformUp), -1) < 0;
          let horizontalMovementIsZero = fixedHorizontalMovement.vec3_isZero(1e-5);
          horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
          let groundPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myGroundNormal, horizontalDirection, transformUp, true);
          let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myCeilingNormal, horizontalDirection, transformUp, false);
          let mustRemainOnGroundOk = true;
          if (collisionCheckParams.myMustStayOnGround) {
            if (previousCollisionRuntimeParams.myIsOnGround && !collisionRuntimeParams.myIsOnGround && (isVerticalMovementZero || isVerticalMovemenDownward)) {
              mustRemainOnGroundOk = false;
            }
          }
          let mustRemainOnCeilingOk = true;
          if (collisionCheckParams.myMustStayOnCeiling) {
            if (previousCollisionRuntimeParams.myIsOnCeiling && !collisionRuntimeParams.myIsOnCeiling && (isVerticalMovementZero || isVerticalMovemenDownward)) {
              mustRemainOnCeilingOk = false;
            }
          }
          let mustStayBelowGroundAngleOk = true;
          if (collisionCheckParams.myMustStayBelowGroundAngleDownhill != null || collisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill) {
            let minAngle = null;
            if (!collisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill) {
              minAngle = collisionCheckParams.myMustStayBelowGroundAngleDownhill;
            } else if (collisionCheckParams.myMustStayBelowGroundAngleDownhill == null) {
              minAngle = collisionCheckParams.myGroundAngleToIgnore;
            } else {
              minAngle = Math.min(collisionCheckParams.myMustStayBelowGroundAngleDownhill, collisionCheckParams.myGroundAngleToIgnore);
            }
            if (!horizontalMovementIsZero && groundPerceivedAngle < 0 && previousCollisionRuntimeParams.myIsOnGround && previousCollisionRuntimeParams.myGroundAngle <= minAngle && collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > minAngle + 1e-4) {
              mustStayBelowGroundAngleOk = false;
            }
          }
          let mustStayBelowCeilingAngleOk = true;
          if (collisionCheckParams.myMustStayBelowCeilingAngleDownhill != null || collisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill) {
            let minAngle = null;
            if (!collisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill) {
              minAngle = collisionCheckParams.myMustStayBelowCeilingAngleDownhill;
            } else if (collisionCheckParams.myMustStayBelowCeilingAngleDownhill == null) {
              minAngle = collisionCheckParams.myCeilingAngleToIgnore;
            } else {
              minAngle = Math.min(collisionCheckParams.myMustStayBelowCeilingAngleDownhill, collisionCheckParams.myCeilingAngleToIgnore);
            }
            if (!horizontalMovementIsZero && groundPerceivedAngle < 0 && previousCollisionRuntimeParams.myIsOnCeiling && previousCollisionRuntimeParams.myCeilingAngle <= minAngle && collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > minAngle + 1e-4) {
              mustStayBelowCeilingAngleOk = false;
            }
          }
          let mustStayOnGroundHitAngleOk = true;
          if (collisionCheckParams.myMovementMustStayOnGroundHitAngle != null) {
            if (!horizontalMovementIsZero && previousCollisionRuntimeParams.myIsOnGround && previousCollisionRuntimeParams.myGroundHitMaxAngle <= collisionCheckParams.myMovementMustStayOnGroundHitAngle && collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundHitMaxAngle > collisionCheckParams.myMovementMustStayOnGroundHitAngle + 1e-4) {
              mustStayOnGroundHitAngleOk = false;
            }
          }
          let mustStayOnCeilingHitAngleOk = true;
          if (collisionCheckParams.myMovementMustStayOnCeilingHitAngle != null) {
            if (!horizontalMovementIsZero && previousCollisionRuntimeParams.myIsOnCeiling && previousCollisionRuntimeParams.myCeilingHitMaxAngle <= collisionCheckParams.myMovementMustStayOnCeilingHitAngle && collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingHitMaxAngle > collisionCheckParams.myMovementMustStayOnCeilingHitAngle + 1e-4) {
              mustStayOnCeilingHitAngleOk = false;
            }
          }
          let isOnValidGroundAngleUphill = true;
          let isOnValidGroundAngleDownhill = true;
          if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
            if (previousCollisionRuntimeParams.myIsOnGround && !horizontalMovementIsZero) {
              if (groundPerceivedAngle > 0) {
                isOnValidGroundAngleUphill = false;
                if (collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
                  isOnValidGroundAngleUphill = Math.abs(groundPerceivedAngle) <= collisionCheckParams.myGroundAngleToIgnore + 1e-4;
                }
              } else if (groundPerceivedAngle < 0) {
                if (previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
                  if (collisionCheckParams.myMustStayOnValidGroundAngleDownhill) {
                    isOnValidGroundAngleDownhill = false;
                  }
                }
              }
            }
          }
          let isOnValidCeilingAngleUphill = true;
          let isOnValidCeilingAngleDownhill = true;
          if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
            if (previousCollisionRuntimeParams.myIsOnCeiling && !horizontalMovementIsZero) {
              if (ceilingPerceivedAngle > 0) {
                isOnValidCeilingAngleUphill = false;
                if (collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
                  isOnValidCeilingAngleUphill = Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4;
                }
              } else if (ceilingPerceivedAngle < 0) {
                if (previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
                  if (collisionCheckParams.myMustStayOnValidCeilingAngleDownhill) {
                    isOnValidCeilingAngleDownhill = false;
                  }
                }
              }
            }
          }
          return mustRemainOnGroundOk && mustRemainOnCeilingOk && mustStayBelowGroundAngleOk && mustStayBelowCeilingAngleOk && mustStayOnGroundHitAngleOk && mustStayOnCeilingHitAngleOk && isOnValidGroundAngleUphill && isOnValidGroundAngleDownhill && isOnValidCeilingAngleUphill && isOnValidCeilingAngleDownhill;
        };
      }();
      CollisionCheck.prototype._surfaceTooSteep = function() {
        let surfaceSteepResults = [false, false];
        return function _surfaceTooSteep(up, direction, collisionCheckParams, collisionRuntimeParams) {
          let groundTooSteep = false;
          let ceilingTooSteep = false;
          if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
            let groundPerceivedAngle = this.computeSurfacePerceivedAngle(
              collisionRuntimeParams.myGroundNormal,
              direction,
              up,
              true
            );
            groundTooSteep = groundPerceivedAngle > 0;
            if (groundTooSteep && collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
              groundTooSteep = Math.abs(groundPerceivedAngle) > collisionCheckParams.myGroundAngleToIgnore + 1e-4;
            }
          }
          if (!groundTooSteep) {
            if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
              let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(
                collisionRuntimeParams.myCeilingNormal,
                direction,
                up,
                false
              );
              ceilingTooSteep = ceilingPerceivedAngle > 0;
              if (ceilingTooSteep && collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
                ceilingTooSteep = Math.abs(ceilingPerceivedAngle) > collisionCheckParams.myCeilingAngleToIgnore + 1e-4;
              }
            }
          }
          surfaceSteepResults[0] = groundTooSteep;
          surfaceSteepResults[1] = ceilingTooSteep;
          return surfaceSteepResults;
        };
      }();
      CollisionCheck.prototype._adjustVerticalMovementWithSurface = function() {
        let horizontalDirection = PP.vec3_create();
        let extraVerticalMovement = PP.vec3_create();
        return function _adjustVerticalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedVerticalMovement) {
          outAdjustedVerticalMovement.vec3_copy(verticalMovement);
          if (horizontalMovement.vec3_isZero(1e-5)) {
            return outAdjustedVerticalMovement;
          }
          let extraVerticalLength = 0;
          horizontalDirection = horizontalMovement.vec3_normalize(horizontalDirection);
          if (previousCollisionRuntimeParams.myIsOnGround) {
            let groundPerceivedAngle = this.computeSurfacePerceivedAngle(
              previousCollisionRuntimeParams.myGroundNormal,
              horizontalDirection,
              up,
              true
            );
            let groundExtraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(groundPerceivedAngle)));
            groundExtraVerticalLength *= Math.pp_sign(groundPerceivedAngle);
            if (Math.abs(groundExtraVerticalLength) > 1e-5) {
              if (groundPerceivedAngle > 0) {
                if (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphill && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle == null || Math.abs(groundPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle == null || previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle)) {
                  extraVerticalLength = groundExtraVerticalLength;
                  collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = true;
                }
              } else if (groundPerceivedAngle < 0) {
                if (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhill && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle == null || Math.abs(groundPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle == null || previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle)) {
                  extraVerticalLength = groundExtraVerticalLength;
                  collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = true;
                }
              }
            }
          }
          if (previousCollisionRuntimeParams.myIsOnCeiling) {
            let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(
              previousCollisionRuntimeParams.myCeilingNormal,
              horizontalDirection,
              up,
              false
            );
            let ceilingExtraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(ceilingPerceivedAngle)));
            ceilingExtraVerticalLength *= Math.pp_sign(ceilingPerceivedAngle);
            if (Math.abs(ceilingExtraVerticalLength) > 1e-5) {
              let sameSignThanGround = Math.pp_sign(extraVerticalLength) == Math.pp_sign(ceilingExtraVerticalLength);
              if (extraVerticalLength == 0 || sameSignThanGround && Math.abs(ceilingExtraVerticalLength) > Math.abs(extraVerticalLength)) {
                if (ceilingPerceivedAngle > 0) {
                  if (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphill && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle == null || Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle == null || previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle)) {
                    extraVerticalLength = ceilingExtraVerticalLength;
                    collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = true;
                    collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = false;
                  }
                } else if (ceilingPerceivedAngle < 0) {
                  if (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhill && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle == null || Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle == null || previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle)) {
                    extraVerticalLength = ceilingExtraVerticalLength;
                    collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = true;
                    collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = false;
                  }
                }
              }
            }
          }
          if (Math.abs(extraVerticalLength) > 1e-5) {
            let verticalMovementLength = verticalMovement.vec3_lengthSigned(up);
            let sameSignThanExtra = Math.pp_sign(extraVerticalLength) == Math.pp_sign(verticalMovementLength);
            extraVerticalMovement = up.vec3_scale(extraVerticalLength, extraVerticalMovement);
            if (verticalMovement.vec3_isZero(1e-5)) {
              outAdjustedVerticalMovement.vec3_copy(extraVerticalMovement);
            } else if (sameSignThanExtra) {
              outAdjustedVerticalMovement = verticalMovement.vec3_add(extraVerticalMovement, outAdjustedVerticalMovement);
            } else if (!sameSignThanExtra && (collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill || collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill)) {
              outAdjustedVerticalMovement = verticalMovement.vec3_add(extraVerticalMovement, outAdjustedVerticalMovement);
            } else {
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = false;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = false;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = false;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = false;
            }
          }
          if (outAdjustedVerticalMovement.vec3_isZero(1e-6)) {
            outAdjustedVerticalMovement.vec3_zero();
          }
          return outAdjustedVerticalMovement;
        };
      }();
      CollisionCheck.prototype._adjustHorizontalMovementWithSurface = function() {
        let extraHorizontalMovement = PP.vec3_create();
        let groundHorizontalDirection = PP.vec3_create();
        let ceilingHorizontalDirection = PP.vec3_create();
        let scaledCeilingHorizontalDirection = PP.vec3_create();
        let scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection = PP.vec3_create();
        let scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection = PP.vec3_create();
        return function _adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedHorizontalMovement) {
          outAdjustedHorizontalMovement.vec3_copy(horizontalMovement);
          if (verticalMovement.vec3_isZero(1e-5)) {
            return outAdjustedHorizontalMovement;
          }
          let isMovementDownward = !verticalMovement.vec3_isConcordant(up);
          extraHorizontalMovement.vec3_zero();
          groundHorizontalDirection.vec3_zero();
          if (previousCollisionRuntimeParams.myIsOnGround) {
            groundHorizontalDirection = previousCollisionRuntimeParams.myGroundNormal.vec3_removeComponentAlongAxis(up, groundHorizontalDirection);
            if (!groundHorizontalDirection.vec3_isZero(1e-5)) {
              groundHorizontalDirection.vec3_normalize(groundHorizontalDirection);
              let groundExtraHorizontalLength = verticalMovement.vec3_length() / Math.tan(Math.pp_toRadians(previousCollisionRuntimeParams.myGroundAngle));
              groundExtraHorizontalLength *= isMovementDownward ? 1 : -1;
              if (Math.abs(groundExtraHorizontalLength) > 1e-5) {
                if (isMovementDownward) {
                  if (collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhill && (collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle == null || previousCollisionRuntimeParams.myGroundAngle >= collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle)) {
                    extraHorizontalMovement = groundHorizontalDirection.vec3_scale(groundExtraHorizontalLength, extraHorizontalMovement);
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = true;
                  }
                }
              }
            }
          }
          if (previousCollisionRuntimeParams.myIsOnCeiling) {
            ceilingHorizontalDirection = previousCollisionRuntimeParams.myCeilingNormal.vec3_removeComponentAlongAxis(up, ceilingHorizontalDirection);
            if (!ceilingHorizontalDirection.vec3_isZero(1e-5)) {
              ceilingHorizontalDirection.vec3_normalize(ceilingHorizontalDirection);
              let ceilingExtraHorizontalLength = verticalMovement.vec3_length() / Math.tan(Math.pp_toRadians(previousCollisionRuntimeParams.myCeilingAngle));
              ceilingExtraHorizontalLength *= isMovementDownward ? -1 : 1;
              if (Math.abs(ceilingExtraHorizontalLength) > 1e-5) {
                let sameDirectionAsGround = ceilingHorizontalDirection.vec3_isConcordant(groundHorizontalDirection);
                if (extraHorizontalMovement.vec3_isZero() || sameDirectionAsGround) {
                  if (!isMovementDownward) {
                    if (collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhill && (collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle == null || previousCollisionRuntimeParams.myCeilingAngle >= collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle)) {
                      scaledCeilingHorizontalDirection = ceilingHorizontalDirection.vec3_scale(ceilingExtraHorizontalLength, scaledCeilingHorizontalDirection);
                      if (!groundHorizontalDirection.vec3_isZero()) {
                        scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection = scaledCeilingHorizontalDirection.vec3_removeComponentAlongAxis(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection);
                        scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection = scaledCeilingHorizontalDirection.vec3_componentAlongAxis(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection);
                        if (scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection.vec3_isFartherAlongAxis(extraHorizontalMovement, groundHorizontalDirection)) {
                          collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = false;
                          extraHorizontalMovement.vec3_copy(scaledCeilingHorizontalDirection);
                          collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = true;
                        } else if (!scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection.vec3_isZero(1e-5)) {
                          extraHorizontalMovement = extraHorizontalMovement.vec3_add(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection, extraHorizontalMovement);
                          collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = true;
                        }
                      } else {
                        extraHorizontalMovement.vec3_copy(scaledCeilingHorizontalDirection);
                        collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = true;
                      }
                    }
                  }
                }
              }
            }
          }
          if (!extraHorizontalMovement.vec3_isZero()) {
            if (horizontalMovement.vec3_isZero(1e-5)) {
              outAdjustedHorizontalMovement.vec3_copy(extraHorizontalMovement);
            } else if (extraHorizontalMovement.vec3_isConcordant(horizontalMovement)) {
              outAdjustedHorizontalMovement = horizontalMovement.vec3_add(extraHorizontalMovement, outAdjustedHorizontalMovement);
            } else {
              outAdjustedHorizontalMovement = horizontalMovement.vec3_add(extraHorizontalMovement, outAdjustedHorizontalMovement);
            }
          }
          if (outAdjustedHorizontalMovement.vec3_isZero(1e-6)) {
            outAdjustedHorizontalMovement.vec3_zero();
          }
          return outAdjustedHorizontalMovement;
        };
      }();
      CollisionCheck.prototype._computeExtraSurfaceVerticalMovement = function() {
        let direction = PP.vec3_create();
        let tempVector = PP.vec3_create();
        return function _computeExtraSurfaceVerticalMovement(horizontalMovement, up, collisionCheckParams, collisionRuntimeParams, outExtraSurfaceVerticalMovement) {
          outExtraSurfaceVerticalMovement.vec3_zero();
          if (!horizontalMovement.vec3_isZero()) {
            if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle != 0) {
              direction = horizontalMovement.vec3_normalize(direction);
              let groundPerceivedAngle = this.computeSurfacePerceivedAngle(
                collisionRuntimeParams.myGroundNormal,
                direction,
                up,
                true
              );
              let extraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(groundPerceivedAngle)));
              extraVerticalLength *= Math.pp_sign(groundPerceivedAngle);
              if (Math.abs(extraVerticalLength) > 1e-5 && (collisionCheckParams.mySnapOnGroundEnabled || extraVerticalLength > 0)) {
                outExtraSurfaceVerticalMovement.vec3_add(up.vec3_scale(extraVerticalLength, tempVector), outExtraSurfaceVerticalMovement);
              }
            } else if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle != 0) {
              direction = horizontalMovement.vec3_normalize(direction);
              let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(
                collisionRuntimeParams.myCeilingNormal,
                direction,
                up,
                false
              );
              let extraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(ceilingPerceivedAngle)));
              extraVerticalLength *= Math.pp_sign(ceilingPerceivedAngle);
              extraVerticalLength *= -1;
              if (Math.abs(extraVerticalLength) > 1e-5 && (collisionCheckParams.mySnapOnCeilingEnabled || extraVerticalLength < 0)) {
                outExtraSurfaceVerticalMovement.vec3_add(up.vec3_scale(extraVerticalLength, tempVector), outExtraSurfaceVerticalMovement);
              }
            }
          }
          return outExtraSurfaceVerticalMovement;
        };
      }();
      CollisionCheck.prototype._gatherSurfaceInfo = function() {
        let verticalDirection = PP.vec3_create();
        let startOffset = PP.vec3_create();
        let endOffset = PP.vec3_create();
        let heightOffset = PP.vec3_create();
        let smallOffset = PP.vec3_create();
        let smallStartPosition = PP.vec3_create();
        let smallEndPosition = PP.vec3_create();
        let surfaceNormal = PP.vec3_create();
        let surfaceHitMaxNormal = PP.vec3_create();
        let hitFromCurrentPosition = PP.vec3_create();
        let startPosition = PP.vec3_create();
        let endPosition = PP.vec3_create();
        let direction = PP.vec3_create();
        return function _gatherSurfaceInfo(feetPosition, height, up, forwardForPerceivedAngle, forwardForVertical, isGround, collisionCheckParams, collisionRuntimeParams) {
          this._myDebugActive = collisionCheckParams.myDebugActive && (isGround && collisionCheckParams.myDebugGroundInfoActive || !isGround && collisionCheckParams.myDebugCeilingInfoActive);
          let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forwardForVertical, collisionCheckParams, collisionRuntimeParams);
          verticalDirection.vec3_copy(up);
          let distanceToBeOnSurface = collisionCheckParams.myDistanceToBeOnGround;
          let distanceToComputeSurfaceInfo = collisionCheckParams.myDistanceToComputeGroundInfo;
          let distanceToFindSurfaceDistance = collisionCheckParams.myFindGroundDistanceMaxOutsideDistance;
          let verticalFixToBeOnSurface = collisionCheckParams.myVerticalFixToBeOnGround;
          let verticalFixToComputeSurfaceInfo = collisionCheckParams.myVerticalFixToComputeGroundInfo;
          let verticalFixToFindSurfaceDistance = collisionCheckParams.myFindGroundDistanceMaxInsideDistance;
          let isOnSurfaceIfInsideHit = collisionCheckParams.myIsOnGroundIfInsideHit;
          let isBaseInsideCollisionCheckEnabled = collisionCheckParams.myGroundIsBaseInsideCollisionCheckEnabled;
          if (!isGround) {
            verticalDirection.vec3_negate(verticalDirection);
            distanceToBeOnSurface = collisionCheckParams.myDistanceToBeOnCeiling;
            distanceToComputeSurfaceInfo = collisionCheckParams.myDistanceToComputeCeilingInfo;
            distanceToFindSurfaceDistance = collisionCheckParams.myFindCeilingDistanceMaxOutsideDistance;
            verticalFixToBeOnSurface = collisionCheckParams.myVerticalFixToBeOnCeiling;
            verticalFixToComputeSurfaceInfo = collisionCheckParams.myVerticalFixToComputeCeilingInfo;
            verticalFixToFindSurfaceDistance = collisionCheckParams.myFindCeilingDistanceMaxInsideDistance;
            isOnSurfaceIfInsideHit = collisionCheckParams.myIsOnCeilingIfInsideHit;
            isBaseInsideCollisionCheckEnabled = collisionCheckParams.myCeilingIsBaseInsideCollisionCheckEnabled;
          }
          startOffset = verticalDirection.vec3_scale(Math.max(verticalFixToBeOnSurface, verticalFixToComputeSurfaceInfo, verticalFixToFindSurfaceDistance, 1e-5), startOffset);
          endOffset = verticalDirection.vec3_negate(endOffset).vec3_scale(Math.max(distanceToBeOnSurface, distanceToComputeSurfaceInfo, distanceToFindSurfaceDistance, 1e-5), endOffset);
          heightOffset.vec3_zero();
          if (!isGround) {
            heightOffset = up.vec3_scale(height, heightOffset);
          }
          smallOffset = verticalDirection.vec3_scale(1e-4, smallOffset);
          let isOnSurface = false;
          let surfaceAngle = 0;
          let surfacePerceivedAngle = 0;
          surfaceNormal.vec3_zero();
          let surfaceHitMaxAngle = 0;
          surfaceHitMaxNormal.vec3_zero();
          let surfaceDistance = null;
          let isBaseInsideCollision = checkPositions.length > 0;
          for (let i = 0; i < checkPositions.length; i++) {
            let currentPosition = checkPositions[i];
            currentPosition.vec3_add(heightOffset, currentPosition);
            let baseHitIsInsideCollision = false;
            if (isBaseInsideCollisionCheckEnabled) {
              smallStartPosition = currentPosition.vec3_add(smallOffset, smallStartPosition);
              smallEndPosition = currentPosition.vec3_sub(smallOffset, smallEndPosition);
              let origin = smallStartPosition;
              direction = smallEndPosition.vec3_sub(origin, direction);
              let distance4 = direction.vec3_length();
              direction.vec3_normalize(direction);
              let raycastResult = this._raycastAndDebug(origin, direction, distance4, false, false, collisionCheckParams, collisionRuntimeParams);
              if (raycastResult.isColliding()) {
                baseHitIsInsideCollision = raycastResult.myHits[0].myIsInsideCollision;
              }
            }
            isBaseInsideCollision &&= baseHitIsInsideCollision;
            if (!baseHitIsInsideCollision) {
              startPosition = currentPosition.vec3_add(startOffset, startPosition);
              endPosition = currentPosition.vec3_add(endOffset, endPosition);
              let origin = startPosition;
              direction = endPosition.vec3_sub(origin, direction);
              let distance4 = direction.vec3_length();
              direction.vec3_normalize(direction);
              let raycastResult = this._raycastAndDebug(origin, direction, distance4, true, false, collisionCheckParams, collisionRuntimeParams);
              if (raycastResult.isColliding()) {
                hitFromCurrentPosition = raycastResult.myHits[0].myPosition.vec3_sub(currentPosition, hitFromCurrentPosition);
                let hitFromCurrentPositionLength = hitFromCurrentPosition.vec3_lengthSigned(verticalDirection);
                if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToBeOnSurface + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToBeOnSurface + 1e-5) {
                  isOnSurface = true;
                }
                if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToComputeSurfaceInfo + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToComputeSurfaceInfo + 1e-5) {
                  let currentSurfaceNormal = raycastResult.myHits[0].myNormal;
                  surfaceNormal.vec3_add(currentSurfaceNormal, surfaceNormal);
                  let surfaceHitAngle = currentSurfaceNormal.vec3_angle(verticalDirection);
                  if (surfaceHitAngle > surfaceHitMaxAngle) {
                    surfaceHitMaxAngle = surfaceHitAngle;
                    surfaceHitMaxNormal.vec3_copy(currentSurfaceNormal);
                  }
                }
                if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToFindSurfaceDistance + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToFindSurfaceDistance + 1e-5) {
                  if (surfaceDistance == null) {
                    surfaceDistance = -hitFromCurrentPositionLength;
                  } else {
                    if (Math.abs(hitFromCurrentPositionLength) < Math.abs(surfaceDistance)) {
                      surfaceDistance = -hitFromCurrentPositionLength;
                    }
                  }
                }
              }
            } else if (isOnSurfaceIfInsideHit) {
              isOnSurface = true;
            }
          }
          if (!surfaceNormal.vec3_isZero()) {
            surfaceNormal.vec3_normalize(surfaceNormal);
            surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
            if (surfaceAngle <= 1e-4) {
              surfaceAngle = 0;
              surfaceNormal.vec3_copy(verticalDirection);
            } else if (surfaceAngle >= 180 - 1e-4) {
              surfaceAngle = 180;
              surfaceNormal = verticalDirection.vec3_negate(surfaceNormal);
            }
            surfacePerceivedAngle = this.computeSurfacePerceivedAngle(surfaceNormal, forwardForPerceivedAngle, up, isGround);
          }
          if (isGround) {
            collisionRuntimeParams.myRealIsOnGround = isOnSurface;
            collisionRuntimeParams.myGroundAngle = surfaceAngle;
            collisionRuntimeParams.myGroundPerceivedAngle = surfacePerceivedAngle;
            collisionRuntimeParams.myGroundNormal.vec3_copy(surfaceNormal);
            collisionRuntimeParams.myGroundHitMaxAngle = surfaceHitMaxAngle;
            collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(surfaceHitMaxNormal);
            collisionRuntimeParams.myGroundDistance = surfaceDistance;
            collisionRuntimeParams.myGroundIsBaseInsideCollision = isBaseInsideCollision;
            if (isOnSurface && (collisionCheckParams.myIsOnGroundMaxSurfaceAngle == null || collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myIsOnGroundMaxSurfaceAngle)) {
              collisionRuntimeParams.myIsOnGround = isOnSurface;
            }
          } else {
            collisionRuntimeParams.myRealIsOnCeiling = isOnSurface;
            collisionRuntimeParams.myCeilingAngle = surfaceAngle;
            collisionRuntimeParams.myCeilingPerceivedAngle = surfacePerceivedAngle;
            collisionRuntimeParams.myCeilingNormal.vec3_copy(surfaceNormal);
            collisionRuntimeParams.myCeilingHitMaxAngle = surfaceHitMaxAngle;
            collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(surfaceHitMaxNormal);
            collisionRuntimeParams.myCeilingDistance = surfaceDistance;
            collisionRuntimeParams.myCeilingIsBaseInsideCollision = isBaseInsideCollision;
            if (isOnSurface && (collisionCheckParams.myIsOnCeilingMaxSurfaceAngle == null || collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myIsOnCeilingMaxSurfaceAngle)) {
              collisionRuntimeParams.myIsOnCeiling = isOnSurface;
            }
          }
        };
      }();
      CollisionCheck.prototype.computeSurfacePerceivedAngle = function() {
        let forwardOnSurface = PP.vec3_create();
        let verticalDirection = PP.vec3_create();
        return function computeSurfacePerceivedAngle(surfaceNormal, forward, up, isGround = true) {
          let surfacePerceivedAngle = 0;
          verticalDirection.vec3_copy(up);
          if (!isGround) {
            verticalDirection.vec3_negate(verticalDirection);
          }
          let surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
          if (surfaceAngle <= Math.PP_EPSILON_DEGREES) {
            surfaceAngle = 0;
          } else if (surfaceAngle >= 180 - Math.PP_EPSILON_DEGREES) {
            surfaceAngle = 180;
          }
          forwardOnSurface = forward.vec3_projectOnPlaneAlongAxis(surfaceNormal, up, forwardOnSurface);
          surfacePerceivedAngle = forwardOnSurface.vec3_angle(forward);
          let isFartherOnUp = forwardOnSurface.vec3_isFartherAlongAxis(forward, up);
          if (!isFartherOnUp && isGround || isFartherOnUp && !isGround) {
            surfacePerceivedAngle *= -1;
          }
          if (Math.abs(surfacePerceivedAngle) >= surfaceAngle) {
            if (surfaceAngle != 0 && surfaceAngle != 180) {
              surfacePerceivedAngle = surfaceAngle * Math.pp_sign(surfacePerceivedAngle);
            } else {
              surfacePerceivedAngle = surfaceAngle;
            }
          }
          return surfacePerceivedAngle;
        };
      }();
      Object.defineProperty(CollisionCheck.prototype, "_surfaceTooSteep", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_computeExtraSurfaceVerticalMovement", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_gatherSurfaceInfo", { enumerable: false });
      Object.defineProperty(CollisionCheck.prototype, "_updateSurfaceInfo", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check_bridge.js
  var require_collision_check_bridge = __commonJS({
    "js/pp/gameplay/character_controller/collision/collision_check_bridge/collision_check_bridge.js"() {
      PP.CollisionCheckBridge = {
        _myCollisionCheck: new CollisionCheck(),
        checkMovement: function() {
          let collisionCheckParams = new CollisionCheckParams();
          let collisionRuntimeParams = new CollisionRuntimeParams();
          return function checkMovement(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
            this.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
            this.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
            this._myCollisionCheck.move(movement, currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
            this.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
          };
        }(),
        checkTeleportToTransform: function() {
          let teleportPosition = PP.vec3_create();
          let collisionCheckParams = new CollisionCheckParams();
          let collisionRuntimeParams = new CollisionRuntimeParams();
          return function checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
            this.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
            this.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
            teleportPosition = teleportTransformQuat.quat2_getPosition(teleportPosition);
            this._myCollisionCheck.teleport(teleportPosition, teleportTransformQuat, collisionCheckParams, collisionRuntimeParams);
            this.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
          };
        }(),
        checkTransform: function() {
          let collisionCheckParams = new CollisionCheckParams();
          let collisionRuntimeParams = new CollisionRuntimeParams();
          return function checkTransform(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
            this.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
            this.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
            this._myCollisionCheck.positionCheck(true, checkTransformQuat, collisionCheckParams, collisionRuntimeParams);
            this.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, checkTransformQuat, outCharacterCollisionResults);
          };
        }(),
        updateGroundInfo: function() {
          let collisionCheckParams = new CollisionCheckParams();
          let collisionRuntimeParams = new CollisionRuntimeParams();
          return function updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
            this.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
            this.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
            collisionCheckParams.myComputeCeilingInfoEnabled = false;
            this._myCollisionCheck.updateSurfaceInfo(currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
            this.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
          };
        }(),
        updateCeilingInfo: function() {
          let collisionCheckParams = new CollisionCheckParams();
          let collisionRuntimeParams = new CollisionRuntimeParams();
          return function updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
            this.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
            this.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
            collisionCheckParams.myComputeGroundInfoEnabled = false;
            this._myCollisionCheck.updateSurfaceInfo(currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
            this.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
          };
        }(),
        convertCharacterCollisionResultsToCollisionRuntimeParams: function(characterCollisionResults, outCollisionRuntimeParams) {
          outCollisionRuntimeParams.reset();
          characterCollisionResults.myTransformResults.myStartTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myOriginalPosition);
          characterCollisionResults.myTransformResults.myEndTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myNewPosition);
          characterCollisionResults.myTransformResults.myStartTransformQuat.quat2_getForward(outCollisionRuntimeParams.myOriginalForward);
          characterCollisionResults.myTransformResults.myStartTransformQuat.quat2_getUp(outCollisionRuntimeParams.myOriginalUp);
          outCollisionRuntimeParams.myOriginalMovement.vec3_copy(characterCollisionResults.myMovementResults.myStartMovement);
          outCollisionRuntimeParams.myFixedMovement.vec3_copy(characterCollisionResults.myMovementResults.myEndMovement);
          outCollisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantStartHorizontalMovement);
          outCollisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantStartVerticalMovement);
          outCollisionRuntimeParams.myLastValidEndHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantEndHorizontalMovement);
          outCollisionRuntimeParams.myLastValidEndVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantEndVerticalMovement);
          outCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantAdjustedStartHorizontalMovement);
          outCollisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantAdjustedStartVerticalMovement);
          outCollisionRuntimeParams.myIsOnGround = characterCollisionResults.myGroundInfo.myIsOnSurface;
          outCollisionRuntimeParams.myGroundAngle = characterCollisionResults.myGroundInfo.mySurfaceAngle;
          outCollisionRuntimeParams.myGroundPerceivedAngle = characterCollisionResults.myGroundInfo.mySurfacePerceivedAngle;
          outCollisionRuntimeParams.myGroundNormal.vec3_copy(characterCollisionResults.myGroundInfo.mySurfaceNormal);
          outCollisionRuntimeParams.myGroundHitMaxAngle = characterCollisionResults.myGroundInfo.mySurfaceHitMaxAngle;
          outCollisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(characterCollisionResults.myGroundInfo.mySurfaceHitMaxNormal);
          outCollisionRuntimeParams.myGroundDistance = characterCollisionResults.myGroundInfo.mySurfaceDistance;
          outCollisionRuntimeParams.myGroundIsBaseInsideCollision = characterCollisionResults.myGroundInfo.myIsBaseInsideCollision;
          outCollisionRuntimeParams.myIsOnCeiling = characterCollisionResults.myCeilingInfo.myIsOnSurface;
          outCollisionRuntimeParams.myCeilingAngle = characterCollisionResults.myCeilingInfo.mySurfaceAngle;
          outCollisionRuntimeParams.myCeilingPerceivedAngle = characterCollisionResults.myCeilingInfo.mySurfacePerceivedAngle;
          outCollisionRuntimeParams.myCeilingNormal.vec3_copy(characterCollisionResults.myCeilingInfo.mySurfaceNormal);
          outCollisionRuntimeParams.myCeilingHitMaxAngle = characterCollisionResults.myCeilingInfo.mySurfaceHitMaxAngle;
          outCollisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(characterCollisionResults.myCeilingInfo.mySurfaceHitMaxNormal);
          outCollisionRuntimeParams.myCeilingDistance = characterCollisionResults.myCeilingInfo.mySurfaceDistance;
          outCollisionRuntimeParams.myCeilingIsBaseInsideCollision = characterCollisionResults.myCeilingInfo.myIsBaseInsideCollision;
          outCollisionRuntimeParams.myHorizontalMovementCanceled = characterCollisionResults.myHorizontalMovementResults.myMovementFailed;
          outCollisionRuntimeParams.myIsCollidingHorizontally = characterCollisionResults.myHorizontalMovementResults.myIsColliding;
          outCollisionRuntimeParams.myHorizontalCollisionHit.copy(characterCollisionResults.myHorizontalMovementResults.myReferenceCollisionHit);
          outCollisionRuntimeParams.myVerticalMovementCanceled = characterCollisionResults.myVerticalMovementResults.myMovementFailed;
          outCollisionRuntimeParams.myIsCollidingVertically = characterCollisionResults.myVerticalMovementResults.myIsColliding;
          outCollisionRuntimeParams.myVerticalCollisionHit.copy(characterCollisionResults.myVerticalMovementResults.myReferenceCollisionHit);
          outCollisionRuntimeParams.myHasSnappedOnGround = characterCollisionResults.myGroundResults.myHasSnappedOnSurface;
          outCollisionRuntimeParams.myHasSnappedOnCeiling = characterCollisionResults.myCeilingResults.myHasSnappedOnSurface;
          outCollisionRuntimeParams.myHasPoppedOutGround = characterCollisionResults.myGroundResults.myHasPoppedOutSurface;
          outCollisionRuntimeParams.myHasPoppedOutCeiling = characterCollisionResults.myCeilingResults.myHasPoppedOutSurface;
          outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill = characterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
          outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill = characterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill;
          outCollisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill = characterCollisionResults.myGroundResults.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill;
          outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill = characterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
          outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill = characterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill;
          outCollisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill = characterCollisionResults.myCeilingResults.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill;
          outCollisionRuntimeParams.myIsSliding = characterCollisionResults.myWallSlideResults.myHasSlid;
          outCollisionRuntimeParams.mySlidingMovementAngle = characterCollisionResults.myWallSlideResults.mySlideMovementAngle;
          outCollisionRuntimeParams.mySlidingCollisionAngle = characterCollisionResults.myWallSlideResults.mySlideMovementWallAngle;
          outCollisionRuntimeParams.mySlidingWallNormal.vec3_copy(characterCollisionResults.myWallSlideResults.myWallNormal);
          outCollisionRuntimeParams.myIsSlidingIntoOppositeDirection = characterCollisionResults.myInternalResults.myHasWallSlidTowardOppositeDirection;
          outCollisionRuntimeParams.myIsSlidingFlickerPrevented = characterCollisionResults.myInternalResults.myLastRelevantWallSlideFlickerPrevented;
          outCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = characterCollisionResults.myInternalResults.myWallSlideFlickerPreventionForceCheckCounter;
          outCollisionRuntimeParams.mySliding90DegreesSign = characterCollisionResults.myInternalResults.myWallSlide90DegreesDirectionSign;
          outCollisionRuntimeParams.mySlidingRecompute90DegreesSign = characterCollisionResults.myInternalResults.myWallSlide90DegreesRecomputeDirectionSign;
          outCollisionRuntimeParams.myLastValidIsSliding = characterCollisionResults.myInternalResults.myLastRelevantHasWallSlid;
          outCollisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantEndHorizontalMovement);
          outCollisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(characterCollisionResults.myTeleportResults.myStartTeleportTransformQuat);
          outCollisionRuntimeParams.myFixedTeleportPosition.vec3_copy(characterCollisionResults.myTeleportResults.myEndTeleportTransformQuat);
          outCollisionRuntimeParams.myTeleportCanceled = characterCollisionResults.myTeleportResults.myTeleportFailed;
          outCollisionRuntimeParams.myIsPositionOk = characterCollisionResults.myCheckTransformResults.myCheckTransformFailed;
          characterCollisionResults.myCheckTransformResults.myStartCheckTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myOriginalPositionCheckPosition);
          characterCollisionResults.myCheckTransformResults.myEndCheckTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myFixedPositionCheckPosition);
          outCollisionRuntimeParams.myIsTeleport = characterCollisionResults.myCheckType == PP.CharacterCollisionCheckType.CHECK_TELEPORT;
          outCollisionRuntimeParams.myIsMove = characterCollisionResults.myCheckType == PP.CharacterCollisionCheckType.CHECK_MOVEMENT;
          outCollisionRuntimeParams.myIsPositionCheck = characterCollisionResults.myCheckType == PP.CharacterCollisionCheckType.CHECK_TRANSFORM;
          outCollisionRuntimeParams.mySplitMovementSteps = characterCollisionResults.mySplitMovementResults.myStepsToPerform;
          outCollisionRuntimeParams.mySplitMovementStepsPerformed = characterCollisionResults.mySplitMovementResults.myStepsPerformed;
          outCollisionRuntimeParams.mySplitMovementStop = characterCollisionResults.mySplitMovementResults.myMovementInterrupted;
          outCollisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(characterCollisionResults.mySplitMovementResults.myMovementChecked);
          return outCollisionRuntimeParams;
        },
        convertCollisionRuntimeParamsToCharacterCollisionResults: function() {
          let rotationQuat = PP.quat_create();
          return function convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults) {
            outCharacterCollisionResults.reset();
            if (collisionRuntimeParams.myIsMove) {
              outCharacterCollisionResults.myCheckType = PP.CharacterCollisionCheckType.CHECK_MOVEMENT;
            } else if (collisionRuntimeParams.myIsTeleport) {
              outCharacterCollisionResults.myCheckType = PP.CharacterCollisionCheckType.CHECK_TELEPORT;
            } else if (collisionRuntimeParams.myIsPositionCheck) {
              outCharacterCollisionResults.myCheckType = PP.CharacterCollisionCheckType.CHECK_TRANSFORM;
            }
            rotationQuat.quat_setForward(collisionRuntimeParams.myOriginalForward, collisionRuntimeParams.myOriginalUp);
            outCharacterCollisionResults.myTransformResults.myStartTransformQuat.quat2_setPositionRotationQuat(collisionRuntimeParams.myOriginalPosition, rotationQuat);
            outCharacterCollisionResults.myTransformResults.myEndTransformQuat.quat2_setPositionRotationQuat(collisionRuntimeParams.myNewPosition, rotationQuat);
            outCharacterCollisionResults.myMovementResults.myStartMovement.vec3_copy(collisionRuntimeParams.myOriginalMovement);
            outCharacterCollisionResults.myMovementResults.myEndMovement.vec3_copy(collisionRuntimeParams.myFixedMovement);
            outCharacterCollisionResults.myMovementResults.myMovementFailed = collisionRuntimeParams.myHorizontalMovementCanceled && collisionRuntimeParams.myVerticalMovementCanceled;
            outCharacterCollisionResults.myMovementResults.myIsColliding = collisionRuntimeParams.myIsCollidingHorizontally || collisionRuntimeParams.myIsCollidingVertically;
            if (collisionRuntimeParams.myIsCollidingHorizontally) {
              outCharacterCollisionResults.myMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
            } else if (collisionRuntimeParams.myIsCollidingVertically) {
              outCharacterCollisionResults.myMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myVerticalCollisionHit);
            }
            outCharacterCollisionResults.myHorizontalMovementResults.myMovementFailed = collisionRuntimeParams.myHorizontalMovementCanceled;
            outCharacterCollisionResults.myHorizontalMovementResults.myIsColliding = collisionRuntimeParams.myIsCollidingHorizontally;
            outCharacterCollisionResults.myHorizontalMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
            outCharacterCollisionResults.myVerticalMovementResults.myMovementFailed = collisionRuntimeParams.myVerticalMovementCanceled;
            outCharacterCollisionResults.myVerticalMovementResults.myIsColliding = collisionRuntimeParams.myIsCollidingVertically;
            outCharacterCollisionResults.myVerticalMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myVerticalCollisionHit);
            outCharacterCollisionResults.myTeleportResults.myStartTeleportTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myStartTransformQuat);
            outCharacterCollisionResults.myTeleportResults.myStartTeleportTransformQuat.quat2_setPosition(collisionRuntimeParams.myOriginalTeleportPosition);
            outCharacterCollisionResults.myTeleportResults.myEndTeleportTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myEndTransformQuat);
            outCharacterCollisionResults.myTeleportResults.myEndTeleportTransformQuat.quat2_setPosition(collisionRuntimeParams.myFixedTeleportPosition);
            outCharacterCollisionResults.myTeleportResults.myTeleportFailed = collisionRuntimeParams.myTeleportCanceled;
            outCharacterCollisionResults.myCheckTransformResults.myStartCheckTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myStartTransformQuat);
            outCharacterCollisionResults.myCheckTransformResults.myStartCheckTransformQuat.quat2_setPosition(collisionRuntimeParams.myOriginalPositionCheckPosition);
            outCharacterCollisionResults.myCheckTransformResults.myEndCheckTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myEndTransformQuat);
            outCharacterCollisionResults.myCheckTransformResults.myEndCheckTransformQuat.quat2_setPosition(collisionRuntimeParams.myFixedPositionCheckPosition);
            outCharacterCollisionResults.myCheckTransformResults.myCheckTransformFailed = !collisionRuntimeParams.myIsPositionOk;
            outCharacterCollisionResults.myWallSlideResults.myHasSlid = collisionRuntimeParams.myIsSliding;
            outCharacterCollisionResults.myWallSlideResults.mySlideMovementAngle = collisionRuntimeParams.mySlidingMovementAngle;
            outCharacterCollisionResults.myWallSlideResults.mySlideMovementWallAngle = collisionRuntimeParams.mySlidingCollisionAngle;
            outCharacterCollisionResults.myWallSlideResults.myWallNormal.vec3_copy(collisionRuntimeParams.mySlidingWallNormal);
            outCharacterCollisionResults.myGroundInfo.myIsOnSurface = collisionRuntimeParams.myIsOnGround;
            outCharacterCollisionResults.myGroundInfo.mySurfaceAngle = collisionRuntimeParams.myGroundAngle;
            outCharacterCollisionResults.myGroundInfo.mySurfacePerceivedAngle = collisionRuntimeParams.myGroundPerceivedAngle;
            outCharacterCollisionResults.myGroundInfo.mySurfaceNormal.vec3_copy(collisionRuntimeParams.myGroundNormal);
            outCharacterCollisionResults.myGroundInfo.mySurfaceHitMaxAngle = collisionRuntimeParams.myGroundHitMaxAngle;
            outCharacterCollisionResults.myGroundInfo.mySurfaceHitMaxNormal.vec3_copy(collisionRuntimeParams.myGroundHitMaxNormal);
            outCharacterCollisionResults.myGroundInfo.mySurfaceDistance = collisionRuntimeParams.myGroundDistance;
            outCharacterCollisionResults.myGroundInfo.myIsBaseInsideCollision = collisionRuntimeParams.myGroundIsBaseInsideCollision;
            outCharacterCollisionResults.myCeilingInfo.myIsOnSurface = collisionRuntimeParams.myIsOnCeiling;
            outCharacterCollisionResults.myCeilingInfo.mySurfaceAngle = collisionRuntimeParams.myCeilingAngle;
            outCharacterCollisionResults.myCeilingInfo.mySurfacePerceivedAngle = collisionRuntimeParams.myCeilingPerceivedAngle;
            outCharacterCollisionResults.myCeilingInfo.mySurfaceNormal.vec3_copy(collisionRuntimeParams.myCeilingNormal);
            outCharacterCollisionResults.myCeilingInfo.mySurfaceHitMaxAngle = collisionRuntimeParams.myCeilingHitMaxAngle;
            outCharacterCollisionResults.myCeilingInfo.mySurfaceHitMaxNormal.vec3_copy(collisionRuntimeParams.myCeilingHitMaxNormal);
            outCharacterCollisionResults.myCeilingInfo.mySurfaceDistance = collisionRuntimeParams.myCeilingDistance;
            outCharacterCollisionResults.myCeilingInfo.myIsBaseInsideCollision = collisionRuntimeParams.myCeilingIsBaseInsideCollision;
            outCharacterCollisionResults.myGroundResults.myHasSnappedOnSurface = collisionRuntimeParams.myHasSnappedOnGround;
            outCharacterCollisionResults.myGroundResults.myHasPoppedOutSurface = collisionRuntimeParams.myHasPoppedOutGround;
            outCharacterCollisionResults.myCeilingResults.myHasSnappedOnSurface = collisionRuntimeParams.myHasSnappedOnCeiling;
            outCharacterCollisionResults.myCeilingResults.myHasPoppedOutSurface = collisionRuntimeParams.myHasPoppedOutCeiling;
            outCharacterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleDownhill;
            outCharacterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnGroundPerceivedAngleUphill;
            outCharacterCollisionResults.myGroundResults.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill = collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnGroundAngleDownhill;
            outCharacterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleDownhill;
            outCharacterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementBasedOnCeilingPerceivedAngleUphill;
            outCharacterCollisionResults.myCeilingResults.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill = collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementBasedOnCeilingAngleDownhill;
            outCharacterCollisionResults.mySplitMovementResults.myStepsToPerform = collisionRuntimeParams.mySplitMovementSteps;
            outCharacterCollisionResults.mySplitMovementResults.myStepsPerformed = collisionRuntimeParams.mySplitMovementStepsPerformed;
            outCharacterCollisionResults.mySplitMovementResults.myMovementInterrupted = collisionRuntimeParams.mySplitMovementStop;
            outCharacterCollisionResults.mySplitMovementResults.myMovementChecked.vec3_copy(collisionRuntimeParams.mySplitMovementMovementChecked);
            outCharacterCollisionResults.myInternalResults.myLastRelevantStartHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidOriginalHorizontalMovement);
            outCharacterCollisionResults.myInternalResults.myLastRelevantEndHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidEndHorizontalMovement);
            outCharacterCollisionResults.myInternalResults.myLastRelevantStartVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidOriginalVerticalMovement);
            outCharacterCollisionResults.myInternalResults.myLastRelevantEndVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidEndVerticalMovement);
            outCharacterCollisionResults.myInternalResults.myLastRelevantAdjustedStartHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement);
            outCharacterCollisionResults.myInternalResults.myLastRelevantAdjustedStartVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement);
            outCharacterCollisionResults.myInternalResults.myLastRelevantHasWallSlid = collisionRuntimeParams.myLastValidIsSliding;
            outCharacterCollisionResults.myInternalResults.myHasWallSlidTowardOppositeDirection = collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
            outCharacterCollisionResults.myInternalResults.myLastRelevantWallSlideFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented;
            outCharacterCollisionResults.myInternalResults.myWallSlideFlickerPreventionForceCheckCounter = collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter;
            outCharacterCollisionResults.myInternalResults.myWallSlide90DegreesDirectionSign = collisionRuntimeParams.mySliding90DegreesSign;
            outCharacterCollisionResults.myInternalResults.myWallSlide90DegreesRecomputeDirectionSign = collisionRuntimeParams.mySlidingRecompute90DegreesSign;
            outCharacterCollisionResults.myTransformResults.myStartTransformQuat.quat2_copy(currentTransformQuat);
            return outCharacterCollisionResults;
          };
        }(),
        convertCharacterColliderSetupToCollisionCheckParams: function() {
          return function convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, outCollisionCheckParams) {
            outCollisionCheckParams.myHeight = characterColliderSetup.myHeight;
            outCollisionCheckParams.myRadius = characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeRadius;
            outCollisionCheckParams.myDistanceFromFeetToIgnore = characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFeetDistanceToIgnore;
            outCollisionCheckParams.myDistanceFromHeadToIgnore = characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckHeadDistanceToIgnore;
            outCollisionCheckParams.myHorizontalMovementCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementStepEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckSplitMovementEnabled;
            outCollisionCheckParams.myHorizontalMovementStepMaxLength = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckSplitMovementMaxStepLength;
            outCollisionCheckParams.myHorizontalMovementRadialStepAmount = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckRadialSteps;
            outCollisionCheckParams.myHorizontalMovementCheckDiagonalOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckDiagonalInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckStraight = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalStraightCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckHorizontalBorder = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalRadialCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckVerticalStraight = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalUpward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalDownward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightCentralCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
            outCollisionCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
            outCollisionCheckParams.myHorizontalPositionCheckEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckEnabled;
            outCollisionCheckParams.myHalfConeAngle = characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeHalfAngle;
            outCollisionCheckParams.myHalfConeSliceAmount = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckConeHalfSlices;
            outCollisionCheckParams.myCheckConeBorder = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHorizontalBorderCheckEnabled;
            outCollisionCheckParams.myCheckConeRay = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHorizontalRadialCheckEnabled;
            outCollisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision;
            outCollisionCheckParams.myHorizontalPositionCheckVerticalDirectionType = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckDirection;
            outCollisionCheckParams.myCheckHeight = characterColliderSetup.myHorizontalCheckSetup.myHorizontalHeightCheckEnabled;
            outCollisionCheckParams.myCheckHeightVerticalMovement = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightVerticalCheckEnabled;
            outCollisionCheckParams.myCheckHeightVerticalPosition = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightVerticalCheckEnabled;
            outCollisionCheckParams.myCheckHeightTopMovement = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightHorizontalCheckEnabled;
            outCollisionCheckParams.myCheckHeightTopPosition = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightHorizontalCheckEnabled;
            outCollisionCheckParams.myCheckHeightConeOnCollision = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit;
            outCollisionCheckParams.myCheckHeightConeOnCollisionKeepHit = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit;
            outCollisionCheckParams.myHeightCheckStepAmountMovement = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightCheckSteps;
            outCollisionCheckParams.myHeightCheckStepAmountPosition = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightCheckSteps;
            outCollisionCheckParams.myCheckVerticalStraight = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalStraightCheckEnabled;
            outCollisionCheckParams.myCheckVerticalDiagonalRayOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled;
            outCollisionCheckParams.myCheckVerticalDiagonalRayInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled;
            outCollisionCheckParams.myCheckVerticalDiagonalBorderOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled;
            outCollisionCheckParams.myCheckVerticalDiagonalBorderInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled;
            outCollisionCheckParams.myCheckVerticalDiagonalBorderRayOutward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled;
            outCollisionCheckParams.myCheckVerticalDiagonalBorderRayInward = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled;
            outCollisionCheckParams.myCheckVerticalSearchFartherVerticalHit = characterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckGetFarthestHit;
            outCollisionCheckParams.myCheckHorizontalFixedForwardEnabled = characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFixedForwardEnabled;
            outCollisionCheckParams.myCheckHorizontalFixedForward.vec3_copy(characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFixedForward);
            outCollisionCheckParams.myVerticalMovementCheckEnabled = characterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckEnabled;
            outCollisionCheckParams.myVerticalPositionCheckEnabled = characterColliderSetup.myVerticalCheckSetup.myVerticalPositionCheckEnabled;
            outCollisionCheckParams.myFeetRadius = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadius;
            outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhill = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
            outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphill = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphill;
            outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfaceAngle;
            outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfaceAngle;
            outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
            outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = characterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
            outCollisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhill = characterColliderSetup.myGroundSetup.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhill;
            outCollisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = characterColliderSetup.myGroundSetup.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhillMinSurfaceAngle;
            outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhill = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
            outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphill = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphill;
            outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfaceAngle;
            outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfaceAngle;
            outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
            outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle = characterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
            outCollisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhill = characterColliderSetup.myCeilingSetup.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhill;
            outCollisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = characterColliderSetup.myCeilingSetup.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhillMinSurfaceAngle;
            outCollisionCheckParams.myCheckVerticalFixedForwardEnabled = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckFixedForwardEnabled;
            outCollisionCheckParams.myCheckVerticalFixedForward.vec3_copy(characterColliderSetup.myVerticalCheckSetup.myVerticalCheckFixedForward);
            outCollisionCheckParams.myCheckVerticalBothDirection = characterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckPerformCheckOnBothSides;
            outCollisionCheckParams.myVerticalMovementReduceEnabled = characterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckReductionEnabled;
            outCollisionCheckParams.myGroundCircumferenceAddCenter = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceCentralCheckEnabled;
            outCollisionCheckParams.myGroundCircumferenceSliceAmount = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices;
            outCollisionCheckParams.myGroundCircumferenceStepAmount = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadialSteps;
            outCollisionCheckParams.myGroundCircumferenceRotationPerStep = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRotationPerRadialStep;
            outCollisionCheckParams.myVerticalAllowHitInsideCollisionIfOneOk = characterColliderSetup.myVerticalCheckSetup.myVerticalCheckAllowHitsInsideCollisionIfOneValid;
            outCollisionCheckParams.myHorizontalBlockLayerFlags.copy(characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckBlockLayerFlags);
            outCollisionCheckParams.myVerticalBlockLayerFlags.copy(characterColliderSetup.myVerticalCheckSetup.myVerticalCheckBlockLayerFlags);
            outCollisionCheckParams.myHorizontalObjectsToIgnore.pp_copy(characterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckObjectsToIgnore);
            outCollisionCheckParams.myVerticalObjectsToIgnore.pp_copy(characterColliderSetup.myVerticalCheckSetup.myVerticalCheckObjectsToIgnore);
            outCollisionCheckParams.mySnapOnGroundEnabled = characterColliderSetup.myGroundSetup.mySurfaceSnapEnabled;
            outCollisionCheckParams.mySnapOnGroundExtraDistance = characterColliderSetup.myGroundSetup.mySurfaceSnapMaxDistance;
            outCollisionCheckParams.mySnapOnCeilingEnabled = characterColliderSetup.myCeilingSetup.mySurfaceSnapEnabled;
            outCollisionCheckParams.mySnapOnCeilingExtraDistance = characterColliderSetup.myCeilingSetup.mySurfaceSnapMaxDistance;
            outCollisionCheckParams.myGroundPopOutEnabled = characterColliderSetup.myGroundSetup.mySurfacePopOutEnabled;
            outCollisionCheckParams.myGroundPopOutExtraDistance = characterColliderSetup.myGroundSetup.mySurfacePopOutMaxDistance;
            outCollisionCheckParams.myCeilingPopOutEnabled = characterColliderSetup.myCeilingSetup.mySurfacePopOutEnabled;
            outCollisionCheckParams.myCeilingPopOutExtraDistance = characterColliderSetup.myCeilingSetup.mySurfacePopOutMaxDistance;
            outCollisionCheckParams.myGroundAngleToIgnore = characterColliderSetup.myGroundSetup.mySurfaceAngleToIgnore;
            outCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle = characterColliderSetup.myGroundSetup.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
            outCollisionCheckParams.myCeilingAngleToIgnore = characterColliderSetup.myCeilingSetup.mySurfaceAngleToIgnore;
            outCollisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle = characterColliderSetup.myCeilingSetup.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
            outCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight = characterColliderSetup.myGroundSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
            outCollisionCheckParams.myHorizontalMovementCeilingAngleIgnoreHeight = characterColliderSetup.myCeilingSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
            outCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight = characterColliderSetup.myGroundSetup.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
            outCollisionCheckParams.myHorizontalPositionCeilingAngleIgnoreHeight = characterColliderSetup.myCeilingSetup.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
            outCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = characterColliderSetup.myGroundSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
            outCollisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = characterColliderSetup.myCeilingSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
            outCollisionCheckParams.myComputeGroundInfoEnabled = characterColliderSetup.myGroundSetup.myCollectSurfaceInfo;
            outCollisionCheckParams.myComputeCeilingInfoEnabled = characterColliderSetup.myCeilingSetup.myCollectSurfaceInfo;
            outCollisionCheckParams.myDistanceToBeOnGround = characterColliderSetup.myGroundSetup.myIsOnSurfaceMaxOutsideDistance;
            outCollisionCheckParams.myDistanceToComputeGroundInfo = characterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxOutsideDistance;
            outCollisionCheckParams.myDistanceToBeOnCeiling = characterColliderSetup.myCeilingSetup.myIsOnSurfaceMaxOutsideDistance;
            outCollisionCheckParams.myDistanceToComputeCeilingInfo = characterColliderSetup.myCeilingSetup.myCollectSurfaceNormalMaxOutsideDistance;
            outCollisionCheckParams.myVerticalFixToBeOnGround = characterColliderSetup.myGroundSetup.myIsOnSurfaceMaxInsideDistance;
            outCollisionCheckParams.myVerticalFixToComputeGroundInfo = characterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxInsideDistance;
            outCollisionCheckParams.myVerticalFixToBeOnCeiling = characterColliderSetup.myCeilingSetup.myIsOnSurfaceMaxInsideDistance;
            outCollisionCheckParams.myVerticalFixToComputeCeilingInfo = characterColliderSetup.myCeilingSetup.myCollectSurfaceNormalMaxInsideDistance;
            outCollisionCheckParams.myGroundIsBaseInsideCollisionCheckEnabled = characterColliderSetup.myGroundSetup.myIsBaseInsideCollisionCheckEnabled;
            outCollisionCheckParams.myCeilingIsBaseInsideCollisionCheckEnabled = characterColliderSetup.myCeilingSetup.myIsBaseInsideCollisionCheckEnabled;
            outCollisionCheckParams.myIsOnGroundIfInsideHit = characterColliderSetup.myGroundSetup.myIsOnSurfaceIfBaseInsideCollision;
            outCollisionCheckParams.myIsOnCeilingIfInsideHit = characterColliderSetup.myCeilingSetup.myIsOnSurfaceIfBaseInsideCollision;
            outCollisionCheckParams.myFindGroundDistanceMaxOutsideDistance = characterColliderSetup.myGroundSetup.myFindSurfaceDistanceMaxOutsideDistance;
            outCollisionCheckParams.myFindGroundDistanceMaxInsideDistance = characterColliderSetup.myGroundSetup.myFindSurfaceDistanceMaxInsideDistance;
            outCollisionCheckParams.myFindCeilingDistanceMaxOutsideDistance = characterColliderSetup.myCeilingSetup.myFindSurfaceDistanceMaxOutsideDistance;
            outCollisionCheckParams.myFindCeilingDistanceMaxInsideDistance = characterColliderSetup.myCeilingSetup.myFindSurfaceDistanceMaxInsideDistance;
            outCollisionCheckParams.myAllowGroundSteepFix = characterColliderSetup.myGroundSetup.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
            outCollisionCheckParams.myAllowCeilingSteepFix = characterColliderSetup.myCeilingSetup.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
            outCollisionCheckParams.myMustStayOnGround = characterColliderSetup.myGroundSetup.myMovementMustStayOnSurface;
            outCollisionCheckParams.myMustStayOnCeiling = characterColliderSetup.myCeilingSetup.myMovementMustStayOnSurface;
            outCollisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail = characterColliderSetup.myGroundSetup.myRecollectSurfaceInfoOnSurfaceCheckFailed;
            outCollisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail = characterColliderSetup.myCeilingSetup.myRecollectSurfaceInfoOnSurfaceCheckFailed;
            outCollisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill = characterColliderSetup.myGroundSetup.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
            outCollisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill = characterColliderSetup.myCeilingSetup.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
            outCollisionCheckParams.myMustStayBelowGroundAngleDownhill = characterColliderSetup.myGroundSetup.myMovementMustStayOnSurfaceAngleDownhill;
            outCollisionCheckParams.myMustStayBelowCeilingAngleDownhill = characterColliderSetup.myCeilingSetup.myMovementMustStayOnSurfaceAngleDownhill;
            outCollisionCheckParams.myMovementMustStayOnGroundHitAngle = characterColliderSetup.myGroundSetup.myMovementMustStayOnSurfaceHitMaxAngle;
            outCollisionCheckParams.myMovementMustStayOnCeilingHitAngle = characterColliderSetup.myCeilingSetup.myMovementMustStayOnSurfaceHitMaxAngle;
            outCollisionCheckParams.myTeleportMustBeOnIgnorableGroundAngle = characterColliderSetup.myGroundSetup.myTeleportMustBeOnIgnorableSurfaceAngle;
            outCollisionCheckParams.myCheckTransformMustBeOnIgnorableGroundAngle = characterColliderSetup.myGroundSetup.myCheckTransformMustBeOnIgnorableSurfaceAngle;
            outCollisionCheckParams.myTeleportMustBeOnIgnorableCeilingAngle = characterColliderSetup.myCeilingSetup.myTeleportMustBeOnIgnorableSurfaceAngle;
            outCollisionCheckParams.myCheckTransformMustBeOnIgnorableCeilingAngle = characterColliderSetup.myCeilingSetup.myCheckTransformMustBeOnIgnorableSurfaceAngle;
            outCollisionCheckParams.myTeleportMustBeOnGroundAngle = characterColliderSetup.myGroundSetup.myTeleportMustBeOnSurfaceAngle;
            outCollisionCheckParams.myCheckTransformMustBeOnGroundAngle = characterColliderSetup.myGroundSetup.myCheckTransformMustBeOnSurfaceAngle;
            outCollisionCheckParams.myTeleportMustBeOnCeilingAngle = characterColliderSetup.myCeilingSetup.myTeleportMustBeOnSurfaceAngle;
            outCollisionCheckParams.myCheckTransformMustBeOnCeilingAngle = characterColliderSetup.myCeilingSetup.myCheckTransformMustBeOnSurfaceAngle;
            outCollisionCheckParams.myTeleportMustBeOnGround = characterColliderSetup.myGroundSetup.myTeleportMustBeOnSurface;
            outCollisionCheckParams.myCheckTransformMustBeOnGround = characterColliderSetup.myGroundSetup.myCheckTransformMustBeOnSurface;
            outCollisionCheckParams.myTeleportMustBeOnCeiling = characterColliderSetup.myCeilingSetup.myTeleportMustBeOnSurface;
            outCollisionCheckParams.myCheckTransformMustBeOnCeiling = characterColliderSetup.myCeilingSetup.myCheckTransformMustBeOnSurface;
            outCollisionCheckParams.mySlidingEnabled = characterColliderSetup.myWallSlideSetup.myWallSlideEnabled;
            outCollisionCheckParams.mySlidingHorizontalMovementCheckBetterNormal = characterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckGetBetterReferenceHit;
            outCollisionCheckParams.mySlidingMaxAttempts = characterColliderSetup.myWallSlideSetup.myWallSlideMaxAttempts;
            outCollisionCheckParams.mySlidingCheckBothDirections = characterColliderSetup.myWallSlideSetup.myCheckBothWallSlideDirections;
            outCollisionCheckParams.mySlidingFlickeringPreventionType = characterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionMode;
            outCollisionCheckParams.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = characterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding;
            outCollisionCheckParams.mySlidingFlickerPreventionCheckAnywayCounter = characterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionForceCheckCounter;
            outCollisionCheckParams.mySlidingAdjustSign90Degrees = characterColliderSetup.myWallSlideSetup.my90DegreesWallSlideAdjustDirectionSign;
            outCollisionCheckParams.mySplitMovementEnabled = characterColliderSetup.mySplitMovementSetup.mySplitMovementEnabled;
            outCollisionCheckParams.mySplitMovementMaxLength = characterColliderSetup.mySplitMovementSetup.mySplitMovementMaxStepLength;
            outCollisionCheckParams.mySplitMovementMaxStepsEnabled = characterColliderSetup.mySplitMovementSetup.mySplitMovementMaxSteps != null;
            outCollisionCheckParams.mySplitMovementMaxSteps = characterColliderSetup.mySplitMovementSetup.mySplitMovementMaxSteps;
            outCollisionCheckParams.mySplitMovementStepEqualLength = characterColliderSetup.mySplitMovementSetup.mySplitMovementMaxStepLength == null;
            outCollisionCheckParams.mySplitMovementStepEqualLengthMinLength = characterColliderSetup.mySplitMovementSetup.mySplitMovementMinStepLength;
            outCollisionCheckParams.mySplitMovementStopWhenHorizontalMovementCanceled = characterColliderSetup.mySplitMovementSetup.mySplitMovementStopOnHorizontalMovementFailed;
            outCollisionCheckParams.mySplitMovementStopWhenVerticalMovementCanceled = characterColliderSetup.mySplitMovementSetup.mySplitMovementStopOnVerticalMovementFailed;
            outCollisionCheckParams.mySplitMovementStopCallback = characterColliderSetup.mySplitMovementSetup.mySplitMovementStopOnCallback;
            outCollisionCheckParams.mySplitMovementStopReturnPrevious = characterColliderSetup.mySplitMovementSetup.mySplitMovementStopReturnPreviousResults;
            outCollisionCheckParams.myPositionOffsetLocal.vec3_copy(characterColliderSetup.myAdditionalSetup.myPositionOffsetLocal);
            outCollisionCheckParams.myRotationOffsetLocalQuat.quat_copy(characterColliderSetup.myAdditionalSetup.myRotationOffsetLocalQuat);
            outCollisionCheckParams.myDebugActive = characterColliderSetup.myDebugSetup.myVisualDebugActive;
            outCollisionCheckParams.myDebugHorizontalMovementActive = characterColliderSetup.myDebugSetup.myVisualDebugHorizontalMovementCheckActive;
            outCollisionCheckParams.myDebugHorizontalPositionActive = characterColliderSetup.myDebugSetup.myVisualDebugHorizontalPositionCheckActive;
            outCollisionCheckParams.myDebugVerticalMovementActive = characterColliderSetup.myDebugSetup.myVisualDebugVerticalMovementCheckActive;
            outCollisionCheckParams.myDebugVerticalPositionActive = characterColliderSetup.myDebugSetup.myVisualDebugVerticalPositionCheckActive;
            outCollisionCheckParams.myDebugSlidingActive = characterColliderSetup.myDebugSetup.myVisualDebugSlideActive;
            outCollisionCheckParams.myDebugGroundInfoActive = characterColliderSetup.myDebugSetup.myVisualDebugGroundInfoActive;
            outCollisionCheckParams.myDebugCeilingInfoActive = characterColliderSetup.myDebugSetup.myVisualDebugGroundInfoActive;
            outCollisionCheckParams.myDebugRuntimeParamsActive = characterColliderSetup.myDebugSetup.myVisualDebugResultsActive;
            outCollisionCheckParams.myDebugMovementActive = characterColliderSetup.myDebugSetup.myVisualDebugMovementActive;
            return outCollisionCheckParams;
          };
        }()
      };
    }
  });

  // js/pp/gameplay/character_controller/collision/character_collider_setup.js
  var require_character_collider_setup = __commonJS({
    "js/pp/gameplay/character_controller/collision/character_collider_setup.js"() {
      PP.CharacterColliderSetup = class CharacterColliderSetup {
        constructor() {
          this.myHeight = 0;
          this.myHorizontalCheckSetup = new PP.CharacterColliderHorizontalCheckSetup();
          this.myVerticalCheckSetup = new PP.CharacterColliderVerticalCheckSetup();
          this.myWallSlideSetup = new PP.CharacterColliderWallSlideSetup();
          this.myGroundSetup = new PP.CharacterColliderSurfaceSetup();
          this.myCeilingSetup = new PP.CharacterColliderSurfaceSetup();
          this.mySplitMovementSetup = new PP.CharacterColliderSplitMovementSetup();
          this.myAdditionalSetup = new PP.CharacterColliderAdditionalSetup();
          this.myDebugSetup = new PP.CharacterColliderDebugSetup();
        }
        copy(other) {
        }
      };
      PP.CharacterColliderHorizontalPositionVerticalCheckDirection = {
        UPWARD: 0,
        // gives less issues with a ground based movement, but may also collide a bit more, resulting in less sliding
        DOWNWARD: 1,
        // gives less issues with a ceiling based movement (unusual), but may also collide a bit more, resulting in less sliding and more stuck in front of a wall
        BOTH: 2
        // check both directions, more expensive (2x checks) and better prevent collisions, sliding more, but is more expensive and gives more issues           
        //                                                                                                                                                  _
        // the issues means that a small step at the end of a slope, maybe due to 2 rectangles, one for the floor and the other for the slope like this -> /   
        // can create a small step if the floor rectangle is a bit above the end of the slope, this will make the character get stuck thinking it's a wall
        // BOTH do a more "aggressive" vertical check that makes the character get less stuck in other situations, but can get stuck in this one
        // the better solution is to properly create the level, and if possible combine the 2 rectangles by having the floor a little below the end of the slope (like this -> /-)
        // the step that is created "on the other side" in fact can easily be ignored thanks to the myHorizontalCheckFeetDistanceToIgnore param
        // if the level is properly created the best solution should be UPWARD
        // and also myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = false
      };
      PP.CharacterColliderHorizontalCheckSetup = class CharacterColliderHorizontalCheckSetup {
        constructor() {
          this.myHorizontalCheckConeRadius = 0;
          this.myHorizontalCheckConeHalfAngle = 0;
          this.myHorizontalHeightCheckEnabled = false;
          this.myHorizontalCheckFeetDistanceToIgnore = 0;
          this.myHorizontalCheckHeadDistanceToIgnore = 0;
          this.myHorizontalCheckFixedForwardEnabled = false;
          this.myHorizontalCheckFixedForward = PP.vec3_create();
          this.myHorizontalMovementCheckEnabled = false;
          this.myHorizontalMovementCheckRadialSteps = 0;
          this.myHorizontalMovementCheckSplitMovementEnabled = false;
          this.myHorizontalMovementCheckSplitMovementMaxSteps = null;
          this.myHorizontalMovementCheckSplitMovementMaxStepLength = null;
          this.myHorizontalMovementCheckSplitMovementMinStepLength = null;
          this.myHorizontalMovementCheckGetBetterReferenceHit = false;
          this.myHorizontalMovementHorizontalRadialCheckEnabled = false;
          this.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = false;
          this.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = false;
          this.myHorizontalMovementHorizontalStraightCheckEnabled = false;
          this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
          this.myHorizontalMovementHeightCheckSteps = 0;
          this.myHorizontalMovementHeightHorizontalCheckEnabled = false;
          this.myHorizontalMovementHeightVerticalCheckEnabled = false;
          this.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled = false;
          this.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled = false;
          this.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = false;
          this.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = false;
          this.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = false;
          this.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = false;
          this.myHorizontalMovementVerticalStraightCheckEnabled = false;
          this.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
          this.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = false;
          this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
          this.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = false;
          this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
          this.myHorizontalPositionCheckEnabled = false;
          this.myHorizontalPositionCheckConeHalfSlices = 0;
          this.myHorizontalPositionHorizontalBorderCheckEnabled = false;
          this.myHorizontalPositionHorizontalRadialCheckEnabled = false;
          this.myHorizontalPositionHeightCheckSteps = 0;
          this.myHorizontalPositionHeightHorizontalCheckEnabled = false;
          this.myHorizontalPositionHeightVerticalCheckEnabled = false;
          this.myHorizontalPositionVerticalStraightCheckEnabled = false;
          this.myHorizontalPositionVerticalStraightCentralCheckEnabled = false;
          this.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = false;
          this.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled = false;
          this.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = false;
          this.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled = false;
          this.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled = false;
          this.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled = false;
          this.myHorizontalPositionVerticalCheckGetFarthestHit = false;
          this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = false;
          this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = false;
          this.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = false;
          this.myHorizontalPositionVerticalCheckDirection = PP.CharacterColliderHorizontalPositionVerticalCheckDirection.UPWARD;
          this.myHorizontalCheckBlockLayerFlags = new PP.PhysicsLayerFlags();
          this.myHorizontalCheckObjectsToIgnore = [];
        }
        copy(other) {
        }
      };
      PP.CharacterColliderVerticalCheckSetup = class CharacterColliderVerticalCheckSetup {
        constructor() {
          this.myVerticalCheckCircumferenceRadius = 0;
          this.myVerticalCheckCircumferenceSlices = 0;
          this.myVerticalCheckCircumferenceCentralCheckEnabled = false;
          this.myVerticalCheckCircumferenceRadialSteps = 0;
          this.myVerticalCheckCircumferenceRotationPerRadialStep = 0;
          this.myVerticalCheckFixedForwardEnabled = false;
          this.myVerticalCheckFixedForward = PP.vec3_create();
          this.myVerticalMovementCheckEnabled = false;
          this.myVerticalMovementCheckReductionEnabled = false;
          this.myVerticalMovementCheckPerformCheckOnBothSides = false;
          this.myVerticalPositionCheckEnabled = false;
          this.myVerticalCheckAllowHitsInsideCollisionIfOneValid = false;
          this.myVerticalCheckBlockLayerFlags = new PP.PhysicsLayerFlags();
          this.myVerticalCheckObjectsToIgnore = [];
        }
        copy(other) {
        }
      };
      PP.CharacterColliderSlideFlickerPreventionMode = {
        NONE: 0,
        USE_PREVIOUS_RESULTS: 1,
        // allow some flicker before stabilizing but avoid stopping for a 1 frame flicker only (false positive), is also less expensive
        COLLISION_ANGLE_ABOVE_90_DEGREES: 2,
        // prevents most flicker apart those on almost flat surface, can have some false positive, always check when sliding into opposite direction
        COLLISION_ANGLE_ABOVE_90_DEGREES_OR_MOVEMENT_ANGLE_ABOVE_85_DEGREES: 3,
        // less flicker than COLLISION_ANGLE_ABOVE_90_DEGREES but more false positive, always check when sliding into opposite direction
        ALWAYS: 4
        // less flicker than COLLISION_ANGLE_ABOVE_90_DEGREES_OR_MOVEMENT_ANGLE_ABOVE_85_DEGREES but more false positive
      };
      PP.CharacterColliderWallSlideSetup = class CharacterColliderWallSlideSetup {
        constructor() {
          this.myWallSlideEnabled = false;
          this.myWallSlideMaxAttempts = 0;
          this.myCheckBothWallSlideDirections = false;
          this.myWallSlideFlickerPreventionMode = PP.CharacterColliderSlideFlickerPreventionMode.NONE;
          this.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = false;
          this.myWallSlideFlickerPreventionForceCheckCounter = 0;
          this.my90DegreesWallSlideAdjustDirectionSign = false;
        }
        copy(other) {
        }
      };
      PP.CharacterColliderSurfaceSetup = class CharacterColliderSurfaceSetup {
        constructor() {
          this.mySurfaceSnapEnabled = false;
          this.mySurfaceSnapMaxDistance = 0;
          this.mySurfacePopOutEnabled = false;
          this.mySurfacePopOutMaxDistance = 0;
          this.mySurfaceAngleToIgnore = 0;
          this.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle = null;
          this.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance = null;
          this.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance = null;
          this.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = null;
          this.myCollectSurfaceInfo = false;
          this.myIsOnSurfaceMaxOutsideDistance = 0;
          this.myIsOnSurfaceMaxInsideDistance = 0;
          this.myIsBaseInsideCollisionCheckEnabled = false;
          this.myIsOnSurfaceIfBaseInsideCollision = false;
          this.myCollectSurfaceNormalMaxOutsideDistance = 0;
          this.myCollectSurfaceNormalMaxInsideDistance = 0;
          this.myFindSurfaceDistanceMaxOutsideDistance = 0;
          this.myFindSurfaceDistanceMaxInsideDistance = 0;
          this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhill = false;
          this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphill = false;
          this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfaceAngle = null;
          this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfaceAngle = null;
          this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle = null;
          this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle = null;
          this.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhill = false;
          this.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhillMinSurfaceAngle = null;
          this.myMovementMustStayOnSurface = false;
          this.myMovementMustStayOnSurfaceHitMaxAngle = null;
          this.myMovementMustStayOnIgnorableSurfaceAngleDownhill = false;
          this.myMovementMustStayOnSurfaceAngleDownhill = null;
          this.myTeleportMustBeOnSurface = false;
          this.myTeleportMustBeOnIgnorableSurfaceAngle = false;
          this.myTeleportMustBeOnSurfaceAngle = null;
          this.myCheckTransformMustBeOnSurface = false;
          this.myCheckTransformMustBeOnIgnorableSurfaceAngle = false;
          this.myCheckTransformMustBeOnSurfaceAngle = null;
          this.myRecollectSurfaceInfoOnSurfaceCheckFailed = false;
          this.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle = false;
        }
        copy(other) {
        }
      };
      PP.CharacterColliderSplitMovementSetup = class CharacterColliderSplitMovementSetup {
        constructor() {
          this.mySplitMovementEnabled = false;
          this.mySplitMovementMaxSteps = null;
          this.mySplitMovementMaxStepLength = null;
          this.mySplitMovementMinStepLength = null;
          this.mySplitMovementStopOnHorizontalMovementFailed = false;
          this.mySplitMovementStopOnVerticalMovementFailed = false;
          this.mySplitMovementStopReturnPreviousResults = false;
        }
        copy(other) {
        }
      };
      PP.CharacterColliderAdditionalSetup = class CharacterColliderAdditionalSetup {
        constructor() {
          this.myPositionOffsetLocal = PP.vec3_create();
          this.myRotationOffsetLocalQuat = PP.quat_create();
        }
        copy(other) {
        }
      };
      PP.CharacterColliderDebugSetup = class CharacterColliderDebugSetup {
        constructor() {
          this.myVisualDebugActive = false;
          this.myVisualDebugMovementActive = false;
          this.myVisualDebugHorizontalMovementCheckActive = false;
          this.myVisualDebugHorizontalPositionCheckActive = false;
          this.myVisualDebugVerticalMovementCheckActive = false;
          this.myVisualDebugVerticalPositionCheckActive = false;
          this.myVisualDebugSlideActive = false;
          this.myVisualDebugGroundInfoActive = false;
          this.myVisualDebugCeilingInfoActive = false;
          this.myVisualDebugResultsActive = false;
        }
        copy(other) {
        }
      };
      PP.CharacterColliderSetup.prototype.copy = function(other) {
        this.myHeight = other.myHeight;
        this.myHorizontalCheckSetup.copy(other.myHorizontalCheckSetup);
        this.myVerticalCheckSetup.copy(other.myVerticalCheckSetup);
        this.myWallSlideSetup.copy(other.myWallSlideSetup);
        this.myGroundSetup.copy(other.myGroundSetup);
        this.myCeilingSetup.copy(other.myCeilingSetup);
        this.mySplitMovementSetup.copy(other.mySplitMovementSetup);
        this.myAdditionalSetup.copy(other.myAdditionalSetup);
        this.myDebugSetup.copy(other.myDebugSetup);
      };
      PP.CharacterColliderHorizontalCheckSetup.prototype.copy = function(other) {
        this.myHorizontalCheckConeRadius = other.myHorizontalCheckConeRadius;
        this.myHorizontalCheckConeHalfAngle = other.myHorizontalCheckConeHalfAngle;
        this.myHorizontalHeightCheckEnabled = other.myHorizontalHeightCheckEnabled;
        this.myHorizontalCheckFeetDistanceToIgnore = other.myHorizontalCheckFeetDistanceToIgnore;
        this.myHorizontalCheckHeadDistanceToIgnore = other.myHorizontalCheckHeadDistanceToIgnore;
        this.myHorizontalCheckFixedForwardEnabled = other.myHorizontalCheckFixedForwardEnabled;
        this.myHorizontalCheckFixedForward.vec3_copy(other.myHorizontalCheckFixedForward);
        this.myHorizontalMovementCheckEnabled = other.myHorizontalMovementCheckEnabled;
        this.myHorizontalMovementCheckRadialSteps = other.myHorizontalMovementCheckRadialSteps;
        this.myHorizontalMovementCheckSplitMovementEnabled = other.myHorizontalMovementCheckSplitMovementEnabled;
        this.myHorizontalMovementCheckSplitMovementMaxSteps = other.myHorizontalMovementCheckSplitMovementMaxSteps;
        this.myHorizontalMovementCheckSplitMovementMaxStepLength = other.myHorizontalMovementCheckSplitMovementMaxStepLength;
        this.myHorizontalMovementCheckSplitMovementMinStepLength = other.myHorizontalMovementCheckSplitMovementMinStepLength;
        this.myHorizontalMovementCheckGetBetterReferenceHit = other.myHorizontalMovementCheckGetBetterReferenceHit;
        this.myHorizontalMovementHorizontalRadialCheckEnabled = other.myHorizontalMovementHorizontalRadialCheckEnabled;
        this.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = other.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled;
        this.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = other.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled;
        this.myHorizontalMovementHorizontalStraightCheckEnabled = other.myHorizontalMovementHorizontalStraightCheckEnabled;
        this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = other.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
        this.myHorizontalMovementHeightCheckSteps = other.myHorizontalMovementHeightCheckSteps;
        this.myHorizontalMovementHeightVerticalCheckEnabled = other.myHorizontalMovementHeightVerticalCheckEnabled;
        this.myHorizontalMovementHeightHorizontalCheckEnabled = other.myHorizontalMovementHeightHorizontalCheckEnabled;
        this.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled = other.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled;
        this.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled = other.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled;
        this.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled;
        this.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled;
        this.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled;
        this.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled;
        this.myHorizontalMovementVerticalStraightCheckEnabled = other.myHorizontalMovementVerticalStraightCheckEnabled;
        this.myHorizontalMovementVerticalStraightCentralCheckEnabled = other.myHorizontalMovementVerticalStraightCentralCheckEnabled;
        this.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled;
        this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
        this.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled;
        this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
        this.myHorizontalPositionCheckEnabled = other.myHorizontalPositionCheckEnabled;
        this.myHorizontalPositionCheckConeHalfSlices = other.myHorizontalPositionCheckConeHalfSlices;
        this.myHorizontalPositionHorizontalBorderCheckEnabled = other.myHorizontalPositionHorizontalBorderCheckEnabled;
        this.myHorizontalPositionHorizontalRadialCheckEnabled = other.myHorizontalPositionHorizontalRadialCheckEnabled;
        this.myHorizontalPositionHeightCheckSteps = other.myHorizontalPositionHeightCheckSteps;
        this.myHorizontalPositionHeightHorizontalCheckEnabled = other.myHorizontalPositionHeightHorizontalCheckEnabled;
        this.myHorizontalPositionHeightVerticalCheckEnabled = other.myHorizontalPositionHeightVerticalCheckEnabled;
        this.myHorizontalPositionVerticalStraightCheckEnabled = other.myHorizontalPositionVerticalStraightCheckEnabled;
        this.myHorizontalPositionVerticalStraightCentralCheckEnabled = other.myHorizontalPositionVerticalStraightCentralCheckEnabled;
        this.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled;
        this.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled;
        this.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled;
        this.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled;
        this.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled;
        this.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled;
        this.myHorizontalPositionVerticalCheckGetFarthestHit = other.myHorizontalPositionVerticalCheckGetFarthestHit;
        this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = other.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit;
        this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = other.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit;
        this.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = other.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision;
        this.myHorizontalPositionVerticalCheckDirection = other.myHorizontalPositionVerticalCheckDirection;
        this.myHorizontalCheckBlockLayerFlags.setMask(other.myHorizontalCheckBlockLayerFlags.getMask());
        this.myHorizontalCheckObjectsToIgnore.pp_copy(other.myHorizontalCheckObjectsToIgnore);
      };
      PP.CharacterColliderVerticalCheckSetup.prototype.copy = function(other) {
        this.myVerticalCheckCircumferenceRadius = other.myVerticalCheckCircumferenceRadius;
        this.myVerticalCheckCircumferenceSlices = other.myVerticalCheckCircumferenceSlices;
        this.myVerticalCheckCircumferenceCentralCheckEnabled = other.myVerticalCheckCircumferenceCentralCheckEnabled;
        this.myVerticalCheckCircumferenceRadialSteps = other.myVerticalCheckCircumferenceRadialSteps;
        this.myVerticalCheckCircumferenceRotationPerRadialStep = other.myVerticalCheckCircumferenceRotationPerRadialStep;
        this.myVerticalCheckFixedForwardEnabled = other.myVerticalCheckFixedForwardEnabled;
        this.myVerticalCheckFixedForward.vec3_copy(other.myVerticalCheckFixedForward);
        this.myVerticalMovementCheckEnabled = other.myVerticalMovementCheckEnabled;
        this.myVerticalMovementCheckReductionEnabled = other.myVerticalMovementCheckReductionEnabled;
        this.myVerticalMovementCheckPerformCheckOnBothSides = other.myVerticalMovementCheckPerformCheckOnBothSides;
        this.myVerticalPositionCheckEnabled = other.myVerticalPositionCheckEnabled;
        this.myVerticalCheckAllowHitsInsideCollisionIfOneValid = other.myVerticalCheckAllowHitsInsideCollisionIfOneValid;
        this.myVerticalCheckBlockLayerFlags.setMask(other.myVerticalCheckBlockLayerFlags.getMask());
        this.myVerticalCheckObjectsToIgnore.pp_copy(other.myVerticalCheckObjectsToIgnore);
      };
      PP.CharacterColliderWallSlideSetup.prototype.copy = function(other) {
        this.myWallSlideEnabled = other.myWallSlideEnabled;
        this.myWallSlideMaxAttempts = other.myWallSlideMaxAttempts;
        this.myCheckBothWallSlideDirections = other.myCheckBothWallSlideDirections;
        this.myWallSlideFlickerPreventionMode = other.myWallSlideFlickerPreventionMode;
        this.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = other.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding;
        this.myWallSlideFlickerPreventionForceCheckCounter = other.myWallSlideFlickerPreventionForceCheckCounter;
        this.my90DegreesWallSlideAdjustDirectionSign = other.my90DegreesWallSlideAdjustDirectionSign;
      };
      PP.CharacterColliderSurfaceSetup.prototype.copy = function(other) {
        this.mySurfaceSnapEnabled = other.mySurfaceSnapEnabled;
        this.mySurfaceSnapMaxDistance = other.mySurfaceSnapMaxDistance;
        this.mySurfacePopOutEnabled = other.mySurfacePopOutEnabled;
        this.mySurfacePopOutMaxDistance = other.mySurfacePopOutMaxDistance;
        this.mySurfaceAngleToIgnore = other.mySurfaceAngleToIgnore;
        this.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle = other.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
        this.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance = other.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
        this.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance = other.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
        this.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = other.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
        this.myCollectSurfaceInfo = other.myCollectSurfaceInfo;
        this.myIsOnSurfaceMaxOutsideDistance = other.myIsOnSurfaceMaxOutsideDistance;
        this.myIsOnSurfaceMaxInsideDistance = other.myIsOnSurfaceMaxInsideDistance;
        this.myIsBaseInsideCollisionCheckEnabled = other.myIsBaseInsideCollisionCheckEnabled;
        this.myIsOnSurfaceIfBaseInsideCollision = other.myIsOnSurfaceIfBaseInsideCollision;
        this.myCollectSurfaceNormalMaxOutsideDistance = other.myCollectSurfaceNormalMaxOutsideDistance;
        this.myCollectSurfaceNormalMaxInsideDistance = other.myCollectSurfaceNormalMaxInsideDistance;
        this.myFindSurfaceDistanceMaxOutsideDistance = other.myFindSurfaceDistanceMaxOutsideDistance;
        this.myFindSurfaceDistanceMaxInsideDistance = other.myFindSurfaceDistanceMaxInsideDistance;
        this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhill = other.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
        this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphill = other.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphill;
        this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfaceAngle = other.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfaceAngle;
        this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfaceAngle = other.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfaceAngle;
        this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle = other.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
        this.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle = other.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
        this.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhill = other.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhill;
        this.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhillMinSurfaceAngle = other.myVerticalMovementAdjustHorizontalMovementBasedOnSurfaceAngleDownhillMinSurfaceAngle;
        this.myMovementMustStayOnSurface = other.myMovementMustStayOnSurface;
        this.myMovementMustStayOnSurfaceHitMaxAngle = other.myMovementMustStayOnSurfaceHitMaxAngle;
        this.myMovementMustStayOnIgnorableSurfaceAngleDownhill = other.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
        this.myMovementMustStayOnSurfaceAngleDownhill = other.myMovementMustStayOnSurfaceAngleDownhill;
        this.myTeleportMustBeOnSurface = other.myTeleportMustBeOnSurface;
        this.myTeleportMustBeOnIgnorableSurfaceAngle = other.myTeleportMustBeOnIgnorableSurfaceAngle;
        this.myTeleportMustBeOnSurfaceAngle = other.myTeleportMustBeOnSurfaceAngle;
        this.myCheckTransformMustBeOnSurface = other.myCheckTransformMustBeOnSurface;
        this.myCheckTransformMustBeOnIgnorableSurfaceAngle = other.myCheckTransformMustBeOnIgnorableSurfaceAngle;
        this.myCheckTransformMustBeOnSurfaceAngle = other.myCheckTransformMustBeOnSurfaceAngle;
        this.myRecollectSurfaceInfoOnSurfaceCheckFailed = other.myRecollectSurfaceInfoOnSurfaceCheckFailed;
        this.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle = other.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
      };
      PP.CharacterColliderSplitMovementSetup.prototype.copy = function(other) {
        this.mySplitMovementEnabled = other.mySplitMovementEnabled;
        this.mySplitMovementMaxSteps = other.mySplitMovementMaxSteps;
        this.mySplitMovementMaxStepLength = other.mySplitMovementMaxStepLength;
        this.mySplitMovementMinStepLength = other.mySplitMovementMinStepLength;
        this.mySplitMovementStopOnHorizontalMovementFailed = other.mySplitMovementStopOnHorizontalMovementFailed;
        this.mySplitMovementStopOnVerticalMovementFailed = other.mySplitMovementStopOnVerticalMovementFailed;
        this.mySplitMovementStopReturnPreviousResults = other.mySplitMovementStopReturnPreviousResults;
      };
      PP.CharacterColliderAdditionalSetup.prototype.copy = function(other) {
        this.myPositionOffsetLocal.vec3_copy(other.myPositionOffsetLocal);
        this.myRotationOffsetLocalQuat.quat_copy(other.myRotationOffsetLocalQuat);
      };
      PP.CharacterColliderDebugSetup.prototype.copy = function(other) {
        this.myVisualDebugActive = other.myVisualDebugActive;
        this.myVisualDebugMovementActive = other.myVisualDebugMovementActive;
        this.myVisualDebugHorizontalMovementCheckActive = other.myVisualDebugHorizontalMovementCheckActive;
        this.myVisualDebugHorizontalPositionCheckActive = other.myVisualDebugHorizontalPositionCheckActive;
        this.myVisualDebugVerticalMovementCheckActive = other.myVisualDebugVerticalMovementCheckActive;
        this.myVisualDebugVerticalPositionCheckActive = other.myVisualDebugVerticalPositionCheckActive;
        this.myVisualDebugSlideActive = other.myVisualDebugSlideActive;
        this.myVisualDebugGroundInfoActive = other.myVisualDebugGroundInfoActive;
        this.myVisualDebugCeilingInfoActive = other.myVisualDebugCeilingInfoActive;
        this.myVisualDebugResultsActive = other.myVisualDebugResultsActive;
      };
      Object.defineProperty(PP.CharacterColliderSetup.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterColliderHorizontalCheckSetup.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterColliderVerticalCheckSetup.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterColliderWallSlideSetup.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterColliderSurfaceSetup.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterColliderSplitMovementSetup.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterColliderAdditionalSetup.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterColliderDebugSetup.prototype, "copy", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/character_collider_utils.js
  var require_character_collider_utils = __commonJS({
    "js/pp/gameplay/character_controller/collision/character_collider_utils.js"() {
      PP.CharacterColliderSetupSimplifiedCreationAccuracyLevel = {
        VERY_LOW: 0,
        LOW: 1,
        MEDIUM: 2,
        HIGH: 3,
        VERY_HIGH: 4
      };
      PP.CharacterColliderSetupSimplifiedCreationParams = class CharacterColliderSetupSimplifiedCreationParams {
        constructor() {
          this.myHeight = 0;
          this.myRadius = 0;
          this.myAccuracyLevel = PP.CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_LOW;
          this.myIsPlayer = false;
          this.myCheckOnlyFeet = false;
          this.myAverageSpeed = 0;
          this.myCanFly = false;
          this.myShouldSlideAgainstWall = false;
          this.myCollectGroundInfo = false;
          this.myShouldSnapOnGround = false;
          this.myMaxDistanceToSnapOnGround = 0;
          this.myMaxWalkableGroundAngle = 0;
          this.myMaxWalkableGroundStepHeight = 0;
          this.myShouldNotFallFromEdges = false;
          this.myHorizontalCheckBlockLayerFlags = new PP.PhysicsLayerFlags();
          this.myHorizontalCheckObjectsToIgnore = [];
          this.myVerticalCheckBlockLayerFlags = new PP.PhysicsLayerFlags();
          this.myVerticalCheckObjectsToIgnore = [];
          this.myHorizontalCheckDebugActive = false;
          this.myVerticalCheckDebugActive = false;
        }
      };
      PP.CharacterColliderUtils = {
        createCharacterColliderSetupSimplified: function(simplifiedCreationParams, outCharacterColliderSetup = new PP.CharacterColliderSetup()) {
        },
        createTeleportColliderFromMovementCollider: function(movementColliderSetup, outTeleportColliderSetup = new PP.CharacterColliderSetup()) {
          outTeleportColliderSetup.copy(movementColliderSetup);
          outTeleportColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeHalfAngle = 180;
          outTeleportColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckConeHalfSlices = Math.round(outTeleportColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeHalfAngle / movementColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeHalfAngle * movementColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckConeHalfSlices);
          outTeleportColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFixedForwardEnabled = true;
          outTeleportColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFixedForward.vec3_set(0, 0, 1);
          return outTeleportColliderSetup;
        }
      };
      PP.CharacterColliderUtils.createCharacterColliderSetupSimplified = function(simplifiedCreationParams, outCharacterColliderSetup = new PP.CharacterColliderSetup()) {
        outCharacterColliderSetup.myHeight = simplifiedCreationParams.myHeight;
        outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeRadius = simplifiedCreationParams.myRadius;
        outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadius = simplifiedCreationParams.myRadius / 2;
        outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckFixedForwardEnabled = true;
        outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckFixedForward.vec3_set(0, 0, 1);
        if (!simplifiedCreationParams.myCheckOnlyFeet || simplifiedCreationParams.myCanFly) {
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalHeightCheckEnabled = true;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalPositionCheckEnabled = true;
        }
        outCharacterColliderSetup.myWallSlideSetup.myWallSlideEnabled = simplifiedCreationParams.myShouldSlideAgainstWall;
        outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFeetDistanceToIgnore = simplifiedCreationParams.myMaxWalkableGroundStepHeight;
        outCharacterColliderSetup.myGroundSetup.mySurfaceSnapMaxDistance = simplifiedCreationParams.myMaxDistanceToSnapOnGround;
        outCharacterColliderSetup.myGroundSetup.mySurfacePopOutMaxDistance = simplifiedCreationParams.myMaxDistanceToSnapOnGround > 0 ? simplifiedCreationParams.myMaxDistanceToSnapOnGround : simplifiedCreationParams.myRadius > 0.1 ? 0.1 : 0.01;
        outCharacterColliderSetup.myGroundSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = simplifiedCreationParams.myRadius;
        outCharacterColliderSetup.myGroundSetup.myCollectSurfaceInfo = simplifiedCreationParams.myCollectGroundInfo || simplifiedCreationParams.myMaxWalkableGroundAngle > 0;
        outCharacterColliderSetup.myGroundSetup.mySurfaceSnapEnabled = simplifiedCreationParams.myShouldSnapOnGround;
        outCharacterColliderSetup.myGroundSetup.mySurfacePopOutEnabled = true;
        outCharacterColliderSetup.myGroundSetup.mySurfaceAngleToIgnore = simplifiedCreationParams.myMaxWalkableGroundAngle;
        outCharacterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngle = true;
        outCharacterColliderSetup.myGroundSetup.myIsOnSurfaceMaxOutsideDistance = 1e-3;
        outCharacterColliderSetup.myGroundSetup.myIsOnSurfaceMaxInsideDistance = 1e-3;
        outCharacterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxOutsideDistance = simplifiedCreationParams.myRadius > 0.1 ? 0.1 : 0.01;
        outCharacterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxInsideDistance = outCharacterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxOutsideDistance;
        if (simplifiedCreationParams.myCanFly) {
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckHeadDistanceToIgnore = outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckFeetDistanceToIgnore;
          outCharacterColliderSetup.myCeilingSetup.myCollectSurfaceInfo = outCharacterColliderSetup.myGroundSetup.myCollectSurfaceInfo;
          outCharacterColliderSetup.myCeilingSetup.mySurfacePopOutEnabled = outCharacterColliderSetup.myGroundSetup.mySurfacePopOutEnabled;
          outCharacterColliderSetup.myCeilingSetup.mySurfaceAngleToIgnore = outCharacterColliderSetup.myGroundSetup.mySurfaceAngleToIgnore;
          outCharacterColliderSetup.myCeilingSetup.mySurfaceSnapMaxDistance = outCharacterColliderSetup.myGroundSetup.mySurfaceSnapMaxDistance;
          outCharacterColliderSetup.myCeilingSetup.mySurfacePopOutMaxDistance = outCharacterColliderSetup.myGroundSetup.mySurfacePopOutMaxDistance;
          outCharacterColliderSetup.myCeilingSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = outCharacterColliderSetup.myGroundSetup.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
          outCharacterColliderSetup.myCeilingSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngle = outCharacterColliderSetup.myGroundSetup.myHorizontalMovementAdjustVerticalMovementBasedOnSurfacePerceivedAngle;
          outCharacterColliderSetup.myCeilingSetup.myIsOnSurfaceMaxOutsideDistance = outCharacterColliderSetup.myGroundSetup.myIsOnSurfaceMaxOutsideDistance;
          outCharacterColliderSetup.myCeilingSetup.myIsOnSurfaceMaxInsideDistance = outCharacterColliderSetup.myGroundSetup.myIsOnSurfaceMaxInsideDistance;
          outCharacterColliderSetup.myCeilingSetup.myCollectSurfaceNormalMaxOutsideDistance = outCharacterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxOutsideDistance;
          outCharacterColliderSetup.myCeilingSetup.myCollectSurfaceNormalMaxInsideDistance = outCharacterColliderSetup.myGroundSetup.myCollectSurfaceNormalMaxInsideDistance;
        }
        if (simplifiedCreationParams.myShouldNotFallFromEdges) {
          outCharacterColliderSetup.myGroundSetup.myMovementMustStayOnSurface = true;
          outCharacterColliderSetup.myGroundSetup.myMovementMustStayOnSurfaceAngleDownhill = Math.max(60, outCharacterColliderSetup.myGroundSetup.mySurfaceAngleToIgnore);
        }
        outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckBlockLayerFlags.copy(simplifiedCreationParams.myHorizontalCheckBlockLayerFlags);
        outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckObjectsToIgnore.pp_copy(simplifiedCreationParams.myHorizontalCheckObjectsToIgnore);
        outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckBlockLayerFlags.copy(simplifiedCreationParams.myVerticalCheckBlockLayerFlags);
        outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckObjectsToIgnore.pp_copy(simplifiedCreationParams.myVerticalCheckObjectsToIgnore);
        if (simplifiedCreationParams.myHorizontalCheckDebugActive) {
          outCharacterColliderSetup.myDebugSetup.myVisualDebugActive = true;
          outCharacterColliderSetup.myDebugSetup.myVisualDebugHorizontalMovementCheckActive = true;
          outCharacterColliderSetup.myDebugSetup.myVisualDebugHorizontalPositionCheckActive = true;
        }
        if (simplifiedCreationParams.myVerticalCheckDebugActive) {
          outCharacterColliderSetup.myDebugSetup.myVisualDebugActive = true;
          outCharacterColliderSetup.myDebugSetup.myVisualDebugVerticalMovementCheckActive = true;
          outCharacterColliderSetup.myDebugSetup.myVisualDebugVerticalPositionCheckActive = true;
        }
        if (simplifiedCreationParams.myAccuracyLevel >= PP.CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_LOW) {
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalCheckConeHalfAngle = 60;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightVerticalCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightVerticalCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckEnabled = false;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckConeHalfSlices = 1;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightCheckSteps = 1;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHorizontalRadialCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalStraightCheckEnabled = true;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices = 4;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceCentralCheckEnabled = true;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadialSteps = 1;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckEnabled = true;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckReductionEnabled = true;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalPositionCheckEnabled = true;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckAllowHitsInsideCollisionIfOneValid = true;
        }
        if (simplifiedCreationParams.myAccuracyLevel >= PP.CharacterColliderSetupSimplifiedCreationAccuracyLevel.LOW) {
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckRadialSteps = 1;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightCheckSteps = 1;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalStraightCentralCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = true;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadialSteps = 2;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices;
          outCharacterColliderSetup.myWallSlideSetup.myWallSlideMaxAttempts = 1;
          outCharacterColliderSetup.myWallSlideSetup.myCheckBothWallSlideDirections = false;
          outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionMode = PP.CharacterColliderSlideFlickerPreventionMode.NONE;
          outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = false;
          outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionForceCheckCounter = 0;
          outCharacterColliderSetup.myWallSlideSetup.my90DegreesWallSlideAdjustDirectionSign = false;
          outCharacterColliderSetup.myWallSlideSetup.myWallSlideMaxAttempts = 2;
        }
        if (simplifiedCreationParams.myAccuracyLevel >= PP.CharacterColliderSetupSimplifiedCreationAccuracyLevel.MEDIUM) {
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightHorizontalCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionCheckConeHalfSlices = 2;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightHorizontalCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHorizontalBorderCheckEnabled = true;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalMovementCheckPerformCheckOnBothSides = true;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices = 6;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadialSteps = 2;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices;
          outCharacterColliderSetup.myWallSlideSetup.myWallSlideMaxAttempts = 3;
          outCharacterColliderSetup.myWallSlideSetup.my90DegreesWallSlideAdjustDirectionSign = true;
          if (simplifiedCreationParams.myIsPlayer) {
            outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionMode = PP.CharacterColliderSlideFlickerPreventionMode.USE_PREVIOUS_RESULTS;
            outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = true;
            outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionForceCheckCounter = 4;
          }
        }
        if (simplifiedCreationParams.myAccuracyLevel >= PP.CharacterColliderSetupSimplifiedCreationAccuracyLevel.HIGH) {
          if (outCharacterColliderSetup.myWallSlideSetup.myWallSlideEnabled) {
            outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementCheckGetBetterReferenceHit = true;
            outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = true;
            outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = true;
          }
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalStraightCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices = 8;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRadialSteps = 2;
          outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices;
          outCharacterColliderSetup.myWallSlideSetup.myWallSlideMaxAttempts = 4;
          if (simplifiedCreationParams.myIsPlayer) {
            outCharacterColliderSetup.myWallSlideSetup.myCheckBothWallSlideDirections = true;
            outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionMode = PP.CharacterColliderSlideFlickerPreventionMode.USE_PREVIOUS_RESULTS;
            outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = true;
            outCharacterColliderSetup.myWallSlideSetup.myWallSlideFlickerPreventionForceCheckCounter = 4;
          }
          outCharacterColliderSetup.myGroundSetup.myIsBaseInsideCollisionCheckEnabled = true;
          outCharacterColliderSetup.myCeilingSetup.myIsBaseInsideCollisionCheckEnabled = true;
          let fps = 90;
          if (simplifiedCreationParams.myAverageSpeed / fps > simplifiedCreationParams.myRadius) {
            outCharacterColliderSetup.mySplitMovementSetup.mySplitMovementEnabled = true;
            outCharacterColliderSetup.mySplitMovementSetup.mySplitMovementMaxSteps = Math.ceil(simplifiedCreationParams.myAverageSpeed / fps / simplifiedCreationParams.myRadius);
            outCharacterColliderSetup.mySplitMovementSetup.mySplitMovementMinStepLength = simplifiedCreationParams.myRadius;
          }
        }
        if (simplifiedCreationParams.myAccuracyLevel >= PP.CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_HIGH) {
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHeightCheckSteps = 2;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementHorizontalRadialCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionHeightCheckSteps = 2;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = true;
          outCharacterColliderSetup.myHorizontalCheckSetup.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = true;
          outCharacterColliderSetup.myGroundSetup.myRecollectSurfaceInfoOnSurfaceCheckFailed = true;
          outCharacterColliderSetup.myCeilingSetup.myRecollectSurfaceInfoOnSurfaceCheckFailed = outCharacterColliderSetup.myGroundSetup.myRecollectSurfaceInfoOnSurfaceCheckFailed;
        }
        return outCharacterColliderSetup;
      };
    }
  });

  // js/pp/gameplay/character_controller/collision/character_collision_results.js
  var require_character_collision_results = __commonJS({
    "js/pp/gameplay/character_controller/collision/character_collision_results.js"() {
      PP.CharacterCollisionResults = class CharacterCollisionResults {
        constructor() {
          this.myCheckType = PP.CharacterCollisionCheckType.NONE;
          this.myTransformResults = new PP.CharacterCollisionTransformResults();
          this.myMovementResults = new PP.CharacterCollisionMovementResults();
          this.myHorizontalMovementResults = new PP.CharacterCollisionMovementResults();
          this.myVerticalMovementResults = new PP.CharacterCollisionMovementResults();
          this.myTeleportResults = new PP.CharacterCollisionTeleportResults();
          this.myCheckTransformResults = new PP.CharacterCollisionCheckTransformResults();
          this.myWallSlideResults = new PP.CharacterCollisionWallSlideResults();
          this.myGroundInfo = new PP.CharacterCollisionSurfaceInfo();
          this.myCeilingInfo = new PP.CharacterCollisionSurfaceInfo();
          this.myGroundResults = new PP.CharacterCollisionSurfaceResults();
          this.myCeilingResults = new PP.CharacterCollisionSurfaceResults();
          this.mySplitMovementResults = new PP.CharacterCollisionSplitMovementResults();
          this.myDebugResults = new PP.CharacterCollisionDebugResults();
          this.myInternalResults = new PP.CharacterCollisionInternalResults();
        }
        reset() {
        }
        copy(other) {
        }
      };
      PP.CharacterCollisionCheckType = {
        NONE: 0,
        CHECK_MOVEMENT: 1,
        CHECK_TELEPORT: 2,
        CHECK_TRANSFORM: 3,
        UPDATE_SURFACE_INFO: 4,
        UPDATE_GROUND_INFO: 5,
        UPDATE_CEILING_INFO: 6
      };
      PP.CharacterCollisionSurfaceInfo = class CharacterCollisionSurfaceInfo {
        constructor() {
          this.myIsOnSurface = false;
          this.mySurfaceAngle = 0;
          this.mySurfacePerceivedAngle = 0;
          this.mySurfaceNormal = PP.vec3_create();
          this.mySurfaceHitMaxAngle = 0;
          this.mySurfaceHitMaxNormal = PP.vec3_create();
          this.mySurfaceDistance = null;
          this.myIsBaseInsideCollision = false;
        }
        reset() {
        }
        copy(other) {
        }
      };
      PP.CharacterCollisionWallSlideResults = class CharacterCollisionWallSlideResults {
        constructor() {
          this.myHasSlid = false;
          this.mySlideMovementAngle = 0;
          this.mySlideMovementWallAngle = 0;
          this.myWallNormal = PP.vec3_create();
        }
        reset() {
        }
        copy(other) {
        }
      };
      PP.CharacterCollisionTransformResults = class CharacterCollisionMovementResults {
        constructor() {
          this.myStartTransformQuat = PP.quat2_create();
          this.myEndTransformQuat = PP.quat2_create();
        }
        reset() {
        }
        copy(other) {
        }
      };
      PP.CharacterCollisionMovementResults = class CharacterCollisionMovementResults {
        constructor() {
          this.myStartMovement = PP.vec3_create();
          this.myEndMovement = PP.vec3_create();
          this.myMovementFailed = false;
          this.myIsColliding = false;
          this.myReferenceCollisionHit = new PP.RaycastHit();
        }
        reset() {
        }
        copy(other) {
        }
      };
      PP.CharacterCollisionTeleportResults = class CharacterCollisionTeleportResults {
        constructor() {
          this.myStartTeleportTransformQuat = PP.quat2_create();
          this.myEndTeleportTransformQuat = PP.quat2_create();
          this.myTeleportFailed = false;
        }
        reset() {
        }
        copy(other) {
        }
      };
      PP.CharacterCollisionCheckTransformResults = class CharacterCollisionCheckTransformResults {
        constructor() {
          this.myStartCheckTransformQuat = PP.quat2_create();
          this.myEndCheckTransformQuat = PP.quat2_create();
          this.myCheckTransformFailed = false;
        }
        reset() {
        }
        copy(other) {
        }
      };
      PP.CharacterCollisionSurfaceResults = class CharacterCollisionCheckTransformResults {
        constructor() {
          this.myHasSnappedOnSurface = false;
          this.myHasPoppedOutSurface = false;
          this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill = false;
          this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill = false;
          this.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill = false;
        }
        reset() {
        }
        copy(other) {
        }
      };
      PP.CharacterCollisionSplitMovementResults = class CharacterCollisionSplitMovementResults {
        constructor() {
          this.myStepsToPerform = 0;
          this.myStepsPerformed = 0;
          this.myMovementInterrupted = false;
          this.myMovementChecked = PP.vec3_create();
        }
        reset() {
        }
        copy(other) {
        }
      };
      PP.CharacterCollisionDebugResults = class CharacterCollisionDebugResults {
        constructor() {
          this._myRaycastsPerformed = 0;
        }
        reset() {
        }
        copy(other) {
        }
      };
      PP.CharacterCollisionInternalResults = class CharacterCollisionSplitMovementResults {
        constructor() {
          this.myLastRelevantStartHorizontalMovement = PP.vec3_create();
          this.myLastRelevantAdjustedStartHorizontalMovement = PP.vec3_create();
          this.myLastRelevantEndHorizontalMovement = PP.vec3_create();
          this.myLastRelevantStartVerticalMovement = PP.vec3_create();
          this.myLastRelevantAdjustedStartVerticalMovement = PP.vec3_create();
          this.myLastRelevantEndVerticalMovement = PP.vec3_create();
          this.myLastRelevantHasWallSlid = false;
          this.myHasWallSlidTowardOppositeDirection = false;
          this.myLastRelevantWallSlideFlickerPrevented = false;
          this.myWallSlideFlickerPreventionForceCheckCounter = 0;
          this.myWallSlide90DegreesDirectionSign = 0;
          this.myWallSlide90DegreesRecomputeDirectionSign = true;
        }
        reset() {
        }
        copy(other) {
        }
      };
      PP.CharacterCollisionResults.prototype.reset = function() {
        this.myCheckType = PP.CharacterCollisionCheckType.NONE;
        this.myTransformResults.reset();
        this.myMovementResults.reset();
        this.myHorizontalMovementResults.reset();
        this.myVerticalMovementResults.reset();
        this.myTeleportResults.reset();
        this.myCheckTransformResults.reset();
        this.myWallSlideResults.reset();
        this.myGroundInfo.reset();
        this.myCeilingInfo.reset();
        this.myGroundResults.reset();
        this.myCeilingResults.reset();
        this.mySplitMovementResults.reset();
        this.myInternalResults.reset();
      };
      PP.CharacterCollisionResults.prototype.copy = function(other) {
        this.myCheckType = other.myCheckType;
        this.myTransformResults.copy(other.myTransformResults);
        this.myMovementResults.copy(other.myMovementResults);
        this.myHorizontalMovementResults.copy(other.myHorizontalMovementResults);
        this.myVerticalMovementResults.copy(other.myVerticalMovementResults);
        this.myTeleportResults.copy(other.myTeleportResults);
        this.myCheckTransformResults.copy(other.myCheckTransformResults);
        this.myWallSlideResults.copy(other.myWallSlideResults);
        this.myGroundInfo.copy(other.myGroundInfo);
        this.myCeilingInfo.copy(other.myCeilingInfo);
        this.myGroundResults.copy(other.myGroundResults);
        this.myCeilingResults.copy(other.myCeilingResults);
        this.mySplitMovementResults.copy(other.mySplitMovementResults);
        this.myInternalResults.copy(other.myInternalResults);
      };
      PP.CharacterCollisionSurfaceInfo.prototype.reset = function() {
        this.myIsOnSurface = false;
        this.mySurfaceAngle = 0;
        this.mySurfacePerceivedAngle = 0;
        this.mySurfaceNormal.vec3_zero();
        this.mySurfaceHitMaxAngle = 0;
        this.mySurfaceHitMaxNormal.vec3_zero();
        this.mySurfaceDistance = null;
        this.myIsBaseInsideCollision = false;
      };
      PP.CharacterCollisionSurfaceInfo.prototype.copy = function(other) {
        this.myIsOnSurface = other.myIsOnSurface;
        this.mySurfaceAngle = other.mySurfaceAngle;
        this.mySurfacePerceivedAngle = other.mySurfacePerceivedAngle;
        this.mySurfaceNormal.vec3_copy(other.mySurfaceNormal);
        this.mySurfaceHitMaxAngle = other.mySurfaceHitMaxAngle;
        this.mySurfaceHitMaxNormal.vec3_copy(other.mySurfaceHitMaxNormal);
        this.mySurfaceDistance = other.mySurfaceDistance;
        this.myIsBaseInsideCollision = other.myIsBaseInsideCollision;
      };
      PP.CharacterCollisionWallSlideResults.prototype.reset = function() {
        this.myHasSlid = false;
        this.mySlideMovementAngle = 0;
        this.mySlideMovementWallAngle = 0;
        this.myWallNormal.vec3_zero();
      };
      PP.CharacterCollisionWallSlideResults.prototype.copy = function(other) {
        this.myHasSlid = other.myHasSlid;
        this.mySlideMovementAngle = other.mySlideMovementAngle;
        this.mySlideMovementWallAngle = other.mySlideMovementWallAngle;
        this.myWallNormal.vec3_copy(other.myWallNormal);
      };
      PP.CharacterCollisionTransformResults.prototype.reset = function() {
        this.myStartTransformQuat.quat2_identity();
        this.myEndTransformQuat.quat2_identity();
      };
      PP.CharacterCollisionTransformResults.prototype.copy = function(other) {
        this.myStartTransformQuat.quat2_copy(other.myStartTransformQuat);
        this.myEndTransformQuat.quat2_copy(other.myEndTransformQuat);
      };
      PP.CharacterCollisionMovementResults.prototype.reset = function() {
        this.myStartMovement.vec3_zero();
        this.myEndMovement.vec3_zero();
        this.myMovementFailed = false;
        this.myIsColliding = false;
        this.myReferenceCollisionHit.reset();
      };
      PP.CharacterCollisionMovementResults.prototype.copy = function(other) {
        this.myStartMovement.vec3_copy(other.myStartMovement);
        this.myEndMovement.vec3_copy(other.myEndMovement);
        this.myMovementFailed = other.myMovementFailed;
        this.myIsColliding = other.myIsColliding;
        this.myReferenceCollisionHit.copy(other.myReferenceCollisionHit);
      };
      PP.CharacterCollisionTeleportResults.prototype.reset = function() {
        this.myStartTeleportTransformQuat.quat2_identity();
        this.myEndTeleportTransformQuat.quat2_identity();
        this.myTeleportFailed = false;
      };
      PP.CharacterCollisionTeleportResults.prototype.copy = function(other) {
        this.myStartTeleportTransformQuat.quat2_copy(other.myStartTeleportTransformQuat);
        this.myEndTeleportTransformQuat.quat2_copy(other.myEndTeleportTransformQuat);
        this.myTeleportFailed = other.myTeleportFailed;
      };
      PP.CharacterCollisionCheckTransformResults.prototype.reset = function() {
        this.myStartCheckTransformQuat.quat2_identity();
        this.myEndCheckTransformQuat.quat2_identity();
        this.myCheckTransformFailed = false;
      };
      PP.CharacterCollisionCheckTransformResults.prototype.copy = function(other) {
        this.myStartCheckTransformQuat.quat2_copy(other.myStartCheckTransformQuat);
        this.myEndCheckTransformQuat.quat2_copy(other.myEndCheckTransformQuat);
        this.myCheckTransformFailed = other.myCheckTransformFailed;
      };
      PP.CharacterCollisionSurfaceResults.prototype.reset = function() {
        this.myHasSnappedOnSurface = false;
        this.myHasPoppedOutSurface = false;
        this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill = false;
        this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill = false;
        this.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill = false;
      };
      PP.CharacterCollisionSurfaceResults.prototype.copy = function(other) {
        this.myHasSnappedOnSurface = other.myHasSnappedOnSurface;
        this.myHasPoppedOutSurface = other.myHasPoppedOutSurface;
        this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill = other.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleDownhill;
        this.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill = other.myHasHorizontalMovementAdjustedVerticalMovementBasedOnSurfacePerceivedAngleUphill;
        this.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill = other.myHasVerticalMovementAdjustedHorizontalMovementBasedOnSurfaceAngleDownhill;
      };
      PP.CharacterCollisionSplitMovementResults.prototype.reset = function() {
        this.myStepsToPerform = 0;
        this.myStepsPerformed = 0;
        this.myMovementInterrupted = false;
        this.myMovementChecked.vec3_zero();
      };
      PP.CharacterCollisionSplitMovementResults.prototype.copy = function(other) {
        this.myStepsToPerform = other.myStepsToPerform;
        this.myStepsPerformed = other.myStepsPerformed;
        this.myMovementInterrupted = other.myMovementInterrupted;
        this.myMovementChecked.vec3_copy(other.myMovementChecked);
      };
      PP.CharacterCollisionDebugResults.prototype.reset = function() {
        this._myRaycastsPerformed = 0;
      };
      PP.CharacterCollisionDebugResults.prototype.copy = function(other) {
        this._myRaycastsPerformed = other._myRaycastsPerformed;
      };
      PP.CharacterCollisionInternalResults.prototype.reset = function() {
      };
      PP.CharacterCollisionInternalResults.prototype.copy = function(other) {
        this.myLastRelevantStartHorizontalMovement.vec3_copy(other.myLastRelevantStartHorizontalMovement);
        this.myLastRelevantAdjustedStartHorizontalMovement.vec3_copy(other.myLastRelevantAdjustedStartHorizontalMovement);
        this.myLastRelevantEndHorizontalMovement.vec3_copy(other.myLastRelevantEndHorizontalMovement);
        this.myLastRelevantStartVerticalMovement.vec3_copy(other.myLastRelevantStartVerticalMovement);
        this.myLastRelevantAdjustedStartVerticalMovement.vec3_copy(other.myLastRelevantAdjustedStartVerticalMovement);
        this.myLastRelevantEndVerticalMovement.vec3_copy(other.myLastRelevantEndVerticalMovement);
        this.myLastRelevantHasWallSlid = other.myLastRelevantHasWallSlid;
        this.myHasWallSlidTowardOppositeDirection = other.myHasWallSlidTowardOppositeDirection;
        this.myLastRelevantWallSlideFlickerPrevented = other.myLastRelevantWallSlideFlickerPrevented;
        this.myWallSlideFlickerPreventionForceCheckCounter = other.myWallSlideFlickerPreventionForceCheckCounter;
        this.myWallSlide90DegreesDirectionSign = other.myWallSlide90DegreesDirectionSign;
        this.myWallSlide90DegreesRecomputeDirectionSign = other.myWallSlide90DegreesRecomputeDirectionSign;
      };
      Object.defineProperty(PP.CharacterCollisionResults.prototype, "reset", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionTransformResults.prototype, "reset", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionMovementResults.prototype, "reset", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionTeleportResults.prototype, "reset", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionCheckTransformResults.prototype, "reset", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionWallSlideResults.prototype, "reset", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionSurfaceInfo.prototype, "reset", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionSurfaceResults.prototype, "reset", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionSplitMovementResults.prototype, "reset", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionInternalResults.prototype, "reset", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionResults.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionTransformResults.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionMovementResults.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionTeleportResults.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionCheckTransformResults.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionWallSlideResults.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionSurfaceInfo.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionSurfaceResults.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionSplitMovementResults.prototype, "copy", { enumerable: false });
      Object.defineProperty(PP.CharacterCollisionInternalResults.prototype, "copy", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/character_collision_system.js
  var require_character_collision_system = __commonJS({
    "js/pp/gameplay/character_controller/collision/character_collision_system.js"() {
      PP.CharacterCollisionSystem = class CharacterCollisionSystem {
        constructor() {
          this._myLastCheckRaycastsPerformed = 0;
          this._myCurrentFrameRaycastsPerformed = 0;
          this._myMaxFrameRaycastsPerformed = 0;
        }
        update(dt) {
          this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
          this._myCurrentFrameRaycastsPerformed = 0;
          PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts = 0;
        }
        checkMovement(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
          PP.CollisionCheckBridge.checkMovement(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
          this._myLastCheckRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
          this._myCurrentFrameRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts;
          this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
          outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
        }
        checkTeleportToPosition(teleportPosition, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
        }
        checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
          PP.CollisionCheckBridge.checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
          this._myLastCheckRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
          this._myCurrentFrameRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts;
          this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
          outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
        }
        checkTransform(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
          PP.CollisionCheckBridge.checkTransform(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
          this._myLastCheckRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
          this._myCurrentFrameRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts;
          this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
          outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
        }
        updateSurfaceInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
          let currentFramePerformedRaycasts = this._myCurrentFrameRaycastsPerformed;
          this.updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
          this.updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
          this._myLastCheckRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts - currentFramePerformedRaycasts;
          this._myCurrentFrameRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts;
          this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
          outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
        }
        updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
          PP.CollisionCheckBridge.updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
          this._myLastCheckRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
          this._myCurrentFrameRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts;
          this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
          outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
        }
        updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new PP.CharacterCollisionResults()) {
          PP.CollisionCheckBridge.updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
          this._myLastCheckRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
          this._myCurrentFrameRaycastsPerformed = PP.CollisionCheckBridge._myCollisionCheck._myTotalRaycasts;
          this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
          outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
        }
      };
      PP.CharacterCollisionSystem.prototype.checkTeleportToPosition = function() {
        let teleportTransformQuat = PP.quat2_create();
        return function checkTeleportToPosition(teleportPosition, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults) {
          teleportTransformQuat.quat2_copy(currentTransformQuat);
          teleportTransformQuat.quat2_setPosition(teleportPosition);
          this.checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
        };
      }();
      Object.defineProperty(PP.CharacterCollisionSystem.prototype, "checkTeleportToPosition", { enumerable: false });
    }
  });

  // js/pp/gameplay/character_controller/collision/components/character_collision_system_component.js
  var character_collision_system_component_exports = {};
  var init_character_collision_system_component = __esm({
    "js/pp/gameplay/character_controller/collision/components/character_collision_system_component.js"() {
      init_api();
      PP.CharacterCollisionSystemComponent = class CharacterCollisionSystemComponent extends Component {
        static TypeName = "pp-character-collision-system";
        static Properties = {};
        init() {
          PP.myCharacterCollisionSystem = new PP.CharacterCollisionSystem();
        }
        start() {
        }
        update(dt) {
          PP.myCharacterCollisionSystem.update(dt);
        }
      };
      WL.registerComponent(PP.CharacterCollisionSystemComponent);
      PP.myCharacterCollisionSystem = null;
    }
  });

  // js/pp/gameplay/character_controller/character_controller.js
  var require_character_controller = __commonJS({
    "js/pp/gameplay/character_controller/character_controller.js"() {
      PP.CharacterController = class CharacterController {
        constructor() {
        }
      };
    }
  });

  // js/pp/gameplay/character_controller/synced_character_controller.js
  var require_synced_character_controller = __commonJS({
    "js/pp/gameplay/character_controller/synced_character_controller.js"() {
      PP.SyncedCharacterController = class SyncedCharacterController extends PP.CharacterController {
        constructor() {
          super();
        }
      };
    }
  });

  // js/pp/gameplay/character_controller/character_controller_utils.js
  var require_character_controller_utils = __commonJS({
    "js/pp/gameplay/character_controller/character_controller_utils.js"() {
      PP.CharacterControllerUtils = {
        computeGroundPerceivedAngle: function(surfaceNormal, direction, up) {
          return this.computeSurfacePerceivedAngle(surfaceNormal, direction, up, true);
        },
        computeCeilingPerceivedAngle: function(surfaceNormal, direction, up) {
          return this.computeSurfacePerceivedAngle(surfaceNormal, direction, up, false);
        },
        computeSurfacePerceivedAngle: function() {
          let directionOnSurface = PP.vec3_create();
          let verticalDirection = PP.vec3_create();
          return function computeSurfacePerceivedAngle(surfaceNormal, direction, up, isGround) {
            let surfacePerceivedAngle = 0;
            verticalDirection.vec3_copy(up);
            if (!isGround) {
              verticalDirection.vec3_negate(verticalDirection);
            }
            let surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
            if (surfaceAngle <= Math.PP_EPSILON_DEGREES) {
              surfaceAngle = 0;
            } else if (surfaceAngle >= 180 - Math.PP_EPSILON_DEGREES) {
              surfaceAngle = 180;
            }
            directionOnSurface = direction.vec3_projectOnPlaneAlongAxis(surfaceNormal, up, directionOnSurface);
            surfacePerceivedAngle = directionOnSurface.vec3_angle(direction);
            let isFartherOnUp = directionOnSurface.vec3_isFartherAlongAxis(direction, up);
            if (!isFartherOnUp && isGround || isFartherOnUp && !isGround) {
              surfacePerceivedAngle *= -1;
            }
            if (Math.abs(surfacePerceivedAngle) >= surfaceAngle) {
              if (surfaceAngle != 0 && surfaceAngle != 180) {
                surfacePerceivedAngle = surfaceAngle * Math.pp_sign(surfacePerceivedAngle);
              } else {
                surfacePerceivedAngle = surfaceAngle;
              }
            }
            return surfacePerceivedAngle;
          };
        }()
      };
    }
  });

  // js/pp/gameplay/character_controller/components/character_controller_component.js
  var character_controller_component_exports = {};
  var init_character_controller_component = __esm({
    "js/pp/gameplay/character_controller/components/character_controller_component.js"() {
      init_api();
      PP.CharacterControllerComponent = class CharacterControllerComponent extends Component {
        static TypeName = "pp-character-controller";
        static Properties = {};
        init() {
        }
        start() {
          this._myCharacterController = new PP.CharacterController();
        }
        update(dt) {
          this._myCharacterController.update(dt);
        }
        getCharacterController() {
          return this._myCharacterController;
        }
      };
      WL.registerComponent(PP.CharacterControllerComponent);
    }
  });

  // js/pp/gameplay/character_controller/player/player_character_controller.js
  var require_player_character_controller = __commonJS({
    "js/pp/gameplay/character_controller/player/player_character_controller.js"() {
      PP.PlayerCharacterController = class PlayerCharacterController extends PP.SyncedCharacterController {
        constructor() {
          super();
        }
      };
    }
  });

  // js/pp/gameplay/character_controller/player/player_head_character_controller.js
  var require_player_head_character_controller = __commonJS({
    "js/pp/gameplay/character_controller/player/player_head_character_controller.js"() {
      PP.PlayerHeadCharacterController = class PlayerHeadCharacterController extends PP.SyncedCharacterController {
        constructor() {
          super();
        }
      };
    }
  });

  // js/pp/gameplay/character_controller/player/player_hand_character_controller.js
  var require_player_hand_character_controller = __commonJS({
    "js/pp/gameplay/character_controller/player/player_hand_character_controller.js"() {
      PP.PlayerHandCharacterController = class PlayerHandCharacterController extends PP.SyncedCharacterController {
        constructor() {
          super();
        }
      };
    }
  });

  // js/pp/gameplay/character_controller/player/components/player_character_controller_component.js
  var player_character_controller_component_exports = {};
  var init_player_character_controller_component = __esm({
    "js/pp/gameplay/character_controller/player/components/player_character_controller_component.js"() {
      init_api();
      PP.PlayerCharacterControllerComponent = class PlayerCharacterControllerComponent extends Component {
        static TypeName = "pp-player-character-controller";
        static Properties = {};
        init() {
        }
        start() {
          this._myPlayerCharacterController = new PP.PlayerCharacterController();
        }
        update(dt) {
          this._myPlayerCharacterController.update(dt);
        }
        getPlayerCharacterController() {
          return this._myPlayerCharacterController;
        }
      };
      WL.registerComponent(PP.PlayerCharacterControllerComponent);
    }
  });

  // js/pp/gameplay/character_controller/player/components/player_head_character_controller_component.js
  var player_head_character_controller_component_exports = {};
  var init_player_head_character_controller_component = __esm({
    "js/pp/gameplay/character_controller/player/components/player_head_character_controller_component.js"() {
      init_api();
      PP.PlayerHeadCharacterControllerComponent = class PlayerHeadCharacterControllerComponent extends Component {
        static TypeName = "pp-player-head-character-controller";
        static Properties = {};
        init() {
        }
        start() {
          this._myPlayerHeadCharacterController = new PP.PlayerHeadCharacterController();
        }
        update(dt) {
          this._myPlayerHeadCharacterController.update(dt);
        }
        getPlayerHeadCharacterController() {
          return this._myPlayerHeadCharacterController;
        }
      };
      WL.registerComponent(PP.PlayerHeadCharacterControllerComponent);
    }
  });

  // js/pp/gameplay/character_controller/player/components/player_hand_character_controller_component.js
  var player_hand_character_controller_component_exports = {};
  var init_player_hand_character_controller_component = __esm({
    "js/pp/gameplay/character_controller/player/components/player_hand_character_controller_component.js"() {
      init_api();
      PP.PlayerHandCharacterControllerComponent = class PlayerHandCharacterControllerComponent extends Component {
        static TypeName = "pp-player-hand-character-controller";
        static Properties = {};
        init() {
        }
        start() {
          this._myPlayerHandCharacterController = new PP.PlayerHandCharacterController();
        }
        update(dt) {
          this._myPlayerHandCharacterController.update(dt);
        }
        getPlayerHandCharacterController() {
          return this._myPlayerHandCharacterController;
        }
      };
      WL.registerComponent(PP.PlayerHandCharacterControllerComponent);
    }
  });

  // js/pp/gameplay/grab_throw/grabbable.js
  var require_grabbable = __commonJS({
    "js/pp/gameplay/grab_throw/grabbable.js"() {
      WL.registerComponent("pp-grabbable", {
        _myThrowLinearVelocityMultiplier: { type: WL.Type.Float, default: 1 },
        _myThrowAngularVelocityMultiplier: { type: WL.Type.Float, default: 1 },
        _myKinematicValueOnRelease: { type: WL.Type.Enum, values: ["true", "false", "keep"], default: "false" }
      }, {
        init: function() {
          this._myIsGrabbed = false;
          this._myGrabber = null;
          this._myGrabCallbacks = /* @__PURE__ */ new Map();
          this._myThrowCallbacks = /* @__PURE__ */ new Map();
          this._myReleaseCallbacks = /* @__PURE__ */ new Map();
        },
        start: function() {
          this._myOldParent = null;
          this._myPhysX = this.object.pp_getComponent("physx");
          this._myOldKinematicValue = null;
        },
        update(dt) {
          if (!this._myPhysX) {
            this._myPhysX = this.object.pp_getComponent("physx");
          }
        },
        onDeactivate: function() {
          this.release();
        },
        grab: function(grabber) {
          if (!this.isGrabbed()) {
            this._myOldKinematicValue = this._myPhysX.kinematic;
          }
          this.release();
          this._myPhysX.kinematic = true;
          this._myOldParent = null;
          this.object.pp_setParent(grabber);
          this._myIsGrabbed = true;
          this._myGrabber = grabber;
          this._myGrabCallbacks.forEach(function(callback) {
            callback(grabber, this);
          }.bind(this));
        },
        throw: function(linearVelocity, angularVelocity) {
          if (this._myIsGrabbed) {
            let grabber = this._myGrabber;
            this._release();
            this._myPhysX.linearVelocity = linearVelocity.vec3_scale(this._myThrowLinearVelocityMultiplier);
            this._myPhysX.angularVelocity = angularVelocity.vec3_scale(this._myThrowAngularVelocityMultiplier);
            this._myThrowCallbacks.forEach(function(callback) {
              callback(grabber, this);
            }.bind(this));
            this._myReleaseCallbacks.forEach(function(callback) {
              callback(grabber, this, true);
            }.bind(this));
          }
        },
        release() {
          if (this._myIsGrabbed) {
            let grabber = this._myGrabber;
            this._release();
            this._myReleaseCallbacks.forEach(function(callback) {
              callback(grabber, this, false);
            }.bind(this));
          }
        },
        getLinearVelocity() {
          let linearVelocity = PP.vec3_create();
          this._myPhysX.linearVelocity.vec3_clone(linearVelocity);
          return linearVelocity;
        },
        getAngularVelocity() {
          return this.getAngularVelocityDegrees();
        },
        getAngularVelocityDegrees() {
          let angularVelocityDegrees = PP.vec3_create();
          this._myPhysX.angularVelocity.vec3_toDegrees(angularVelocityDegrees);
          return angularVelocityDegrees;
        },
        getAngularVelocityRadians() {
          let angularVelocityRadians = PP.vec3_create();
          this._myPhysX.angularVelocity.vec3_clone(angularVelocityRadians);
          return angularVelocityRadians;
        },
        isGrabbed() {
          return this._myIsGrabbed;
        },
        getGrabber() {
          return this._myGrabber;
        },
        registerGrabEventListener(id, callback) {
          this._myGrabCallbacks.set(id, callback);
        },
        unregisterGrabEventListener(id) {
          this._myGrabCallbacks.delete(id);
        },
        registerThrowEventListener(id, callback) {
          this._myThrowCallbacks.set(id, callback);
        },
        unregisterThrowEventListener(id) {
          this._myThrowCallbacks.delete(id);
        },
        registerReleaseEventListener(id, callback) {
          this._myReleaseCallbacks.set(id, callback);
        },
        unregisterReleaseEventListener(id) {
          this._myReleaseCallbacks.delete(id);
        },
        _release() {
          this.object.pp_setParent(this._myOldParent);
          this._myIsGrabbed = false;
          this._myGrabber = null;
          if (this._myKinematicValueOnRelease == 0) {
            this._myPhysX.kinematic = true;
          } else if (this._myKinematicValueOnRelease == 1) {
            this._myPhysX.kinematic = false;
          } else if (this._myOldKinematicValue != null) {
            this._myPhysX.kinematic = this._myOldKinematicValue;
          }
          if (this._myPhysX.kinematic) {
            this._myPhysX.linearVelocity = PP.vec3_create();
            this._myPhysX.angularVelocity = PP.vec3_create();
          }
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          clonedComponent._myThrowLinearVelocityMultiplier = this._myThrowLinearVelocityMultiplier;
          clonedComponent._myThrowAngularVelocityMultiplier = this._myThrowAngularVelocityMultiplier;
          clonedComponent._myKinematicValueOnRelease = this._myKinematicValueOnRelease;
          return clonedComponent;
        },
        pp_clonePostProcess(clonedComponent) {
          clonedComponent.start();
        }
      });
    }
  });

  // js/pp/gameplay/grab_throw/grabber_hand.js
  var require_grabber_hand = __commonJS({
    "js/pp/gameplay/grab_throw/grabber_hand.js"() {
      WL.registerComponent("pp-grabber-hand", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myGrabButton: { type: WL.Type.Enum, values: ["select", "squeeze", "both", "both_exclusive"], default: "squeeze" },
        // both_exclusive means u can use both buttons but you have to use the same button you grabbed with to throw
        _mySnapOnPivot: { type: WL.Type.Bool, default: false },
        _myMaxNumberOfObjects: { type: WL.Type.Int, default: 1 },
        // how many objects you can grab at the same time
        // ADVANCED SETTINGS
        _myThrowVelocitySource: { type: WL.Type.Enum, values: ["hand", "grabbable"], default: "hand" },
        _myThrowLinearVelocityMultiplier: { type: WL.Type.Float, default: 1 },
        // multiply the overall throw speed, so slow throws will be multiplied too
        _myThrowMaxLinearSpeed: { type: WL.Type.Float, default: 15 },
        _myThrowAngularVelocityMultiplier: { type: WL.Type.Float, default: 0.5 },
        _myThrowMaxAngularSpeed: { type: WL.Type.Float, default: 1080 },
        // degrees
        _myThrowLinearVelocityBoost: { type: WL.Type.Float, default: 1.75 },
        // this boost is applied from 0% to 100% based on how fast you throw, so slow throws are not affected
        _myThrowLinearVelocityBoostMinSpeedThreshold: { type: WL.Type.Float, default: 0.6 },
        // 0% boost is applied if plain throw speed is under this value
        _myThrowLinearVelocityBoostMaxSpeedThreshold: { type: WL.Type.Float, default: 2.5 }
        // 100% boost is applied if plain throw speed is over this value
      }, {
        init: function() {
          this._myGrabbables = [];
          this._myGamepad = null;
          this._myActiveGrabButton = null;
          this._myLinearVelocityHistorySize = 5;
          this._myLinearVelocityHistorySpeedAverageSamplesFromStart = 1;
          this._myLinearVelocityHistoryDirectionAverageSamplesFromStart = 3;
          this._myLinearVelocityHistoryDirectionAverageSkipFromStart = 0;
          this._myHandLinearVelocityHistory = new Array(this._myLinearVelocityHistorySize);
          this._myHandLinearVelocityHistory.fill(PP.vec3_create());
          this._myAngularVelocityHistorySize = 1;
          this._myHandAngularVelocityHistory = new Array(this._myAngularVelocityHistorySize);
          this._myHandAngularVelocityHistory.fill(PP.vec3_create());
          this._myThrowMaxAngularSpeedRadians = Math.pp_toRadians(this._myThrowMaxAngularSpeed);
          this._myGrabCallbacks = /* @__PURE__ */ new Map();
          this._myThrowCallbacks = /* @__PURE__ */ new Map();
          this._myDebugActive = false;
        },
        start: function() {
          if (this._myHandedness == PP.HandednessIndex.LEFT) {
            this._myGamepad = PP.myLeftGamepad;
          } else {
            this._myGamepad = PP.myRightGamepad;
          }
          this._myPhysX = this.object.pp_getComponent("physx");
          this._myCollisionsCollector = new PP.PhysicsCollisionCollector(this._myPhysX, true);
          this._myAudioPrendi = null;
        },
        update: function(dt) {
          if (Global.myReady) {
            if (this._myAudioPrendi == null) {
              this._myAudioPrendi = PP.myAudioManager.createAudioPlayer(AudioID.PRENDI_FRUTTO);
            }
          }
          this._myCollisionsCollector.update(dt);
          if (this._myGrabbables.length > 0) {
            this._updateLinearVelocityHistory();
            this._updateAngularVelocityHistory();
          }
          if (this._myGamepad.getHandPose() == null || !this._myGamepad.getHandPose().isValid()) {
            this.throw();
          }
        },
        grab: function(grabButton = null) {
          this._grab(grabButton);
        },
        throw: function(throwButton = null) {
          this._throw(throwButton);
        },
        registerGrabEventListener(id, callback) {
          this._myGrabCallbacks.set(id, callback);
        },
        unregisterGrabEventListener(id) {
          this._myGrabCallbacks.delete(id);
        },
        registerThrowEventListener(id, callback) {
          this._myThrowCallbacks.set(id, callback);
        },
        unregisterThrowEventListener(id) {
          this._myThrowCallbacks.delete(id);
        },
        onActivate() {
          if (this._myGamepad == null) {
            return;
          }
          if (this._myGrabButton == 0) {
            this._myGamepad.registerButtonEventListener(PP.GamepadButtonID.SELECT, PP.GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, PP.GamepadButtonID.SELECT));
            this._myGamepad.registerButtonEventListener(PP.GamepadButtonID.SELECT, PP.GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, PP.GamepadButtonID.SELECT));
          } else if (this._myGrabButton == 1) {
            this._myGamepad.registerButtonEventListener(PP.GamepadButtonID.SQUEEZE, PP.GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, PP.GamepadButtonID.SQUEEZE));
            this._myGamepad.registerButtonEventListener(PP.GamepadButtonID.SQUEEZE, PP.GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, PP.GamepadButtonID.SQUEEZE));
          } else {
            this._myGamepad.registerButtonEventListener(PP.GamepadButtonID.SQUEEZE, PP.GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, PP.GamepadButtonID.SQUEEZE));
            this._myGamepad.registerButtonEventListener(PP.GamepadButtonID.SQUEEZE, PP.GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, PP.GamepadButtonID.SQUEEZE));
            this._myGamepad.registerButtonEventListener(PP.GamepadButtonID.SELECT, PP.GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, PP.GamepadButtonID.SELECT));
            this._myGamepad.registerButtonEventListener(PP.GamepadButtonID.SELECT, PP.GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, PP.GamepadButtonID.SELECT));
          }
        },
        onDeactivate() {
          if (this._myGamepad == null) {
            return;
          }
          if (this._myGrabButton == 0) {
            this._myGamepad.unregisterButtonEventListener(PP.GamepadButtonID.SELECT, PP.GamepadButtonEvent.PRESS_START, this);
            this._myGamepad.unregisterButtonEventListener(PP.GamepadButtonID.SELECT, PP.GamepadButtonEvent.PRESS_END, this);
          } else if (this._myGrabButton == 1) {
            this._myGamepad.unregisterButtonEventListener(PP.GamepadButtonID.SQUEEZE, PP.GamepadButtonEvent.PRESS_START, this);
            this._myGamepad.unregisterButtonEventListener(PP.GamepadButtonID.SQUEEZE, PP.GamepadButtonEvent.PRESS_END, this);
          } else {
            this._myGamepad.unregisterButtonEventListener(PP.GamepadButtonID.SQUEEZE, PP.GamepadButtonEvent.PRESS_START, this);
            this._myGamepad.unregisterButtonEventListener(PP.GamepadButtonID.SQUEEZE, PP.GamepadButtonEvent.PRESS_END, this);
            this._myGamepad.unregisterButtonEventListener(PP.GamepadButtonID.SELECT, PP.GamepadButtonEvent.PRESS_START, this);
            this._myGamepad.unregisterButtonEventListener(PP.GamepadButtonID.SELECT, PP.GamepadButtonEvent.PRESS_END, this);
          }
        },
        _grab: function(grabButton) {
          if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
            return;
          }
          if (this._myGamepad.getHandPose() == null || !this._myGamepad.getHandPose().isValid()) {
            return;
          }
          if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == grabButton || grabButton == null) {
            let grabbablesToGrab = [];
            let collisions = this._myCollisionsCollector.getCollisions();
            for (let i = 0; i < collisions.length; i++) {
              let grabbable = collisions[i].getComponent("pp-grabbable");
              if (grabbable && grabbable.active) {
                grabbablesToGrab.push(grabbable);
              }
            }
            let grabberPosition = this.object.pp_getPosition();
            grabbablesToGrab.sort(function(first, second) {
              let firstPosition = first.object.pp_getPosition();
              let secondPosition = second.object.pp_getPosition();
              let firstDistance = firstPosition.vec3_distance(grabberPosition);
              let secondDistance = secondPosition.vec3_distance(grabberPosition);
              return Math.pp_sign(firstDistance - secondDistance, 0);
            });
            for (let grabbableToGrab of grabbablesToGrab) {
              if (!this._isAlreadyGrabbed(grabbableToGrab)) {
                let grabbableData = new PP.GrabberHandGrabbableData(grabbableToGrab, this._myThrowVelocitySource == 1, this._myLinearVelocityHistorySize, this._myAngularVelocityHistorySize);
                this._myGrabbables.push(grabbableData);
                grabbableToGrab.grab(this.object);
                grabbableToGrab.registerReleaseEventListener(this, this._onRelease.bind(this));
                if (this._mySnapOnPivot) {
                  grabbableToGrab.object.resetTranslation();
                }
                this._myGrabCallbacks.forEach(function(callback) {
                  callback(this, grabbableToGrab);
                }.bind(this));
              }
              if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
                break;
              }
            }
            if (this._myGrabbables.length > 0) {
              if (this._myActiveGrabButton == null) {
                this._myActiveGrabButton = grabButton;
              }
              let intensity = 0.35;
              let pulseInfo = this._myGamepad.getPulseInfo();
              if (pulseInfo.myIntensity <= intensity) {
                this._myGamepad.pulse(intensity, 0.1);
              }
              if (this._myAudioPrendi != null) {
                this._myAudioPrendi.setPosition(this.object.pp_getPosition());
                this._myAudioPrendi.setPitch(Math.pp_random(1.25 - 0.15, 1.25 + 0.05));
                this._myAudioPrendi.play();
              }
            }
          }
        },
        _throw: function(throwButton) {
          if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == throwButton || throwButton == null) {
            if (this._myGrabbables.length > 0) {
              let linearVelocity = null;
              let angularVelocity = null;
              if (this._myThrowVelocitySource == 0) {
                linearVelocity = this._computeReleaseLinearVelocity(this._myHandLinearVelocityHistory);
                angularVelocity = this._computeReleaseAngularVelocity(this._myHandAngularVelocityHistory);
              }
              for (let grabbableData of this._myGrabbables) {
                let grabbable = grabbableData.getGrabbable();
                grabbable.unregisterReleaseEventListener(this);
                if (this._myThrowVelocitySource == 1) {
                  linearVelocity = this._computeReleaseLinearVelocity(grabbableData.getLinearVelocityHistory());
                  angularVelocity = this._computeReleaseAngularVelocity(grabbableData.getAngularVelocityHistory());
                }
                grabbable.throw(linearVelocity, angularVelocity);
                this._myThrowCallbacks.forEach(function(callback) {
                  callback(this, grabbable);
                }.bind(this));
              }
              this._myGrabbables = [];
            }
            this._myActiveGrabButton = null;
          }
        },
        _onRelease(grabber, grabbable) {
          grabbable.unregisterReleaseEventListener(this);
          this._myGrabbables.pp_remove((element) => element.getGrabbable() == grabbable);
          if (this._myGrabbables.length <= 0) {
            this._myActiveGrabButton = null;
          }
        },
        _updateLinearVelocityHistory() {
          let handPose = this._myGamepad.getHandPose();
          if (handPose) {
            this._myHandLinearVelocityHistory.unshift(handPose.getLinearVelocity().pp_clone());
            this._myHandLinearVelocityHistory.pop();
          }
          for (let grabbable of this._myGrabbables) {
            grabbable.updateLinearVelocityHistory();
          }
        },
        _updateAngularVelocityHistory() {
          let handPose = this._myGamepad.getHandPose();
          if (handPose) {
            this._myHandAngularVelocityHistory.unshift(handPose.getAngularVelocityRadians().pp_clone());
            this._myHandAngularVelocityHistory.pop();
          }
          for (let grabbable of this._myGrabbables) {
            grabbable.updateAngularVelocityHistory();
          }
        },
        _computeReleaseLinearVelocity(linearVelocityHistory) {
          let speed = linearVelocityHistory[0].vec3_length();
          for (let i = 1; i < this._myLinearVelocityHistorySpeedAverageSamplesFromStart; i++) {
            speed += linearVelocityHistory[i].vec3_length();
          }
          speed /= this._myLinearVelocityHistorySpeedAverageSamplesFromStart;
          let speedEaseMultiplier = Math.pp_mapToRange(speed, this._myThrowLinearVelocityBoostMinSpeedThreshold, this._myThrowLinearVelocityBoostMaxSpeedThreshold, 0, 1);
          speedEaseMultiplier = PP.EasingFunction.easeIn(speedEaseMultiplier);
          let extraSpeed = speed * (speedEaseMultiplier * this._myThrowLinearVelocityBoost);
          speed += extraSpeed;
          speed *= this._myThrowLinearVelocityMultiplier;
          speed = Math.pp_clamp(speed, 0, this._myThrowMaxLinearSpeed);
          if (this._myDebugActive) {
            this._debugDirectionLines(linearVelocityHistory);
          }
          let directionCurrentWeight = this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
          let lastDirectionIndex = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
          let direction = PP.vec3_create();
          for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
            let currentDirection = linearVelocityHistory[i];
            currentDirection.vec3_scale(directionCurrentWeight, currentDirection);
            direction.vec3_add(currentDirection, direction);
            directionCurrentWeight--;
          }
          direction.vec3_normalize(direction);
          direction.vec3_scale(speed, direction);
          return direction;
        },
        _computeReleaseAngularVelocity(angularVelocityHistory) {
          let angularVelocity = angularVelocityHistory[0];
          let speed = angularVelocity.vec3_length();
          speed = Math.pp_clamp(speed * this._myThrowAngularVelocityMultiplier, 0, this._myThrowMaxAngularSpeedRadians);
          let direction = angularVelocity;
          direction.vec3_normalize(direction);
          direction.vec3_scale(speed, direction);
          return direction;
        },
        _debugDirectionLines(linearVelocityHistory) {
          for (let j = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart; j > this._myLinearVelocityHistoryDirectionAverageSkipFromStart; j--) {
            let directionCurrentWeight = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
            let lastDirectionIndex = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
            let direction = PP.vec3_create();
            for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
              let currentDirection = linearVelocityHistory[i].pp_clone();
              currentDirection.vec3_scale(directionCurrentWeight, currentDirection);
              direction.vec3_add(currentDirection, direction);
              directionCurrentWeight--;
            }
            direction.vec3_normalize(direction);
            let color = 1 / j;
            PP.myDebugVisualManager.drawLine(5, this.object.pp_getPosition(), direction, 0.2, PP.vec4_create(color, color, color, 1));
          }
        },
        _isAlreadyGrabbed(grabbable) {
          let found = this._myGrabbables.pp_find((element) => element.getGrabbable() == grabbable);
          return found != null;
        }
      });
      PP.GrabberHandGrabbableData = class GrabberHandGrabbableData {
        constructor(grabbable, useGrabbableAsVelocitySource, linearVelocityHistorySize, angularVelocityHistorySize) {
          this._myGrabbable = grabbable;
          this._myUseGrabbableAsVelocitySource = useGrabbableAsVelocitySource;
          if (this._myUseGrabbableAsVelocitySource) {
            this._myLinearVelocityHistory = new Array(linearVelocityHistorySize);
            this._myLinearVelocityHistory.fill(PP.vec3_create());
            this._myAngularVelocityHistory = new Array(angularVelocityHistorySize);
            this._myAngularVelocityHistory.fill(PP.vec3_create());
          }
        }
        getGrabbable() {
          return this._myGrabbable;
        }
        getLinearVelocityHistory() {
          return this._myLinearVelocityHistory;
        }
        getAngularVelocityHistory() {
          return this._myAngularVelocityHistory;
        }
        updateLinearVelocityHistory() {
          if (this._myUseGrabbableAsVelocitySource) {
            this._myLinearVelocityHistory.unshift(this._myGrabbable.getLinearVelocity());
            this._myLinearVelocityHistory.pop();
          }
        }
        updateAngularVelocityHistory() {
          if (this._myUseGrabbableAsVelocitySource) {
            this._myAngularVelocityHistory.unshift(this._myGrabbable.getAngularVelocityRadians());
            this._myAngularVelocityHistory.pop();
          }
        }
      };
    }
  });

  // js/pp/gameplay/locomotion/components/global_gravity.js
  var global_gravity_exports = {};
  var init_global_gravity = __esm({
    "js/pp/gameplay/locomotion/components/global_gravity.js"() {
      init_api();
      PP.GlobalGravityComponent = class GlobalGravityComponent extends Component {
        static TypeName = "pp-global-gravity";
        static Properties = {};
        init() {
        }
      };
      WL.registerComponent(PP.GlobalGravityComponent);
      PP.myGravityAcceleration = 0;
      PP.myGravityDirection = PP.vec3_create();
    }
  });

  // js/pp/gameplay/locomotion/player/player_locomotion_smooth.js
  var require_player_locomotion_smooth = __commonJS({
    "js/pp/gameplay/locomotion/player/player_locomotion_smooth.js"() {
      PP.PlayerLocomotionSmooth = class PlayerLocomotionSmooth {
        constructor() {
        }
      };
    }
  });

  // js/pp/gameplay/locomotion/player/player_locomotion_rotate.js
  var require_player_locomotion_rotate = __commonJS({
    "js/pp/gameplay/locomotion/player/player_locomotion_rotate.js"() {
      PP.PlayerLocomotionRotate = class PlayerLocomotionRotate {
        constructor() {
        }
      };
    }
  });

  // js/pp/gameplay/locomotion/player/player_locomotion_gravity.js
  var require_player_locomotion_gravity = __commonJS({
    "js/pp/gameplay/locomotion/player/player_locomotion_gravity.js"() {
      PP.PlayerLocomotionGravity = class PlayerLocomotionGravity {
        constructor() {
        }
      };
    }
  });

  // js/pp/gameplay/locomotion/player/teleport/player_locomotion_teleport.js
  var require_player_locomotion_teleport = __commonJS({
    "js/pp/gameplay/locomotion/player/teleport/player_locomotion_teleport.js"() {
      PP.PlayerLocomotionTeleport = class PlayerLocomotionTeleport {
        constructor() {
        }
      };
    }
  });

  // js/pp/gameplay/locomotion/player/components/player_locomotion_teleport_component.js
  var player_locomotion_teleport_component_exports = {};
  var init_player_locomotion_teleport_component = __esm({
    "js/pp/gameplay/locomotion/player/components/player_locomotion_teleport_component.js"() {
      init_api();
      PP.PlayerLocomotionTeleportComponent = class PlayerLocomotionTeleportComponent extends Component {
        static TypeName = "pp-player-locomotion-teleport";
        static Properties = {};
        init() {
        }
        start() {
          this._myPlayerLocomotionTeleport = new PP.PlayerLocomotionTeleport();
        }
        update(dt) {
          this._myPlayerLocomotionTeleport.update(dt);
        }
        getPlayerLocomotionTeleport() {
          return this._myPlayerLocomotionTeleport;
        }
      };
      WL.registerComponent(PP.PlayerLocomotionTeleportComponent);
    }
  });

  // js/pp/gameplay/locomotion/player/components/player_locomotion_smooth_component.js
  var player_locomotion_smooth_component_exports = {};
  var init_player_locomotion_smooth_component = __esm({
    "js/pp/gameplay/locomotion/player/components/player_locomotion_smooth_component.js"() {
      init_api();
      PP.PlayerLocomotionSmoothComponent = class PlayerLocomotionSmoothComponent extends Component {
        static TypeName = "pp-player-locomotion-smooth";
        static Properties = {};
        init() {
        }
        start() {
          this._myPlayerLocomotionSmooth = new PP.PlayerLocomotionSmooth();
        }
        update(dt) {
          this._myPlayerLocomotionSmooth.update(dt);
        }
        getPlayerLocomotionSmooth() {
          return this._myPlayerLocomotionSmooth;
        }
      };
      WL.registerComponent(PP.PlayerLocomotionSmoothComponent);
    }
  });

  // js/pp/gameplay/locomotion/player/components/player_locomotion_rotate_component.js
  var player_locomotion_rotate_component_exports = {};
  var init_player_locomotion_rotate_component = __esm({
    "js/pp/gameplay/locomotion/player/components/player_locomotion_rotate_component.js"() {
      init_api();
      PP.PlayerLocomotionRotateComponent = class PlayerLocomotionRotateComponent extends Component {
        static TypeName = "pp-player-locomotion-rotate";
        static Properties = {};
        init() {
        }
        start() {
          this._myPlayerLocomotionRotate = new PP.PlayerLocomotionRotate();
        }
        update(dt) {
          this._myPlayerLocomotionRotate.update(dt);
        }
        getPlayerLocomotionRotate() {
          return this._myPlayerLocomotionRotate;
        }
      };
      WL.registerComponent(PP.PlayerLocomotionRotateComponent);
    }
  });

  // js/pp/gameplay/locomotion/player/components/player_locomotion_gravity_component.js
  var player_locomotion_gravity_component_exports = {};
  var init_player_locomotion_gravity_component = __esm({
    "js/pp/gameplay/locomotion/player/components/player_locomotion_gravity_component.js"() {
      init_api();
      PP.PlayerLocomotionGravityComponent = class PlayerLocomotionGravityComponent extends Component {
        static TypeName = "pp-player-locomotion-gravity";
        static Properties = {};
        init() {
        }
        start() {
          this._myPlayerLocomotionGravity = new PP.PlayerLocomotionGravity();
        }
        update(dt) {
          this._myPlayerLocomotionGravity.update(dt);
        }
        getPlayerLocomotionGravity() {
          return this._myPlayerLocomotionGravity;
        }
      };
      WL.registerComponent(PP.PlayerLocomotionGravityComponent);
    }
  });

  // js/pp/gameplay/utils/ca_utils.js
  var require_ca_utils = __commonJS({
    "js/pp/gameplay/utils/ca_utils.js"() {
      PP.CAUtils = {
        _myDummyServer: null,
        _myUseDummyServerOnSDKMissing: false,
        _myUseDummyServerOnError: false,
        _myLeaderboardSDKReady: false,
        _myViverseAppID: "mhzzb94zpv",
        setUseDummyServerOnSDKMissing: function(useDummyServer) {
          PP.CAUtils._myUseDummyServerOnSDKMissing = useDummyServer;
        },
        setUseDummyServerOnError: function(useDummyServer) {
          PP.CAUtils._myUseDummyServerOnError = useDummyServer;
        },
        setDummyServer: function(dummyServer) {
          PP.CAUtils._myDummyServer = dummyServer;
        },
        isUseDummyServerOnSDKMissing: function() {
          return PP.CAUtils._myUseDummyServerOnSDKMissing;
        },
        isUseDummyServerOnError: function() {
          return PP.CAUtils._myUseDummyServerOnError;
        },
        getDummyServer: function() {
          return PP.CAUtils._myDummyServer;
        },
        isSDKAvailable: function() {
          return window.heyVR != null || window.viverseClient != null;
        },
        initializeSDK: async function() {
          if (window.viverse != null) {
            window.viverseClient = new window.viverse.client({
              clientId: PP.CAUtils._myViverseAppID,
              domain: "account.htcvive.com"
            });
            const authInfo = await window.viverseClient.checkAuth();
            if (authInfo != null) {
              window.viverseLeaderboard = new window.viverse.gameDashboard({
                baseURL: "https://www.viveport.com/",
                communityBaseURL: "https://www.viverse.com/",
                token: authInfo.access_token
              });
            } else {
              window.viverseLeaderboard = null;
            }
          }
          PP.CAUtils._myLeaderboardSDKReady = true;
        },
        isLeaderboardSDKReady: function() {
          return PP.CAUtils.isSDKAvailable() && PP.CAUtils._myLeaderboardSDKReady;
        },
        isHeyVR: function() {
          return window.heyVR != null;
        },
        isViverse: function() {
          return window.viverseClient != null;
        },
        getSDK: function() {
          if (PP.CAUtils.isHeyVR()) {
            return window.heyVR;
          } else if (PP.CAUtils.isViverse()) {
            return window.viverseClient;
          }
          return null;
        },
        getLeaderboardSDK: function() {
          if (PP.CAUtils.isHeyVR()) {
            return window.heyVR.leaderboard;
          } else if (PP.CAUtils.isViverse()) {
            return window.viverseLeaderboard;
          }
          return null;
        },
        getLeaderboard: function(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
          if (PP.CAUtils.isLeaderboardSDKReady()) {
            try {
              PP.CAUtils._getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount).then(function(result) {
                if (result.leaderboard != null) {
                  if (!aroundPlayer) {
                    if (PP.CAUtils.isViverse() && result.leaderboard == PP.CAUtils.CAError.USER_NOT_LOGGED_IN) {
                      if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getLeaderboard != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                        PP.CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, PP.CAUtils.CAError.USER_NOT_LOGGED_IN);
                      } else if (onErrorCallback != null) {
                        let error = {};
                        error.reason = "User not logged in";
                        error.type = PP.CAUtils.CAError.USER_NOT_LOGGED_IN;
                        onErrorCallback(error, null);
                      }
                    } else if (onDoneCallback != null) {
                      onDoneCallback(result.leaderboard);
                    }
                  } else {
                    let userLeaderboard = result.leaderboard;
                    PP.CAUtils.getUser(
                      function(user) {
                        let isViverse = PP.CAUtils.isViverse();
                        let userName = isViverse ? user.accountID : user.displayName;
                        let userValid = false;
                        for (let userLeaderboardEntry of userLeaderboard) {
                          if (!isViverse && userLeaderboardEntry.displayName == userName || isViverse && userLeaderboardEntry.accountID == userName) {
                            userValid = true;
                            break;
                          }
                        }
                        if (userValid) {
                          if (PP.CAUtils.isViverse() && userLeaderboard.length > scoresAmount) {
                            let userIndex = userLeaderboard.findIndex((entry) => entry.accountID === userName);
                            const half = Math.ceil(scoresAmount / 2);
                            let start = userIndex - (half - 1);
                            let end = userIndex + half + (scoresAmount % 2 === 0 ? 0 : -1);
                            if (start < 0) {
                              end += -start;
                              start = 0;
                            }
                            if (end >= userLeaderboard.length) {
                              start -= end - userLeaderboard.length + 1;
                              end = userLeaderboard.length - 1;
                            }
                            if (start < 0)
                              start = 0;
                            userLeaderboard = userLeaderboard.slice(start, end + 1);
                          }
                          if (onDoneCallback != null) {
                            onDoneCallback(userLeaderboard);
                          }
                        } else {
                          if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getLeaderboard != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                            PP.CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, PP.CAUtils.CAError.USER_HAS_NO_SCORE);
                          } else if (onErrorCallback != null) {
                            let error = {};
                            error.reason = "Searching for around player but the user has not submitted a score yet";
                            error.type = PP.CAUtils.CAError.USER_HAS_NO_SCORE;
                            onErrorCallback(error, null);
                          }
                        }
                      },
                      function(error, result2) {
                        if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getLeaderboard != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                          PP.CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, error.type);
                        } else if (onErrorCallback != null) {
                          onErrorCallback(error, result2);
                        }
                      },
                      false
                    );
                  }
                } else {
                  if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getLeaderboard != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                    PP.CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, PP.CAUtils.CAError.GET_LEADERBOARD_FAILED);
                  } else if (onErrorCallback != null) {
                    let error = {};
                    error.reason = "Get leaderboard failed";
                    error.type = PP.CAUtils.CAError.GET_LEADERBOARD_FAILED;
                    onErrorCallback(error, result);
                  }
                }
              }).catch(function(result) {
                if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getLeaderboard != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                  PP.CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, PP.CAUtils.CAError.GET_LEADERBOARD_FAILED);
                } else if (onErrorCallback != null) {
                  let error = {};
                  error.reason = "Get leaderboard failed";
                  error.type = PP.CAUtils.CAError.GET_LEADERBOARD_FAILED;
                  onErrorCallback(error, result);
                }
              });
            } catch (error) {
              if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getLeaderboard != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                PP.CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, PP.CAUtils.CAError.GET_LEADERBOARD_FAILED);
              } else if (onErrorCallback != null) {
                let error2 = {};
                error2.reason = "Get leaderboard failed";
                error2.type = PP.CAUtils.CAError.GET_LEADERBOARD_FAILED;
                onErrorCallback(error2, null);
              }
            }
          } else {
            if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getLeaderboard != null && (PP.CAUtils._myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
              PP.CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, PP.CAUtils.CAError.CA_SDK_MISSING);
            } else if (onErrorCallback != null) {
              let error = {};
              error.reason = "Construct Arcade SDK missing";
              error.type = PP.CAUtils.CAError.CA_SDK_MISSING;
              onErrorCallback(error, null);
            }
          }
        },
        getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null, caError = PP.CAUtils.CAError.NONE) {
          if (PP.CAUtils._myDummyServer) {
            PP.CAUtils._myDummyServer.getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, caError);
          } else {
            if (onErrorCallback != null) {
              let error = {};
              error.reason = "Dummy server not initialized";
              error.type = PP.CAUtils.CAError.DUMMY_NOT_INITIALIZED;
              onErrorCallback(error, null);
            }
          }
        },
        submitScore(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
          if (PP.CAUtils.isLeaderboardSDKReady()) {
            try {
              PP.CAUtils._submitScore(leaderboardID, scoreToSubmit).then(function(result) {
                if (result.scoreSubmitted) {
                  if (onDoneCallback != null) {
                    onDoneCallback();
                  }
                } else if (result.scoreSubmitted != null) {
                  if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.submitScore != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                    PP.CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, PP.CAUtils.CAError.USER_NOT_LOGGED_IN);
                  } else if (onErrorCallback != null) {
                    let error = {};
                    error.reason = "The score can't be submitted because the user is not logged in";
                    error.type = PP.CAUtils.CAError.USER_NOT_LOGGED_IN;
                    onErrorCallback(error, result);
                  }
                } else {
                  if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.submitScore != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                    PP.CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, PP.CAUtils.CAError.SUBMIT_SCORE_FAILED);
                  } else if (onErrorCallback != null) {
                    let error = {};
                    error.reason = "Submit score failed";
                    error.type = PP.CAUtils.CAError.SUBMIT_SCORE_FAILED;
                    onErrorCallback(error, result);
                  }
                }
              }).catch(function(result) {
                if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.submitScore != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                  PP.CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, PP.CAUtils.CAError.SUBMIT_SCORE_FAILED);
                } else if (onErrorCallback != null) {
                  let error = {};
                  error.reason = "Submit score failed";
                  error.type = PP.CAUtils.CAError.SUBMIT_SCORE_FAILED;
                  onErrorCallback(error, result);
                }
              });
            } catch (error) {
              if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.submitScore != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                PP.CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, PP.CAUtils.CAError.SUBMIT_SCORE_FAILED);
              } else if (onErrorCallback != null) {
                let error2 = {};
                error2.reason = "Submit score failed";
                error2.type = PP.CAUtils.CAError.SUBMIT_SCORE_FAILED;
                onErrorCallback(error2, null);
              }
            }
          } else {
            if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.submitScore != null && (PP.CAUtils._myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
              PP.CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, PP.CAUtils.CAError.CA_SDK_MISSING);
            } else if (onErrorCallback != null) {
              let error = {};
              error.reason = "Construct Arcade SDK missing";
              error.type = PP.CAUtils.CAError.CA_SDK_MISSING;
              onErrorCallback(error, null);
            }
          }
        },
        submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null, caError = PP.CAUtils.CAError.NONE) {
          if (PP.CAUtils._myDummyServer) {
            PP.CAUtils._myDummyServer.submitScore(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, caError);
          } else {
            if (onErrorCallback != null) {
              let error = {};
              error.reason = "Dummy server not initialized";
              error.type = PP.CAUtils.CAError.DUMMY_NOT_INITIALIZED;
              onErrorCallback(error, null);
            }
          }
        },
        getUser(onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
          if (PP.CAUtils.isSDKAvailable()) {
            try {
              PP.CAUtils._getUser().then(function(result) {
                if (result.user != null && result.user.displayName != null) {
                  if (onDoneCallback != null) {
                    onDoneCallback(result.user);
                  }
                } else if (result.user != null) {
                  if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getUser != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                    PP.CAUtils.getUserDummy(onDoneCallback, onErrorCallback, PP.CAUtils.CAError.USER_NOT_LOGGED_IN);
                  } else if (onErrorCallback != null) {
                    let error = {};
                    error.reason = "User not logged in";
                    error.type = PP.CAUtils.CAError.USER_NOT_LOGGED_IN;
                    onErrorCallback(error, result);
                  }
                } else {
                  if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getUser != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                    PP.CAUtils.getUserDummy(onDoneCallback, onErrorCallback, PP.CAUtils.CAError.GET_USER_FAILED);
                  } else if (onErrorCallback != null) {
                    let error = {};
                    error.reason = "Get user failed";
                    error.type = PP.CAUtils.CAError.GET_USER_FAILED;
                    onErrorCallback(error, result);
                  }
                }
              }).catch(function(result) {
                if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getUser != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                  PP.CAUtils.getUserDummy(onDoneCallback, onErrorCallback, PP.CAUtils.CAError.GET_USER_FAILED);
                } else if (onErrorCallback != null) {
                  let error = {};
                  error.reason = "Get user failed";
                  error.type = PP.CAUtils.CAError.GET_USER_FAILED;
                  onErrorCallback(error, result);
                }
              });
            } catch (error) {
              if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getUser != null && (PP.CAUtils._myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                PP.CAUtils.getUserDummy(onDoneCallback, onErrorCallback, PP.CAUtils.CAError.GET_USER_FAILED);
              } else if (onErrorCallback != null) {
                let error2 = {};
                error2.reason = "Get user failed";
                error2.type = PP.CAUtils.CAError.GET_USER_FAILED;
                onErrorCallback(error2, null);
              }
            }
          } else {
            if (PP.CAUtils._myDummyServer != null && PP.CAUtils._myDummyServer.getUser != null && (PP.CAUtils._myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
              PP.CAUtils.getUserDummy(onDoneCallback, onErrorCallback, PP.CAUtils.CAError.CA_SDK_MISSING);
            } else if (onErrorCallback != null) {
              let error = {};
              error.reason = "Construct Arcade SDK missing";
              error.type = PP.CAUtils.CAError.CA_SDK_MISSING;
              onErrorCallback(error, null);
            }
          }
        },
        getUserDummy(onDoneCallback = null, onErrorCallback = null, caError = PP.CAUtils.CAError.NONE) {
          if (PP.CAUtils._myDummyServer) {
            PP.CAUtils._myDummyServer.getUser(onDoneCallback, onErrorCallback, caError);
          } else {
            if (onErrorCallback != null) {
              let error = {};
              error.reason = "Dummy server not initialized";
              error.type = PP.CAUtils.CAError.DUMMY_NOT_INITIALIZED;
              onErrorCallback(error, null);
            }
          }
        },
        _getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount) {
          if (PP.CAUtils.isHeyVR()) {
            let leaderboardSDK = PP.CAUtils.getLeaderboardSDK();
            if (aroundPlayer) {
              return leaderboardSDK.getMy(leaderboardID, scoresAmount).then(function(result) {
                let adjustedLeaderboard = [];
                for (let leaderboardEntry of result) {
                  adjustedLeaderboard.push({ rank: leaderboardEntry.rank - 1, displayName: leaderboardEntry.user, score: leaderboardEntry.score });
                }
                return { leaderboard: adjustedLeaderboard };
              }).catch(function(error) {
                if (error != null && error.status != null && error.status.debug == "err_unauthenticated") {
                  return { leaderboard: [] };
                } else {
                  return { leaderboard: null };
                }
              });
            } else {
              return leaderboardSDK.get(leaderboardID, scoresAmount).then(function(result) {
                let adjustedLeaderboard = [];
                for (let leaderboardEntry of result) {
                  adjustedLeaderboard.push({ rank: leaderboardEntry.rank - 1, displayName: leaderboardEntry.user, score: leaderboardEntry.score });
                }
                return { leaderboard: adjustedLeaderboard };
              }).catch(function() {
                return { leaderboard: null };
              });
            }
          } else if (PP.CAUtils.isViverse()) {
            let leaderboardSDK = PP.CAUtils.getLeaderboardSDK();
            if (leaderboardSDK != null) {
              let leaderboardConfig = {
                name: leaderboardID,
                range_start: 0,
                range_end: scoresAmount,
                region: "global",
                time_range: "alltime",
                around_user: aroundPlayer
              };
              if (aroundPlayer) {
                leaderboardConfig = {
                  name: leaderboardID,
                  range_start: -scoresAmount,
                  range_end: scoresAmount,
                  region: "global",
                  time_range: "alltime",
                  around_user: aroundPlayer
                };
              }
              return leaderboardSDK.getLeaderboard(PP.CAUtils._myViverseAppID, leaderboardConfig).then(function(leaderboard) {
                if (!aroundPlayer) {
                  leaderboard.ranking.length = Math.min(leaderboard.ranking.length, scoresAmount);
                }
                let adjustedLeaderboard = [];
                for (let leaderboardEntry of leaderboard.ranking) {
                  adjustedLeaderboard.push({ rank: leaderboardEntry.rank, displayName: leaderboardEntry.name, score: leaderboardEntry.value, accountID: leaderboardEntry.uid });
                }
                return { leaderboard: adjustedLeaderboard };
              }).catch(function() {
                return { leaderboard: null };
              });
            } else {
              if (aroundPlayer) {
                return Promise.resolve({ leaderboard: [] });
              } else {
                return Promise.resolve({ leaderboard: PP.CAUtils.CAError.USER_NOT_LOGGED_IN });
              }
            }
          }
        },
        _submitScore(leaderboardID, scoreToSubmit) {
          if (PP.CAUtils.isHeyVR()) {
            let leaderboardSDK = PP.CAUtils.getLeaderboardSDK();
            return leaderboardSDK.postScore(leaderboardID, scoreToSubmit).then(function() {
              return { scoreSubmitted: true };
            }).catch(function(error) {
              if (error != null && error.status != null && error.status.debug == "err_unauthenticated") {
                return { scoreSubmitted: false };
              } else {
                return { scoreSubmitted: null };
              }
            });
          } else if (PP.CAUtils.isViverse()) {
            let leaderboardSDK = PP.CAUtils.getLeaderboardSDK();
            if (leaderboardSDK != null) {
              return leaderboardSDK.uploadLeaderboardScore(PP.CAUtils._myViverseAppID, [{ name: leaderboardID, value: scoreToSubmit }]).then(function() {
                return { scoreSubmitted: true };
              }).catch(function(error) {
                return { scoreSubmitted: null };
              });
            } else {
              return Promise.resolve({ scoreSubmitted: false });
            }
          }
        },
        _getUser() {
          if (PP.CAUtils.isHeyVR()) {
            let sdk = PP.CAUtils.getSDK();
            return sdk.user.getName().then((result) => {
              return { user: { displayName: result } };
            }).catch(function(error) {
              if (error != null && error.status != null && error.status.debug == "err_unauthenticated") {
                return { user: { displayName: null } };
              } else {
                return { user: null };
              }
            });
          } else if (PP.CAUtils.isViverse()) {
            let sdk = PP.CAUtils.getSDK();
            if (sdk != null) {
              return sdk.checkAuth().then((result) => {
                if (result != null) {
                  return { user: { displayName: result.account_id, accountID: result.account_id } };
                }
                return { user: { displayName: null } };
              }).catch(function(error) {
                return { user: null };
              });
            } else {
              return Promise.resolve({ user: null });
            }
          }
        },
        CAError: {
          NONE: 0,
          CA_SDK_MISSING: 1,
          DUMMY_NOT_INITIALIZED: 2,
          GET_LEADERBOARD_FAILED: 3,
          SUBMIT_SCORE_FAILED: 4,
          GET_USER_FAILED: 5,
          USER_NOT_LOGGED_IN: 6,
          USER_HAS_NO_SCORE: 7
        }
      };
      PP.CADummyServer = class CADummyServer {
        constructor() {
        }
        getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null, caError = PP.CAUtils.CAError.NONE) {
          let leaderboard = null;
          if (caError != PP.CAUtils.CAError.CA_SDK_MISSING) {
            if (aroundPlayer && (caError == PP.CAUtils.CAError.USER_NOT_LOGGED_IN || caError == PP.CAUtils.CAError.USER_HAS_NO_SCORE)) {
              leaderboard = [
                { rank: 0, displayName: "Sign In", score: 0 },
                { rank: 1, displayName: "And", score: 0 },
                { rank: 2, displayName: "Play", score: 0 },
                { rank: 3, displayName: "On", score: 0 },
                { rank: 4, displayName: "HeyVR", score: 0 },
                { rank: 5, displayName: "To", score: 0 },
                { rank: 6, displayName: "Submit", score: 0 },
                { rank: 7, displayName: "Your", score: 0 },
                { rank: 8, displayName: "Own", score: 0 },
                { rank: 9, displayName: "Score", score: 0 }
              ];
            } else {
              leaderboard = [
                { rank: 0, displayName: "An", score: 0 },
                { rank: 1, displayName: "Error", score: 0 },
                { rank: 2, displayName: "Has", score: 0 },
                { rank: 3, displayName: "Occurred", score: 0 },
                { rank: 4, displayName: "While", score: 0 },
                { rank: 5, displayName: "Trying", score: 0 },
                { rank: 6, displayName: "To", score: 0 },
                { rank: 7, displayName: "Retrieve", score: 0 },
                { rank: 8, displayName: "The", score: 0 },
                { rank: 9, displayName: "Leaderboard", score: 0 }
              ];
            }
          } else {
            if (aroundPlayer) {
              leaderboard = [
                { rank: 0, displayName: "Sign In", score: 0 },
                { rank: 1, displayName: "And", score: 0 },
                { rank: 2, displayName: "Play", score: 0 },
                { rank: 3, displayName: "On", score: 0 },
                { rank: 4, displayName: "HeyVR", score: 0 },
                { rank: 5, displayName: "To", score: 0 },
                { rank: 6, displayName: "Submit", score: 0 },
                { rank: 7, displayName: "Your", score: 0 },
                { rank: 8, displayName: "Own", score: 0 },
                { rank: 9, displayName: "Score", score: 0 }
              ];
            } else {
              leaderboard = [
                { rank: 0, displayName: "The", score: 0 },
                { rank: 1, displayName: "Top 10", score: 0 },
                { rank: 2, displayName: "Leaderboard", score: 0 },
                { rank: 3, displayName: "Is", score: 0 },
                { rank: 4, displayName: "Available", score: 0 },
                { rank: 5, displayName: "Only", score: 0 },
                { rank: 5, displayName: "When", score: 0 },
                { rank: 7, displayName: "Playing", score: 0 },
                { rank: 8, displayName: "On", score: 0 },
                { rank: 9, displayName: "HeyVR", score: 0 }
              ];
            }
          }
          while (leaderboard.length > scoresAmount) {
            leaderboard.pop();
          }
          if (onDoneCallback != null) {
            onDoneCallback(leaderboard);
          }
        }
        submitScore(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null, caError = PP.CAUtils.CAError.NONE) {
          if (onDoneCallback != null) {
            onDoneCallback();
          }
        }
        getUser(onDoneCallback = null, onErrorCallback = null, caError = PP.CAUtils.CAError.NONE) {
          let user = {};
          user.displayName = "Jonathan";
          if (onDoneCallback != null) {
            onDoneCallback(user);
          }
        }
      };
    }
  });

  // js/pp/input/cauldron/finger_cursor.js
  var require_finger_cursor2 = __commonJS({
    "js/pp/input/cauldron/finger_cursor.js"() {
      WL.registerComponent("pp-finger-cursor", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myEnableMultipleClicks: { type: WL.Type.Bool, default: true },
        _myCollisionGroup: { type: WL.Type.Int, default: 1 },
        _myCollisionSize: { type: WL.Type.Float, default: 0.0125 },
        _myCursorObject: { type: WL.Type.Object, default: null }
      }, {
        init: function() {
          this._myLastTarget = null;
          this._myReferenceSpace = null;
          this._myHandInputSource = null;
          this._myHandednessString = ["left", "right"][this._myHandedness];
          this._myDoubleClickTimer = 0;
          this._myTripleClickTimer = 0;
          this._myMultipleClickObject = null;
          this._myMultipleClickDelay = 0.3;
        },
        start: function() {
          this._myCursorObjectRoot = WL.scene.addObject(this.object);
          if (this._myCursorObject == null) {
            this._myCursorObject = this._myCursorObjectRoot.pp_addObject();
          } else {
            this._myCursorObject.pp_setParent(this._myCursorObjectRoot);
          }
          this._myCollisionComponent = this._myCursorObject.addComponent("collision");
          this._myCollisionComponent.collider = WL.Collider.Sphere;
          this._myCollisionComponent.group = 1 << this._myCollisionGroup;
          this._myCollisionComponent.extents = PP.vec3_create(this._myCollisionSize, this._myCollisionSize, this._myCollisionSize);
          if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        },
        update: function(dt) {
          if (this._myDoubleClickTimer > 0) {
            this._myDoubleClickTimer -= dt;
          }
          if (this._myTripleClickTimer > 0) {
            this._myTripleClickTimer -= dt;
          }
          this._myCursorObjectRoot.pp_setTransformQuat(PP.myPlayerObjects.myPlayerPivot.pp_getTransformQuat());
          this._updateHand();
          if (this._myHandInputSource) {
            let overlaps = this._myCollisionComponent.queryOverlaps();
            let overlapTarget = null;
            for (let i = 0; i < overlaps.length; ++i) {
              let object = overlaps[i].object;
              let target = object.getComponent("cursor-target");
              if (target && (overlapTarget == null || !target.isSurface)) {
                overlapTarget = target;
                if (!target.isSurface) {
                  break;
                }
              }
            }
            if (!overlapTarget) {
              this._targetTouchEnd();
            } else if (!overlapTarget.equals(this._myLastTarget)) {
              this._targetTouchEnd();
              this._myLastTarget = overlapTarget;
              this._targetTouchStart();
            }
          } else {
            this._targetTouchEnd();
          }
        },
        _targetTouchStart: function() {
          this._myLastTarget.onHover(this._myLastTarget.object, this);
          this._myLastTarget.onDown(this._myLastTarget.object, this);
        },
        _targetTouchEnd: function() {
          if (this._myLastTarget) {
            if (this._myEnableMultipleClicks && this._myTripleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject.equals(this._myLastTarget.object)) {
              this._myLastTarget.onTripleClick(this._myLastTarget.object, this);
              this._myTripleClickTimer = 0;
            } else if (this._myEnableMultipleClicks && this._myDoubleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject.equals(this._myLastTarget.object)) {
              this._myLastTarget.onDoubleClick(this._myLastTarget.object, this);
              this._myTripleClickTimer = this._myMultipleClickDelay;
              this._myDoubleClickTimer = 0;
            } else {
              this._myLastTarget.onClick(this._myLastTarget.object, this);
              this._myTripleClickTimer = 0;
              this._myDoubleClickTimer = this._myMultipleClickDelay;
              this._myMultipleClickObject = this._myLastTarget.object;
            }
            this._myLastTarget.onUp(this._myLastTarget.object, this);
            this._myLastTarget.onUnhover(this._myLastTarget.object, this);
            this._myLastTarget = null;
          }
        },
        onActivate: function() {
          this._myCursorObjectRoot.pp_setActive(true);
        },
        onDeactivate: function() {
          if (this._myCursorObjectRoot != null) {
            this._myCursorObjectRoot.pp_setActive(false);
          }
        },
        _updateHand() {
          this._myHandInputSource = PP.InputUtils.getInputSource(this._myHandednessString, PP.InputSourceType.TRACKED_HAND);
          if (this._myHandInputSource) {
            let tip = null;
            try {
              tip = Module["webxr_frame"].getJointPose(this._myHandInputSource.hand.get("index-finger-tip"), this._myReferenceSpace);
            } catch (error) {
            }
            if (tip) {
              this._myCursorObject.pp_setRotationLocalQuat([
                tip.transform.orientation.x,
                tip.transform.orientation.y,
                tip.transform.orientation.z,
                tip.transform.orientation.w
              ]);
              this._myCursorObject.pp_setPositionLocal([
                tip.transform.position.x,
                tip.transform.position.y,
                tip.transform.position.z
              ]);
            }
          }
        },
        _onXRSessionStart: function(session) {
          session.requestReferenceSpace(WebXR.refSpace).then(function(referenceSpace) {
            this._myReferenceSpace = referenceSpace;
          }.bind(this));
        },
        _onXRSessionEnd: function(session) {
          this._myReferenceSpace = null;
        }
      });
    }
  });

  // js/pp/input/cauldron/input_types.js
  var require_input_types = __commonJS({
    "js/pp/input/cauldron/input_types.js"() {
      PP.Handedness = {
        LEFT: "left",
        RIGHT: "right"
      };
      PP.HandednessIndex = {
        LEFT: 0,
        RIGHT: 1
      };
      PP.InputSourceType = {
        GAMEPAD: 0,
        TRACKED_HAND: 1
      };
      PP.TrackedHandJointID = {
        WRIST: "wrist",
        THUMB_METACARPAL: "thumb-metacarpal",
        THUMB_PHALANX_PROXIMAL: "thumb-phalanx-proximal",
        THUMB_PHALANX_DISTAL: "thumb-phalanx-distal",
        THUMB_TIP: "thumb-tip",
        INDEX_FINGER_METACARPAL: "index-finger-metacarpal",
        INDEX_FINGER_PHALANX_PROXIMAL: "index-finger-phalanx-proximal",
        INDEX_FINGER_PHALANX_INTERMEDIATE: "index-finger-phalanx-intermediate",
        INDEX_FINGER_PHALANX_DISTAL: "index-finger-phalanx-distal",
        INDEX_FINGER_TIP: "index-finger-tip",
        MIDDLE_FINGER_METACARPAL: "middle-finger-metacarpal",
        MIDDLE_FINGER_PHALANX_PROXIMAL: "middle-finger-phalanx-proximal",
        MIDDLE_FINGER_PHALANX_INTERMEDIATE: "middle-finger-phalanx-intermediate",
        MIDDLE_FINGER_PHALANX_DISTAL: "middle-finger-phalanx-distal",
        MIDDLE_FINGER_TIP: "middle-finger-tip",
        RING_FINGER_METACARPAL: "ring-finger-metacarpal",
        RING_FINGER_PHALANX_PROXIMAL: "ring-finger-phalanx-proximal",
        RING_FINGER_PHALANX_INTERMEDIATE: "ring-finger-phalanx-intermediate",
        RING_FINGER_PHALANX_DISTAL: "ring-finger-phalanx-distal",
        RING_FINGER_TIP: "ring-finger-tip",
        PINKY_FINGER_METACARPAL: "pinky-finger-metacarpal",
        PINKY_FINGER_PHALANX_PROXIMAL: "pinky-finger-phalanx-proximal",
        PINKY_FINGER_PHALANX_INTERMEDIATE: "pinky-finger-phalanx-intermediate",
        PINKY_FINGER_PHALANX_DISTAL: "pinky-finger-phalanx-distal",
        PINKY_FINGER_TIP: "pinky-finger-tip"
      };
      PP.TrackedHandJointIDIndex = {
        WRIST: 0,
        THUMB_METACARPAL: 1,
        THUMB_PHALANX_PROXIMAL: 2,
        THUMB_PHALANX_DISTAL: 3,
        THUMB_TIP: 4,
        INDEX_FINGER_METACARPAL: 5,
        INDEX_FINGER_PHALANX_PROXIMAL: 6,
        INDEX_FINGER_PHALANX_INTERMEDIATE: 7,
        INDEX_FINGER_PHALANX_DISTAL: 8,
        INDEX_FINGER_TIP: 9,
        MIDDLE_FINGER_METACARPAL: 10,
        MIDDLE_FINGER_PHALANX_PROXIMAL: 11,
        MIDDLE_FINGER_PHALANX_INTERMEDIATE: 12,
        MIDDLE_FINGER_PHALANX_DISTAL: 13,
        MIDDLE_FINGER_TIP: 14,
        RING_FINGER_METACARPAL: 15,
        RING_FINGER_PHALANX_PROXIMAL: 16,
        RING_FINGER_PHALANX_INTERMEDIATE: 17,
        RING_FINGER_PHALANX_DISTAL: 18,
        RING_FINGER_TIP: 19,
        PINKY_FINGER_METACARPAL: 20,
        PINKY_FINGER_PHALANX_PROXIMAL: 21,
        PINKY_FINGER_PHALANX_INTERMEDIATE: 22,
        PINKY_FINGER_PHALANX_DISTAL: 23,
        PINKY_FINGER_TIP: 24
      };
    }
  });

  // js/pp/input/cauldron/input_utils.js
  var require_input_utils = __commonJS({
    "js/pp/input/cauldron/input_utils.js"() {
      PP.InputUtils = {
        getHandednessByIndex: function(index) {
          let handedness = null;
          switch (index) {
            case PP.HandednessIndex.LEFT:
              handedness = PP.Handedness.LEFT;
              break;
            case PP.HandednessIndex.RIGHT:
              handedness = PP.Handedness.RIGHT;
              break;
          }
          return handedness;
        },
        getInputSource: function(handedness, inputSourceType) {
          let inputSource = null;
          if (WL.xrSession && WL.xrSession.inputSources) {
            for (let i = 0; i < WL.xrSession.inputSources.length; i++) {
              let input = WL.xrSession.inputSources[i];
              let isCorrectType = !inputSourceType || inputSourceType == PP.InputSourceType.GAMEPAD && !input.hand || inputSourceType == PP.InputSourceType.TRACKED_HAND && input.hand;
              if (isCorrectType && input.handedness == handedness) {
                inputSource = input;
                break;
              }
            }
          }
          return inputSource;
        },
        getInputSourceTypeByHandedness: function(handedness) {
          let inputSource = PP.InputUtils.getInputSource(handedness);
          return PP.InputUtils.getInputSourceType(inputSource);
        },
        getInputSourceType: function(inputSource) {
          let inputSourceType = null;
          if (inputSource) {
            if (inputSource.hand) {
              inputSourceType = PP.InputSourceType.TRACKED_HAND;
            } else {
              inputSourceType = PP.InputSourceType.GAMEPAD;
            }
          }
          return inputSourceType;
        },
        getOppositeHandedness: function(handedness) {
          let oppositeHandedness = null;
          switch (handedness) {
            case PP.Handedness.LEFT:
              oppositeHandedness = PP.Handedness.RIGHT;
              break;
            case PP.Handedness.RIGHT:
              oppositeHandedness = PP.Handedness.LEFT;
              break;
          }
          return oppositeHandedness;
        },
        getJointIDByIndex: function(index) {
          let jointID = null;
          let jointIDKey = null;
          for (let jointIDIndexKey in PP.TrackedHandJointIDIndex) {
            if (PP.TrackedHandJointIDIndex[jointIDIndexKey] == index) {
              jointIDKey = jointIDIndexKey;
              break;
            }
          }
          if (jointIDKey != null) {
            jointID = PP.TrackedHandJointID[jointIDKey];
          }
          return jointID;
        }
      };
    }
  });

  // js/pp/input/cauldron/keyboard.js
  var require_keyboard = __commonJS({
    "js/pp/input/cauldron/keyboard.js"() {
      PP.KeyID = {
        _0: "0",
        _1: "1",
        _2: "2",
        _3: "3",
        _4: "4",
        _5: "5",
        _6: "6",
        _7: "7",
        _8: "8",
        _9: "9",
        A: "A",
        B: "B",
        C: "C",
        D: "D",
        E: "E",
        F: "F",
        G: "G",
        H: "H",
        I: "I",
        J: "J",
        K: "K",
        L: "L",
        M: "M",
        N: "N",
        O: "O",
        P: "P",
        Q: "Q",
        R: "R",
        S: "S",
        T: "T",
        U: "U",
        V: "V",
        W: "W",
        X: "X",
        Y: "Y",
        Z: "Z",
        a: "a",
        b: "b",
        c: "c",
        d: "d",
        e: "e",
        f: "f",
        g: "g",
        h: "h",
        i: "i",
        j: "j",
        k: "k",
        l: "l",
        m: "m",
        n: "n",
        o: "o",
        p: "p",
        q: "q",
        r: "r",
        s: "s",
        t: "t",
        u: "u",
        v: "v",
        w: "w",
        x: "x",
        y: "y",
        z: "z",
        UP: "ArrowUp",
        DOWN: "ArrowDown",
        LEFT: "ArrowLeft",
        RIGHT: "ArrowRight",
        SPACE: " ",
        ENTER: "Enter",
        BACKSPACE: "Backspace",
        ESC: "Escape",
        SHIFT_LEFT: "ShiftLeft",
        SHIFT_RIGHT: "ShiftRight",
        CONTROL_LEFT: "ControlLeft",
        CONTROL_RIGHT: "ControlRight",
        ALT_LEFT: "AltLeft",
        ALT_RIGHT: "AltRight"
      };
      PP.Keyboard = class Keyboard {
        constructor() {
          this._myKeyInfos = /* @__PURE__ */ new Map();
          for (let key in PP.KeyID) {
            this.addKey(PP.KeyID[key]);
          }
        }
        isKeyPressed(keyID) {
          let isPressed = false;
          if (this._myKeyInfos.has(keyID)) {
            isPressed = this._myKeyInfos.get(keyID).myIsPressed;
          }
          return isPressed;
        }
        isKeyPressStart(keyID) {
          let isPressStart = false;
          if (this._myKeyInfos.has(keyID)) {
            isPressStart = this._myKeyInfos.get(keyID).myIsPressStart;
          }
          return isPressStart;
        }
        isKeyPressEnd(keyID) {
          let isPressEnd = false;
          if (this._myKeyInfos.has(keyID)) {
            isPressEnd = this._myKeyInfos.get(keyID).myIsPressEnd;
          }
          return isPressEnd;
        }
        addKey(keyID) {
          this._myKeyInfos.set(keyID, this._createKeyInfo());
        }
        start() {
          window.addEventListener("keydown", this._keyDown.bind(this));
          window.addEventListener("keyup", this._keyUp.bind(this));
        }
        update(dt) {
          if (!document.hasFocus()) {
            for (let keyInfo of this._myKeyInfos.values()) {
              if (keyInfo.myIsPressed) {
                keyInfo.myIsPressed = false;
                keyInfo.myIsPressEndToProcess = true;
              }
            }
          }
          for (let keyInfo of this._myKeyInfos.values()) {
            keyInfo.myIsPressStart = keyInfo.myIsPressStartToProcess;
            keyInfo.myIsPressEnd = keyInfo.myIsPressEndToProcess;
            keyInfo.myIsPressStartToProcess = false;
            keyInfo.myIsPressEndToProcess = false;
          }
        }
        _keyDown(event) {
          this._keyPressedChanged(event.key, true);
          if (event.key != event.code) {
            this._keyPressedChanged(event.code, true);
          }
        }
        _keyUp(event) {
          this._keyPressedChanged(event.key, false);
          if (event.key != event.code) {
            this._keyPressedChanged(event.code, false);
          }
        }
        _keyPressedChanged(keyID, isPressed) {
          if (this._myKeyInfos.has(keyID)) {
            let keyInfo = this._myKeyInfos.get(keyID);
            if (isPressed) {
              keyInfo.myIsPressed = true;
              keyInfo.myIsPressStartToProcess = true;
            } else {
              keyInfo.myIsPressed = false;
              keyInfo.myIsPressEndToProcess = true;
            }
          }
        }
        _createKeyInfo() {
          return { myIsPressed: false, myIsPressStart: false, myIsPressStartToProcess: false, myIsPressEnd: false, myIsPressEndToProcess: false };
        }
      };
    }
  });

  // js/pp/input/cauldron/mouse.js
  var require_mouse = __commonJS({
    "js/pp/input/cauldron/mouse.js"() {
      PP.MouseButtonID = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
      };
      PP.Mouse = class Mouse {
        constructor() {
          this._myButtonInfos = /* @__PURE__ */ new Map();
          for (let key in PP.MouseButtonID) {
            this._myButtonInfos.set(PP.MouseButtonID[key], this._createButtonInfo());
          }
          this._myPreventContextMenuCallback = this._preventContextMenu.bind(this);
          this._myPreventMiddleButtonScrollCallback = this._preventMiddleButtonScroll.bind(this);
          this._myInternalMousePosition = PP.vec2_create();
          this._myScreenSize = PP.vec2_create();
          this._updateScreenSize();
          this._myResetMovingDelay = 0.15;
          this._myResetMovingTimer = new PP.Timer(this._myResetMovingDelay, false);
          this._myIsMoving = false;
          this._myIsInsideView = false;
          this._myIsValid = false;
          this._myPointerUpOnPointerLeave = true;
          this._myContextMenuActive = true;
          this._myMiddleButtonScrollActive = true;
          this._myPointerID = null;
          this._myLastValidPointerEvent = null;
          this._myPointerEventValidCallbacks = /* @__PURE__ */ new Map();
          this._myProjectionMatrixInverse = PP.mat4_create();
          this._myRotationQuat = PP.quat_create();
          this._myOriginWorld = PP.vec3_create();
          this._myDirectionWorld = PP.vec3_create();
        }
        start() {
          this._myOnPointerMoveCallback = this._onPointerAction.bind(this, this._onPointerMove.bind(this));
          document.body.addEventListener("pointermove", this._myOnPointerMoveCallback);
          this._myOnPointerDownCallback = this._onPointerAction.bind(this, this._onPointerDown.bind(this));
          document.body.addEventListener("pointerdown", this._myOnPointerDownCallback);
          this._myOnPointerUpCallback = this._onPointerAction.bind(this, this._onPointerUp.bind(this));
          document.body.addEventListener("pointerup", this._myOnPointerUpCallback);
          this._myOnPointerLeaveCallback = this._onPointerLeave.bind(this);
          document.body.addEventListener("pointerleave", this._myOnPointerLeaveCallback);
          this._myOnPointerEnterCallback = this._onPointerEnter.bind(this);
          document.body.addEventListener("pointerenter", this._myOnPointerEnterCallback);
          this._myOnMouseDownCallback = this._onMouseAction.bind(this, this._onPointerDown.bind(this));
          document.body.addEventListener("mousedown", this._myOnMouseDownCallback);
          this._myOnMouseUpCallback = this._onMouseAction.bind(this, this._onPointerUp.bind(this));
          document.body.addEventListener("mouseup", this._myOnMouseUpCallback);
        }
        update(dt) {
          if (this._myResetMovingTimer.isRunning()) {
            this._myResetMovingTimer.update(dt);
            if (this._myResetMovingTimer.isDone()) {
              this._myResetMovingTimer.reset();
              this._myIsMoving = false;
            }
          }
          for (let buttonInfo of this._myButtonInfos.values()) {
            buttonInfo.myIsPressStart = buttonInfo.myIsPressStartToProcess;
            buttonInfo.myIsPressEnd = buttonInfo.myIsPressEndToProcess;
            buttonInfo.myIsPressStartToProcess = false;
            buttonInfo.myIsPressEndToProcess = false;
          }
          this._updateScreenSize();
          if (!this.isAnyButtonPressed() && !this._myIsMoving) {
            this._myPointerID = null;
          }
          if (this._myLastValidPointerEvent != null) {
            let isLastValidPointerEventStillValid = this._isPointerEventValid(this._myLastValidPointerEvent);
            if (!isLastValidPointerEventStillValid) {
              if (this._myIsInsideView) {
                this._onPointerLeave(this._myLastValidPointerEvent);
              }
              this._myLastValidPointerEvent = null;
            }
          }
        }
        destroy() {
          document.body.removeEventListener("pointermove", this._myOnPointerMoveCallback);
          document.body.removeEventListener("pointerdown", this._myOnPointerDownCallback);
          document.body.removeEventListener("pointerup", this._myOnPointerUpCallback);
          document.body.removeEventListener("pointerleave", this._myOnPointerLeaveCallback);
          document.body.removeEventListener("pointerenter", this._myOnPointerEnterCallback);
          document.body.removeEventListener("mousedown", this._myOnMouseDownCallback);
          document.body.removeEventListener("mouseup", this._myOnMouseUpCallback);
          document.body.removeEventListener("contextmenu", this._myPreventContextMenuCallback);
          document.body.removeEventListener("mousedown", this._myPreventMiddleButtonScrollCallback);
        }
        isValid() {
          return this._myIsValid;
        }
        isButtonPressed(buttonID) {
          let isPressed = false;
          if (this._myButtonInfos.has(buttonID)) {
            isPressed = this._myButtonInfos.get(buttonID).myIsPressed;
          }
          return isPressed;
        }
        isAnyButtonPressed() {
          let isPressed = false;
          for (let buttonInfo of this._myButtonInfos.values()) {
            if (buttonInfo.myIsPressed) {
              isPressed = true;
              break;
            }
          }
          return isPressed;
        }
        isButtonPressStart(buttonID) {
          let isPressStart = false;
          if (this._myButtonInfos.has(buttonID)) {
            isPressStart = this._myButtonInfos.get(buttonID).myIsPressStart;
          }
          return isPressStart;
        }
        isButtonPressEnd(buttonID = null) {
          let isPressEnd = false;
          if (this._myButtonInfos.has(buttonID)) {
            isPressEnd = this._myButtonInfos.get(buttonID).myIsPressEnd;
          }
          return isPressEnd;
        }
        isMoving() {
          return this._myIsMoving;
        }
        isInsideView() {
          return this._myIsInsideView;
        }
        isTargetingRenderCanvas() {
          return this.isInsideView() && this._myLastValidPointerEvent != null && this._myLastValidPointerEvent.target == WL.canvas;
        }
        // the origin and direction are set by the mouse
        raycastWorld(raycastSetup, raycastResults = new PP.RaycastResults()) {
          this.getOriginWorld(raycastSetup.myOrigin);
          this.getDirectionWorld(raycastSetup.myDirection);
          raycastResults = PP.PhysicsUtils.raycast(raycastSetup, raycastResults);
          return raycastResults;
        }
        getPositionScreen(out = PP.vec2_create()) {
          let mousePosition = out;
          mousePosition[0] = this._myInternalMousePosition[0];
          mousePosition[1] = this._myScreenSize[1] - 1 - this._myInternalMousePosition[1];
          return mousePosition;
        }
        getPositionScreenNormalized(out = PP.vec2_create()) {
          let mousePosition = out;
          mousePosition[0] = this._myScreenSize[0] == 0 ? 0 : this._myInternalMousePosition[0] / this._myScreenSize[0] * 2 - 1;
          mousePosition[1] = this._myScreenSize[1] == 0 ? 0 : (this._myScreenSize[1] - 1 - this._myInternalMousePosition[1]) / this._myScreenSize[1] * 2 - 1;
          return mousePosition;
        }
        getScreenSize() {
          return this._myScreenSize;
        }
        getPositionWorld(distanceFromCamera, out = PP.vec3_create()) {
          let originWorld = this.getOriginWorld(this._myOriginWorld);
          let directionWorld = this.getDirectionWorld(this._myDirectionWorld);
          out = originWorld.vec3_add(directionWorld.vec3_scale(distanceFromCamera, out), out);
          return out;
        }
        getOriginWorld(out = PP.vec3_create()) {
          if (PP.XRUtils.isSessionActive()) {
            PP.myPlayerObjects.myEyeLeft.pp_getPosition(out);
          } else {
            PP.myPlayerObjects.myNonVRCamera.pp_getPosition(out);
          }
          return out;
        }
        getDirectionWorld(out = PP.vec3_create()) {
          let right = this._myInternalMousePosition[0] / this._myScreenSize[0];
          let up = this._myInternalMousePosition[1] / this._myScreenSize[1];
          let directionLocal = out;
          directionLocal.vec3_set(right * 2 - 1, -up * 2 + 1, -1);
          let projectionMatrixInvert = this._myProjectionMatrixInverse;
          if (PP.XRUtils.isSessionActive()) {
            projectionMatrixInvert = PP.myPlayerObjects.myEyeLeft.pp_getComponentHierarchy("view").projectionMatrix.mat4_invert(projectionMatrixInvert);
          } else {
            projectionMatrixInvert = PP.myPlayerObjects.myNonVRCamera.pp_getComponentHierarchy("view").projectionMatrix.mat4_invert(projectionMatrixInvert);
          }
          directionLocal.vec3_transformMat4(projectionMatrixInvert, directionLocal);
          directionLocal.vec3_normalize(directionLocal);
          let directionWorld = directionLocal;
          if (PP.XRUtils.isSessionActive()) {
            directionWorld = directionLocal.vec3_transformQuat(PP.myPlayerObjects.myEyeLeft.pp_getRotationQuat(this._myRotationQuat), directionLocal);
          } else {
            directionWorld = directionLocal.vec3_transformQuat(PP.myPlayerObjects.myNonVRCamera.pp_getRotationQuat(this._myRotationQuat), directionLocal);
          }
          directionWorld.vec3_normalize(directionWorld);
          return out;
        }
        setTouchValid(touchValid) {
          let callbackID = "internal_touch_valid_callback";
          if (touchValid) {
            this.removePointerEventValidCallback(callbackID);
          } else {
            this.addPointerEventValidCallback(callbackID, function(event) {
              return event.pointerType == "mouse";
            });
          }
        }
        setTargetOnlyRenderCanvas(targetOnlyRenderCanvas) {
          let callbackID = "internal_target_only_render_canvas_callback";
          if (targetOnlyRenderCanvas) {
            this.addPointerEventValidCallback(callbackID, function(event) {
              return event.target == WL.canvas;
            });
          } else {
            this.removePointerEventValidCallback(callbackID);
          }
        }
        getLastValidPointerEvent() {
          return this._myLastValidPointerEvent;
        }
        // can be used to specify that only some pointerType are valid (eg: mouse, touch, pen) or just some target (eg: WL.canvas)
        addPointerEventValidCallback(id, callback) {
          this._myPointerEventValidCallbacks.set(id, callback);
        }
        removePointerEventValidCallback(id) {
          this._myPointerEventValidCallbacks.delete(id);
        }
        isPointerUpOnPointerLeave() {
          return this._myPointerUpOnPointerLeave;
        }
        setPointerUpOnPointerLeave(pointerUpOnPointerLeave) {
          this._myPointerUpOnPointerLeave = pointerUpOnPointerLeave;
        }
        isContextMenuActive() {
          return this._myContextMenuActive;
        }
        setContextMenuActive(active) {
          if (this._myContextMenuActive != active) {
            if (active) {
              document.body.removeEventListener("contextmenu", this._myPreventContextMenuCallback);
            } else {
              document.body.addEventListener("contextmenu", this._myPreventContextMenuCallback, false);
            }
            this._myContextMenuActive = active;
          }
        }
        isMiddleButtonScrollActive() {
          return this._myMiddleButtonScrollActive;
        }
        setMiddleButtonScrollActive(active) {
          if (this._myMiddleButtonScrollActive != active) {
            if (active) {
              document.body.removeEventListener("mousedown", this._myPreventMiddleButtonScrollCallback);
            } else {
              document.body.addEventListener("mousedown", this._myPreventMiddleButtonScrollCallback, false);
            }
            this._myMiddleButtonScrollActive = active;
          }
        }
        setResetMovingDelay(delay) {
          this._myResetMovingDelay = delay;
        }
        getResetMovingDelay() {
          return this._myResetMovingDelay;
        }
        _onPointerAction(actionCallback, event) {
          if (!this._isPointerEventIDValid(event))
            return;
          if (!this._isPointerEventValid(event)) {
            if (this._myIsInsideView) {
              this._onPointerLeave(event);
            }
            return;
          }
          if (!this._myIsInsideView) {
            this._onPointerEnter(event);
          }
          actionCallback(event);
          this._updatePositionAndScreen(event);
          this._updatePointerData(event);
        }
        _onMouseAction(actionCallback, event) {
          if (!this._myIsInsideView)
            return;
          if (!this._isMouseAllowed())
            return;
          if (!this._isPointerEventIDValid(this._myLastValidPointerEvent))
            return;
          if (!this._isPointerEventValid(this._myLastValidPointerEvent))
            return;
          actionCallback(event);
        }
        _onPointerMove(event) {
          this._myResetMovingTimer.start(this._myResetMovingDelay);
          this._myIsMoving = true;
        }
        _onPointerDown(event) {
          let buttonInfo = this._myButtonInfos.get(event.button);
          if (!buttonInfo.myIsPressed) {
            buttonInfo.myIsPressed = true;
            buttonInfo.myIsPressStartToProcess = true;
          }
        }
        _onPointerUp(event) {
          let buttonInfo = this._myButtonInfos.get(event.button);
          if (buttonInfo.myIsPressed) {
            buttonInfo.myIsPressed = false;
            buttonInfo.myIsPressEndToProcess = true;
          }
        }
        _onPointerLeave(event) {
          if (!this._myIsInsideView || this._myLastValidPointerEvent == null || event.pointerId != this._myLastValidPointerEvent.pointerId)
            return;
          this._myIsInsideView = false;
          this._myIsMoving = false;
          if (this._myPointerUpOnPointerLeave) {
            for (let buttonInfo of this._myButtonInfos.values()) {
              if (buttonInfo.myIsPressed) {
                buttonInfo.myIsPressed = false;
                buttonInfo.myIsPressEndToProcess = true;
              }
            }
          }
          this._myPointerID = null;
        }
        _onPointerEnter(event) {
          if (this._myIsInsideView && this._myPointerID != null || !this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
            return;
          this._myIsInsideView = true;
          this._updatePositionAndScreen(event);
          this._updatePointerData(event);
        }
        _preventContextMenu(event) {
          if (!this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
            return;
          event.preventDefault();
        }
        _preventMiddleButtonScroll(event) {
          if (!this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
            return;
          if (event.button == 1) {
            event.preventDefault();
            return false;
          }
        }
        _updatePositionAndScreen(event) {
          this._updateScreenSize();
          this._myInternalMousePosition[0] = event.clientX;
          this._myInternalMousePosition[1] = event.clientY;
          this._myIsValid = true;
        }
        _updateScreenSize() {
          let bounds = document.body.getBoundingClientRect();
          this._myScreenSize[0] = bounds.width;
          this._myScreenSize[1] = bounds.height;
        }
        _updatePointerData(event) {
          this._myPointerID = event.pointerId;
          this._myLastValidPointerEvent = event;
        }
        _isPointerEventIDValid(event) {
          if (event == null)
            return false;
          return this._myPointerID == null || this._myPointerID == event.pointerId;
        }
        _isPointerEventValid(event) {
          if (event == null)
            return false;
          let isValid = true;
          for (let callback of this._myPointerEventValidCallbacks.values()) {
            if (!callback(event)) {
              isValid = false;
              break;
            }
          }
          return isValid;
        }
        _isMouseAllowed() {
          return this._myLastValidPointerEvent != null && this._myLastValidPointerEvent.pointerId == 1;
        }
        _createButtonInfo() {
          return { myIsPressed: false, myIsPressStart: false, myIsPressStartToProcess: false, myIsPressEnd: false, myIsPressEndToProcess: false };
        }
      };
    }
  });

  // js/pp/input/cauldron/input_manager.js
  var require_input_manager = __commonJS({
    "js/pp/input/cauldron/input_manager.js"() {
      PP.InputManager = class InputManager {
        constructor() {
          this._myMouse = new PP.Mouse();
          this._myKeyboard = new PP.Keyboard();
          this._myGamepadManager = new PP.GamepadManager();
        }
        start() {
          this._myMouse.start();
          this._myKeyboard.start();
          this._myGamepadManager.start();
        }
        update(dt) {
          this._myMouse.update(dt);
          this._myKeyboard.update(dt);
          this._myGamepadManager.update(dt);
        }
        getMouse() {
          return this._myMouse;
        }
        getKeyboard() {
          return this._myKeyboard;
        }
        getGamepadManager() {
          return this._myGamepadManager;
        }
      };
    }
  });

  // js/pp/input/cauldron/input_manager_component.js
  var require_input_manager_component = __commonJS({
    "js/pp/input/cauldron/input_manager_component.js"() {
      WL.registerComponent("pp-input-manager", {
        _myGamepadFixForward: { type: WL.Type.Bool, default: true },
        _myMousePreventContextMenu: { type: WL.Type.Bool, default: true },
        _myMousePreventMiddleButtonScroll: { type: WL.Type.Bool, default: true }
      }, {
        init() {
          this._myInputManager = new PP.InputManager();
          PP.myInputManager = this._myInputManager;
          PP.myMouse = this._myInputManager.getMouse();
          PP.myKeyboard = this._myInputManager.getKeyboard();
          PP.myGamepadManager = this._myInputManager.getGamepadManager();
          PP.myGamepads = PP.myGamepadManager.getGamepads();
          PP.myLeftGamepad = PP.myGamepadManager.getLeftGamepad();
          PP.myRightGamepad = PP.myGamepadManager.getRightGamepad();
        },
        start() {
          this._myInputManager.start();
          this._setupMousePrevent();
          this._addGamepadCores();
        },
        update(dt) {
          this._myInputManager.update(dt);
        },
        _setupMousePrevent() {
          if (this._myMousePreventContextMenu) {
            PP.myMouse.setContextMenuActive(false);
          }
          if (this._myMousePreventMiddleButtonScroll) {
            PP.myMouse.setMiddleButtonScrollActive(false);
          }
        },
        _addGamepadCores() {
          let handPoseParams = new PP.HandPoseParams();
          handPoseParams.myReferenceObject = PP.myPlayerObjects.myPlayerPivot;
          handPoseParams.myFixForward = this._myFixForward;
          handPoseParams.myForceEmulatedVelocities = false;
          let leftXRGamepadCore = new PP.XRGamepadCore(PP.Handedness.LEFT, handPoseParams);
          let rightXRGamepadCore = new PP.XRGamepadCore(PP.Handedness.RIGHT, handPoseParams);
          PP.myLeftGamepad.addGamepadCore("left_xr_gamepad", leftXRGamepadCore);
          PP.myRightGamepad.addGamepadCore("right_xr_gamepad", rightXRGamepadCore);
          let leftKeyboardGamepadCore = new PP.KeyboardGamepadCore(PP.Handedness.LEFT, leftXRGamepadCore.getHandPose());
          let rightKeyboardGamepadCore = new PP.KeyboardGamepadCore(PP.Handedness.RIGHT, rightXRGamepadCore.getHandPose());
          PP.myLeftGamepad.addGamepadCore("left_keyboard_gamepad", leftKeyboardGamepadCore);
          PP.myRightGamepad.addGamepadCore("right_keyboard_gamepad", rightKeyboardGamepadCore);
        }
      });
      PP.myInputManager = null;
      PP.myMouse = null;
      PP.myKeyboard = null;
      PP.myGamepadManager = null;
      PP.myGamepads = null;
      PP.myLeftGamepad = null;
      PP.myRightGamepad = null;
    }
  });

  // js/pp/input/cauldron/switch_hand_object.js
  var require_switch_hand_object = __commonJS({
    "js/pp/input/cauldron/switch_hand_object.js"() {
      WL.registerComponent("pp-switch-hand-object", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myGamepad: { type: WL.Type.Object },
        _myTrackedHand: { type: WL.Type.Object }
      }, {
        init: function() {
        },
        start: function() {
          this._myHandednessType = PP.InputUtils.getHandednessByIndex(this._myHandedness);
          this._myFirstUpdate = true;
          this._myCurrentInputSourceType = null;
        },
        onActivate() {
          this._myFirstUpdate = true;
        },
        update: function(dt) {
          if (this._myFirstUpdate) {
            this._myFirstUpdate = false;
            this._start();
          }
          let inputSourceType = PP.InputUtils.getInputSourceTypeByHandedness(this._myHandednessType);
          if (inputSourceType != null && this._myCurrentInputSourceType != inputSourceType) {
            this._myCurrentInputSourceType = inputSourceType;
            if (inputSourceType == PP.InputSourceType.TRACKED_HAND) {
              if (this._myGamepad != null) {
                this._myGamepad.pp_setActive(false);
              }
              if (this._myTrackedHand != null) {
                this._myTrackedHand.pp_setActive(true);
              }
            } else if (inputSourceType == PP.InputSourceType.GAMEPAD) {
              if (this._myTrackedHand != null) {
                this._myTrackedHand.pp_setActive(false);
              }
              if (this._myGamepad != null) {
                this._myGamepad.pp_setActive(true);
              }
            }
          }
        },
        _start() {
          if (this._myGamepad != null) {
            this._myGamepad.pp_setActive(false);
          }
          if (this._myTrackedHand != null) {
            this._myTrackedHand.pp_setActive(false);
          }
          this._myCurrentInputSourceType = null;
        }
      });
    }
  });

  // js/pp/input/cauldron/tracked_hand_draw_joint.js
  var require_tracked_hand_draw_joint = __commonJS({
    "js/pp/input/cauldron/tracked_hand_draw_joint.js"() {
      WL.registerComponent("pp-tracked-hand-draw-joint", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myFixForward: { type: WL.Type.Bool, default: true },
        _myJointID: {
          type: WL.Type.Enum,
          values: [
            "Wrist",
            "Thumb Metacarpal",
            "Thumb Phalanx Proximal",
            "Thumb Phalanx Distal",
            "Thumb Tip",
            "Index Metacarpal",
            "Index Phalanx Proximal",
            "Index Phalanx Intermediate",
            "Index Phalanx Distal",
            "Index Tip",
            "Middle Metacarpal",
            "Middle Phalanx Proximal",
            "Middle Phalanx Intermediate",
            "Middle Phalanx Distal",
            "Middle Tip",
            "Ring Metacarpal",
            "Ring Phalanx Proximal",
            "Ring Phalanx Intermediate",
            "Ring Phalanx Distal",
            "Ring Tip",
            "Pinky Metacarpal",
            "Pinky Phalanx Proximal",
            "Pinky Phalanx Intermediate",
            "Pinky Phalanx Distal",
            "Pinky Tip"
          ],
          default: "Wrist"
        },
        _myJointMesh: { type: WL.Type.Mesh },
        _myJointMaterial: { type: WL.Type.Material }
      }, {
        init: function() {
          this._myHandednessInternal = PP.InputUtils.getHandednessByIndex(this._myHandedness);
          this._myJointIDInternal = PP.InputUtils.getJointIDByIndex(this._myJointID);
          this._myTrackedHandJointPose = new PP.TrackedHandJointPose(this._myHandednessInternal, this._myJointIDInternal);
          this._myTrackedHandJointPose.setFixForward(this._myFixForward);
        },
        start: function() {
          this._myTrackedHandJointPose.start();
          this._buildTrackedHandHierarchy();
        },
        update: function(dt) {
          this._myTrackedHandJointPose.update(dt);
          this._myJointMeshObject.pp_setTransformLocalQuat(this._myTrackedHandJointPose.getTransformQuat());
          this._myJointMeshObject.pp_setScaleLocal(this._myTrackedHandJointPose.getJointRadius());
        },
        _buildTrackedHandHierarchy() {
          this._myJointMeshObject = this.object.pp_addObject();
          let mesh = this._myJointMeshObject.pp_addComponent("mesh");
          mesh.mesh = this._myJointMesh;
          mesh.material = this._myJointMaterial;
          this._myJointMeshObject.pp_setScaleLocal(0);
        }
      });
    }
  });

  // js/pp/input/cauldron/tracked_hand_draw_all_joints.js
  var require_tracked_hand_draw_all_joints = __commonJS({
    "js/pp/input/cauldron/tracked_hand_draw_all_joints.js"() {
      WL.registerComponent("pp-tracked-hand-draw-all-joints", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myFixForward: { type: WL.Type.Bool, default: true },
        _myHideMetacarpals: { type: WL.Type.Bool, default: true },
        _myJointMesh: { type: WL.Type.Mesh },
        _myJointMaterial: { type: WL.Type.Material }
      }, {
        init: function() {
        },
        start: function() {
          this._buildTrackedHandHierarchy();
        },
        update: function(dt) {
        },
        _buildTrackedHandHierarchy() {
          this._myTrackedHandMeshObject = this.object.pp_addObject();
          this._myJointMeshObjectList = [];
          for (let jointIDKey in PP.TrackedHandJointID) {
            let jointID = PP.TrackedHandJointID[jointIDKey];
            if (!this._myHideMetacarpals || jointID != PP.TrackedHandJointID.THUMB_METACARPAL && jointID != PP.TrackedHandJointID.INDEX_FINGER_METACARPAL && jointID != PP.TrackedHandJointID.MIDDLE_FINGER_METACARPAL && jointID != PP.TrackedHandJointID.RING_FINGER_METACARPAL && jointID != PP.TrackedHandJointID.PINKY_FINGER_METACARPAL) {
              let jointObject = this._myTrackedHandMeshObject.pp_addObject();
              this._myJointMeshObjectList[jointID] = jointObject;
              jointObject.pp_addComponent(
                "pp-tracked-hand-draw-joint",
                {
                  "_myHandedness": this._myHandedness,
                  "_myFixForward": this._myFixForward,
                  "_myJointID": PP.TrackedHandJointIDIndex[jointIDKey],
                  "_myJointMesh": this._myJointMesh,
                  "_myJointMaterial": this._myJointMaterial
                }
              );
            }
          }
        }
      });
    }
  });

  // js/pp/input/cauldron/tracked_hand_draw_skin.js
  var require_tracked_hand_draw_skin = __commonJS({
    "js/pp/input/cauldron/tracked_hand_draw_skin.js"() {
      WL.registerComponent("pp-tracked-hand-draw-skin", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myFixForward: { type: WL.Type.Bool, default: true },
        _myHandSkin: { type: WL.Type.Skin, default: null }
      }, {
        init: function() {
          this._myHandednessInternal = PP.InputUtils.getHandednessByIndex(this._myHandedness);
          this._myTrackedHandPose = new PP.TrackedHandPose(this._myHandednessInternal);
          this._myTrackedHandPose.setFixForward(this._myFixForward);
        },
        start: function() {
          this._myTrackedHandPose.start();
          this._prepareJoints();
        },
        update: function update(dt) {
          this._myTrackedHandPose.update(dt);
          for (let i = 0; i < this._myJoints.length; i++) {
            let jointObject = this._myJoints[i];
            let jointID = jointObject.name;
            let jointPose = this._myTrackedHandPose.getJointPose(jointID);
            jointObject.pp_setTransformLocalQuat(jointPose.getTransformQuat());
          }
        },
        _prepareJoints() {
          this._myJoints = [];
          let skinJointIDs = this._myHandSkin.jointIds;
          for (let i = 0; i < skinJointIDs.length; i++) {
            this._myJoints[i] = WL._wrapObject(skinJointIDs[i]);
          }
        }
      });
    }
  });

  // js/pp/input/gamepad/gamepad_buttons.js
  var require_gamepad_buttons = __commonJS({
    "js/pp/input/gamepad/gamepad_buttons.js"() {
      PP.GamepadButtonID = {
        SELECT: 0,
        // Trigger
        SQUEEZE: 1,
        // Grip
        TOUCHPAD: 2,
        // This is to support older gamepads, you can just use TOP_BUTTON to use this button for both older and newer gamepads
        THUMBSTICK: 3,
        BOTTOM_BUTTON: 4,
        // A or X button on oculus quest gamepad
        TOP_BUTTON: 5,
        // B or Y button on oculus quest gamepad, reverts to TOUCHPAD button for gamepads that does not support TOP_BUTTON
        THUMB_REST: 6
      };
      PP.GamepadButtonEvent = {
        PRESS_START: 0,
        PRESS_END: 1,
        PRESSED: 2,
        //Every frame that it is pressed
        NOT_PRESSED: 3,
        //Every frame that it is not pressed
        TOUCH_START: 4,
        TOUCH_END: 5,
        TOUCHED: 6,
        //Every frame that it is touched
        NOT_TOUCHED: 7,
        //Every frame that it is not touched
        VALUE_CHANGED: 8,
        ALWAYS: 9
        //Every frame
      };
      PP.GamepadAxesEvent = {
        X_CHANGED: 0,
        Y_CHANGED: 1,
        AXES_CHANGED: 2,
        ALWAYS: 3
      };
      PP.GamepadButtonInfo = class GamepadButtonInfo {
        constructor(id, handedness) {
          this.myID = id;
          this.myHandedness = handedness;
          this.myIsPressed = false;
          this.myPrevIsPressed = false;
          this.myIsTouched = false;
          this.myPrevIsTouched = false;
          this.myValue = 0;
          this.myPrevValue = 0;
          this.myTimePressed = 0;
          this.myPrevTimePressed = 0;
          this.myTimeNotPressed = 0;
          this.myPrevTimeNotPressed = 0;
          this.myTimeTouched = 0;
          this.myPrevTimeTouched = 0;
          this.myTimeNotTouched = 0;
          this.myPrevTimeNotTouched = 0;
          this.myMultiplePressStartCount = 0;
          this.myPrevMultiplePressStartCount = 0;
          this.myMultiplePressEndCount = 0;
          this.myPrevMultiplePressEndCount = 0;
          this.myMultipleTouchStartCount = 0;
          this.myPrevMultipleTouchStartCount = 0;
          this.myMultipleTouchEndCount = 0;
          this.myPrevMultipleTouchEndCount = 0;
        }
        getID() {
          return this.myID;
        }
        getHandedness() {
          return this.myHandedness;
        }
        getValue() {
          return this.myValue;
        }
        isPressed() {
          return this.myIsPressed;
        }
        isTouched() {
          return this.myIsTouched;
        }
        isPressStart(multiplePressCount = null) {
          return this.myIsPressed && !this.myPrevIsPressed && (multiplePressCount == null || this.myMultiplePressStartCount == multiplePressCount);
        }
        isPressEnd(multiplePressCount = null) {
          return !this.myIsPressed && this.myPrevIsPressed && (multiplePressCount == null || this.myMultiplePressEndCount == multiplePressCount);
        }
        isTouchStart(multipleTouchCount = null) {
          return this.myIsTouched && !this.myPrevIsTouched && (multipleTouchCount == null || this.myMultipleTouchStartCount == multipleTouchCount);
        }
        isTouchEnd(multipleTouchCount = null) {
          return !this.myIsTouched && this.myPrevIsTouched && (multipleTouchCount == null || this.myMultipleTouchEndCount == multipleTouchCount);
        }
        clone() {
          let value = new PP.GamepadButtonInfo(this.myID, this.myHandedness);
          value.myIsPressed = this.myIsPressed;
          value.myPrevIsPressed = this.myPrevIsPressed;
          value.myIsTouched = this.myIsTouched;
          value.myPrevIsTouched = this.myPrevIsTouched;
          value.myValue = this.myValue;
          value.myPrevValue = this.myPrevValue;
          value.myTimePressed = this.myTimePressed;
          value.myPrevTimePressed = this.myPrevTimePressed;
          value.myTimeNotPressed = this.myTimeNotPressed;
          value.myPrevTimeNotPressed = this.myPrevTimeNotPressed;
          value.myTimeTouched = this.myTimeTouched;
          value.myPrevTimeTouched = this.myPrevTimeTouched;
          value.myTimeNotTouched = this.myTimeNotTouched;
          value.myPrevTimeNotTouched = this.myPrevTimeNotTouched;
          value.myMultiplePressStartCount = this.myMultiplePressStartCount;
          value.myPrevMultiplePressStartCount = this.myPrevMultiplePressStartCount;
          value.myMultiplePressEndCount = this.myMultiplePressEndCount;
          value.myPrevMultiplePressEndCount = this.myPrevMultiplePressEndCount;
          value.myMultipleTouchStartCount = this.myMultipleTouchStartCount;
          value.myPrevMultipleTouchStartCount = this.myPrevMultipleTouchStartCount;
          value.myMultipleTouchEndCount = this.myMultipleTouchEndCount;
          value.myPrevMultipleTouchEndCount = this.myPrevMultipleTouchEndCount;
          return value;
        }
      };
      PP.GamepadAxesInfo = class GamepadAxesInfo {
        constructor(handedness) {
          this.myHandedness = handedness;
          this.myAxes = PP.vec2_create(0, 0);
          this.myPrevAxes = PP.vec2_create(0, 0);
        }
        getAxes() {
          return this.myAxes;
        }
        getHandedness() {
          return this.myHandedness;
        }
        clone() {
          let value = new PP.GamepadAxesInfo(this.myHandedness);
          value.myAxes.vec2_copy(this.myAxes);
          value.myPrevAxes.vec2_copy(this.myPrevAxes);
          return value;
        }
      };
      PP.GamepadPulseInfo = class GamepadPulseInfo {
        constructor() {
          this.myIntensity = 0;
          this.myDuration = 0;
          this.myIsDevicePulsing = false;
        }
        clone() {
          let value = new PP.GamepadPulseInfo();
          value.myIntensity = this.myIntensity;
          value.myDuration = this.myDuration;
          value.myIsDevicePulsing = this.myIsDevicePulsing;
          return value;
        }
      };
    }
  });

  // js/pp/input/gamepad/base_gamepad.js
  var require_base_gamepad = __commonJS({
    "js/pp/input/gamepad/base_gamepad.js"() {
      PP.BaseGamepad = class BaseGamepad {
        constructor(handedness) {
          this._myHandedness = handedness;
          this._myButtonInfos = [];
          for (let key in PP.GamepadButtonID) {
            this._myButtonInfos[PP.GamepadButtonID[key]] = new PP.GamepadButtonInfo(PP.GamepadButtonID[key], this._myHandedness);
          }
          this._myAxesInfo = new PP.GamepadAxesInfo(this._myHandedness);
          this._myButtonCallbacks = [];
          for (let key in PP.GamepadButtonID) {
            this._myButtonCallbacks[PP.GamepadButtonID[key]] = [];
            for (let eventKey in PP.GamepadButtonEvent) {
              this._myButtonCallbacks[PP.GamepadButtonID[key]][PP.GamepadButtonEvent[eventKey]] = /* @__PURE__ */ new Map();
            }
          }
          this._myAxesCallbacks = [];
          for (let eventKey in PP.GamepadAxesEvent) {
            this._myAxesCallbacks[PP.GamepadAxesEvent[eventKey]] = /* @__PURE__ */ new Map();
          }
          this._myPulseInfo = new PP.GamepadPulseInfo();
          this._myMultiplePressMaxDelay = 0.5;
          this._myMultipleTouchMaxDelay = 0.5;
        }
        getHandedness() {
          return this._myHandedness;
        }
        getButtonInfo(buttonID) {
          return this._myButtonInfos[buttonID];
        }
        registerButtonEventListener(buttonID, buttonEvent, id, callback) {
          this._myButtonCallbacks[buttonID][buttonEvent].set(id, callback);
        }
        unregisterButtonEventListener(buttonID, buttonEvent, id) {
          this._myButtonCallbacks[buttonID][buttonEvent].delete(id);
        }
        getAxesInfo() {
          return this._myAxesInfo;
        }
        registerAxesEventListener(axesEvent, id, callback) {
          this._myAxesCallbacks[axesEvent].set(id, callback);
        }
        unregisterAxesEventListener(axesEvent, id) {
          this._myAxesCallbacks[axesEvent].delete(id);
        }
        pulse(intensity, duration = 0) {
          this._myPulseInfo.myIntensity = Math.min(Math.max(intensity, 0), 1);
          this._myPulseInfo.myDuration = Math.max(duration, 0);
        }
        stopPulse() {
          this._myPulseInfo.myIntensity = 0;
          this._myPulseInfo.myDuration = 0;
        }
        isPulsing() {
          return this._myPulseInfo.myIntensity > 0 || this._myPulseInfo.myDuration > 0;
        }
        getPulseInfo() {
          return this._myPulseInfo;
        }
        getMultiplePressMaxDelay() {
          return this._myMultiplePressMaxDelay;
        }
        setMultiplePressMaxDelay(maxDelay) {
          this._myMultiplePressMaxDelay = maxDelay;
        }
        getMultipleTouchMaxDelay() {
          return this._myMultipleTouchMaxDelay;
        }
        setMultipleTouchMaxDelay(maxDelay) {
          this._myMultipleTouchMaxDelay = maxDelay;
        }
        // the following functions should be re-implemented in the actual class
        getHandPose() {
          return null;
        }
        _start() {
        }
        _preUpdate(dt) {
        }
        _postUpdate(dt) {
        }
        _getButtonData(buttonID) {
          let buttonData = this._createButtonData();
          return buttonData;
        }
        _getAxesData() {
          let axesData = this._createAxesData();
          return axesData;
        }
        _getHapticActuators() {
          let hapticActuator = [];
          return hapticActuator;
        }
        // the above functions should be re-implemented in the actual class
        start() {
          this._start();
        }
        update(dt) {
          this._preUpdate(dt);
          this._preUpdateButtonInfos();
          this._updateButtonInfos();
          this._postUpdateButtonInfos(dt);
          this._preUpdateAxesInfos();
          this._updateAxesInfos();
          this._postUpdateAxesInfos();
          this._updatePulse(dt);
          this._postUpdate(dt);
        }
        _preUpdateButtonInfos() {
          this._myButtonInfos.forEach(function(item) {
            item.myPrevIsPressed = item.myIsPressed;
            item.myPrevIsTouched = item.myIsTouched;
            item.myPrevValue = item.myValue;
          });
        }
        _updateButtonInfos() {
          this._updateSingleButtonInfo(PP.GamepadButtonID.SELECT);
          this._updateSingleButtonInfo(PP.GamepadButtonID.SQUEEZE);
          this._updateSingleButtonInfo(PP.GamepadButtonID.TOUCHPAD);
          this._updateSingleButtonInfo(PP.GamepadButtonID.THUMBSTICK);
          this._updateSingleButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON);
          this._updateSingleButtonInfo(PP.GamepadButtonID.TOP_BUTTON);
          this._updateSingleButtonInfo(PP.GamepadButtonID.THUMB_REST);
        }
        _updateSingleButtonInfo(buttonID) {
          let button = this._myButtonInfos[buttonID];
          let buttonData = this._getButtonData(buttonID);
          button.myIsPressed = buttonData.myIsPressed;
          button.myIsTouched = buttonData.myIsTouched;
          button.myValue = buttonData.myValue;
          if (button.myIsPressed) {
            button.myIsTouched = true;
            if (button.myValue == 0) {
              button.myValue = 1;
            }
          }
        }
        _postUpdateButtonInfos(dt) {
          this._myButtonInfos.forEach(function(item) {
            if (item.myIsPressed) {
              item.myTimePressed += dt;
              if (!item.myPrevIsPressed) {
                item.myMultiplePressStartCount += 1;
                item.myPrevTimeNotPressed = item.myTimeNotPressed;
                item.myTimeNotPressed = 0;
              }
              if (item.myPrevTimeNotPressed + item.myTimePressed > this._myMultiplePressMaxDelay && item.myMultiplePressEndCount > 0) {
                item.myPrevMultiplePressEndCount = item.myMultiplePressEndCount;
                item.myMultiplePressEndCount = 0;
              }
              if (item.myTimePressed > this._myMultiplePressMaxDelay && item.myMultiplePressStartCount > 0) {
                item.myPrevMultiplePressStartCount = item.myMultiplePressStartCount;
                item.myMultiplePressStartCount = 0;
              }
            } else {
              item.myTimeNotPressed += dt;
              if (item.myPrevIsPressed) {
                item.myMultiplePressEndCount += 1;
                item.myPrevTimePressed = item.myTimePressed;
                item.myTimePressed = 0;
              }
              if (item.myPrevTimePressed + item.myTimeNotPressed > this._myMultiplePressMaxDelay && item.myMultiplePressStartCount > 0) {
                item.myPrevMultiplePressStartCount = item.myMultiplePressStartCount;
                item.myMultiplePressStartCount = 0;
              }
              if (item.myTimeNotPressed > this._myMultiplePressMaxDelay && item.myMultiplePressEndCount > 0) {
                item.myPrevMultiplePressEndCount = item.myMultiplePressEndCount;
                item.myMultiplePressEndCount = 0;
              }
            }
            if (item.myIsTouched) {
              item.myTimeTouched += dt;
              if (!item.myPrevIsTouched) {
                item.myMultipleTouchStartCount += 1;
                item.myPrevTimeNotTouched = item.myTimeNotTouched;
                item.myTimeNotTouched = 0;
              }
              if (item.myPrevTimeNotTouched + item.myTimeTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchEndCount > 0) {
                item.myPrevMultipleTouchEndCount = item.myMultipleTouchEndCount;
                item.myMultipleTouchEndCount = 0;
              }
              if (item.myTimeTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchStartCount > 0) {
                item.myPrevMultipleTouchStartCount = item.myMultipleTouchStartCount;
                item.myMultipleTouchStartCount = 0;
              }
            } else {
              item.myTimeNotTouched += dt;
              if (item.myPrevIsTouched) {
                item.myMultipleTouchEndCount += 1;
                item.myPrevTimeTouched = item.myTimeTouched;
                item.myTimeTouched = 0;
              }
              if (item.myPrevTimeTouched + item.myTimeNotTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchStartCount > 0) {
                item.myPrevMultipleTouchStartCount = item.myMultipleTouchStartCount;
                item.myMultipleTouchStartCount = 0;
              }
              if (item.myTimeNotTouched > this._myMultipleTouchMaxDelay && item.myMultipleTouchEndCount > 0) {
                item.myPrevMultipleTouchEndCount = item.myMultipleTouchEndCount;
                item.myMultipleTouchEndCount = 0;
              }
            }
          }.bind(this));
          for (let key in PP.GamepadButtonID) {
            let buttonInfo = this._myButtonInfos[PP.GamepadButtonID[key]];
            let buttonCallbacks = this._myButtonCallbacks[PP.GamepadButtonID[key]];
            if (buttonInfo.myIsPressed && !buttonInfo.myPrevIsPressed) {
              let callbacks2 = buttonCallbacks[PP.GamepadButtonEvent.PRESS_START];
              this._triggerCallbacks(callbacks2, buttonInfo);
            }
            if (!buttonInfo.myIsPressed && buttonInfo.myPrevIsPressed) {
              let callbacks2 = buttonCallbacks[PP.GamepadButtonEvent.PRESS_END];
              this._triggerCallbacks(callbacks2, buttonInfo);
            }
            if (buttonInfo.myIsPressed) {
              let callbacks2 = buttonCallbacks[PP.GamepadButtonEvent.PRESSED];
              this._triggerCallbacks(callbacks2, buttonInfo);
            } else {
              let callbacks2 = buttonCallbacks[PP.GamepadButtonEvent.NOT_PRESSED];
              this._triggerCallbacks(callbacks2, buttonInfo);
            }
            if (buttonInfo.myIsTouched && !buttonInfo.myPrevIsTouched) {
              let callbacks2 = buttonCallbacks[PP.GamepadButtonEvent.TOUCH_START];
              this._triggerCallbacks(callbacks2, buttonInfo);
            }
            if (!buttonInfo.myIsTouched && buttonInfo.myPrevIsTouched) {
              let callbacks2 = buttonCallbacks[PP.GamepadButtonEvent.TOUCH_END];
              this._triggerCallbacks(callbacks2, buttonInfo);
            }
            if (buttonInfo.myIsTouched) {
              let callbacks2 = buttonCallbacks[PP.GamepadButtonEvent.TOUCHED];
              this._triggerCallbacks(callbacks2, buttonInfo);
            } else {
              let callbacks2 = buttonCallbacks[PP.GamepadButtonEvent.NOT_TOUCHED];
              this._triggerCallbacks(callbacks2, buttonInfo);
            }
            if (buttonInfo.myValue != buttonInfo.myPrevValue) {
              let callbacks2 = buttonCallbacks[PP.GamepadButtonEvent.VALUE_CHANGED];
              this._triggerCallbacks(callbacks2, buttonInfo);
            }
            let callbacks = buttonCallbacks[PP.GamepadButtonEvent.ALWAYS];
            this._triggerCallbacks(callbacks, buttonInfo);
          }
          this._mySelectStart = false;
          this._mySelectEnd = false;
          this._mySqueezeStart = false;
          this._mySqueezeEnd = false;
        }
        _preUpdateAxesInfos() {
          this._myAxesInfo.myPrevAxes[0] = this._myAxesInfo.myAxes[0];
          this._myAxesInfo.myPrevAxes[1] = this._myAxesInfo.myAxes[1];
        }
        _updateAxesInfos() {
          let axesData = this._getAxesData();
          this._myAxesInfo.myAxes[0] = axesData[0];
          this._myAxesInfo.myAxes[1] = axesData[1];
        }
        _postUpdateAxesInfos() {
          if (this._myAxesInfo.myAxes[0] != this._myAxesInfo.myPrevAxes[0]) {
            let callbacks2 = this._myAxesCallbacks[PP.GamepadAxesEvent.X_CHANGED];
            this._triggerCallbacks(callbacks2, this._myAxesInfo);
          }
          if (this._myAxesInfo.myAxes[1] != this._myAxesInfo.myPrevAxes[1]) {
            let callbacks2 = this._myAxesCallbacks[PP.GamepadAxesEvent.Y_CHANGED];
            this._triggerCallbacks(callbacks2, this._myAxesInfo);
          }
          if (this._myAxesInfo.myAxes[0] != this._myAxesInfo.myPrevAxes[0] || this._myAxesInfo.myAxes[1] != this._myAxesInfo.myPrevAxes[1]) {
            let callbacks2 = this._myAxesCallbacks[PP.GamepadAxesEvent.AXES_CHANGED];
            this._triggerCallbacks(callbacks2, this._myAxesInfo);
          }
          let callbacks = this._myAxesCallbacks[PP.GamepadAxesEvent.ALWAYS];
          this._triggerCallbacks(callbacks, this._myAxesInfo);
        }
        _updatePulse(dt) {
          if (this._myPulseInfo.myIsDevicePulsing || this._myPulseInfo.myIntensity > 0) {
            let hapticActuators = this._getHapticActuators();
            if (hapticActuators.length > 0) {
              if (this._myPulseInfo.myIntensity > 0) {
                for (let hapticActuator of hapticActuators) {
                  hapticActuator.pulse(this._myPulseInfo.myIntensity, Math.max(250, this._myPulseInfo.myDuration * 1e3));
                }
                this._myPulseInfo.myIsDevicePulsing = true;
              } else if (this._myPulseInfo.myIsDevicePulsing) {
                for (let hapticActuator of hapticActuators) {
                  hapticActuator.pulse(0, 1);
                  try {
                    if (hapticActuator.reset != null) {
                      hapticActuator.reset();
                    }
                  } catch (error) {
                  }
                }
                this._myPulseInfo.myIsDevicePulsing = false;
              }
            } else {
              this._myPulseInfo.myIsDevicePulsing = false;
            }
          }
          this._myPulseInfo.myDuration -= dt;
          if (this._myPulseInfo.myDuration <= 0) {
            this._myPulseInfo.myIntensity = 0;
            this._myPulseInfo.myDuration = 0;
          }
        }
        _triggerCallbacks(callbacks, info) {
          for (let callback of callbacks.values()) {
            callback(info, this);
          }
        }
        _createButtonData() {
          return { myIsPressed: false, myIsTouched: false, myValue: 0 };
        }
        _createAxesData() {
          return PP.vec2_create(0, 0);
        }
      };
    }
  });

  // js/pp/input/gamepad/universal_gamepad.js
  var require_universal_gamepad = __commonJS({
    "js/pp/input/gamepad/universal_gamepad.js"() {
      PP.UniversalGamepad = class UniversalGamepad extends PP.BaseGamepad {
        constructor(handedness) {
          super(handedness);
          this._myGamepadCores = /* @__PURE__ */ new Map();
          this._myStarted = false;
          this._myButtonData = this._createButtonData();
          this._myAxesData = this._createAxesData();
          this._myHapticActuators = [];
        }
        addGamepadCore(id, gamepadCore) {
          if (gamepadCore.getHandedness() == this.getHandedness()) {
            this._myGamepadCores.set(id, gamepadCore);
            if (this._myStarted) {
              gamepadCore.start();
            }
          }
        }
        getGamepadCore(id) {
          return this._myGamepadCores.get(id);
        }
        removeGamepadCore(id) {
          let gamepadCore = this._myGamepadCores.get(id);
          if (gamepadCore) {
            this._myGamepadCores.delete(id);
          }
        }
        removeAllGamepadCores() {
          for (let id of this._myGamepadCores.keys()) {
            this.removeGamepadCore(id);
          }
        }
        getHandPose() {
          let handPose = null;
          for (let core of this._myGamepadCores.values()) {
            if (core.isGamepadCoreActive()) {
              let currentCoreHandPose = core.getHandPose();
              if (handPose == null || currentCoreHandPose != null && currentCoreHandPose.isValid()) {
                handPose = currentCoreHandPose;
              }
            }
            if (handPose != null && handPose.isValid()) {
              break;
            }
          }
          return handPose;
        }
        _start() {
          for (let core of this._myGamepadCores.values()) {
            core.start();
          }
          this._myStarted = true;
        }
        _preUpdate(dt) {
          for (let core of this._myGamepadCores.values()) {
            core.preUpdate(dt);
          }
        }
        _postUpdate(dt) {
          for (let core of this._myGamepadCores.values()) {
            core.postUpdate(dt);
          }
        }
        _getButtonData(buttonID) {
          this._myButtonData.myIsPressed = false;
          this._myButtonData.myIsTouched = false;
          this._myButtonData.myValue = 0;
          for (let core of this._myGamepadCores.values()) {
            if (core.isGamepadCoreActive()) {
              let coreButtonData = core.getButtonData(buttonID);
              this._myButtonData.myIsPressed = this._myButtonData.myIsPressed || coreButtonData.myIsPressed;
              this._myButtonData.myIsTouched = this._myButtonData.myIsTouched || coreButtonData.myIsTouched;
              if (Math.abs(coreButtonData.myValue) > Math.abs(this._myButtonData.myValue)) {
                this._myButtonData.myValue = coreButtonData.myValue;
              }
            }
          }
          return this._myButtonData;
        }
        _getAxesData() {
          this._myAxesData.vec2_zero();
          for (let core of this._myGamepadCores.values()) {
            if (core.isGamepadCoreActive()) {
              let coreAxesData = core.getAxesData();
              if (Math.abs(coreAxesData[0]) > Math.abs(this._myAxesData[0])) {
                this._myAxesData[0] = coreAxesData[0];
              }
              if (Math.abs(coreAxesData[1]) > Math.abs(this._myAxesData[1])) {
                this._myAxesData[1] = coreAxesData[1];
              }
            }
          }
          return this._myAxesData;
        }
        _getHapticActuators() {
          this._myHapticActuators.pp_clear();
          for (let core of this._myGamepadCores.values()) {
            if (core.isGamepadCoreActive()) {
              this._myHapticActuators.push(...core.getHapticActuators());
            }
          }
          return this._myHapticActuators;
        }
      };
    }
  });

  // js/pp/input/gamepad/gamepad_cores/gamepad_core.js
  var require_gamepad_core = __commonJS({
    "js/pp/input/gamepad/gamepad_cores/gamepad_core.js"() {
      PP.GamepadCore = class GamepadCore {
        constructor(handedness, handPose) {
          this._myHandedness = handedness;
          this._myHandPose = handPose;
        }
        getHandedness() {
          return this._myHandedness;
        }
        getHandPose() {
          return this._myHandPose;
        }
        isGamepadCoreActive() {
          return true;
        }
        start() {
        }
        preUpdate(dt) {
        }
        postUpdate(dt) {
        }
        getButtonData(buttonID) {
          let buttonData = this._createButtonData();
          return buttonData;
        }
        getAxesData() {
          let axesData = this._createAxesData();
          return axesData;
        }
        getHapticActuators() {
          let hapticActuators = [];
          return hapticActuators;
        }
        _createButtonData() {
          return { myIsPressed: false, myIsTouched: false, myValue: 0 };
        }
        _createAxesData() {
          return PP.vec2_create(0, 0);
        }
      };
    }
  });

  // js/pp/input/gamepad/gamepad_cores/xr_gamepad_core.js
  var require_xr_gamepad_core = __commonJS({
    "js/pp/input/gamepad/gamepad_cores/xr_gamepad_core.js"() {
      PP.XRGamepadCore = class XRGamepadCore extends PP.GamepadCore {
        constructor(handedness, handPoseParams = new PP.HandPoseParams()) {
          super(handedness, new PP.HandPose(handedness, handPoseParams));
          this._mySelectPressed = false;
          this._mySqueezePressed = false;
          this._myIsXRSessionActive = false;
          this._myInputSource = null;
          this._myGamepad = null;
          this._myButtonData = this._createButtonData();
          this._myAxesData = this._createAxesData();
          this._myHapticActuators = [];
        }
        isGamepadCoreActive() {
          return this._myIsXRSessionActive && this._myGamepad != null && (this._myGamepad.connected == null || this._myGamepad.connected);
        }
        start() {
          this._myHandPose.start();
          if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        }
        preUpdate(dt) {
          this._updateHandPose(dt);
        }
        getButtonData(buttonID) {
          this._myButtonData.myIsPressed = false;
          this._myButtonData.myIsTouched = false;
          this._myButtonData.myValue = 0;
          if (this.isGamepadCoreActive()) {
            if (buttonID < this._myGamepad.buttons.length) {
              let gamepadButton = this._myGamepad.buttons[buttonID];
              if (buttonID != PP.GamepadButtonID.SELECT && buttonID != PP.GamepadButtonID.SQUEEZE) {
                this._myButtonData.myIsPressed = gamepadButton.pressed;
              } else {
                this._myButtonData.myIsPressed = this._getSpecialButtonPressed(buttonID);
              }
              this._myButtonData.myIsTouched = gamepadButton.touched;
              this._myButtonData.myValue = gamepadButton.value;
            } else if (buttonID == PP.GamepadButtonID.TOP_BUTTON && this._myGamepad.buttons.length >= 3) {
              let touchButton = this._myGamepad.buttons[2];
              this._myButtonData.myIsPressed = touchButton.pressed;
              this._myButtonData.myIsTouched = touchButton.touched;
              this._myButtonData.myValue = touchButton.value;
            }
          }
          return this._myButtonData;
        }
        getAxesData() {
          this._myAxesData.vec2_zero();
          if (this.isGamepadCoreActive()) {
            let internalAxes = this._myGamepad.axes;
            if (internalAxes.length == 4) {
              if (Math.abs(internalAxes[0]) > Math.abs(internalAxes[2])) {
                this._myAxesData[0] = internalAxes[0];
              } else {
                this._myAxesData[0] = internalAxes[2];
              }
              if (Math.abs(internalAxes[1]) > Math.abs(internalAxes[3])) {
                this._myAxesData[1] = internalAxes[1];
              } else {
                this._myAxesData[1] = internalAxes[3];
              }
            } else if (internalAxes.length == 2) {
              this._myAxesData[0] = internalAxes[0];
              this._myAxesData[1] = internalAxes[1];
            }
            this._myAxesData[1] = -this._myAxesData[1];
          }
          return this._myAxesData;
        }
        getHapticActuators() {
          this._myHapticActuators.pp_clear();
          if (this.isGamepadCoreActive()) {
            if (this._myGamepad.hapticActuators != null && this._myGamepad.hapticActuators.length > 0) {
              this._myHapticActuators.push(...this._myGamepad.hapticActuators);
            }
            if (this._myGamepad.vibrationActuator != null) {
              this._myHapticActuators.push(this._myGamepad.vibrationActuator);
            }
          }
          return this._myHapticActuators;
        }
        _updateHandPose(dt) {
          this._myHandPose.update(dt);
          let prevInputSource = this._myInputSource;
          this._myInputSource = this._myHandPose.getInputSource();
          if (prevInputSource != this._myInputSource) {
            this._mySelectPressed = false;
            this._mySqueezePressed = false;
          }
          if (this._myInputSource != null) {
            this._myGamepad = this._myInputSource.gamepad;
          } else {
            this._myGamepad = null;
          }
        }
        //This is to be more compatible
        _getSpecialButtonPressed(buttonID) {
          let isPressed = false;
          if (this.isGamepadCoreActive()) {
            if (buttonID == PP.GamepadButtonID.SELECT) {
              isPressed = this._mySelectPressed;
            } else if (buttonID == PP.GamepadButtonID.SQUEEZE) {
              isPressed = this._mySqueezePressed;
            }
          }
          return isPressed;
        }
        _onXRSessionStart(session) {
          session.addEventListener("selectstart", this._selectStart.bind(this));
          session.addEventListener("selectend", this._selectEnd.bind(this));
          session.addEventListener("squeezestart", this._squeezeStart.bind(this));
          session.addEventListener("squeezeend", this._squeezeEnd.bind(this));
          this._myIsXRSessionActive = true;
        }
        _onXRSessionEnd(session) {
          this._mySelectPressed = false;
          this._mySqueezePressed = false;
          this._myIsXRSessionActive = false;
        }
        //Select and Squeeze are managed this way to be more compatible
        _selectStart(event) {
          if (this._myInputSource != null && this._myInputSource == event.inputSource) {
            this._mySelectPressed = true;
          }
        }
        _selectEnd(event) {
          if (this._myInputSource != null && this._myInputSource == event.inputSource) {
            this._mySelectPressed = false;
          }
        }
        _squeezeStart(event) {
          if (this._myInputSource != null && this._myInputSource == event.inputSource) {
            this._mySqueezePressed = true;
          }
        }
        _squeezeEnd(event) {
          if (this._myInputSource != null && this._myInputSource == event.inputSource) {
            this._mySqueezePressed = false;
          }
        }
      };
    }
  });

  // js/pp/input/gamepad/gamepad_cores/keyboard_gamepad_core.js
  var require_keyboard_gamepad_core = __commonJS({
    "js/pp/input/gamepad/gamepad_cores/keyboard_gamepad_core.js"() {
      PP.KeyboardGamepadCore = class KeyboardGamepadCore extends PP.GamepadCore {
        constructor(handedness, handPose = null) {
          super(handedness, handPose);
          this._myHandPoseUpdateActive = false;
          this._myButtonData = this._createButtonData();
          this._myAxesData = this._createAxesData();
          this._myHapticActuators = [];
        }
        setHandPoseUpdateActive(active) {
          this._myHandPoseUpdateActive = active;
        }
        isHandPoseUpdateActive() {
          return this._myHandPoseUpdateActive;
        }
        isGamepadCoreActive() {
          return !PP.XRUtils.isSessionActive();
        }
        start() {
          if (this._myHandPose && this._myHandPoseUpdateActive) {
            this._myHandPose.start();
          }
        }
        preUpdate(dt) {
          if (this._myHandPose && this._myHandPoseUpdateActive) {
            this._myHandPose.update(dt);
          }
        }
        getButtonData(buttonID) {
          this._myButtonData.myIsPressed = false;
          this._myButtonData.myIsTouched = false;
          this._myButtonData.myValue = 0;
          if (this.isGamepadCoreActive()) {
            if (this.getHandedness() == PP.Handedness.LEFT) {
              switch (buttonID) {
                case PP.GamepadButtonID.SELECT:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.E) || PP.myKeyboard.isKeyPressed(PP.KeyID.e);
                  break;
                case PP.GamepadButtonID.SQUEEZE:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.Q) || PP.myKeyboard.isKeyPressed(PP.KeyID.q);
                  break;
                case PP.GamepadButtonID.TOUCHPAD:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.X) || PP.myKeyboard.isKeyPressed(PP.KeyID.x);
                  break;
                case PP.GamepadButtonID.THUMBSTICK:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.R) || PP.myKeyboard.isKeyPressed(PP.KeyID.r);
                  break;
                case PP.GamepadButtonID.BOTTOM_BUTTON:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.C) || PP.myKeyboard.isKeyPressed(PP.KeyID.c);
                  break;
                case PP.GamepadButtonID.TOP_BUTTON:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.F) || PP.myKeyboard.isKeyPressed(PP.KeyID.f);
                  break;
                case PP.GamepadButtonID.THUMB_REST:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.V) || PP.myKeyboard.isKeyPressed(PP.KeyID.v);
                  break;
              }
            } else {
              switch (buttonID) {
                case PP.GamepadButtonID.SELECT:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.U) || PP.myKeyboard.isKeyPressed(PP.KeyID.u);
                  break;
                case PP.GamepadButtonID.SQUEEZE:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.O) || PP.myKeyboard.isKeyPressed(PP.KeyID.o);
                  break;
                case PP.GamepadButtonID.TOUCHPAD:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.M) || PP.myKeyboard.isKeyPressed(PP.KeyID.m);
                  break;
                case PP.GamepadButtonID.THUMBSTICK:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.Y) || PP.myKeyboard.isKeyPressed(PP.KeyID.y);
                  break;
                case PP.GamepadButtonID.BOTTOM_BUTTON:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.N) || PP.myKeyboard.isKeyPressed(PP.KeyID.n);
                  break;
                case PP.GamepadButtonID.TOP_BUTTON:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.H) || PP.myKeyboard.isKeyPressed(PP.KeyID.h);
                  break;
                case PP.GamepadButtonID.THUMB_REST:
                  this._myButtonData.myIsPressed = PP.myKeyboard.isKeyPressed(PP.KeyID.B) || PP.myKeyboard.isKeyPressed(PP.KeyID.b);
                  break;
              }
            }
          }
          if (this._myButtonData.myIsPressed) {
            this._myButtonData.myIsTouched = true;
            this._myButtonData.myValue = 1;
          }
          return this._myButtonData;
        }
        getAxesData() {
          this._myAxesData.vec2_zero();
          if (this.isGamepadCoreActive()) {
            if (this.getHandedness() == PP.Handedness.LEFT) {
              if (PP.myKeyboard.isKeyPressed(PP.KeyID.W) || PP.myKeyboard.isKeyPressed(PP.KeyID.w))
                this._myAxesData[1] += 1;
              if (PP.myKeyboard.isKeyPressed(PP.KeyID.S) || PP.myKeyboard.isKeyPressed(PP.KeyID.s))
                this._myAxesData[1] += -1;
              if (PP.myKeyboard.isKeyPressed(PP.KeyID.D) || PP.myKeyboard.isKeyPressed(PP.KeyID.d))
                this._myAxesData[0] += 1;
              if (PP.myKeyboard.isKeyPressed(PP.KeyID.A) || PP.myKeyboard.isKeyPressed(PP.KeyID.a))
                this._myAxesData[0] += -1;
            } else {
              if (PP.myKeyboard.isKeyPressed(PP.KeyID.I) || PP.myKeyboard.isKeyPressed(PP.KeyID.i) || PP.myKeyboard.isKeyPressed(PP.KeyID.UP))
                this._myAxesData[1] += 1;
              if (PP.myKeyboard.isKeyPressed(PP.KeyID.K) || PP.myKeyboard.isKeyPressed(PP.KeyID.k) || PP.myKeyboard.isKeyPressed(PP.KeyID.DOWN))
                this._myAxesData[1] += -1;
              if (PP.myKeyboard.isKeyPressed(PP.KeyID.L) || PP.myKeyboard.isKeyPressed(PP.KeyID.l) || PP.myKeyboard.isKeyPressed(PP.KeyID.RIGHT))
                this._myAxesData[0] += 1;
              if (PP.myKeyboard.isKeyPressed(PP.KeyID.J) || PP.myKeyboard.isKeyPressed(PP.KeyID.j) || PP.myKeyboard.isKeyPressed(PP.KeyID.LEFT))
                this._myAxesData[0] += -1;
            }
          }
          return this._myAxesData;
        }
        getHapticActuators() {
          return this._myHapticActuators;
        }
      };
    }
  });

  // js/pp/input/gamepad/gamepad_cores/virtual_gamepad_gamepad_core.js
  var require_virtual_gamepad_gamepad_core = __commonJS({
    "js/pp/input/gamepad/gamepad_cores/virtual_gamepad_gamepad_core.js"() {
      PP.VirtualGamepadGamepadCore = class VirtualGamepadGamepadCore extends PP.GamepadCore {
        constructor(virtualGamepad, handedness, handPose = null) {
          super(handedness, handPose);
          this._myHandPoseUpdateActive = false;
          this._myVirtualGamepad = virtualGamepad;
          this._myButtonData = this._createButtonData();
          this._myAxesData = this._createAxesData();
          this._myHapticActuators = [];
        }
        setHandPoseUpdateActive(active) {
          this._myHandPoseUpdateActive = active;
        }
        isHandPoseUpdateActive() {
          return this._myHandPoseUpdateActive;
        }
        isGamepadCoreActive() {
          return this._myVirtualGamepad.isVisible();
        }
        start() {
          if (this._myHandPose && this._myHandPoseUpdateActive) {
            this._myHandPose.start();
          }
        }
        preUpdate(dt) {
          if (this._myHandPose && this._myHandPoseUpdateActive) {
            this._myHandPose.update(dt);
          }
        }
        getButtonData(buttonID) {
          this._myButtonData.myIsPressed = false;
          this._myButtonData.myIsTouched = false;
          this._myButtonData.myValue = 0;
          if (this.isGamepadCoreActive()) {
            if (this._myVirtualGamepad.isButtonPressed(this._myHandedness, buttonID)) {
              this._myButtonData.myIsPressed = true;
              this._myButtonData.myIsTouched = true;
              this._myButtonData.myValue = 1;
            }
          }
          return this._myButtonData;
        }
        getAxesData() {
          this._myAxesData.vec2_zero();
          if (this.isGamepadCoreActive()) {
            this._myVirtualGamepad.getAxes(this._myHandedness, this._myAxesData);
          }
          return this._myAxesData;
        }
        getHapticActuators() {
          return this._myHapticActuators;
        }
      };
    }
  });

  // js/pp/input/gamepad/cauldron/gamepad_mesh_animator.js
  var require_gamepad_mesh_animator = __commonJS({
    "js/pp/input/gamepad/cauldron/gamepad_mesh_animator.js"() {
      WL.registerComponent("pp-gamepad-mesh-animator", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _mySelect: { type: WL.Type.Object, default: null },
        _mySqueeze: { type: WL.Type.Object, default: null },
        _myThumbstick: { type: WL.Type.Object, default: null },
        _myTopButton: { type: WL.Type.Object, default: null },
        _myBottomButton: { type: WL.Type.Object, default: null },
        _mySelectRotateAngle: { type: WL.Type.Float, default: 15 },
        _mySqueezeRotateAngle: { type: WL.Type.Float, default: 11 },
        _myThumbstickRotateAngle: { type: WL.Type.Float, default: 15 },
        _myThumbstickPressOffset: { type: WL.Type.Float, default: 625e-6 },
        _myTopButtonPressOffset: { type: WL.Type.Float, default: 15e-4 },
        _myBottomButtonPressOffset: { type: WL.Type.Float, default: 15e-4 },
        _myUsePressForSqueeze: { type: WL.Type.Bool, default: false },
        _mySqueezePressOffset: { type: WL.Type.Float, default: 15e-4 }
      }, {
        start: function() {
          let gamepad = null;
          if (this._myHandedness == 0) {
            gamepad = PP.myLeftGamepad;
          } else {
            gamepad = PP.myRightGamepad;
          }
          if (this._mySelect != null) {
            this._mySelectOriginalRotation = this._mySelect.pp_getRotationLocalQuat();
            this._mySelectOriginalLeft = this._mySelect.pp_getLeftLocal();
          }
          if (this._mySqueeze != null) {
            this._mySqueezeOriginalPosition = this._mySqueeze.pp_getPositionLocal();
            this._mySqueezeOriginalRotation = this._mySqueeze.pp_getRotationLocalQuat();
            this._mySqueezeOriginalLeft = this._mySqueeze.pp_getLeftLocal();
            this._mySqueezeOriginalForward = this._mySqueeze.pp_getForwardLocal();
          }
          if (this._myThumbstick != null) {
            this._myThumbstickOriginalPosition = this._myThumbstick.pp_getPositionLocal();
            this._myThumbstickOriginalRotation = this._myThumbstick.pp_getRotationLocalQuat();
            this._myThumbstickOriginalLeft = this._myThumbstick.pp_getLeftLocal();
            this._myThumbstickOriginalUp = this._myThumbstick.pp_getUpLocal();
            this._myThumbstickOriginalForward = this._myThumbstick.pp_getForwardLocal();
          }
          if (this._myTopButton != null) {
            this._myTopButtonOriginalPosition = this._myTopButton.pp_getPositionLocal();
            this._myTopButtonOriginalUp = this._myTopButton.pp_getUpLocal();
          }
          if (this._myBottomButton != null) {
            this._myBottomButtonOriginalPosition = this._myBottomButton.pp_getPositionLocal();
            this._myBottomButtonOriginalUp = this._myBottomButton.pp_getUpLocal();
          }
          if (this._myThumbstick != null) {
            gamepad.registerButtonEventListener(PP.GamepadButtonID.THUMBSTICK, PP.GamepadButtonEvent.PRESS_START, this, this._thumbstickPressedStart.bind(this));
            gamepad.registerButtonEventListener(PP.GamepadButtonID.THUMBSTICK, PP.GamepadButtonEvent.PRESS_END, this, this._thumbstickPressedEnd.bind(this));
          }
          if (this._myTopButton != null) {
            gamepad.registerButtonEventListener(PP.GamepadButtonID.TOP_BUTTON, PP.GamepadButtonEvent.PRESS_START, this, this._topButtonPressedStart.bind(this));
            gamepad.registerButtonEventListener(PP.GamepadButtonID.TOP_BUTTON, PP.GamepadButtonEvent.PRESS_END, this, this._topButtonPressedEnd.bind(this));
          }
          if (this._myBottomButton != null) {
            gamepad.registerButtonEventListener(PP.GamepadButtonID.BOTTOM_BUTTON, PP.GamepadButtonEvent.PRESS_START, this, this._bottomButtonPressedStart.bind(this));
            gamepad.registerButtonEventListener(PP.GamepadButtonID.BOTTOM_BUTTON, PP.GamepadButtonEvent.PRESS_END, this, this._bottomButtonPressedEnd.bind(this));
          }
          if (this._mySelect != null) {
            gamepad.registerButtonEventListener(PP.GamepadButtonID.SELECT, PP.GamepadButtonEvent.VALUE_CHANGED, this, this._selectValueChanged.bind(this));
          }
          if (this._mySqueeze != null) {
            gamepad.registerButtonEventListener(PP.GamepadButtonID.SQUEEZE, PP.GamepadButtonEvent.VALUE_CHANGED, this, this._squeezeValueChanged.bind(this));
          }
          if (this._myThumbstick != null) {
            gamepad.registerAxesEventListener(PP.GamepadAxesEvent.AXES_CHANGED, this, this._thumbstickValueChanged.bind(this));
          }
        },
        _thumbstickPressedStart: function() {
          let upTranslation = PP.vec3_create();
          return function _thumbstickPressedStart(buttonInfo, gamepad) {
            this._myThumbstickOriginalUp.vec3_scale(-this._myThumbstickPressOffset, upTranslation);
            this._myThumbstick.pp_translateLocal(upTranslation);
          };
        }(),
        _thumbstickPressedEnd: function _thumbstickPressedEnd(buttonInfo, gamepad) {
          this._myThumbstick.pp_setPositionLocal(this._myThumbstickOriginalPosition);
        },
        _topButtonPressedStart: function(buttonInfo, gamepad) {
          this._myTopButton.pp_translateAxisLocal(-this._myTopButtonPressOffset, this._myTopButtonOriginalUp);
        },
        _topButtonPressedEnd: function(buttonInfo, gamepad) {
          this._myTopButton.pp_setPositionLocal(this._myTopButtonOriginalPosition);
        },
        _bottomButtonPressedStart: function(buttonInfo, gamepad) {
          this._myBottomButton.pp_translateAxisLocal(-this._myBottomButtonPressOffset, this._myBottomButtonOriginalUp);
        },
        _bottomButtonPressedEnd: function(buttonInfo, gamepad) {
          this._myBottomButton.pp_setPositionLocal(this._myBottomButtonOriginalPosition);
        },
        _selectValueChanged: function(buttonInfo, gamepad) {
          this._mySelect.pp_setRotationLocalQuat(this._mySelectOriginalRotation);
          if (buttonInfo.myValue > 1e-5) {
            this._mySelect.pp_rotateAxisLocal(this._mySelectRotateAngle * buttonInfo.myValue, this._mySelectOriginalLeft);
          }
        },
        _squeezeValueChanged: function(buttonInfo, gamepad) {
          this._mySqueeze.pp_setPositionLocal(this._mySqueezeOriginalPosition);
          this._mySqueeze.pp_setRotationLocalQuat(this._mySqueezeOriginalRotation);
          if (buttonInfo.myValue > 1e-5) {
            if (this._myUsePressForSqueeze) {
              let translation = this._mySqueezePressOffset;
              if (this._myHandedness == 1) {
                translation *= -1;
              }
              this._mySqueeze.pp_translateAxisLocal(translation * buttonInfo.myValue, this._mySqueezeOriginalLeft);
            } else {
              let rotation = -this._mySqueezeRotateAngle;
              if (this._myHandedness == 1) {
                rotation *= -1;
              }
              this._mySqueeze.pp_rotateAxisLocal(rotation * buttonInfo.myValue, this._mySqueezeOriginalForward);
            }
          }
        },
        _thumbstickValueChanged: function(axesInfo, gamepad) {
          this._myThumbstick.pp_setRotationLocalQuat(this._myThumbstickOriginalRotation);
          let leftRotation = this._myThumbstickRotateAngle * axesInfo.myAxes[1];
          let forwardRotation = this._myThumbstickRotateAngle * axesInfo.myAxes[0];
          if (Math.abs(leftRotation) > 1e-4) {
            this._myThumbstick.pp_rotateAxisLocal(leftRotation, this._myThumbstickOriginalLeft);
          }
          if (Math.abs(forwardRotation) > 1e-4) {
            this._myThumbstick.pp_rotateAxisLocal(forwardRotation, this._myThumbstickOriginalForward);
          }
        }
      });
    }
  });

  // js/pp/input/gamepad/cauldron/gamepad_manager.js
  var require_gamepad_manager = __commonJS({
    "js/pp/input/gamepad/cauldron/gamepad_manager.js"() {
      PP.GamepadManager = class GamepadManager {
        constructor() {
          this._myLeftGamepad = new PP.UniversalGamepad(PP.Handedness.LEFT);
          this._myRightGamepad = new PP.UniversalGamepad(PP.Handedness.RIGHT);
        }
        start() {
          this._myLeftGamepad.start();
          this._myRightGamepad.start();
        }
        update(dt) {
          this._myLeftGamepad.update(dt);
          this._myRightGamepad.update(dt);
        }
        getLeftGamepad() {
          return this._myLeftGamepad;
        }
        getRightGamepad() {
          return this._myRightGamepad;
        }
        getGamepad(handedness) {
          let gamepad = null;
          switch (handedness) {
            case PP.Handedness.LEFT:
              gamepad = this._myLeftGamepad;
              break;
            case PP.Handedness.RIGHT:
              gamepad = this._myRightGamepad;
              break;
            default:
              gamepad = null;
          }
          return gamepad;
        }
        getGamepads() {
          let gamepads = [];
          gamepads[PP.Handedness.LEFT] = this._myLeftGamepad;
          gamepads[PP.Handedness.RIGHT] = this._myRightGamepad;
          return gamepads;
        }
      };
    }
  });

  // js/pp/input/gamepad/cauldron/gamepad_utils.js
  var require_gamepad_utils = __commonJS({
    "js/pp/input/gamepad/cauldron/gamepad_utils.js"() {
      PP.GamepadUtils = {
        _mySimultaneousPressMaxDelay: 0.15,
        _mySimultaneousTouchMaxDelay: 0.15,
        setSimultaneousPressMaxDelay: function(simultaneousPressMaxDelay) {
          PP.GamepadUtils._mySimultaneousPressMaxDelay = simultaneousPressMaxDelay;
        },
        setSimultaneousTouchMaxDelay: function(simultaneousTouchMaxDelay) {
          PP.GamepadUtils._mySimultaneousTouchMaxDelay = simultaneousTouchMaxDelay;
        },
        getSimultaneousPressMaxDelay: function() {
          return PP.GamepadUtils._mySimultaneousPressMaxDelay;
        },
        getSimultaneousTouchMaxDelay: function() {
          return PP.GamepadUtils._mySimultaneousTouchMaxDelay;
        },
        // gamepadButtonIDsList is a sequence of a gamepads and a list of buttonIDs like this ([gamepad1, squeeze, top, select], [gamepad2, bottom, squeeze, select], ...)
        // if the first parameter is a number it's used as multiplePressCount
        // if the buttonIDs list is empty for a given gamepad, it means that every button will be included
        isAnyButtonPressStart: function(...gamepadButtonIDsList) {
          let multiplePressCount = null;
          let realGamepadButtonIDsList = gamepadButtonIDsList;
          if (!isNaN(gamepadButtonIDsList[0])) {
            multiplePressCount = gamepadButtonIDsList[0];
            realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
          }
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            if (gamepadButtonIDs.length == 1) {
              for (let key in PP.GamepadButtonID) {
                gamepadButtonIDs.push(PP.GamepadButtonID[key]);
              }
            }
          }
          let isOnePressStart = false;
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            let gamepad = gamepadButtonIDs[0];
            for (let i = 1; i < gamepadButtonIDs.length; i++) {
              let buttonID = gamepadButtonIDs[i];
              let button = gamepad.getButtonInfo(buttonID);
              if (button.isPressStart(multiplePressCount)) {
                isOnePressStart = true;
                break;
              }
            }
            if (isOnePressStart) {
              break;
            }
          }
          return isOnePressStart;
        },
        // gamepadButtonIDsList is a sequence of a gamepads and a list of buttonIDs like this ([gamepad1, squeeze, top, select], [gamepad2, bottom, squeeze, select], ...)
        // if the first parameter is a number it's used as multiplePressCount
        // if the buttonIDs list is empty for a given gamepad, it means that every button will be included
        areButtonsPressStart: function(...gamepadButtonIDsList) {
          let multiplePressCount = null;
          let realGamepadButtonIDsList = gamepadButtonIDsList;
          if (!isNaN(gamepadButtonIDsList[0])) {
            multiplePressCount = gamepadButtonIDsList[0];
            realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
          }
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            if (gamepadButtonIDs.length == 1) {
              for (let key in PP.GamepadButtonID) {
                gamepadButtonIDs.push(PP.GamepadButtonID[key]);
              }
            }
          }
          let areButtonPressedRecently = true;
          let isOnePressStart = false;
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            let gamepad = gamepadButtonIDs[0];
            for (let i = 1; i < gamepadButtonIDs.length; i++) {
              let buttonID = gamepadButtonIDs[i];
              let button = gamepad.getButtonInfo(buttonID);
              if (!(button.myIsPressed && (multiplePressCount == null || button.myMultiplePressStartCount == multiplePressCount) && button.myTimePressed < PP.GamepadUtils._mySimultaneousPressMaxDelay)) {
                areButtonPressedRecently = false;
                break;
              }
              if (button.isPressStart(multiplePressCount)) {
                isOnePressStart = true;
              }
            }
            if (!areButtonPressedRecently) {
              break;
            }
          }
          return areButtonPressedRecently && isOnePressStart;
        },
        isAnyButtonPressEnd: function(...gamepadButtonIDsList) {
          let multiplePressCount = null;
          let realGamepadButtonIDsList = gamepadButtonIDsList;
          if (!isNaN(gamepadButtonIDsList[0])) {
            multiplePressCount = gamepadButtonIDsList[0];
            realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
          }
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            if (gamepadButtonIDs.length == 1) {
              for (let key in PP.GamepadButtonID) {
                gamepadButtonIDs.push(PP.GamepadButtonID[key]);
              }
            }
          }
          let isOnePressEnd = false;
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            let gamepad = gamepadButtonIDs[0];
            for (let i = 1; i < gamepadButtonIDs.length; i++) {
              let buttonID = gamepadButtonIDs[i];
              let button = gamepad.getButtonInfo(buttonID);
              if (button.isPressEnd(multiplePressCount)) {
                isOnePressEnd = true;
                break;
              }
            }
            if (isOnePressEnd) {
              break;
            }
          }
          return isOnePressEnd;
        },
        areButtonsPressEnd: function(...gamepadButtonIDsList) {
          let multiplePressCount = null;
          let realGamepadButtonIDsList = gamepadButtonIDsList;
          if (!isNaN(gamepadButtonIDsList[0])) {
            multiplePressCount = gamepadButtonIDsList[0];
            realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
          }
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            if (gamepadButtonIDs.length == 1) {
              for (let key in PP.GamepadButtonID) {
                gamepadButtonIDs.push(PP.GamepadButtonID[key]);
              }
            }
          }
          let areButtonNotPressedRecently = true;
          let isOnePressEnd = false;
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            let gamepad = gamepadButtonIDs[0];
            for (let i = 1; i < gamepadButtonIDs.length; i++) {
              let buttonID = gamepadButtonIDs[i];
              let button = gamepad.getButtonInfo(buttonID);
              if (!(!button.myIsPressed && (multiplePressCount == null || button.myMultiplePressEndCount == multiplePressCount) && button.myTimeNotPressed < PP.GamepadUtils._mySimultaneousPressMaxDelay)) {
                areButtonNotPressedRecently = false;
                break;
              }
              if (button.isPressEnd(multiplePressCount)) {
                isOnePressEnd = true;
              }
            }
            if (!areButtonNotPressedRecently) {
              break;
            }
          }
          return areButtonNotPressedRecently && isOnePressEnd;
        },
        isAnyButtonTouchStart: function(...gamepadButtonIDsList) {
          let multiplePressCount = null;
          let realGamepadButtonIDsList = gamepadButtonIDsList;
          if (!isNaN(gamepadButtonIDsList[0])) {
            multiplePressCount = gamepadButtonIDsList[0];
            realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
          }
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            if (gamepadButtonIDs.length == 1) {
              for (let key in PP.GamepadButtonID) {
                gamepadButtonIDs.push(PP.GamepadButtonID[key]);
              }
            }
          }
          let isOneTouchStart = false;
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            let gamepad = gamepadButtonIDs[0];
            for (let i = 1; i < gamepadButtonIDs.length; i++) {
              let buttonID = gamepadButtonIDs[i];
              let button = gamepad.getButtonInfo(buttonID);
              if (button.isTouchStart(multiplePressCount)) {
                isOneTouchStart = true;
                break;
              }
            }
            if (isOneTouchStart) {
              break;
            }
          }
          return isOneTouchStart;
        },
        areButtonsTouchStart: function(...gamepadButtonIDsList) {
          let multipleTouchCount = null;
          let realGamepadButtonIDsList = gamepadButtonIDsList;
          if (!isNaN(gamepadButtonIDsList[0])) {
            multipleTouchCount = gamepadButtonIDsList[0];
            realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
          }
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            if (gamepadButtonIDs.length == 1) {
              for (let key in PP.GamepadButtonID) {
                gamepadButtonIDs.push(PP.GamepadButtonID[key]);
              }
            }
          }
          let areButtonTouchedRecently = true;
          let isOneTouchStart = false;
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            let gamepad = gamepadButtonIDs[0];
            for (let i = 1; i < gamepadButtonIDs.length; i++) {
              let buttonID = gamepadButtonIDs[i];
              let button = gamepad.getButtonInfo(buttonID);
              if (!(button.myIsTouched && (multipleTouchCount == null || button.myMultipleTouchStartCount == multipleTouchCount) && button.myTimeTouched < PP.GamepadUtils._mySimultaneousTouchMaxDelay)) {
                areButtonTouchedRecently = false;
                break;
              }
              if (button.isTouchStart(multipleTouchCount)) {
                isOneTouchStart = true;
              }
            }
            if (!areButtonTouchedRecently) {
              break;
            }
          }
          return areButtonTouchedRecently && isOneTouchStart;
        },
        isAnyButtonTouchEnd: function(...gamepadButtonIDsList) {
          let multiplePressCount = null;
          let realGamepadButtonIDsList = gamepadButtonIDsList;
          if (!isNaN(gamepadButtonIDsList[0])) {
            multiplePressCount = gamepadButtonIDsList[0];
            realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
          }
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            if (gamepadButtonIDs.length == 1) {
              for (let key in PP.GamepadButtonID) {
                gamepadButtonIDs.push(PP.GamepadButtonID[key]);
              }
            }
          }
          let isOneTouchEnd = false;
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            let gamepad = gamepadButtonIDs[0];
            for (let i = 1; i < gamepadButtonIDs.length; i++) {
              let buttonID = gamepadButtonIDs[i];
              let button = gamepad.getButtonInfo(buttonID);
              if (button.isTouchEnd(multiplePressCount)) {
                isOneTouchEnd = true;
                break;
              }
            }
            if (isOneTouchEnd) {
              break;
            }
          }
          return isOneTouchEnd;
        },
        areButtonsTouchEnd: function(...gamepadButtonIDsList) {
          let multipleTouchCount = null;
          let realGamepadButtonIDsList = gamepadButtonIDsList;
          if (!isNaN(gamepadButtonIDsList[0])) {
            multipleTouchCount = gamepadButtonIDsList[0];
            realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
          }
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            if (gamepadButtonIDs.length == 1) {
              for (let key in PP.GamepadButtonID) {
                gamepadButtonIDs.push(PP.GamepadButtonID[key]);
              }
            }
          }
          let areButtonNotTouchedRecently = true;
          let isOneTouchEnd = false;
          for (let gamepadButtonIDs of realGamepadButtonIDsList) {
            let gamepad = gamepadButtonIDs[0];
            for (let i = 1; i < gamepadButtonIDs.length; i++) {
              let buttonID = gamepadButtonIDs[i];
              let button = gamepad.getButtonInfo(buttonID);
              if (!(!button.myIsTouched && (multipleTouchCount == null || button.myMultipleTouchEndCount == multipleTouchCount) && button.myTimeNotTouched < PP.GamepadUtils._mySimultaneousTouchMaxDelay)) {
                areButtonNotTouchedRecently = false;
                break;
              }
              if (button.isTouchEnd(multipleTouchCount)) {
                isOneTouchEnd = true;
              }
            }
            if (!areButtonNotTouchedRecently) {
              break;
            }
          }
          return areButtonNotTouchedRecently && isOneTouchEnd;
        }
      };
    }
  });

  // js/pp/input/gamepad/cauldron/gamepad_control_scheme.js
  var require_gamepad_control_scheme = __commonJS({
    "js/pp/input/gamepad/cauldron/gamepad_control_scheme.js"() {
      WL.registerComponent("pp-gamepad-control-scheme", {
        _myShowOnStart: { type: WL.Type.Bool, default: true },
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _mySelectText: { type: WL.Type.String, default: "" },
        _mySqueezeText: { type: WL.Type.String, default: "" },
        _myThumbstickText: { type: WL.Type.String, default: "" },
        _myBottomButtonText: { type: WL.Type.String, default: "" },
        _myTopButtonText: { type: WL.Type.String, default: "" },
        _mySelect: { type: WL.Type.Object, default: null },
        _mySqueeze: { type: WL.Type.Object, default: null },
        _myThumbstick: { type: WL.Type.Object, default: null },
        _myBottomButton: { type: WL.Type.Object, default: null },
        _myTopButton: { type: WL.Type.Object, default: null },
        _myTextScaleMultiplier: { type: WL.Type.Float, default: 1 },
        _myTextOffsetMultiplier: { type: WL.Type.Float, default: 1 },
        _myLineLengthMultiplier: { type: WL.Type.Float, default: 1 },
        _myLineThicknessMultiplier: { type: WL.Type.Float, default: 1 },
        _myDistanceFromButtonsMultiplier: { type: WL.Type.Float, default: 1 },
        _myTextMaterial: { type: WL.Type.Material },
        _myLineMaterial: { type: WL.Type.Material }
      }, {
        init: function() {
        },
        start: function() {
          this._myTextMaterialFinal = this._myTextMaterial != null ? this._myTextMaterial : PP.myDefaultResources.myMaterials.myText.clone();
          this._myLineMaterialFinal = this._myLineMaterial != null ? this._myLineMaterial : PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
          this._myHandednessType = PP.InputUtils.getHandednessByIndex(this._myHandedness);
          this._myControlSchemeDirection = this._myHandednessType == PP.Handedness.LEFT ? 1 : -1;
          this._myVisible = false;
          this._mySetVisibleNextUpdate = false;
          this._createControlScheme();
          this.setVisible(this._myShowOnStart);
          this._myVisibleBackup = this._myVisible;
        },
        update: function(dt) {
          if (this._mySetVisibleNextUpdate) {
            this._mySetVisibleNextUpdate = false;
            this.setVisible(false);
            this.setVisible(this._myVisibleBackup);
          }
        },
        onActivate() {
          this._mySetVisibleNextUpdate = true;
        },
        onDeactivate() {
          if (this._myVisible != null) {
            this._myVisibleBackup = this._myVisible;
            this.setVisible(false);
          }
        },
        isVisible() {
          return this._myVisible;
        },
        setVisible(visible) {
          this._myVisible = visible;
          if (this._myRootObject != null) {
            this._myRootObject.pp_setActive(this._myVisible);
            if (this._myVisible) {
              this._hideEmptySchemes();
            }
          }
        },
        setSelectText(text) {
          this._mySelectText = text;
          this._mySelectTextComponent.text = this._mySelectText;
          this.setVisible(this._myVisible);
        },
        setSqueezeText(text) {
          this._mySqueezeText = text;
          this._mySqueezeTextComponent.text = this._mySqueezeText;
          this.setVisible(this._myVisible);
        },
        setThumbstickText(text) {
          this._myThumbstickText = text;
          this._myThumbstickTextComponent.text = this._myThumbstickText;
          this.setVisible(this._myVisible);
        },
        setBottomButtonText(text) {
          this._myBottomButtonText = text;
          this._myBottomButtonTextComponent.text = this._myBottomButtonText;
          this.setVisible(this._myVisible);
        },
        setTopButtonText(text) {
          this._myTopButtonText = text;
          this._myTopButtonTextComponent.text = this._myTopButtonText;
          this.setVisible(this._myVisible);
        },
        _createControlScheme() {
          this._myRootObject = this.object.pp_addObject();
          let distanceFromButton = 0.02 * this._myDistanceFromButtonsMultiplier;
          let lineLength = 0.0935 * this._myLineLengthMultiplier;
          let referenceObject = this._myThumbstick;
          this._mySelectObject = this._myRootObject.pp_addObject();
          this._mySelectTextComponent = this._addScheme(
            this._mySelect,
            referenceObject,
            PP.vec3_create(0, 0, distanceFromButton),
            PP.vec3_create(lineLength * this._myControlSchemeDirection, 0, 0),
            this._mySelectObject
          );
          this._mySelectTextComponent.text = this._mySelectText;
          this._mySqueezeObject = this._myRootObject.pp_addObject();
          this._mySqueezeTextComponent = this._addScheme(
            this._mySqueeze,
            referenceObject,
            PP.vec3_create(distanceFromButton * this._myControlSchemeDirection, 0, 0),
            PP.vec3_create(lineLength * this._myControlSchemeDirection, 0, 0),
            this._mySqueezeObject
          );
          this._mySqueezeTextComponent.text = this._mySqueezeText;
          this._myThumbstickObject = this._myRootObject.pp_addObject();
          this._myThumbstickTextComponent = this._addScheme(
            this._myThumbstick,
            referenceObject,
            PP.vec3_create(0, distanceFromButton, 0),
            PP.vec3_create(-lineLength * this._myControlSchemeDirection, 0, 0),
            this._myThumbstickObject
          );
          this._myThumbstickTextComponent.text = this._myThumbstickText;
          let thumbstickPositionLocal = this._myThumbstick.pp_getPositionLocal();
          let thumbstickUpLocal = this._myThumbstick.pp_getUpLocal();
          {
            let bottomButtonPositionLocal = this._myBottomButton.pp_getPositionLocal();
            let difference = bottomButtonPositionLocal.vec3_sub(thumbstickPositionLocal);
            let differenceOnUp = difference.vec3_valueAlongAxis(thumbstickUpLocal);
            this._myBottomButtonObject = this._myRootObject.pp_addObject();
            this._myBottomButtonTextComponent = this._addScheme(
              this._myBottomButton,
              referenceObject,
              PP.vec3_create(0, distanceFromButton - differenceOnUp, 0),
              PP.vec3_create(0, 0, -lineLength),
              this._myBottomButtonObject
            );
            this._myBottomButtonTextComponent.text = this._myBottomButtonText;
          }
          {
            let topButtonPositionLocal = this._myTopButton.pp_getPositionLocal();
            let difference = topButtonPositionLocal.vec3_sub(thumbstickPositionLocal);
            let differenceOnUp = difference.vec3_valueAlongAxis(thumbstickUpLocal);
            this._myTopButtonObject = this._myRootObject.pp_addObject();
            this._myTopButtonTextComponent = this._addScheme(
              this._myTopButton,
              referenceObject,
              PP.vec3_create(0, distanceFromButton - differenceOnUp, 0),
              PP.vec3_create(-lineLength * this._myControlSchemeDirection, 0, 0).vec3_rotateAxis(-45 * this._myControlSchemeDirection, PP.vec3_create(0, 1, 0)),
              this._myTopButtonObject
            );
            this._myTopButtonTextComponent.text = this._myTopButtonText;
          }
        },
        _addScheme(buttonObject, referenceObject, startOffset, endOffset, parentObject) {
          let buttonPosition = buttonObject.pp_getPositionLocal();
          let referenceForward = referenceObject.pp_getForwardLocal();
          let referenceRight = referenceObject.pp_getRightLocal();
          let referenceUp = referenceObject.pp_getUpLocal();
          let lineStart = buttonPosition.vec3_add(referenceRight.vec3_scale(startOffset[0]));
          lineStart.vec3_add(referenceUp.vec3_scale(startOffset[1]), lineStart);
          lineStart.vec3_add(referenceForward.vec3_scale(startOffset[2]), lineStart);
          let lineEnd = lineStart.vec3_add(referenceRight.vec3_scale(endOffset[0]));
          lineEnd.vec3_add(referenceUp.vec3_scale(endOffset[1]), lineEnd);
          lineEnd.vec3_add(referenceForward.vec3_scale(endOffset[2]), lineEnd);
          let textOffset = 0.01 * this._myTextOffsetMultiplier;
          let textPosition = lineEnd.vec3_add(referenceForward.vec3_scale(-textOffset));
          this._addLine(lineStart, lineEnd, parentObject);
          let textComponent = this._addText(textPosition, referenceForward, referenceUp, parentObject);
          return textComponent;
        },
        _addLine(start, end, parentObject) {
          let lineDirection = end.vec3_sub(start);
          let length6 = lineDirection.vec3_length();
          lineDirection.vec3_normalize(lineDirection);
          let lineRootObject = parentObject.pp_addObject();
          let lineObject = lineRootObject.pp_addObject();
          let lineMesh = lineObject.addComponent("mesh");
          lineMesh.mesh = PP.myDefaultResources.myMeshes.myCylinder;
          lineMesh.material = this._myLineMaterialFinal;
          lineRootObject.pp_setPositionLocal(start);
          let thickness = 1e-3 * this._myLineThicknessMultiplier;
          lineObject.pp_scaleObject(PP.vec3_create(thickness / 2, length6 / 2, thickness / 2));
          lineObject.pp_setUpLocal(lineDirection);
          lineObject.pp_translateObject(PP.vec3_create(0, length6 / 2, 0));
        },
        _addText(position, forward, up, parentObject) {
          let textObject = parentObject.pp_addObject();
          textObject.pp_setPositionLocal(position);
          textObject.pp_lookToLocal(up, forward);
          textObject.pp_scaleObject(0.0935 * this._myTextScaleMultiplier);
          let textComponent = textObject.pp_addComponent("text");
          textComponent.alignment = WL.Alignment.Center;
          textComponent.justification = WL.Justification.Top;
          textComponent.material = this._myTextMaterialFinal;
          return textComponent;
        },
        _hideEmptySchemes() {
          if (this._mySelectText.length == 0) {
            this._mySelectObject.pp_setActive(false);
          }
          if (this._mySqueezeText.length == 0) {
            this._mySqueezeObject.pp_setActive(false);
          }
          if (this._myThumbstickText.length == 0) {
            this._myThumbstickObject.pp_setActive(false);
          }
          if (this._myBottomButtonText.length == 0) {
            this._myBottomButtonObject.pp_setActive(false);
          }
          if (this._myTopButtonText.length == 0) {
            this._myTopButtonObject.pp_setActive(false);
          }
        }
      });
    }
  });

  // js/pp/input/gamepad/virtual_gamepad/virtual_gamepad.js
  var require_virtual_gamepad = __commonJS({
    "js/pp/input/gamepad/virtual_gamepad/virtual_gamepad.js"() {
      PP.VirtualGamepad = class VirtualGamepad {
        constructor(params = new PP.VirtualGamepadParams()) {
          this._myParams = params;
          this._myVisible = true;
          this._myVirtualGamepadContainer = null;
          this._myVirtualGamepadVirtualButtons = [];
          this._myVirtualGamepadVirtualButtons[PP.Handedness.LEFT] = [];
          this._myVirtualGamepadVirtualButtons[PP.Handedness.RIGHT] = [];
          this._myVirtualGamepadVirtualButtons[PP.Handedness.LEFT][PP.GamepadButtonID.SELECT] = null;
          this._myVirtualGamepadVirtualButtons[PP.Handedness.LEFT][PP.GamepadButtonID.SQUEEZE] = null;
          this._myVirtualGamepadVirtualButtons[PP.Handedness.LEFT][PP.GamepadButtonID.THUMBSTICK] = null;
          this._myVirtualGamepadVirtualButtons[PP.Handedness.LEFT][PP.GamepadButtonID.TOP_BUTTON] = null;
          this._myVirtualGamepadVirtualButtons[PP.Handedness.LEFT][PP.GamepadButtonID.BOTTOM_BUTTON] = null;
          this._myVirtualGamepadVirtualButtons[PP.Handedness.RIGHT][PP.GamepadButtonID.SELECT] = null;
          this._myVirtualGamepadVirtualButtons[PP.Handedness.RIGHT][PP.GamepadButtonID.SQUEEZE] = null;
          this._myVirtualGamepadVirtualButtons[PP.Handedness.RIGHT][PP.GamepadButtonID.THUMBSTICK] = null;
          this._myVirtualGamepadVirtualButtons[PP.Handedness.RIGHT][PP.GamepadButtonID.TOP_BUTTON] = null;
          this._myVirtualGamepadVirtualButtons[PP.Handedness.RIGHT][PP.GamepadButtonID.BOTTOM_BUTTON] = null;
          this._myButtonsAmount = this._myVirtualGamepadVirtualButtons[PP.Handedness.LEFT].length;
          this._myVirtualGamepadVirtualThumbsticks = [];
          this._myVirtualGamepadVirtualThumbsticks[PP.Handedness.LEFT] = null;
          this._myVirtualGamepadVirtualThumbsticks[PP.Handedness.RIGHT] = null;
        }
        isVisible() {
          return this._myVisible;
        }
        setVisible(visible) {
          if (this._myVisible != visible) {
            this._myVisible = visible;
            if (this._myVirtualGamepadContainer != null) {
              if (this._myVisible) {
                this._myVirtualGamepadContainer.style.display = "block";
              } else {
                this._myVirtualGamepadContainer.style.display = "none";
              }
              for (let handedness in this._myVirtualGamepadVirtualButtons) {
                for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
                  let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
                  if (button != null) {
                    button.setActive(this._myVisible);
                  }
                }
              }
              for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
                let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness];
                if (thumbstick != null) {
                  thumbstick.setActive(this._myVisible);
                }
              }
            }
          }
        }
        isButtonPressed(handedness, gamepadButtonID) {
          if (!this._myVisible)
            return false;
          let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
          if (button != null) {
            return button.isPressed();
          }
          return false;
        }
        getAxes(handedness, outAxes = PP.vec2_create(0, 0)) {
          if (!this._myVisible)
            return outAxes;
          let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness];
          if (thumbstick != null) {
            outAxes.vec2_copy(thumbstick.getAxes());
          }
          return outAxes;
        }
        start() {
          this._buildVirtualGamepad();
          let currentVisible = this._myVisible;
          this._myVisible = !this._myVisible;
          this.setVisible(currentVisible);
        }
        update(dt) {
          if (this._myParams.myAutoUpdateVisibility) {
            if (PP.XRUtils.isSessionActive() && WL.vrSupported == 1) {
              this.setVisible(false);
            } else if (this._myParams.myShowOnDesktop && PP.BrowserUtils.isDesktop() && WL.vrSupported == 0) {
              this.setVisible(true);
            } else if (this._myParams.myShowOnHeadset && PP.BrowserUtils.isDesktop() && WL.vrSupported == 1) {
              this.setVisible(true);
            } else if (this._myParams.myShowOnMobile && PP.BrowserUtils.isMobile()) {
              this.setVisible(true);
            } else {
              this.setVisible(false);
            }
          }
          if (this._myVisible) {
            for (let handedness in this._myVirtualGamepadVirtualButtons) {
              for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
                let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
                if (button != null) {
                  button.update(dt);
                }
              }
            }
            for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
              let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness];
              if (thumbstick != null) {
                thumbstick.update(dt);
              }
            }
            this._setMouseHoverActive(!(this._myParams.myDisableMouseHoverWhenPressed && this._isAnyElementPressed()));
          }
        }
        _buildVirtualGamepad() {
          this._documentBodySetup();
          this._myVirtualGamepadContainer = document.createElement("div");
          this._myVirtualGamepadContainer.style.display = "block";
          this._myVirtualGamepadContainer.style.opacity = this._myParams.myOpacity.toString();
          document.body.appendChild(this._myVirtualGamepadContainer);
          let leftDiv = document.createElement("div");
          this._myVirtualGamepadContainer.appendChild(leftDiv);
          let rightDiv = document.createElement("div");
          this._myVirtualGamepadContainer.appendChild(rightDiv);
          let buttonsAmount = this._myParams.myButtonsOrder[PP.Handedness.LEFT].length;
          for (let i = 0; i < buttonsAmount; i++) {
            if (this._myParams.myButtonsOrder[PP.Handedness.LEFT][i] != null) {
              let gamepadButtonHandedness = this._myParams.myButtonsOrder[PP.Handedness.LEFT][i][0];
              let gamepadButtonID = this._myParams.myButtonsOrder[PP.Handedness.LEFT][i][1];
              this._buildButton(leftDiv, PP.Handedness.LEFT, i, gamepadButtonHandedness, gamepadButtonID);
            }
            if (this._myParams.myButtonsOrder[PP.Handedness.RIGHT][i] != null) {
              let gamepadButtonHandedness = this._myParams.myButtonsOrder[PP.Handedness.RIGHT][i][0];
              let gamepadButtonID = this._myParams.myButtonsOrder[PP.Handedness.RIGHT][i][1];
              this._buildButton(rightDiv, PP.Handedness.RIGHT, i, gamepadButtonHandedness, gamepadButtonID);
            }
          }
          if (this._myParams.myThumbsticksOrder[PP.Handedness.LEFT] != null) {
            let gamepadThumbstickHandedness = this._myParams.myThumbsticksOrder[PP.Handedness.LEFT];
            this._buildThumbstick(leftDiv, PP.Handedness.LEFT, gamepadThumbstickHandedness);
          }
          if (this._myParams.myThumbsticksOrder[PP.Handedness.RIGHT] != null) {
            let gamepadThumbstickHandedness = this._myParams.myThumbsticksOrder[PP.Handedness.RIGHT];
            this._buildThumbstick(rightDiv, PP.Handedness.RIGHT, gamepadThumbstickHandedness);
          }
        }
        _documentBodySetup() {
          document.body.style.overflow = "hidden";
          document.body.style.userSelect = "none";
          document.body.style.webkitUserSelect = "none";
          document.body.style.webkitTapHighlightColor = "transparent";
          document.body.style.touchAction = "none";
          document.addEventListener("gesturestart", function(e) {
            e.preventDefault();
          });
        }
        _buildButton(buttonElementParent, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID) {
          let virtualGamepadVirtualButton = new PP.VirtualGamepadVirtualButton(buttonElementParent, this._myParams, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID);
          this._myVirtualGamepadVirtualButtons[gamepadButtonHandedness][gamepadButtonID] = virtualGamepadVirtualButton;
        }
        _buildThumbstick(thumbstickElementParent, virtualThumbstickHandedness, gamepadThumbstickHandedness) {
          let virtualGamepadVirtualThumbstick = new PP.VirtualGamepadVirtualThumbstick(thumbstickElementParent, this._myParams, virtualThumbstickHandedness, gamepadThumbstickHandedness);
          this._myVirtualGamepadVirtualThumbsticks[gamepadThumbstickHandedness] = virtualGamepadVirtualThumbstick;
        }
        _createSizeValue(value, minSizeMultiplier) {
          return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
        }
        _isAnyElementPressed() {
          let isAnyElementPressed = false;
          for (let handedness in this._myVirtualGamepadVirtualButtons) {
            for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
              let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
              if (button != null && button.isPressed()) {
                isAnyElementPressed = true;
                break;
              }
            }
          }
          if (!isAnyElementPressed) {
            for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
              let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness];
              if (thumbstick != null && thumbstick.isPressed()) {
                isAnyElementPressed = true;
                break;
              }
            }
          }
          return isAnyElementPressed;
        }
        _setMouseHoverActive(hoverActive) {
          for (let handedness in this._myVirtualGamepadVirtualButtons) {
            for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
              let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
              if (button != null) {
                button.setMouseHoverActive(hoverActive);
              }
            }
          }
          for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
            let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness];
            if (thumbstick != null) {
              thumbstick.setMouseHoverActive(hoverActive);
            }
          }
        }
      };
    }
  });

  // js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_component.js
  var require_virtual_gamepad_component = __commonJS({
    "js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_component.js"() {
      WL.registerComponent("pp-virtual-gamepad", {
        _myShowOnDesktop: { type: WL.Type.Bool, default: false },
        // you may have to enable headset too
        _myShowOnMobile: { type: WL.Type.Bool, default: true },
        _myShowOnHeadset: { type: WL.Type.Bool, default: false },
        // not 100% reliable, this is true if the device supports vr and it is desktop
        _myReleaseOnPointerLeave: { type: WL.Type.Bool, default: false },
        _myAddToUniversalGamepad: { type: WL.Type.Bool, default: true },
        _myOpacity: { type: WL.Type.Float, default: 0.5 },
        _myIconColor: { type: WL.Type.String, default: "#e0e0e0" },
        _myBackgroundColor: { type: WL.Type.String, default: "#616161" },
        _myInterfaceScale: { type: WL.Type.Float, default: 1 },
        _myMarginScale: { type: WL.Type.Float, default: 1 },
        ADVANCED_PARAMS_BELOW: { type: WL.Type.String, default: "" },
        _myLabelFontSize: { type: WL.Type.Float, default: 2 },
        _myLabelFontFamily: { type: WL.Type.String, default: "sans-serif" },
        _myLabelFontWeight: { type: WL.Type.String, default: "bold" },
        _myImagePressedBrightness: { type: WL.Type.Float, default: 0.5 },
        _myLeftSelectButtonVisible: { type: WL.Type.Bool, default: true },
        _myLeftSelectButtonOrderIndex: { type: WL.Type.Int, default: 1 },
        _myLeftSelectButtonIconType: { type: WL.Type.Enum, values: ["none", "label", "image", "dot", "circle", "square", "ring", "frame"], default: "frame" },
        _myLeftSelectButtonIconLabelOrImageUrl: { type: WL.Type.String, default: "" },
        _myLeftSqueezeButtonVisible: { type: WL.Type.Bool, default: true },
        _myLeftSqueezeButtonOrderIndex: { type: WL.Type.Int, default: 0 },
        _myLeftSqueezeButtonIconType: { type: WL.Type.Enum, values: ["none", "label", "image", "dot", "circle", "square", "ring", "frame"], default: "square" },
        _myLeftSqueezeButtonIconLabelOrImageUrl: { type: WL.Type.String, default: "" },
        _myLeftThumbstickButtonVisible: { type: WL.Type.Bool, default: true },
        _myLeftThumbstickButtonOrderIndex: { type: WL.Type.Int, default: 4 },
        _myLeftThumbstickButtonIconType: { type: WL.Type.Enum, values: ["none", "label", "image", "dot", "circle", "square", "ring", "frame"], default: "dot" },
        _myLeftThumbstickButtonIconLabelOrImageUrl: { type: WL.Type.String, default: "" },
        _myLeftTopButtonVisible: { type: WL.Type.Bool, default: true },
        _myLeftTopButtonOrderIndex: { type: WL.Type.Int, default: 2 },
        _myLeftTopButtonIconType: { type: WL.Type.Enum, values: ["none", "label", "image", "dot", "circle", "square", "ring", "frame"], default: "circle" },
        _myLeftTopButtonIconLabelOrImageUrl: { type: WL.Type.String, default: "" },
        _myLeftBottomButtonVisible: { type: WL.Type.Bool, default: true },
        _myLeftBottomButtonOrderIndex: { type: WL.Type.Int, default: 3 },
        _myLeftBottomButtonIconType: { type: WL.Type.Enum, values: ["none", "label", "image", "dot", "circle", "square", "ring", "frame"], default: "ring" },
        _myLeftBottomButtonIconLabelOrImageUrl: { type: WL.Type.String, default: "" },
        _myRightSelectButtonVisible: { type: WL.Type.Bool, default: true },
        _myRightSelectButtonOrderIndex: { type: WL.Type.Int, default: 1 },
        _myRightSelectButtonIconType: { type: WL.Type.Enum, values: ["none", "label", "image", "dot", "circle", "square", "ring", "frame"], default: "frame" },
        _myRightSelectButtonIconLabelOrImageUrl: { type: WL.Type.String, default: "" },
        _myRightSqueezeButtonVisible: { type: WL.Type.Bool, default: true },
        _myRightSqueezeButtonOrderIndex: { type: WL.Type.Int, default: 0 },
        _myRightSqueezeButtonIconType: { type: WL.Type.Enum, values: ["none", "label", "image", "dot", "circle", "square", "ring", "frame"], default: "square" },
        _myRightSqueezeButtonIconLabelOrImageUrl: { type: WL.Type.String, default: "" },
        _myRightThumbstickButtonVisible: { type: WL.Type.Bool, default: true },
        _myRightThumbstickButtonOrderIndex: { type: WL.Type.Int, default: 4 },
        _myRightThumbstickButtonIconType: { type: WL.Type.Enum, values: ["none", "label", "image", "dot", "circle", "square", "ring", "frame"], default: "dot" },
        _myRightThumbstickButtonIconLabelOrImageUrl: { type: WL.Type.String, default: "" },
        _myRightTopButtonVisible: { type: WL.Type.Bool, default: true },
        _myRightTopButtonOrderIndex: { type: WL.Type.Int, default: 2 },
        _myRightTopButtonIconType: { type: WL.Type.Enum, values: ["none", "label", "image", "dot", "circle", "square", "ring", "frame"], default: "circle" },
        _myRightTopButtonIconLabelOrImageUrl: { type: WL.Type.String, default: "" },
        _myRightBottomButtonVisible: { type: WL.Type.Bool, default: true },
        _myRightBottomButtonOrderIndex: { type: WL.Type.Int, default: 3 },
        _myRightBottomButtonIconType: { type: WL.Type.Enum, values: ["none", "label", "image", "dot", "circle", "square", "ring", "frame"], default: "ring" },
        _myRightBottomButtonIconLabelOrImageUrl: { type: WL.Type.String, default: "" }
      }, {
        start() {
          let params = new PP.VirtualGamepadParams();
          params.defaultSetup();
          for (let handedness in params.myButtonParams) {
            for (let gamepadButtonID in params.myButtonParams[handedness]) {
              let buttonParams = params.myButtonParams[handedness][gamepadButtonID];
              buttonParams.myIconParams.myBackgroundColor = this._myBackgroundColor;
              buttonParams.myIconParams.myBackgroundPressedColor = this._myIconColor;
              buttonParams.myIconParams.myIconColor = this._myIconColor;
              buttonParams.myIconParams.myIconPressedColor = this._myBackgroundColor;
            }
          }
          for (let handedness in params.myThumbstickParams) {
            let thumbstickParams = params.myThumbstickParams[handedness];
            thumbstickParams.myBackgroundColor = this._myBackgroundColor;
            thumbstickParams.myIconParams.myBackgroundColor = this._myIconColor;
            thumbstickParams.myIconParams.myBackgroundPressedColor = this._myIconColor;
            thumbstickParams.myIconParams.myIconColor = this._myBackgroundColor;
            thumbstickParams.myIconParams.myIconPressedColor = this._myBackgroundColor;
          }
          params.myOpacity = this._myOpacity;
          params.myReleaseOnPointerLeave = this._myReleaseOnPointerLeave;
          params.myInterfaceScale = this._myInterfaceScale;
          params.myMarginScale = this._myMarginScale;
          params.myShowOnDesktop = this._myShowOnDesktop;
          params.myShowOnMobile = this._myShowOnMobile;
          params.myShowOnHeadset = this._myShowOnHeadset;
          if (params.myShowOnDesktop || params.myShowOnMobile || params.myShowOnHeadset) {
            params.myAutoUpdateVisibility = true;
          } else {
            params.myAutoUpdateVisibility = false;
          }
          this._advancedSetup(params);
          this._myVirtualGamepad = new PP.VirtualGamepad(params);
          if (!params.myAutoUpdateVisibility) {
            this._myVirtualGamepad.setVisible(false);
          }
          this._myVirtualGamepad.start();
          this._myFirstUpdate = true;
        },
        update(dt) {
          if (this._myFirstUpdate) {
            this._myFirstUpdate = false;
            if (this._myAddToUniversalGamepad) {
              let leftVirtualGamepadGamepadCore = new PP.VirtualGamepadGamepadCore(this._myVirtualGamepad, PP.Handedness.LEFT, PP.myLeftGamepad.getGamepadCore("left_xr_gamepad").getHandPose());
              let rightVirtualGamepadGamepadCore = new PP.VirtualGamepadGamepadCore(this._myVirtualGamepad, PP.Handedness.RIGHT, PP.myRightGamepad.getGamepadCore("right_xr_gamepad").getHandPose());
              PP.myLeftGamepad.addGamepadCore("left_virtual_gamepad", leftVirtualGamepadGamepadCore);
              PP.myRightGamepad.addGamepadCore("right_virtual_gamepad", rightVirtualGamepadGamepadCore);
            }
          }
          this._myVirtualGamepad.update(dt);
        },
        _advancedSetup(params) {
          params.myButtonsOrder[PP.Handedness.LEFT] = [null, null, null, null, null];
          params.myButtonsOrder[PP.Handedness.RIGHT] = [null, null, null, null, null];
          {
            let buttonParams = params.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.SELECT];
            buttonParams.myIconParams.myIconType = this._myLeftSelectButtonIconType;
            buttonParams.myIconParams.myLabel = this._myLeftSelectIconLabelOrImageUrl;
            buttonParams.myIconParams.myImageURL = this._myLeftSelectIconLabelOrImageUrl;
            buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
            buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
            buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
            buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
            if (this._myLeftSelectButtonVisible) {
              params.myButtonsOrder[PP.Handedness.LEFT][this._myLeftSelectButtonOrderIndex] = [PP.Handedness.LEFT, PP.GamepadButtonID.SELECT];
            }
          }
          {
            let buttonParams = params.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.SQUEEZE];
            buttonParams.myIconParams.myIconType = this._myLeftSqueezeButtonIconType;
            buttonParams.myIconParams.myLabel = this._myLeftSqueezeIconLabelOrImageUrl;
            buttonParams.myIconParams.myImageURL = this._myLeftSqueezeIconLabelOrImageUrl;
            buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
            buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
            buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
            buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
            if (this._myLeftSqueezeButtonVisible) {
              params.myButtonsOrder[PP.Handedness.LEFT][this._myLeftSqueezeButtonOrderIndex] = [PP.Handedness.LEFT, PP.GamepadButtonID.SQUEEZE];
            }
          }
          {
            let buttonParams = params.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.THUMBSTICK];
            buttonParams.myIconParams.myIconType = this._myLeftThumbstickButtonIconType;
            buttonParams.myIconParams.myLabel = this._myLeftThumbstickButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myImageURL = this._myLeftThumbstickButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
            buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
            buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
            buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
            if (this._myLeftThumbstickButtonVisible) {
              params.myButtonsOrder[PP.Handedness.LEFT][this._myLeftThumbstickButtonOrderIndex] = [PP.Handedness.LEFT, PP.GamepadButtonID.THUMBSTICK];
            }
          }
          {
            let buttonParams = params.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.TOP_BUTTON];
            buttonParams.myIconParams.myIconType = this._myLeftTopButtonIconType;
            buttonParams.myIconParams.myLabel = this._myLeftTopButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myImageURL = this._myLeftTopButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
            buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
            buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
            buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
            if (this._myLeftTopButtonVisible) {
              params.myButtonsOrder[PP.Handedness.LEFT][this._myLeftTopButtonOrderIndex] = [PP.Handedness.LEFT, PP.GamepadButtonID.TOP_BUTTON];
            }
          }
          {
            let buttonParams = params.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.BOTTOM_BUTTON];
            buttonParams.myIconParams.myIconType = this._myLeftBottomButtonIconType;
            buttonParams.myIconParams.myLabel = this._myLeftBottomButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myImageURL = this._myLeftBottomButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
            buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
            buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
            buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
            if (this._myLeftBottomButtonVisible) {
              params.myButtonsOrder[PP.Handedness.LEFT][this._myLeftBottomButtonOrderIndex] = [PP.Handedness.LEFT, PP.GamepadButtonID.BOTTOM_BUTTON];
            }
          }
          {
            let buttonParams = params.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.SELECT];
            buttonParams.myIconParams.myIconType = this._myRightSelectButtonIconType;
            buttonParams.myIconParams.myLabel = this._myRightSelectIconLabelOrImageUrl;
            buttonParams.myIconParams.myImageURL = this._myRightSelectIconLabelOrImageUrl;
            buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
            buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
            buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
            buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
            if (this._myRightSelectButtonVisible) {
              params.myButtonsOrder[PP.Handedness.RIGHT][this._myRightSelectButtonOrderIndex] = [PP.Handedness.RIGHT, PP.GamepadButtonID.SELECT];
            }
          }
          {
            let buttonParams = params.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.SQUEEZE];
            buttonParams.myIconParams.myIconType = this._myRightSqueezeButtonIconType;
            buttonParams.myIconParams.myLabel = this._myRightSqueezeIconLabelOrImageUrl;
            buttonParams.myIconParams.myImageURL = this._myRightSqueezeIconLabelOrImageUrl;
            buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
            buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
            buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
            buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
            if (this._myRightSqueezeButtonVisible) {
              params.myButtonsOrder[PP.Handedness.RIGHT][this._myRightSqueezeButtonOrderIndex] = [PP.Handedness.RIGHT, PP.GamepadButtonID.SQUEEZE];
            }
          }
          {
            let buttonParams = params.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.THUMBSTICK];
            buttonParams.myIconParams.myIconType = this._myRightThumbstickButtonIconType;
            buttonParams.myIconParams.myLabel = this._myRightThumbstickButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myImageURL = this._myRightThumbstickButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
            buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
            buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
            buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
            if (this._myRightThumbstickButtonVisible) {
              params.myButtonsOrder[PP.Handedness.RIGHT][this._myRightThumbstickButtonOrderIndex] = [PP.Handedness.RIGHT, PP.GamepadButtonID.THUMBSTICK];
            }
          }
          {
            let buttonParams = params.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.TOP_BUTTON];
            buttonParams.myIconParams.myIconType = this._myRightTopButtonIconType;
            buttonParams.myIconParams.myLabel = this._myRightTopButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myImageURL = this._myRightTopButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
            buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
            buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
            buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
            if (this._myRightTopButtonVisible) {
              params.myButtonsOrder[PP.Handedness.RIGHT][this._myRightTopButtonOrderIndex] = [PP.Handedness.RIGHT, PP.GamepadButtonID.TOP_BUTTON];
            }
          }
          {
            let buttonParams = params.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.BOTTOM_BUTTON];
            buttonParams.myIconParams.myIconType = this._myRightBottomButtonIconType;
            buttonParams.myIconParams.myLabel = this._myRightBottomButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myImageURL = this._myRightBottomButtonIconLabelOrImageUrl;
            buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
            buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
            buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
            buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
            if (this._myRightBottomButtonVisible) {
              params.myButtonsOrder[PP.Handedness.RIGHT][this._myRightBottomButtonOrderIndex] = [PP.Handedness.RIGHT, PP.GamepadButtonID.BOTTOM_BUTTON];
            }
          }
        }
      });
    }
  });

  // js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_params.js
  var require_virtual_gamepad_params = __commonJS({
    "js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_params.js"() {
      PP.VirtualGamepadButtonParams = class VirtualGamepadButtonParams {
        constructor() {
          this.myIconParams = new PP.VirtualGamepadIconParams();
        }
      };
      PP.VirtualGamepadThumbstickParams = class VirtualGamepadThumbstickParams {
        constructor() {
          this.myBackgroundColor = "";
          this.myMaxDistanceFromCenterMultiplier = 1;
          this.myReleaseTransitionSeconds = 0.2;
          this.myMoveTransitionSeconds = 0;
          this.myIncludeBackgroundToDetection = false;
          this.myIconParams = new PP.VirtualGamepadIconParams();
        }
      };
      PP.VirtualGamepadParams = class VirtualGamepadParams {
        constructor() {
          this.myShowOnDesktop = false;
          this.myShowOnMobile = false;
          this.myShowOnHeadset = false;
          this.myAutoUpdateVisibility = false;
          this.myOpacity = 1;
          this.myInterfaceScale = 1;
          this.myMarginScale = 1;
          this.myReleaseOnPointerLeave = false;
          this.myStopPropagatingMouseDownEvents = true;
          this.myButtonParams = [];
          this.myButtonParams[PP.Handedness.LEFT] = [];
          this.myButtonParams[PP.Handedness.RIGHT] = [];
          this.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.SELECT] = new PP.VirtualGamepadButtonParams();
          this.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.SQUEEZE] = new PP.VirtualGamepadButtonParams();
          this.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.THUMBSTICK] = new PP.VirtualGamepadButtonParams();
          this.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.TOP_BUTTON] = new PP.VirtualGamepadButtonParams();
          this.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.BOTTOM_BUTTON] = new PP.VirtualGamepadButtonParams();
          this.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.SELECT] = new PP.VirtualGamepadButtonParams();
          this.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.SQUEEZE] = new PP.VirtualGamepadButtonParams();
          this.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.THUMBSTICK] = new PP.VirtualGamepadButtonParams();
          this.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.TOP_BUTTON] = new PP.VirtualGamepadButtonParams();
          this.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.BOTTOM_BUTTON] = new PP.VirtualGamepadButtonParams();
          this.myThumbstickParams = [];
          this.myThumbstickParams[PP.Handedness.LEFT] = new PP.VirtualGamepadThumbstickParams();
          this.myThumbstickParams[PP.Handedness.RIGHT] = new PP.VirtualGamepadThumbstickParams();
          this.myButtonsOrder = [];
          this.myButtonsOrder[PP.Handedness.LEFT] = [null, null, null, null, null];
          this.myButtonsOrder[PP.Handedness.RIGHT] = [null, null, null, null, null];
          this.myThumbsticksOrder = [];
          this.myThumbsticksOrder[PP.Handedness.LEFT] = null;
          this.myThumbsticksOrder[PP.Handedness.RIGHT] = null;
          this.myValidPointerButtons = [];
          this.myMarginLeft = 0;
          this.myMarginRight = 0;
          this.myMarginBottom = 0;
          this.myThumbstickSize = 0;
          this.myButtonSize = 0;
          this.myButtonsRingRadius = 0;
          this.myButtonsRingStartAngle = 0;
          this.myButtonsRingEndAngle = 0;
          this.myFontSize = 0;
          this.myMinSizeMultiplier = 0;
          this.myDisableMouseHoverWhenPressed = false;
        }
        defaultSetup() {
          this.myShowOnMobile = true;
          this.myAutoUpdateVisibility = true;
          this.myOpacity = 0.5;
          let backgroundColor = "#616161";
          let iconColor = "#e0e0e0";
          let buttonHoveredBrightness = 0.75;
          let thumbstickHoveredBrightness = 0.75;
          let thumbstickIncludeBackgroundToDetection = true;
          for (let handedness in this.myButtonParams) {
            for (let gamepadButtonID in this.myButtonParams[handedness]) {
              let buttonParams = this.myButtonParams[handedness][gamepadButtonID];
              buttonParams.myIconParams.myBackgroundColor = backgroundColor;
              buttonParams.myIconParams.myBackgroundPressedColor = iconColor;
              buttonParams.myIconParams.myIconColor = iconColor;
              buttonParams.myIconParams.myIconPressedColor = backgroundColor;
              buttonParams.myIconParams.myOverallHoveredBrightness = buttonHoveredBrightness;
            }
          }
          this.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.SQUEEZE].myIconParams.myIconType = PP.VirtualGamepadIconType.SQUARE;
          this.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.SQUEEZE].myIconParams.myIconType = PP.VirtualGamepadIconType.SQUARE;
          this.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.SELECT].myIconParams.myIconType = PP.VirtualGamepadIconType.FRAME;
          this.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.SELECT].myIconParams.myIconType = PP.VirtualGamepadIconType.FRAME;
          this.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.TOP_BUTTON].myIconParams.myIconType = PP.VirtualGamepadIconType.CIRCLE;
          this.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.TOP_BUTTON].myIconParams.myIconType = PP.VirtualGamepadIconType.CIRCLE;
          this.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.BOTTOM_BUTTON].myIconParams.myIconType = PP.VirtualGamepadIconType.RING;
          this.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.BOTTOM_BUTTON].myIconParams.myIconType = PP.VirtualGamepadIconType.RING;
          this.myButtonParams[PP.Handedness.LEFT][PP.GamepadButtonID.THUMBSTICK].myIconParams.myIconType = PP.VirtualGamepadIconType.DOT;
          this.myButtonParams[PP.Handedness.RIGHT][PP.GamepadButtonID.THUMBSTICK].myIconParams.myIconType = PP.VirtualGamepadIconType.DOT;
          for (let handedness in this.myThumbstickParams) {
            let thumbstickParams = this.myThumbstickParams[handedness];
            thumbstickParams.myBackgroundColor = backgroundColor;
            thumbstickParams.myIconParams.myBackgroundColor = iconColor;
            thumbstickParams.myIconParams.myBackgroundPressedColor = iconColor;
            thumbstickParams.myIconParams.myIconColor = backgroundColor;
            thumbstickParams.myIconParams.myIconPressedColor = backgroundColor;
            thumbstickParams.myIconParams.myOverallHoveredBrightness = thumbstickHoveredBrightness;
            thumbstickParams.myIncludeBackgroundToDetection = thumbstickIncludeBackgroundToDetection;
          }
          this.myButtonsOrder[PP.Handedness.LEFT][0] = [PP.Handedness.LEFT, PP.GamepadButtonID.SQUEEZE];
          this.myButtonsOrder[PP.Handedness.LEFT][1] = [PP.Handedness.LEFT, PP.GamepadButtonID.SELECT];
          this.myButtonsOrder[PP.Handedness.LEFT][2] = [PP.Handedness.LEFT, PP.GamepadButtonID.TOP_BUTTON];
          this.myButtonsOrder[PP.Handedness.LEFT][3] = [PP.Handedness.LEFT, PP.GamepadButtonID.BOTTOM_BUTTON];
          this.myButtonsOrder[PP.Handedness.LEFT][4] = [PP.Handedness.LEFT, PP.GamepadButtonID.THUMBSTICK];
          this.myButtonsOrder[PP.Handedness.RIGHT][0] = [PP.Handedness.RIGHT, PP.GamepadButtonID.SQUEEZE];
          this.myButtonsOrder[PP.Handedness.RIGHT][1] = [PP.Handedness.RIGHT, PP.GamepadButtonID.SELECT];
          this.myButtonsOrder[PP.Handedness.RIGHT][2] = [PP.Handedness.RIGHT, PP.GamepadButtonID.TOP_BUTTON];
          this.myButtonsOrder[PP.Handedness.RIGHT][3] = [PP.Handedness.RIGHT, PP.GamepadButtonID.BOTTOM_BUTTON];
          this.myButtonsOrder[PP.Handedness.RIGHT][4] = [PP.Handedness.RIGHT, PP.GamepadButtonID.THUMBSTICK];
          this.myThumbsticksOrder[PP.Handedness.LEFT] = PP.Handedness.LEFT;
          this.myThumbsticksOrder[PP.Handedness.RIGHT] = PP.Handedness.RIGHT;
          this.myMarginLeft = 3;
          this.myMarginRight = 3;
          this.myMarginBottom = 3;
          this.myThumbstickSize = 15;
          this.myButtonSize = 5;
          this.myButtonsRingRadius = 12;
          this.myButtonsRingStartAngle = 385;
          this.myButtonsRingEndAngle = 245;
          this.myMinSizeMultiplier = 5 / 3;
          this.myDisableMouseHoverWhenPressed = true;
          this.myValidPointerButtons = [0];
        }
      };
    }
  });

  // js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_button.js
  var require_virtual_gamepad_virtual_button = __commonJS({
    "js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_button.js"() {
      PP.VirtualGamepadVirtualButton = class VirtualGamepadVirtualButton {
        constructor(buttonElementParent, virtualGamepadParams, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID) {
          this._myButtonElement = null;
          this._myButtonIcon = null;
          this._myButtonDetectionElement = null;
          this._myIsActive = true;
          this._myPointerID = null;
          this._myPointerButton = null;
          this._myIsPressed = false;
          this._myVirtualGamepadParams = virtualGamepadParams;
          this._myParams = this._myVirtualGamepadParams.myButtonParams[gamepadButtonHandedness][gamepadButtonID];
          this._build(buttonElementParent, virtualButtonHandedness, virtualButtonIndex);
          this._myButtonDetectionElement.addEventListener("pointerdown", this._onPointerDown.bind(this, this._myVirtualGamepadParams.myStopPropagatingPointerDownEvents));
          document.body.addEventListener("pointerup", this._onPointerUp.bind(this));
          if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
            document.body.addEventListener("pointerleave", this._onPointerLeave.bind(this));
          }
          this._myButtonDetectionElement.addEventListener("mouseenter", this._onButtonEnter.bind(this));
          this._myButtonDetectionElement.addEventListener("mouseleave", this._onButtonLeave.bind(this));
        }
        isPressed() {
          return this._myIsActive && this._myIsPressed;
        }
        setActive(active) {
          if (this._myIsActive != active) {
            this.reset();
            this._myButtonIcon.reset();
          }
          this._myIsActive = active;
        }
        setMouseHoverActive(hoverActive) {
          this._myButtonIcon.setMouseHoverActive(hoverActive);
        }
        reset() {
          this._myButtonIcon.setPressed(false);
          this._myIsPressed = false;
          this._myPointerID = null;
          this._myPointerButton = null;
        }
        update(dt) {
          this._myButtonIcon.update(dt);
        }
        _onPointerDown(stopPropagatingPointerDownEvents, event) {
          if (!this._myIsActive)
            return;
          if (this._myIsPressed)
            return;
          if (!this._myVirtualGamepadParams.myValidPointerButtons.pp_hasEqual(event.button))
            return;
          if (stopPropagatingPointerDownEvents) {
            event.stopPropagation();
          }
          event.preventDefault();
          this._myButtonIcon.setPressed(true);
          this._myPointerID = event.pointerId;
          this._myPointerButton = event.button;
          this._myIsPressed = true;
        }
        _onPointerUp(event) {
          if (!this._myIsActive)
            return;
          if (!this._myIsPressed)
            return;
          if (this._myPointerID != event.pointerId)
            return;
          if (this._myPointerButton != null && this._myPointerButton != event.button)
            return;
          this.reset();
        }
        _onPointerLeave(event) {
          if (!this._myIsActive)
            return;
          if (this._myPointerID != event.pointerId)
            return;
          this.reset();
        }
        _onButtonEnter(event) {
          if (!this._myIsActive)
            return;
          this._myButtonIcon.onMouseEnter(event);
        }
        _onButtonLeave(event) {
          if (!this._myIsActive)
            return;
          this._myButtonIcon.onMouseLeave(event);
        }
        _build(buttonElementParent, virtualButtonHandedness, virtualButtonIndex) {
          let buttonSize = this._myVirtualGamepadParams.myButtonSize * this._myVirtualGamepadParams.myInterfaceScale;
          let buttonsRingRadius = this._myVirtualGamepadParams.myButtonsRingRadius * this._myVirtualGamepadParams.myInterfaceScale;
          let thumbstickSize = this._myVirtualGamepadParams.myThumbstickSize * this._myVirtualGamepadParams.myInterfaceScale;
          let marginBottom = this._myVirtualGamepadParams.myMarginBottom * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
          let marginLeft = this._myVirtualGamepadParams.myMarginLeft * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
          let marginRight = this._myVirtualGamepadParams.myMarginRight * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
          let buttonRingStartAngle = this._myVirtualGamepadParams.myButtonsRingStartAngle;
          let buttonRingEndAngle = this._myVirtualGamepadParams.myButtonsRingEndAngle;
          let minSizeMultiplier = Math.max(1, this._myVirtualGamepadParams.myMinSizeMultiplier / this._myVirtualGamepadParams.myInterfaceScale);
          let buttonsAmount = this._myVirtualGamepadParams.myButtonsOrder[PP.Handedness.LEFT].length;
          let angleStep = (buttonRingEndAngle - buttonRingStartAngle) / (buttonsAmount - 1);
          let currentAngle = Math.pp_angleClamp(buttonRingStartAngle + angleStep * virtualButtonIndex);
          if (virtualButtonHandedness == PP.Handedness.RIGHT) {
            currentAngle = 270 + (270 - currentAngle);
            currentAngle = Math.pp_angleClamp(currentAngle, true);
          }
          let counterAngle = 360 - currentAngle;
          let buttonPivot = document.createElement("div");
          buttonPivot.style.position = "absolute";
          buttonPivot.style.width = this._createSizeValue(buttonSize, minSizeMultiplier);
          buttonPivot.style.height = this._createSizeValue(buttonSize, minSizeMultiplier);
          let centerOnThumbstickBottom = marginBottom + thumbstickSize / 2 - buttonSize / 2;
          buttonPivot.style.bottom = this._createSizeValue(centerOnThumbstickBottom, minSizeMultiplier);
          if (virtualButtonHandedness == PP.Handedness.LEFT) {
            let centerOnThumbstickLeft = marginLeft + thumbstickSize / 2 - buttonSize / 2;
            buttonPivot.style.left = this._createSizeValue(centerOnThumbstickLeft, minSizeMultiplier);
          } else {
            let centerOnThumbstickRight = marginRight + thumbstickSize / 2 - buttonSize / 2;
            buttonPivot.style.right = this._createSizeValue(centerOnThumbstickRight, minSizeMultiplier);
          }
          buttonPivot.style.transform = "rotate(" + currentAngle + "deg) translateX(" + this._createSizeValue(buttonsRingRadius, minSizeMultiplier) + ")";
          buttonElementParent.appendChild(buttonPivot);
          this._myButtonElement = document.createElement("div");
          this._myButtonElement.style.position = "absolute";
          this._myButtonElement.style.width = "100%";
          this._myButtonElement.style.height = "100%";
          this._myButtonElement.style.transform = "rotate(" + counterAngle + "deg)";
          buttonPivot.appendChild(this._myButtonElement);
          this._myButtonIcon = new PP.VirtualGamepadIcon(this._myButtonElement, this._myParams.myIconParams, minSizeMultiplier, this._myVirtualGamepadParams.myInterfaceScale);
          let buttonElementStill = document.createElement("div");
          buttonElementStill.style.position = "absolute";
          buttonElementStill.style.width = "100%";
          buttonElementStill.style.height = "100%";
          buttonElementStill.style.transform = "rotate(" + counterAngle + "deg)";
          buttonPivot.appendChild(buttonElementStill);
          let buttonDetectionElementSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          buttonDetectionElementSVG.style.position = "absolute";
          buttonDetectionElementSVG.style.width = "100%";
          buttonDetectionElementSVG.style.height = "100%";
          buttonElementStill.appendChild(buttonDetectionElementSVG);
          let buttonDetectionElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          buttonDetectionElement.setAttributeNS(null, "cx", "50%");
          buttonDetectionElement.setAttributeNS(null, "cy", "50%");
          buttonDetectionElement.setAttributeNS(null, "r", "50%");
          buttonDetectionElement.style.fill = "#00000000";
          buttonDetectionElementSVG.appendChild(buttonDetectionElement);
          this._myButtonDetectionElement = buttonDetectionElement;
        }
        _createSizeValue(value, minSizeMultiplier) {
          return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
        }
      };
    }
  });

  // js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_thumbstick.js
  var require_virtual_gamepad_virtual_thumbstick = __commonJS({
    "js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_thumbstick.js"() {
      PP.VirtualGamepadVirtualThumbstick = class VirtualGamepadVirtualThumbstick {
        constructor(thumbstickElementParent, virtualGamepadParams, virtualThumbstickHandedness, gamepadThumbstickHandedness) {
          this._myThumbstickElement = null;
          this._myThumbstickIcon = null;
          this._myThumbstickBackground = null;
          this._myThumbstickDetectionElement = null;
          this._myIsActive = true;
          this._myPointerID = null;
          this._myPointerButton = null;
          this._myThumbstickDragStartPosition = PP.vec2_create();
          this._myAxes = PP.vec2_create();
          this._myIsPressed = false;
          this._myVirtualGamepadParams = virtualGamepadParams;
          this._myParams = this._myVirtualGamepadParams.myThumbstickParams[gamepadThumbstickHandedness];
          this._build(thumbstickElementParent, virtualThumbstickHandedness);
          this._myThumbstickDetectionElement.addEventListener("pointerdown", this._onPointerDown.bind(this, this._myVirtualGamepadParams.myStopPropagatingPointerDownEvents));
          document.body.addEventListener("pointerup", this._onPointerUp.bind(this));
          document.body.addEventListener("pointermove", this._onPointerMove.bind(this));
          if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
            document.body.addEventListener("pointerleave", this._onPointerLeave.bind(this));
          }
          this._myThumbstickDetectionElement.addEventListener("mouseenter", this._onThumbstickEnter.bind(this));
          this._myThumbstickDetectionElement.addEventListener("mouseleave", this._onThumbstickLeave.bind(this));
        }
        isPressed() {
          return this._myIsActive && this._myIsPressed;
        }
        getAxes() {
          return this._myAxes;
        }
        setActive(active) {
          if (this._myIsActive != active) {
            this.reset();
            this._myThumbstickIcon.reset();
          }
          this._myIsActive = active;
        }
        setMouseHoverActive(hoverActive) {
          this._myThumbstickIcon.setMouseHoverActive(hoverActive);
        }
        reset() {
          this._myThumbstickIcon.setPressed(false);
          this._myAxes[0] = 0;
          this._myAxes[1] = 0;
          this._myIsPressed = false;
          this._myPointerID = null;
          this._myPointerButton = null;
          this._myThumbstickElement.style.transition = "all " + this._myParams.myReleaseTransitionSeconds + "s ease 0s";
          this._myThumbstickElement.style.transform = "translate(0px, 0px)";
        }
        update(dt) {
          this._myThumbstickIcon.update(dt);
        }
        _onPointerDown(stopPropagatingPointerDownEvents, event) {
          if (!this._myIsActive)
            return;
          if (this._myIsPressed)
            return;
          if (!this._myVirtualGamepadParams.myValidPointerButtons.pp_hasEqual(event.button))
            return;
          if (stopPropagatingPointerDownEvents) {
            event.stopPropagation();
          }
          event.preventDefault();
          this._myThumbstickIcon.setPressed(true);
          this._myPointerID = event.pointerId;
          this._myPointerButton = event.button;
          this._myThumbstickDragStartPosition[0] = event.clientX;
          this._myThumbstickDragStartPosition[1] = event.clientY;
          this._myIsPressed = true;
        }
        _onPointerUp(event) {
          if (!this._myIsActive)
            return;
          if (!this._myIsPressed)
            return;
          if (this._myPointerID != event.pointerId)
            return;
          if (this._myPointerButton != null && this._myPointerButton != event.button)
            return;
          this.reset();
        }
        _onPointerLeave(event) {
          if (!this._myIsActive)
            return;
          if (this._myPointerID != event.pointerId)
            return;
          this.reset();
        }
        _onThumbstickEnter(event) {
          this._myThumbstickIcon.onMouseEnter(event);
        }
        _onThumbstickLeave(event) {
          this._myThumbstickIcon.onMouseLeave(event);
        }
        _onPointerMove(event) {
          if (!this._myIsActive)
            return;
          if (!this._myIsPressed)
            return;
          if (event.pointerId != this._myPointerID)
            return;
          let mouseX = event.clientX;
          let mouseY = event.clientY;
          let backgroundRect = this._myThumbstickBackground.getBoundingClientRect();
          let maxDistanceFromCenter = backgroundRect.width / 2 * this._myParams.myMaxDistanceFromCenterMultiplier;
          let xDiff = mouseX - this._myThumbstickDragStartPosition[0];
          let yDiff = mouseY - this._myThumbstickDragStartPosition[1];
          let angle3 = Math.atan2(yDiff, xDiff);
          let distanceFromDragStart = Math.min(maxDistanceFromCenter, Math.hypot(xDiff, yDiff));
          let translateThumbstickX = distanceFromDragStart * Math.cos(angle3);
          let translateThumbstickY = distanceFromDragStart * Math.sin(angle3);
          this._myThumbstickElement.style.transition = "all " + this._myParams.myMoveTransitionSeconds + "s ease-out 0s";
          this._myThumbstickElement.style.transform = "translate(" + translateThumbstickX + "px, " + translateThumbstickY + "px)";
          this._myAxes[0] = translateThumbstickX / maxDistanceFromCenter;
          this._myAxes[1] = -(translateThumbstickY / maxDistanceFromCenter);
        }
        _build(thumbstickElementParent, virtualThumbstickHandedness) {
          let thumbstickSize = this._myVirtualGamepadParams.myThumbstickSize * this._myVirtualGamepadParams.myInterfaceScale;
          let marginBottom = this._myVirtualGamepadParams.myMarginBottom * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
          let marginLeft = this._myVirtualGamepadParams.myMarginLeft * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
          let marginRight = this._myVirtualGamepadParams.myMarginRight * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
          let minSizeMultiplier = Math.max(1, this._myVirtualGamepadParams.myMinSizeMultiplier / this._myVirtualGamepadParams.myInterfaceScale);
          let thumbstickContainer = document.createElement("div");
          thumbstickContainer.style.position = "absolute";
          thumbstickContainer.style.width = this._createSizeValue(thumbstickSize, minSizeMultiplier);
          thumbstickContainer.style.height = this._createSizeValue(thumbstickSize, minSizeMultiplier);
          thumbstickContainer.style.bottom = this._createSizeValue(marginBottom, minSizeMultiplier);
          if (virtualThumbstickHandedness == PP.Handedness.LEFT) {
            thumbstickContainer.style.left = this._createSizeValue(marginLeft, minSizeMultiplier);
          } else {
            thumbstickContainer.style.right = this._createSizeValue(marginRight, minSizeMultiplier);
          }
          thumbstickElementParent.appendChild(thumbstickContainer);
          let thumbstickContainerSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          thumbstickContainerSVG.style.position = "absolute";
          thumbstickContainerSVG.style.width = "100%";
          thumbstickContainerSVG.style.height = "100%";
          thumbstickContainer.appendChild(thumbstickContainerSVG);
          this._myThumbstickBackground = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          this._myThumbstickBackground.setAttributeNS(null, "cx", "50%");
          this._myThumbstickBackground.setAttributeNS(null, "cy", "50%");
          this._myThumbstickBackground.setAttributeNS(null, "r", "48%");
          this._myThumbstickBackground.style.fill = this._myParams.myBackgroundColor;
          thumbstickContainerSVG.appendChild(this._myThumbstickBackground);
          this._myThumbstickElement = document.createElement("div");
          this._myThumbstickElement.style.position = "absolute";
          this._myThumbstickElement.style.width = "34%";
          this._myThumbstickElement.style.height = "34%";
          this._myThumbstickElement.style.top = "33%";
          this._myThumbstickElement.style.left = "33%";
          thumbstickContainer.appendChild(this._myThumbstickElement);
          this._myThumbstickIcon = new PP.VirtualGamepadIcon(this._myThumbstickElement, this._myParams.myIconParams, minSizeMultiplier, this._myVirtualGamepadParams.myScale);
          if (this._myParams.myIncludeBackgroundToDetection) {
            let thumbstickBackgroundDetectionElementSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            thumbstickBackgroundDetectionElementSVG.style.position = "absolute";
            thumbstickBackgroundDetectionElementSVG.style.width = "100%";
            thumbstickBackgroundDetectionElementSVG.style.height = "100%";
            thumbstickContainer.appendChild(thumbstickBackgroundDetectionElementSVG);
            let thumbstickBackgroundDetectionElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            thumbstickBackgroundDetectionElement.setAttributeNS(null, "cx", "50%");
            thumbstickBackgroundDetectionElement.setAttributeNS(null, "cy", "50%");
            thumbstickBackgroundDetectionElement.setAttributeNS(null, "r", "48%");
            thumbstickBackgroundDetectionElement.style.fill = "#00000000";
            thumbstickBackgroundDetectionElementSVG.appendChild(thumbstickBackgroundDetectionElement);
            this._myThumbstickDetectionElement = thumbstickBackgroundDetectionElement;
          } else {
            let thumbstickElementStill = document.createElement("div");
            thumbstickElementStill.style.position = "absolute";
            thumbstickElementStill.style.width = "34%";
            thumbstickElementStill.style.height = "34%";
            thumbstickElementStill.style.top = "33%";
            thumbstickElementStill.style.left = "33%";
            thumbstickContainer.appendChild(thumbstickElementStill);
            let thumbstickDetectionElementSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            thumbstickDetectionElementSVG.style.position = "absolute";
            thumbstickDetectionElementSVG.style.width = "100%";
            thumbstickDetectionElementSVG.style.height = "100%";
            thumbstickElementStill.appendChild(thumbstickDetectionElementSVG);
            let thumbstickDetectionElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            thumbstickDetectionElement.setAttributeNS(null, "cx", "50%");
            thumbstickDetectionElement.setAttributeNS(null, "cy", "50%");
            thumbstickDetectionElement.setAttributeNS(null, "r", "50%");
            thumbstickDetectionElement.style.fill = "#00000000";
            thumbstickDetectionElementSVG.appendChild(thumbstickDetectionElement);
            this._myThumbstickDetectionElement = thumbstickDetectionElement;
          }
        }
        _createSizeValue(value, minSizeMultiplier) {
          return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
        }
      };
    }
  });

  // js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_icon.js
  var require_virtual_gamepad_icon = __commonJS({
    "js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_icon.js"() {
      PP.VirtualGamepadIconType = {
        NONE: 0,
        LABEL: 1,
        IMAGE: 2,
        DOT: 3,
        CIRCLE: 4,
        SQUARE: 5,
        RING: 6,
        FRAME: 7
      };
      PP.VirtualGamepadIconParams = class VirtualGamepadIconParams {
        constructor() {
          this.myBackgroundColor = "";
          this.myBackgroundPressedColor = "";
          this.myIconColor = "";
          this.myIconPressedColor = "";
          this.myIconType = PP.VirtualGamepadIconType.NONE;
          this.myOverallHoveredBrightness = 1;
          this.myLabel = "";
          this.myLabelFontSize = 0;
          this.myLabelFontFamily = "";
          this.myLabelFontWeight = "";
          this.myImageURL = "";
          this.myImagePressedBrightness = 1;
        }
      };
      PP.VirtualGamepadIcon = class VirtualGamepadIcon {
        constructor(iconElementParent, iconParams, minSizeMultiplier, scale8) {
          this._myParams = iconParams;
          this._myIconContainerElement = null;
          this._myBackgroundElement = null;
          this._myIconElement = null;
          this._myPressed = false;
          this._myIsMouseHover = false;
          this._myIsMouseHoverActive = true;
          this._build(iconElementParent, minSizeMultiplier, scale8);
        }
        update(dt) {
          if (this._myPressed || !this._myIsMouseHover || !this._myIsMouseHoverActive) {
            this._myIconContainerElement.style.filter = "none";
          } else {
            this._myIconContainerElement.style.filter = "brightness(" + this._myParams.myOverallHoveredBrightness + ")";
          }
        }
        reset() {
          this.setPressed(false);
          this._myIsMouseHover = false;
          this._myIconContainerElement.style.filter = "none";
        }
        setPressed(pressed) {
          if (this._myPressed != pressed) {
            this._myPressed = pressed;
            if (this._myPressed) {
              this._myBackgroundElement.style.fill = this._myParams.myBackgroundPressedColor;
              if (this._myIconElement != null) {
                if (this._myIconElement.style.strokeWidth.length > 0) {
                  this._myIconElement.style.stroke = this._myParams.myIconPressedColor;
                } else {
                  this._myIconElement.style.fill = this._myParams.myIconPressedColor;
                }
                if (this._myParams.myIconType == PP.VirtualGamepadIconType.IMAGE) {
                  this._myIconElement.style.filter = "brightness(" + this._myParams.myImagePressedBrightness + ")";
                }
              }
            } else {
              this._myBackgroundElement.style.fill = this._myParams.myBackgroundColor;
              if (this._myIconElement != null) {
                if (this._myIconElement.style.strokeWidth.length > 0) {
                  this._myIconElement.style.stroke = this._myParams.myIconColor;
                } else {
                  this._myIconElement.style.fill = this._myParams.myIconColor;
                }
                if (this._myParams.myIconType == PP.VirtualGamepadIconType.IMAGE) {
                  this._myIconElement.style.filter = "none";
                }
              }
            }
          }
        }
        onMouseEnter() {
          this._myIsMouseHover = true;
        }
        onMouseLeave() {
          this._myIsMouseHover = false;
        }
        setMouseHoverActive(hoverActive) {
          this._myIsMouseHoverActive = hoverActive;
        }
        _build(iconElementParent, minSizeMultiplier, scale8) {
          this._myIconContainerElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          this._myIconContainerElement.style.position = "absolute";
          this._myIconContainerElement.style.width = "100%";
          this._myIconContainerElement.style.height = "100%";
          iconElementParent.appendChild(this._myIconContainerElement);
          this._myBackgroundElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          this._myBackgroundElement.setAttributeNS(null, "cx", "50%");
          this._myBackgroundElement.setAttributeNS(null, "cy", "50%");
          this._myBackgroundElement.setAttributeNS(null, "r", "50%");
          this._myBackgroundElement.style.fill = this._myParams.myBackgroundColor;
          this._myIconContainerElement.appendChild(this._myBackgroundElement);
          switch (this._myParams.myIconType) {
            case PP.VirtualGamepadIconType.NONE:
              break;
            case PP.VirtualGamepadIconType.LABEL:
              this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
              this._myIconElement.setAttributeNS(null, "x", "50%");
              this._myIconElement.setAttributeNS(null, "y", "50%");
              this._myIconElement.style.textAlign = "center";
              this._myIconElement.style.textAnchor = "middle";
              this._myIconElement.style.dominantBaseline = "central";
              this._myIconElement.style.alignmentBaseline = "central";
              this._myIconElement.style.fontFamily = this._myParams.myLabelFontFamily;
              this._myIconElement.style.fontWeight = this._myParams.myLabelFontWeight;
              this._myIconElement.style.fontSize = this._createSizeValue(this._myParams.myLabelFontSize * scale8, minSizeMultiplier);
              this._myIconElement.style.fill = this._myParams.myIconColor;
              this._myIconElement.textContent = this._myParams.myLabel;
              this._myIconContainerElement.appendChild(this._myIconElement);
              break;
            case PP.VirtualGamepadIconType.IMAGE:
              this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "image");
              this._myIconElement.setAttributeNS(null, "x", "0%");
              this._myIconElement.setAttributeNS(null, "y", "0%");
              this._myIconElement.setAttribute("href", this._myParams.myImageURL);
              this._myIconElement.style.width = "100%";
              this._myIconElement.style.height = "100%";
              this._myIconElement.style.filter = "none";
              this._myIconContainerElement.appendChild(this._myIconElement);
              break;
            case PP.VirtualGamepadIconType.DOT:
              this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
              this._myIconElement.setAttributeNS(null, "cx", "50%");
              this._myIconElement.setAttributeNS(null, "cy", "50%");
              this._myIconElement.setAttributeNS(null, "r", "17.5%");
              this._myIconElement.style.fill = this._myParams.myIconColor;
              this._myIconContainerElement.appendChild(this._myIconElement);
              break;
            case PP.VirtualGamepadIconType.CIRCLE:
              this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
              this._myIconElement.setAttributeNS(null, "cx", "50%");
              this._myIconElement.setAttributeNS(null, "cy", "50%");
              this._myIconElement.setAttributeNS(null, "r", "24%");
              this._myIconElement.style.fill = this._myParams.myIconColor;
              this._myIconContainerElement.appendChild(this._myIconElement);
              break;
            case PP.VirtualGamepadIconType.SQUARE:
              this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              this._myIconElement.setAttributeNS(null, "x", "28%");
              this._myIconElement.setAttributeNS(null, "y", "28%");
              this._myIconElement.setAttributeNS(null, "rx", "10%");
              this._myIconElement.setAttributeNS(null, "ry", "10%");
              this._myIconElement.setAttributeNS(null, "width", "44%");
              this._myIconElement.setAttributeNS(null, "height", "44%");
              this._myIconElement.style.fill = this._myParams.myIconColor;
              this._myIconElement.style.transformOrigin = "center";
              this._myIconContainerElement.appendChild(this._myIconElement);
              break;
            case PP.VirtualGamepadIconType.RING:
              this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
              this._myIconElement.setAttributeNS(null, "cx", "50%");
              this._myIconElement.setAttributeNS(null, "cy", "50%");
              this._myIconElement.setAttributeNS(null, "r", "20%");
              this._myIconElement.style.fill = "#00000000";
              this._myIconElement.style.stroke = this._myParams.myIconColor;
              this._myIconElement.style.strokeWidth = "10%";
              this._myIconContainerElement.appendChild(this._myIconElement);
              break;
            case PP.VirtualGamepadIconType.FRAME:
              this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              this._myIconElement.setAttributeNS(null, "x", "31.5%");
              this._myIconElement.setAttributeNS(null, "y", "31.5%");
              this._myIconElement.setAttributeNS(null, "rx", "10%");
              this._myIconElement.setAttributeNS(null, "ry", "10%");
              this._myIconElement.setAttributeNS(null, "width", "37%");
              this._myIconElement.setAttributeNS(null, "height", "37%");
              this._myIconElement.style.fill = "#00000000";
              this._myIconElement.style.stroke = this._myParams.myIconColor;
              this._myIconElement.style.strokeWidth = "10%";
              this._myIconElement.style.transformOrigin = "center";
              this._myIconContainerElement.appendChild(this._myIconElement);
              break;
          }
        }
        _createSizeValue(value, minSizeMultiplier) {
          return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
        }
        _invertColors() {
          if (this._myIconElement.style.strokeWidth.length > 0) {
            this._myBackgroundElement.style.fill = this._myParams.myIconColor;
            this._myIconElement.style.fill = this._myParams.myIconColor;
            this._myIconElement.style.stroke = this._myParams.myBackgroundColor;
          } else {
            this._myBackgroundElement.style.fill = this._myParams.myIconColor;
            this._myIconElement.style.fill = this._myParams.myBackgroundColor;
          }
        }
      };
    }
  });

  // js/pp/input/pose/base_pose.js
  var require_base_pose = __commonJS({
    "js/pp/input/pose/base_pose.js"() {
      PP.BasePoseParams = class BasePoseParams {
        constructor() {
          this.myReferenceObject = null;
          this.myFixForward = true;
          this.myForceEmulatedVelocities = false;
          this.myUpdateOnViewReset = false;
        }
      };
      PP.BasePose = class BasePose {
        constructor(basePoseParams = new PP.BasePoseParams()) {
          this._myFixForward = basePoseParams.myFixForward;
          this._myForceEmulatedVelocities = basePoseParams.myForceEmulatedVelocities;
          this._myUpdateOnViewReset = basePoseParams.myUpdateOnViewReset;
          this._myReferenceSpace = null;
          this._myReferenceObject = basePoseParams.myReferenceObject;
          this._myPosition = PP.vec3_create();
          this._myRotationQuat = PP.quat_create();
          this._myPrevPosition = PP.vec3_create();
          this._myPrevRotationQuat = PP.quat_create();
          this._myLinearVelocity = PP.vec3_create();
          this._myAngularVelocityRadians = PP.vec3_create();
          this._myIsValid = false;
          this._myIsLinearVelocityEmulated = true;
          this._myIsAngularVelocityEmulated = true;
          this._myPoseUpdatedCallbacks = /* @__PURE__ */ new Map();
        }
        // if the reference object is set, the transform will be converted using it as a parent,
        // otherwise the transform will be local, as if the parent/reference object was the identity transform
        setReferenceObject(referenceObject) {
          this._myReferenceObject = referenceObject;
        }
        getReferenceObject() {
          return this._myReferenceObject;
        }
        setFixForward(fixForward) {
          this._myFixForward = fixForward;
        }
        isFixForward() {
          return this._myFixForward;
        }
        setForceEmulatedVelocities(forceEmulatedVelocities) {
          this._myForceEmulatedVelocities = forceEmulatedVelocities;
        }
        isForceEmulatedVelocities() {
          return this._myForceEmulatedVelocities;
        }
        setUpdateOnViewReset(updateOnViewReset) {
          this._myUpdateOnViewReset = updateOnViewReset;
        }
        isUpdateOnViewReset() {
          return this._myUpdateOnViewReset;
        }
        getReferenceSpace() {
          return this._myReferenceSpace;
        }
        getInputSource() {
          return this._myInputSource;
        }
        getPosition() {
        }
        getRotation() {
          return this.getRotationDegrees();
        }
        getRotationDegrees() {
          return this.getRotationQuat().quat_toDegrees();
        }
        getRotationRadians() {
          return this.getRotationQuat().quat_toRadians();
        }
        getRotationQuat() {
        }
        getTransform() {
          return this.getTransformMatrix();
        }
        getTransformMatrix() {
        }
        getTransformQuat() {
        }
        getLinearVelocity() {
        }
        getAngularVelocity() {
          return this.getAngularVelocityDegrees();
        }
        getAngularVelocityDegrees() {
        }
        getAngularVelocityRadians() {
        }
        isValid() {
          return this._myIsValid;
        }
        isLinearVelocityEmulated() {
          return this._myIsLinearVelocityEmulated;
        }
        isAngularVelocityEmulated() {
          return this._myIsAngularVelocityEmulated;
        }
        registerPoseUpdatedEventListener(id, callback) {
          this._myPoseUpdatedCallbacks.set(id, callback);
        }
        unregisterPoseUpdatedEventListener(id) {
          this._myPoseUpdatedCallbacks.delete(id);
        }
        start() {
          if (WL.xrSession) {
            this._onXRSessionStart(true, WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this, false));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        }
        update(dt) {
          this._update(dt, true);
        }
        // Hooks
        _isReadyToGetPose() {
          return true;
        }
        _getPose(xrFrame) {
          return null;
        }
        _updateHook(dt, updateVelocity, xrPose) {
        }
        _onXRSessionStartHook(manualStart, session) {
        }
        _onXRSessionEndHook() {
        }
        _onViewResetHook() {
        }
        // Hooks end
        _update(dt, updateVelocity) {
          this._myPrevPosition.vec3_copy(this._myPosition);
          this._myPrevRotationQuat.quat_copy(this._myRotationQuat);
          let xrFrame = Module["webxr_frame"];
          if (xrFrame && this._isReadyToGetPose()) {
            let xrPose = null;
            try {
              xrPose = this._getPose(xrFrame);
            } catch (error) {
            }
            if (xrPose) {
              this._myPosition[0] = xrPose.transform.position.x;
              this._myPosition[1] = xrPose.transform.position.y;
              this._myPosition[2] = xrPose.transform.position.z;
              this._myRotationQuat[0] = xrPose.transform.orientation.x;
              this._myRotationQuat[1] = xrPose.transform.orientation.y;
              this._myRotationQuat[2] = xrPose.transform.orientation.z;
              this._myRotationQuat[3] = xrPose.transform.orientation.w;
              this._myRotationQuat.quat_normalize(this._myRotationQuat);
              if (updateVelocity) {
                if (xrPose.linearVelocity && !this._myForceEmulatedVelocities) {
                  this._myLinearVelocity[0] = xrPose.linearVelocity.x;
                  this._myLinearVelocity[1] = xrPose.linearVelocity.y;
                  this._myLinearVelocity[2] = xrPose.linearVelocity.z;
                  this._myIsLinearVelocityEmulated = false;
                } else {
                  this._computeEmulatedLinearVelocity(dt);
                  this._myIsLinearVelocityEmulated = true;
                }
                if (xrPose.angularVelocity && !this._myForceEmulatedVelocities) {
                  this._myAngularVelocityRadians[0] = xrPose.angularVelocity.x;
                  this._myAngularVelocityRadians[1] = xrPose.angularVelocity.y;
                  this._myAngularVelocityRadians[2] = xrPose.angularVelocity.z;
                  this._myIsAngularVelocityEmulated = false;
                } else {
                  this._computeEmulatedAngularVelocity(dt);
                  this._myIsAngularVelocityEmulated = true;
                }
              }
              this._myIsValid = true;
            } else {
              if (updateVelocity) {
                this._myLinearVelocity[0] = 0;
                this._myLinearVelocity[1] = 0;
                this._myLinearVelocity[2] = 0;
                this._myAngularVelocityRadians[0] = 0;
                this._myAngularVelocityRadians[1] = 0;
                this._myAngularVelocityRadians[2] = 0;
              }
              this._myIsValid = false;
              this._myIsLinearVelocityEmulated = true;
              this._myIsAngularVelocityEmulated = true;
            }
            this._updateHook(dt, updateVelocity, xrPose);
          } else {
            if (updateVelocity) {
              this._myLinearVelocity[0] = 0;
              this._myLinearVelocity[1] = 0;
              this._myLinearVelocity[2] = 0;
              this._myAngularVelocityRadians[0] = 0;
              this._myAngularVelocityRadians[1] = 0;
              this._myAngularVelocityRadians[2] = 0;
            }
            this._myIsValid = false;
            this._myIsLinearVelocityEmulated = true;
            this._myIsAngularVelocityEmulated = true;
            this._updateHook(dt, updateVelocity, null);
          }
          this._myPoseUpdatedCallbacks.forEach(function(callback) {
            callback(this);
          }.bind(this));
        }
        _computeEmulatedLinearVelocity(dt) {
          if (dt > 0) {
            this._myPosition.vec3_sub(this._myPrevPosition, this._myLinearVelocity);
            this._myLinearVelocity.vec3_scale(1 / dt, this._myLinearVelocity);
          } else {
            this._myLinearVelocity[0] = 0;
            this._myLinearVelocity[1] = 0;
            this._myLinearVelocity[2] = 0;
          }
        }
        _onXRSessionStart(manualStart, session) {
          session.requestReferenceSpace(WebXR.refSpace).then(function(referenceSpace) {
            this._myReferenceSpace = referenceSpace;
            if (referenceSpace.addEventListener != null) {
              referenceSpace.addEventListener("reset", this._onViewReset.bind(this));
            }
          }.bind(this));
          this._onXRSessionStartHook(manualStart, session);
        }
        _onXRSessionEnd() {
          this._onXRSessionEndHook();
          this._myReferenceSpace = null;
        }
        _onViewReset() {
          if (this._myUpdateOnViewReset) {
            this._update(0, false);
          }
          this._onViewResetHook();
        }
      };
      PP.BasePose.prototype.getPosition = function() {
        let position = PP.vec3_create();
        let transform = PP.mat4_create();
        return function getPosition() {
          if (this._myReferenceObject == null) {
            return this._myPosition;
          }
          return this._myPosition.vec3_convertPositionToWorld(this._myReferenceObject.pp_getTransform(transform), position);
        };
      }();
      PP.BasePose.prototype.getRotationQuat = function() {
        let rotationQuat = PP.quat_create();
        let playerRotationQuat = PP.quat_create();
        let up = PP.vec3_create();
        return function getRotationQuat() {
          rotationQuat.quat_copy(this._myRotationQuat);
          if (this._myFixForward) {
            rotationQuat.quat_rotateAxisRadians(Math.PI, rotationQuat.quat_getUp(up), rotationQuat);
          }
          if (this._myReferenceObject == null) {
            return rotationQuat;
          }
          return rotationQuat.quat_toWorld(this._myReferenceObject.pp_getRotationQuat(playerRotationQuat), rotationQuat);
        };
      }();
      PP.BasePose.prototype.getTransformMatrix = function() {
        let transform = PP.mat4_create();
        return function getTransformMatrix() {
          return this.getTransformQuat().quat2_toMatrix(transform);
        };
      }();
      PP.BasePose.prototype.getTransformQuat = function() {
        let transformQuat3 = PP.quat2_create();
        let playerTransformQuat = PP.quat2_create();
        return function getTransformQuat() {
          transformQuat3.quat2_setPositionRotationQuat(this._myPosition, this.getRotationQuat());
          if (this._myReferenceObject == null) {
            return transformQuat3;
          }
          return transformQuat3.quat_toWorld(this._myReferenceObject.pp_getTransformQuat(playerTransformQuat), transformQuat3);
        };
      }();
      PP.BasePose.prototype.getLinearVelocity = function() {
        let position = PP.vec3_create();
        let transform = PP.mat4_create();
        return function getLinearVelocity() {
          if (this._myReferenceObject == null) {
            return this._myLinearVelocity;
          }
          return this._myLinearVelocity.vec3_convertDirectionToWorld(this._myReferenceObject.pp_getTransform(transform), position);
        };
      }();
      PP.BasePose.prototype.getAngularVelocityDegrees = function() {
        let rotationDegrees = PP.vec3_create();
        return function getAngularVelocityDegrees() {
          this.getAngularVelocityRadians().vec3_toDegrees(rotationDegrees);
        };
      }();
      PP.BasePose.prototype.getAngularVelocityRadians = function() {
        let rotationRadians = PP.vec3_create();
        let transform = PP.mat4_create();
        return function getAngularVelocityRadians() {
          if (this._myReferenceObject == null) {
            return this._myAngularVelocityRadians;
          }
          return this._myAngularVelocityRadians.vec3_convertDirectionToWorld(this._myReferenceObject.pp_getTransform(transform), rotationRadians);
        };
      }();
      PP.BasePose.prototype._computeEmulatedAngularVelocity = function() {
        let rotationRadians = PP.vec3_create();
        let prevRotationRadians = PP.vec3_create();
        return function _computeEmulatedAngularVelocity(dt) {
          if (dt > 0) {
            rotationRadians = this._myRotationQuat.quat_toRadians(rotationRadians);
            prevRotationRadians = this._myPrevRotationQuat.quat_toRadians(prevRotationRadians);
            rotationRadians.vec3_sub(prevRotationRadians, this._myAngularVelocityRadians);
            this._myAngularVelocityRadians.vec3_scale(1 / dt, this._myAngularVelocityRadians);
          } else {
            this._myAngularVelocityRadians[0] = 0;
            this._myAngularVelocityRadians[1] = 0;
            this._myAngularVelocityRadians[2] = 0;
          }
        };
      }();
      Object.defineProperty(PP.BasePose.prototype, "getPosition", { enumerable: false });
      Object.defineProperty(PP.BasePose.prototype, "getRotationQuat", { enumerable: false });
      Object.defineProperty(PP.BasePose.prototype, "getTransformMatrix", { enumerable: false });
      Object.defineProperty(PP.BasePose.prototype, "getTransformQuat", { enumerable: false });
      Object.defineProperty(PP.BasePose.prototype, "getLinearVelocity", { enumerable: false });
      Object.defineProperty(PP.BasePose.prototype, "getAngularVelocityDegrees", { enumerable: false });
      Object.defineProperty(PP.BasePose.prototype, "getAngularVelocityRadians", { enumerable: false });
      Object.defineProperty(PP.BasePose.prototype, "_computeEmulatedAngularVelocity", { enumerable: false });
    }
  });

  // js/pp/input/pose/hand_pose.js
  var require_hand_pose = __commonJS({
    "js/pp/input/pose/hand_pose.js"() {
      PP.HandPoseParams = class HandPoseParams extends PP.BasePoseParams {
        constructor() {
          super();
          this.myFixTrackedHandRotation = true;
        }
      };
      PP.HandPose = class HandPose extends PP.BasePose {
        constructor(handedness, handPoseParams = new PP.HandPoseParams()) {
          super(handPoseParams);
          this._myInputSource = null;
          this._myHandedness = handedness;
          this._myFixTrackedHandRotation = handPoseParams.myFixTrackedHandRotation;
          this._myIsTrackedHand = false;
        }
        getInputSourceType() {
          if (this._myInputSource == null) {
            return null;
          }
          return PP.InputUtils.getInputSourceType(this._myInputSource);
        }
        isFixTrackedHandRotation() {
          return this._myFixTrackedHandRotation;
        }
        setFixTrackedHandRotation(fixTrackedHandRotation) {
          this.myFixTrackedHandRotation = fixTrackedHandRotation;
        }
        _isReadyToGetPose() {
          return this._myInputSource != null;
        }
        _getPose(xrFrame) {
          return xrFrame.getPose(this._myInputSource.gripSpace, this._myReferenceSpace);
        }
        _onXRSessionStartHook(manualStart, session) {
          this._myInputSource = null;
          if (session.inputSources != null && session.inputSources.length > 0) {
            for (let i = 0; i < session.inputSources.length; i++) {
              let inputSource = session.inputSources[i];
              if (inputSource.handedness == this._myHandedness) {
                this._myInputSource = inputSource;
                this._myIsTrackedHand = PP.InputUtils.getInputSourceType(this._myInputSource) == PP.InputSourceType.TRACKED_HAND;
              }
            }
          }
          session.addEventListener("inputsourceschange", function() {
            this._myInputSource = null;
            if (session.inputSources != null && session.inputSources.length > 0) {
              for (let i = 0; i < session.inputSources.length; i++) {
                let inputSource = session.inputSources[i];
                if (inputSource.handedness == this._myHandedness) {
                  this._myInputSource = inputSource;
                  this._myIsTrackedHand = PP.InputUtils.getInputSourceType(this._myInputSource) == PP.InputSourceType.TRACKED_HAND;
                }
              }
            }
          }.bind(this));
        }
        _onXRSessionEndHook() {
          this._myInputSource = null;
        }
      };
      PP.HandPose.prototype.getRotationQuat = function() {
        let rotationQuat = PP.quat_create();
        let playerRotationQuat = PP.quat_create();
        let up = PP.vec3_create();
        let right = PP.vec3_create();
        let forward = PP.vec3_create();
        return function getRotationQuat() {
          rotationQuat.quat_copy(this._myRotationQuat);
          if (this._myFixForward) {
            rotationQuat.quat_rotateAxisRadians(Math.PI, rotationQuat.quat_getUp(up), rotationQuat);
          }
          if (this._myFixTrackedHandRotation && this._myIsTrackedHand) {
            rotationQuat.quat_rotateAxis(-60, rotationQuat.quat_getRight(right), rotationQuat);
            let forwardRotation = 20;
            forwardRotation = this._myHandedness == PP.Handedness.LEFT ? forwardRotation : -forwardRotation;
            rotationQuat.quat_rotateAxis(forwardRotation, rotationQuat.quat_getForward(forward), rotationQuat);
          }
          if (this._myReferenceObject == null) {
            return rotationQuat;
          }
          return rotationQuat.quat_toWorld(this._myReferenceObject.pp_getRotationQuat(playerRotationQuat), rotationQuat);
        };
      }();
      Object.defineProperty(PP.HandPose.prototype, "getRotationQuat", { enumerable: false });
    }
  });

  // js/pp/input/pose/head_pose.js
  var require_head_pose = __commonJS({
    "js/pp/input/pose/head_pose.js"() {
      PP.HeadPose = class HeadPose extends PP.BasePose {
        _getPose(xrFrame) {
          return xrFrame.getViewerPose(this._myReferenceSpace);
        }
      };
    }
  });

  // js/pp/input/pose/tracked_hand_joint_pose.js
  var require_tracked_hand_joint_pose = __commonJS({
    "js/pp/input/pose/tracked_hand_joint_pose.js"() {
      PP.TrackedHandJointPose = class TrackedHandJointPose extends PP.BasePose {
        constructor(handedness, trackedHandJointID, basePoseParams = new PP.BasePoseParams()) {
          super(basePoseParams);
          this._myInputSource = null;
          this._myHandedness = handedness;
          this._myTrackedHandJointID = trackedHandJointID;
          this._myJointRadius = 0;
        }
        getTrackedHandJointID() {
          return this._myTrackedHandJointID;
        }
        setTrackedHandJointID(trackedHandJointID) {
          this._myTrackedHandJointID = trackedHandJointID;
        }
        getJointRadius() {
          return this._myJointRadius;
        }
        _isReadyToGetPose() {
          return this._myInputSource != null;
        }
        _getPose(xrFrame) {
          return xrFrame.getJointPose(this._myInputSource.hand.get(this._myTrackedHandJointID), this._myReferenceSpace);
        }
        _updateHook(dt, updateVelocity, xrPose) {
          if (xrPose != null) {
            this._myJointRadius = xrPose.radius;
          }
        }
        _onXRSessionStartHook(manualStart, session) {
          this._myInputSource = null;
          if (session.inputSources != null && session.inputSources.length > 0) {
            for (let i = 0; i < session.inputSources.length; i++) {
              let inputSource = session.inputSources[i];
              if (inputSource.handedness == this._myHandedness) {
                if (PP.InputUtils.getInputSourceType(inputSource) == PP.InputSourceType.TRACKED_HAND) {
                  this._myInputSource = inputSource;
                }
              }
            }
          }
          session.addEventListener("inputsourceschange", function() {
            this._myInputSource = null;
            if (session.inputSources != null && session.inputSources.length > 0) {
              for (let i = 0; i < session.inputSources.length; i++) {
                let inputSource = session.inputSources[i];
                if (inputSource.handedness == this._myHandedness) {
                  if (PP.InputUtils.getInputSourceType(inputSource) == PP.InputSourceType.TRACKED_HAND) {
                    this._myInputSource = inputSource;
                  }
                }
              }
            }
          }.bind(this));
        }
        _onXRSessionEndHook() {
          this._myInputSource = null;
        }
      };
    }
  });

  // js/pp/input/pose/tracked_hand_pose.js
  var require_tracked_hand_pose = __commonJS({
    "js/pp/input/pose/tracked_hand_pose.js"() {
      PP.TrackedHandPoseParams = class TrackedHandPoseParams extends PP.BasePoseParams {
        constructor(addAllJointIDs = true) {
          super();
          this.myTrackedHandJointIDList = [];
          if (addAllJointIDs) {
            for (let key in PP.TrackedHandJointID) {
              this.myTrackedHandJointIDList.push([PP.TrackedHandJointID[key]]);
            }
          }
        }
      };
      PP.TrackedHandPose = class TrackedHandPose {
        constructor(handedness, trackedHandPoseParams = new PP.TrackedHandPoseParams()) {
          this._myHandedness = handedness;
          this._myFixForward = trackedHandPoseParams.myFixForward;
          this._myForceEmulatedVelocities = trackedHandPoseParams.myForceEmulatedVelocities;
          this._myReferenceObject = trackedHandPoseParams.myReferenceObject;
          this._myTrackedHandJointPoseParams = new PP.BasePoseParams();
          this._myTrackedHandJointPoseParams.myFixForward = this._myFixForward;
          this._myTrackedHandJointPoseParams.myForceEmulatedVelocities = this._myForceEmulatedVelocities;
          this._myTrackedHandJointPoseParams.myReferenceObject = this._myReferenceObject;
          this._myTrackedHandJointPoseList = [];
          for (let jointID of trackedHandPoseParams.myTrackedHandJointIDList) {
            let trackedHandJointPose = new PP.TrackedHandJointPose(this._myHandedness, jointID, this._myTrackedHandJointPoseParams);
            this._myTrackedHandJointPoseList[jointID] = trackedHandJointPose;
          }
        }
        start() {
          for (let jointPoseKey in this._myTrackedHandJointPoseList) {
            let jointPose = this._myTrackedHandJointPoseList[jointPoseKey];
            jointPose.start();
          }
        }
        update(dt) {
          for (let jointPoseKey in this._myTrackedHandJointPoseList) {
            let jointPose = this._myTrackedHandJointPoseList[jointPoseKey];
            jointPose.update(dt);
          }
        }
        getJointPoseList() {
          return this._myTrackedHandJointPoseList;
        }
        getJointPose(jointID) {
          return this._myTrackedHandJointPoseList[jointID];
        }
        getJointPoseByIndex(jointIDIndex) {
          return this._myTrackedHandJointPoseList[PP.InputUtils.getJointIDByIndex(jointIDIndex)];
        }
        addTrackedHandJointID(jointID) {
          if (!this._myTrackedHandJointPoseList.pp_has((element) => element.getTrackedHandJointID() == jointID)) {
            let trackedHandJointPose = new PP.TrackedHandJointPose(this._myHandedness, jointID, this._myTrackedHandJointPoseParams);
            this._myTrackedHandJointPoseList.push(trackedHandJointPose);
          }
        }
        removeTrackedHandJointID(jointID) {
          this._myTrackedHandJointPoseList.pp_remove((element) => element.getTrackedHandJointID() == jointID);
        }
        setReferenceObject(referenceObject) {
          this._myReferenceObject = referenceObject;
          this._myTrackedHandJointPoseParams.myReferenceObject = this._myReferenceObject;
          for (let jointPoseKey in this._myTrackedHandJointPoseList) {
            let jointPose = this._myTrackedHandJointPoseList[jointPoseKey];
            jointPose.setReferenceObject(referenceObject);
          }
        }
        getReferenceObject() {
          return this._myReferenceObject;
        }
        setFixForward(fixForward) {
          this._myFixForward = fixForward;
          this._myTrackedHandJointPoseParams.myFixForward = this._myFixForward;
          for (let jointPoseKey in this._myTrackedHandJointPoseList) {
            let jointPose = this._myTrackedHandJointPoseList[jointPoseKey];
            jointPose.setFixForward(fixForward);
          }
        }
        isFixForward() {
          return this._myFixForward;
        }
        setForceEmulatedVelocities(forceEmulatedVelocities) {
          this._myForceEmulatedVelocities = forceEmulatedVelocities;
          this._myTrackedHandJointPoseParams.myForceEmulatedVelocities = this._myForceEmulatedVelocities;
          for (let jointPoseKey in this._myTrackedHandJointPoseList) {
            let jointPose = this._myTrackedHandJointPoseList[jointPoseKey];
            jointPose.setForceEmulatedVelocities(forceEmulatedVelocities);
          }
        }
        isForceEmulatedVelocities() {
          return this._myForceEmulatedVelocities;
        }
      };
    }
  });

  // js/pp/input/pose/components/set_player_height.js
  var require_set_player_height = __commonJS({
    "js/pp/input/pose/components/set_player_height.js"() {
      WL.registerComponent("pp-set-player-height", {
        _myEyesHeight: { type: WL.Type.Float, default: 1.65 },
        _mySetOnlyOnStart: { type: WL.Type.Bool, default: false }
      }, {
        start() {
          let localPosition = this.object.pp_getPositionLocal();
          this.object.pp_setPositionLocal(PP.vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
          this._myHeightSetOnce = false;
          if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        },
        _onXRSessionStart() {
          if (this.active && (!this._mySetOnlyOnStart || !this._myHeightSetOnce)) {
            let localPosition = this.object.pp_getPositionLocal();
            if (PP.XRUtils.isReferenceSpaceLocalFloor()) {
              this.object.pp_setPositionLocal(PP.vec3_create(localPosition[0], 0, localPosition[2]));
            } else if (PP.XRUtils.isDeviceEmulated() && Global.myIsLocalhost) {
              this.object.pp_setPositionLocal(PP.vec3_create(localPosition[0], 0, localPosition[2]));
            } else {
              this.object.pp_setPositionLocal(PP.vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
            }
            this._myHeightSetOnce = true;
          }
        },
        _onXRSessionEnd() {
          if (this.active && !this._mySetOnlyOnStart) {
            let localPosition = this.object.pp_getPositionLocal();
            this.object.pp_setPositionLocal(PP.vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
          }
        }
      });
    }
  });

  // js/pp/input/pose/components/set_hand_local_transform.js
  var require_set_hand_local_transform = __commonJS({
    "js/pp/input/pose/components/set_hand_local_transform.js"() {
      WL.registerComponent("pp-set-hand-local-transform", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myFixForward: { type: WL.Type.Bool, default: true },
        _myUpdateOnViewReset: { type: WL.Type.Bool, default: true }
      }, {
        init: function() {
          this._myHandPose = new PP.HandPose(PP.InputUtils.getHandednessByIndex(this._myHandedness));
          this._myHandPose.setFixForward(this._myFixForward);
          this._myHandPose.setUpdateOnViewReset(this._myUpdateOnViewReset);
          this._myHandPose.registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
        },
        start: function() {
          this._myHandPose.start();
        },
        update: function update(dt) {
          this._myHandPose.update(dt);
        },
        onPoseUpdated: function() {
          let handPoseTransform = PP.quat2_create();
          return function onPoseUpdated() {
            this.object.pp_setTransformLocalQuat(this._myHandPose.getTransformQuat(handPoseTransform));
          };
        }()
      });
    }
  });

  // js/pp/input/pose/components/set_head_local_transform.js
  var require_set_head_local_transform = __commonJS({
    "js/pp/input/pose/components/set_head_local_transform.js"() {
      WL.registerComponent("pp-set-head-local-transform", {
        _myNonVRCamera: { type: WL.Type.Object },
        _myFixForward: { type: WL.Type.Bool, default: true },
        _myUpdateOnViewReset: { type: WL.Type.Bool, default: true }
      }, {
        init: function() {
          this._myHeadPose = new PP.HeadPose();
          this._myHeadPose.setFixForward(this._myFixForward);
          this._myHeadPose.setUpdateOnViewReset(this._myUpdateOnViewReset);
          this._myHeadPose.registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
        },
        start: function() {
          this._myHeadPose.start();
        },
        update: function() {
          let nonVRCameraRotation = PP.quat_create();
          let nonVRCameraUp = PP.vec3_create();
          let nonVRCameraPosition = PP.vec3_create();
          return function update(dt) {
            if (PP.XRUtils.isSessionActive()) {
              this._myHeadPose.update(dt);
            } else {
              nonVRCameraRotation = this._myNonVRCamera.pp_getRotationLocalQuat(nonVRCameraRotation);
              if (this._myFixForward) {
                nonVRCameraRotation.quat_rotateAxisRadians(Math.PI, nonVRCameraRotation.quat_getUp(nonVRCameraUp), nonVRCameraRotation);
              }
              this.object.pp_setPositionLocal(this._myNonVRCamera.pp_getPositionLocal(nonVRCameraPosition));
              this.object.pp_setRotationLocalQuat(nonVRCameraRotation);
            }
          };
        }(),
        onPoseUpdated: function() {
          let headPoseTransform = PP.quat2_create();
          return function onPoseUpdated() {
            if (PP.XRUtils.isSessionActive()) {
              this.object.pp_setTransformLocalQuat(this._myHeadPose.getTransformQuat(headPoseTransform));
            }
          };
        }()
      });
    }
  });

  // js/pp/input/pose/components/set_vr_head_local_transform.js
  var require_set_vr_head_local_transform = __commonJS({
    "js/pp/input/pose/components/set_vr_head_local_transform.js"() {
      WL.registerComponent("pp-set-vr-head-local-transform", {
        _myFixForward: { type: WL.Type.Bool, default: true },
        _myUpdateOnViewReset: { type: WL.Type.Bool, default: true }
      }, {
        init: function() {
          this._myHeadPose = new PP.HeadPose();
          this._myHeadPose.setFixForward(this._myFixForward);
          this._myHeadPose.setUpdateOnViewReset(this._myUpdateOnViewReset);
          this._myHeadPose.registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
        },
        start: function() {
          this._myHeadPose.start();
        },
        update: function update(dt) {
          this._myHeadPose.update(dt);
        },
        onPoseUpdated: function() {
          let headPoseTransform = PP.quat2_create();
          return function onPoseUpdated() {
            this.object.pp_setTransformLocalQuat(this._myHeadPose.getTransformQuat(headPoseTransform));
          };
        }()
      });
    }
  });

  // js/pp/input/pose/components/set_non_vr_head_local_transform.js
  var require_set_non_vr_head_local_transform = __commonJS({
    "js/pp/input/pose/components/set_non_vr_head_local_transform.js"() {
      WL.registerComponent("pp-set-non-vr-head-local-transform", {
        _myNonVRCamera: { type: WL.Type.Object },
        _myFixForward: { type: WL.Type.Bool, default: true }
      }, {
        init: function() {
        },
        start: function() {
        },
        update: function(dt) {
          let nonVRCameraRotation = PP.quat_create();
          let nonVRCameraUp = PP.vec3_create();
          let nonVRCameraPosition = PP.vec3_create();
          return function update(dt2) {
            nonVRCameraRotation = this._myNonVRCamera.pp_getRotationLocalQuat(nonVRCameraRotation);
            if (this._myFixForward) {
              nonVRCameraRotation.quat_rotateAxisRadians(Math.PI, nonVRCameraRotation.quat_getUp(nonVRCameraUp), nonVRCameraRotation);
            }
            this.object.pp_setPositionLocal(this._myNonVRCamera.pp_getPositionLocal(nonVRCameraPosition));
            this.object.pp_setRotationLocalQuat(nonVRCameraRotation);
          };
        }()
      });
    }
  });

  // js/pp/input/pose/components/set_tracked_hand_joint_local_transform.js
  var require_set_tracked_hand_joint_local_transform = __commonJS({
    "js/pp/input/pose/components/set_tracked_hand_joint_local_transform.js"() {
      WL.registerComponent("pp-set-tracked-hand-joint-local-transform", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myFixForward: { type: WL.Type.Bool, default: true },
        _myUpdateOnViewReset: { type: WL.Type.Bool, default: true },
        _mySetLocalScaleAsJointRadius: { type: WL.Type.Bool, default: false },
        _myJointID: {
          type: WL.Type.Enum,
          values: [
            "Wrist",
            "Thumb Metacarpal",
            "Thumb Phalanx Proximal",
            "Thumb Phalanx Distal",
            "Thumb Tip",
            "Index Metacarpal",
            "Index Phalanx Proximal",
            "Index Phalanx Intermediate",
            "Index Phalanx Distal",
            "Index Tip",
            "Middle Metacarpal",
            "Middle Phalanx Proximal",
            "Middle Phalanx Intermediate",
            "Middle Phalanx Distal",
            "Middle Tip",
            "Ring Metacarpal",
            "Ring Phalanx Proximal",
            "Ring Phalanx Intermediate",
            "Ring Phalanx Distal",
            "Ring Tip",
            "Pinky Metacarpal",
            "Pinky Phalanx Proximal",
            "Pinky Phalanx Intermediate",
            "Pinky Phalanx Distal",
            "Pinky Tip"
          ],
          default: "Wrist"
        }
      }, {
        init: function() {
          this._myHandednessInternal = PP.InputUtils.getHandednessByIndex(this._myHandedness);
          this._myJointIDInternal = PP.InputUtils.getJointIDByIndex(this._myJointID);
          this._myTrackedHandJointPose = new PP.TrackedHandJointPose(this._myHandednessInternal, this._myJointIDInternal);
          this._myTrackedHandJointPose.setFixForward(this._myFixForward);
          this._myTrackedHandJointPose.setUpdateOnViewReset(this._myUpdateOnViewReset);
          this._myTrackedHandJointPose.registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
        },
        start: function() {
          this._myTrackedHandJointPose.start();
        },
        update: function(dt) {
          this._myTrackedHandJointPose.update(dt);
        },
        onPoseUpdated: function() {
          let jointPoseTransform = PP.quat2_create();
          return function onPoseUpdated() {
            this.object.pp_setTransformLocalQuat(this._myTrackedHandJointPose.getTransformQuat(jointPoseTransform));
            if (this._mySetLocalScaleAsJointRadius) {
              this.object.pp_setScaleLocal(this._myTrackedHandJointPose.getJointRadius());
            }
          };
        }()
      });
    }
  });

  // js/pp/input/pose/components/copy_hand_transform.js
  var require_copy_hand_transform = __commonJS({
    "js/pp/input/pose/components/copy_hand_transform.js"() {
      WL.registerComponent("pp-copy-hand-transform", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" }
      }, {
        init: function() {
          this._myHandednessType = this._myHandedness == 0 ? PP.Handedness.LEFT : PP.Handedness.RIGHT;
        },
        update: function(dt) {
          let hand = PP.myPlayerObjects.myHands[this._myHandednessType];
          this.object.pp_setTransformQuat(hand.pp_getTransformQuat());
          this.object.pp_setScale(hand.pp_getScale());
        }
      });
    }
  });

  // js/pp/input/pose/components/copy_head_transform.js
  var require_copy_head_transform = __commonJS({
    "js/pp/input/pose/components/copy_head_transform.js"() {
      WL.registerComponent("pp-copy-head-transform", {}, {
        update: function(dt) {
          let head = PP.myPlayerObjects.myHead;
          this.object.pp_setTransformQuat(head.pp_getTransformQuat());
          this.object.pp_setScale(head.pp_getScale());
        }
      });
    }
  });

  // js/pp/input/pose/components/copy_player_transform.js
  var require_copy_player_transform = __commonJS({
    "js/pp/input/pose/components/copy_player_transform.js"() {
      WL.registerComponent("pp-copy-player-transform", {}, {
        update: function(dt) {
          let player = PP.myPlayerObjects.myPlayer;
          this.object.pp_setTransformQuat(player.pp_getTransformQuat());
          this.object.pp_setScale(player.pp_getScale());
        }
      });
    }
  });

  // js/pp/input/pose/components/copy_player_pivot_transform.js
  var require_copy_player_pivot_transform = __commonJS({
    "js/pp/input/pose/components/copy_player_pivot_transform.js"() {
      WL.registerComponent("pp-copy-player-pivot-transform", {}, {
        update: function(dt) {
          let playerPivot = PP.myPlayerObjects.myPlayerPivot;
          this.object.pp_setTransformQuat(playerPivot.pp_getTransformQuat());
          this.object.pp_setScale(playerPivot.pp_getScale());
        }
      });
    }
  });

  // js/pp/tool/cauldron/cauldron/tool_types.js
  var require_tool_types = __commonJS({
    "js/pp/tool/cauldron/cauldron/tool_types.js"() {
      PP.ToolHandedness = {
        NONE: null,
        LEFT: "left",
        RIGHT: "right"
      };
      PP.ToolInputSourceType = {
        NONE: null,
        GAMEPAD: 0,
        TRACKED_HAND: 1
      };
    }
  });

  // js/pp/tool/cauldron/components/tool_cursor.js
  var require_tool_cursor = __commonJS({
    "js/pp/tool/cauldron/components/tool_cursor.js"() {
      WL.registerComponent("pp-tool-cursor", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myFixForward: { type: WL.Type.Bool, default: true },
        _myApplyDefaultCursorOffset: { type: WL.Type.Bool, default: true },
        _myPulseOnHover: { type: WL.Type.Bool, default: false },
        _myShowFingerCursor: { type: WL.Type.Bool, default: false }
      }, {
        init: function() {
          this._myHandednessString = ["left", "right"][this._myHandedness];
          this._myCursorPositionDefaultOffset = PP.vec3_create(0, -0.035, -0.05);
          this._myCursorRotationDefaultOffset = PP.vec3_create(-30, 0, 0);
          this._myCursorMeshScale = PP.vec3_create(25e-4, 25e-4, 25e-4);
          this._myCursorColor = [255 / 255, 255 / 255, 255 / 255, 1];
          this._myCursorTargetCollisionGroup = 7;
        },
        start: function() {
          this._myToolCursorObject = WL.scene.addObject(this.object);
          this._myFixForwardObject = WL.scene.addObject(this._myToolCursorObject);
          if (this._myFixForward) {
            this._myFixForwardObject.pp_rotateObject(PP.vec3_create(0, 180, 0));
          }
          this._myCursorObjectVR = WL.scene.addObject(this._myFixForwardObject);
          if (this._myApplyDefaultCursorOffset) {
            this._myCursorObjectVR.pp_setPositionLocal(this._myCursorPositionDefaultOffset);
            this._myCursorObjectVR.pp_rotateObject(this._myCursorRotationDefaultOffset);
          }
          {
            this._myCursorMeshobject = WL.scene.addObject(this._myCursorObjectVR);
            this._myCursorMeshobject.pp_setScale(this._myCursorMeshScale);
            let cursorMeshComponent = this._myCursorMeshobject.addComponent("mesh");
            cursorMeshComponent.mesh = PP.myDefaultResources.myMeshes.mySphere;
            cursorMeshComponent.material = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
            cursorMeshComponent.material.color = this._myCursorColor;
            let cursorComponent = this._myCursorObjectVR.addComponent("cursor", { "collisionGroup": this._myCursorTargetCollisionGroup, "handedness": this._myHandedness + 1, "cursorObject": this._myCursorMeshobject });
            cursorComponent.rayCastMode = 0;
            if (this._myPulseOnHover) {
              cursorComponent.globalTarget.addHoverFunction(this._pulseOnHover.bind(this));
            }
          }
          this._myCursorObjectNonVR = WL.scene.addObject(this._myToolCursorObject);
          {
            let cursorComponent = this._myCursorObjectNonVR.addComponent("cursor", { "collisionGroup": this._myCursorTargetCollisionGroup, "handedness": this._myHandedness + 1 });
            cursorComponent.rayCastMode = 0;
            if (this._myPulseOnHover) {
              cursorComponent.globalTarget.addHoverFunction(this._pulseOnHover.bind(this));
            }
            cursorComponent.setViewComponent(PP.myPlayerObjects.myNonVRCamera.getComponent("view"));
          }
          let fingerCursorMeshObject = null;
          let fingerCollisionSize = 0.0125;
          if (this._myShowFingerCursor) {
            fingerCursorMeshObject = this._myToolCursorObject.pp_addObject();
            let meshComponent = fingerCursorMeshObject.addComponent("mesh");
            meshComponent.mesh = PP.myDefaultResources.myMeshes.mySphere;
            meshComponent.material = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
            meshComponent.material.color = this._myCursorColor;
            fingerCursorMeshObject.pp_setScale(fingerCollisionSize);
          }
          this._myFingerCursorObject = WL.scene.addObject(this._myToolCursorObject);
          this._myFingerCursorComponent = this._myFingerCursorObject.addComponent("pp-finger-cursor", {
            "_myHandedness": this._myHandedness,
            "_myEnableMultipleClicks": true,
            "_myCollisionGroup": this._myCursorTargetCollisionGroup,
            "_myCollisionSize": fingerCollisionSize,
            "_myCursorObject": fingerCursorMeshObject
          });
          this._myCursorObjectVR.pp_setActive(false);
          this._myCursorObjectNonVR.pp_setActive(false);
          this._myFingerCursorObject.pp_setActive(false);
        },
        update: function() {
          let transformQuat3 = PP.quat2_create();
          return function update(dt) {
            let isUsingHand = this._isUsingHand();
            this._myFingerCursorObject.pp_setActive(isUsingHand);
            if (isUsingHand) {
              this._myCursorObjectNonVR.pp_setActive(false);
              this._myCursorObjectVR.pp_setActive(false);
            } else {
              if (PP.XRUtils.isSessionActive()) {
                this._myCursorObjectVR.pp_setActive(!isUsingHand);
                this._myCursorObjectNonVR.pp_setActive(false);
              } else {
                this._myCursorObjectNonVR.pp_setActive(!isUsingHand);
                this._myCursorObjectVR.pp_setActive(false);
                this._myCursorObjectNonVR.pp_setTransformQuat(PP.myPlayerObjects.myNonVRCamera.pp_getTransformQuat(transformQuat3));
              }
            }
          };
        }(),
        _isUsingHand: function() {
          let isUsingHand = false;
          if (WL.xrSession && WL.xrSession.inputSources) {
            for (let i = 0; i < WL.xrSession.inputSources.length; i++) {
              let input = WL.xrSession.inputSources[i];
              if (input.hand && input.handedness == this._myHandednessString) {
                isUsingHand = true;
                break;
              }
            }
          }
          return isUsingHand;
        },
        _pulseOnHover: function(object) {
          let targetComponent = object.getComponent("cursor-target");
          if (targetComponent && !targetComponent.isSurface) {
            if (this._myHandedness == 0) {
              if (PP.myLeftGamepad) {
                PP.myLeftGamepad.pulse(0.4, 0);
              }
            } else {
              if (PP.myRightGamepad) {
                PP.myRightGamepad.pulse(0.4, 0);
              }
            }
          }
        }
      });
    }
  });

  // js/pp/tool/console_vr/console_vr_widget_setup.js
  var require_console_vr_widget_setup = __commonJS({
    "js/pp/tool/console_vr/console_vr_widget_setup.js"() {
      PP.ConsoleVRWidgetSetup = class ConsoleVRWidgetSetup {
        constructor() {
          this._initializeBuildSetup();
          this._initializeRuntimeSetup();
        }
        _initializeBuildSetup() {
          this.myBackgroundColor = [46 / 255, 46 / 255, 46 / 255, 1];
          this.myCursorTargetCollisionCollider = 2;
          this.myCursorTargetCollisionGroup = 7;
          this.myCursorTargetCollisionThickness = 1e-3;
          this.myDefaultTextColor = [255 / 255, 255 / 255, 255 / 255, 1];
          this.myTextAlignment = 2;
          this.myTextJustification = 2;
          this.myTextColor = this.myDefaultTextColor;
          this.myMessageTypeColors = [];
          this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.LOG] = this.myDefaultTextColor;
          this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.ERROR] = [255 / 255, 40 / 255, 40 / 255, 1];
          this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.WARN] = [250 / 255, 220 / 255, 40 / 255, 1];
          this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.INFO] = [60 / 255, 200 / 255, 255 / 255, 1];
          this.myMessagesPanelPosition = PP.vec3_create(0, 0.075, 0);
          this.myMessagesBackgroundScale = PP.vec3_create(0.34, 0.15, 1);
          {
            let xPaddingPercentage = 0.03;
            let yPaddingPercentage = xPaddingPercentage * this.myMessagesBackgroundScale[0] / this.myMessagesBackgroundScale[1] * 0.8;
            let xPosition = -this.myMessagesBackgroundScale[0] + this.myMessagesBackgroundScale[0] * xPaddingPercentage;
            let yPosition = this.myMessagesBackgroundScale[1] - this.myMessagesBackgroundScale[1] * yPaddingPercentage;
            this.myMessagesTextsPanelPosition = PP.vec3_create(xPosition, yPosition, 7e-3);
          }
          this.myMessagesTextsPanelScale = PP.vec3_create(0.1, 0.1, 0.1);
          this.myMessagesTextStartString = ".\n";
          this.myMessagesTextAlignment = 1;
          this.myMessagesTextJustification = 3;
          this.myMessagesTextPositions = [];
          this.myMessagesTextPositions[PP.ConsoleVRWidget.MessageType.LOG] = PP.vec3_create(0, 0, 1e-5);
          this.myMessagesTextPositions[PP.ConsoleVRWidget.MessageType.ERROR] = PP.vec3_create(0, 0, 0);
          this.myMessagesTextPositions[PP.ConsoleVRWidget.MessageType.WARN] = PP.vec3_create(0, 0, 0);
          this.myMessagesTextPositions[PP.ConsoleVRWidget.MessageType.INFO] = PP.vec3_create(0, 0, 0);
          this.myMessagesTextColors = [];
          this.myMessagesTextColors[PP.ConsoleVRWidget.MessageType.LOG] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.LOG];
          this.myMessagesTextColors[PP.ConsoleVRWidget.MessageType.ERROR] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.ERROR];
          this.myMessagesTextColors[PP.ConsoleVRWidget.MessageType.WARN] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.WARN];
          this.myMessagesTextColors[PP.ConsoleVRWidget.MessageType.INFO] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.INFO];
          this.myButtonsPanelPosition = PP.vec3_create(0, -0.11, 0.015);
          this.myButtonBackgroundScale = PP.vec3_create(0.04, 0.02, 1);
          this.myButtonTextPosition = PP.vec3_create(0, 0, 7e-3);
          this.myButtonTextScale = PP.vec3_create(0.18, 0.18, 0.18);
          this.myButtonCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myButtonCursorTargetPosition[2] = this.myButtonTextPosition[2];
          this.myButtonsCollisionCollider = this.myCursorTargetCollisionCollider;
          this.myButtonsCollisionGroup = this.myCursorTargetCollisionGroup;
          this.myButtonsCollisionExtents = this.myButtonBackgroundScale.slice(0);
          this.myButtonsCollisionExtents[2] = this.myCursorTargetCollisionThickness;
          this.myClearButtonTextLabel = "clear";
          this.myUpButtonTextLabel = "up";
          this.myDownButtonTextLabel = "down";
          this.myFilterButtonsTextColors = [];
          this.myFilterButtonsTextColors[PP.ConsoleVRWidget.MessageType.LOG] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.LOG];
          this.myFilterButtonsTextColors[PP.ConsoleVRWidget.MessageType.ERROR] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.ERROR];
          this.myFilterButtonsTextColors[PP.ConsoleVRWidget.MessageType.WARN] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.WARN];
          this.myFilterButtonsTextColors[PP.ConsoleVRWidget.MessageType.INFO] = this.myMessageTypeColors[PP.ConsoleVRWidget.MessageType.INFO];
          this.myFilterButtonsTextLabel = [];
          this.myFilterButtonsTextLabel[PP.ConsoleVRWidget.MessageType.LOG] = "log";
          this.myFilterButtonsTextLabel[PP.ConsoleVRWidget.MessageType.ERROR] = "error";
          this.myFilterButtonsTextLabel[PP.ConsoleVRWidget.MessageType.WARN] = "warn";
          this.myFilterButtonsTextLabel[PP.ConsoleVRWidget.MessageType.INFO] = "info";
          {
            let numberOfButtons = 7;
            let buttonsHorizontalSpace = Math.max(0.68, this.myButtonBackgroundScale[0] * numberOfButtons);
            let numberOfSpacesBetweenButtons = 2 + 3 + 4 + 4 + 1 + 2;
            let spaceWidth = Math.max((buttonsHorizontalSpace - numberOfButtons * this.myButtonBackgroundScale[0] * 2) / numberOfSpacesBetweenButtons, 0);
            let halfButtonWidth = this.myButtonBackgroundScale[0];
            let initialPosition = -buttonsHorizontalSpace / 2;
            this.myFilterButtonsPositions = [];
            this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.LOG] = [initialPosition + spaceWidth * 2 + halfButtonWidth, 0, 0];
            this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.ERROR] = [this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.LOG][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
            this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.WARN] = [this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.ERROR][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
            this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.INFO] = [this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.WARN][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
            this.myClearButtonPosition = [this.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType.INFO][0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
            this.myUpButtonPosition = [this.myClearButtonPosition[0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
            this.myDownButtonPosition = [this.myUpButtonPosition[0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
          }
          this.myNotifyIconBackgroundScale = PP.vec3_create(0.01, 0.01, 1);
          this.myNotifyIconPanelPositions = [];
          this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE] = PP.vec3_create(0, 0, 0);
          this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE][0] = -this.myMessagesBackgroundScale[0] + this.myNotifyIconBackgroundScale[0] + 0.01;
          this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE][1] = -this.myMessagesBackgroundScale[1] + this.myNotifyIconBackgroundScale[1] + 0.01;
          this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE][2] = this.myMessagesTextsPanelPosition[2] - 1e-5;
          this.myNotifyIconPanelPositions[PP.ToolHandedness.LEFT] = this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE];
          this.myNotifyIconPanelPositions[PP.ToolHandedness.RIGHT] = this.myNotifyIconPanelPositions[PP.ToolHandedness.NONE];
          this.myNotifyIconCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myNotifyIconCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - this.myMessagesTextsPanelPosition[2];
          this.myNotifyIconCollisionExtents = this.myNotifyIconBackgroundScale.slice(0);
          this.myNotifyIconCollisionExtents[2] = this.myCursorTargetCollisionThickness;
          this.myNotifyIconColor = [210 / 255, 210 / 255, 210 / 255, 1];
          this.myPointerCollisionCollider = this.myCursorTargetCollisionCollider;
          this.myPointerCollisionGroup = this.myCursorTargetCollisionGroup;
          {
            let spaceBetweenMessagesAndButtons = Math.abs(this.myMessagesPanelPosition[1] - this.myMessagesBackgroundScale[1] - (this.myButtonsPanelPosition[1] + this.myButtonBackgroundScale[1]));
            let pointerCollisionHalfHeight = this.myMessagesBackgroundScale[1] + this.myButtonBackgroundScale[1] + spaceBetweenMessagesAndButtons / 2;
            this.myPointerCollisionExtents = PP.vec3_create(this.myMessagesBackgroundScale[0], pointerCollisionHalfHeight, this.myCursorTargetCollisionThickness);
          }
          this.myPointerCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myPointerCursorTargetPosition[1] = this.myMessagesPanelPosition[1] + this.myMessagesBackgroundScale[1] - this.myPointerCollisionExtents[1];
          this.myPointerCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - 1e-4;
        }
        _initializeRuntimeSetup() {
          this.myTabString = "     ";
          this.myAssertStartString = "Assertion failed:";
          this.myMaxCharactersPerLine = 100;
          this.myMaxLineSplits = 50;
          this.myMaxLines = 22;
          this.myMaxMessages = 2e3;
          this.myMaxMessagesDeletePad = 2e3;
          this.myLinesBetweenMessages = 1;
          this.myButtonHoverColor = [150 / 255, 150 / 255, 150 / 255, 1];
          this.myButtonDisabledTextColor = this.myBackgroundColor;
          this.myButtonDisabledBackgroundColor = [110 / 255, 110 / 255, 110 / 255, 1];
          this.myFilterButtonDisabledTextColor = this.myButtonDisabledTextColor;
          this.myFilterButtonDisabledBackgroundColor = this.myButtonDisabledBackgroundColor;
          this.myScrollDelay = 0.1;
          this.myScrollAmount = 1;
          this.myScrollThumbstickHandedness = PP.ToolHandedness.RIGHT;
          this.myScrollThumbstickDelay = 0.1;
          this.myScrollThumbstickMinThreshold = 0.2;
          this.myScrollThumbstickAmount = 3;
          this.myPulseDelay = 5;
          this.myPulseIntensity = 0.3;
          this.myPulseDuration = 0.085;
          this.myClearBrowserConsoleWhenClearPressed = true;
          this.myGamepadScrollOnlyOnHover = true;
        }
      };
    }
  });

  // js/pp/tool/console_vr/console_vr_widget_ui.js
  var require_console_vr_widget_ui = __commonJS({
    "js/pp/tool/console_vr/console_vr_widget_ui.js"() {
      PP.ConsoleVRWidgetUI = class ConsoleVRWidgetUI {
        build(parentObject, setup, additionalSetup) {
          this._myParentObject = parentObject;
          this._mySetup = setup;
          this._myAdditionalSetup = additionalSetup;
          this._myPlaneMesh = PP.MeshUtils.createPlaneMesh();
          this._createSkeleton();
          this._setTransforms();
          this._addComponents();
          this._setTransformForNonVR();
          if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        }
        setVisible(visible) {
          this.myPivotObject.pp_setActiveHierarchy(visible);
        }
        //Skeleton
        _createSkeleton() {
          this.myPivotObject = WL.scene.addObject(this._myParentObject);
          this._createMessagesSkeleton();
          this._createButtonsSkeleton();
          this._createPointerSkeleton();
        }
        _createMessagesSkeleton() {
          this.myMessagesPanel = WL.scene.addObject(this.myPivotObject);
          this.myMessagesBackground = WL.scene.addObject(this.myMessagesPanel);
          this.myMessagesTextsPanel = WL.scene.addObject(this.myMessagesPanel);
          this.myMessagesTexts = [];
          for (let key in PP.ConsoleVRWidget.MessageType) {
            this.myMessagesTexts[PP.ConsoleVRWidget.MessageType[key]] = WL.scene.addObject(this.myMessagesTextsPanel);
          }
          this.myNotifyIconPanel = WL.scene.addObject(this.myMessagesPanel);
          this.myNotifyIconBackground = WL.scene.addObject(this.myNotifyIconPanel);
          this.myNotifyIconCursorTarget = WL.scene.addObject(this.myNotifyIconPanel);
        }
        _createButtonsSkeleton() {
          this.myButtonsPanel = WL.scene.addObject(this.myPivotObject);
          this.myFilterButtonsPanels = [];
          this.myFilterButtonsBackgrounds = [];
          this.myFilterButtonsTexts = [];
          this.myFilterButtonsCursorTargets = [];
          for (let key in PP.ConsoleVRWidget.MessageType) {
            this.myFilterButtonsPanels[PP.ConsoleVRWidget.MessageType[key]] = WL.scene.addObject(this.myButtonsPanel);
            this.myFilterButtonsBackgrounds[PP.ConsoleVRWidget.MessageType[key]] = WL.scene.addObject(this.myFilterButtonsPanels[PP.ConsoleVRWidget.MessageType[key]]);
            this.myFilterButtonsTexts[PP.ConsoleVRWidget.MessageType[key]] = WL.scene.addObject(this.myFilterButtonsPanels[PP.ConsoleVRWidget.MessageType[key]]);
            this.myFilterButtonsCursorTargets[PP.ConsoleVRWidget.MessageType[key]] = WL.scene.addObject(this.myFilterButtonsPanels[PP.ConsoleVRWidget.MessageType[key]]);
          }
          this.myClearButtonPanel = WL.scene.addObject(this.myButtonsPanel);
          this.myClearButtonBackground = WL.scene.addObject(this.myClearButtonPanel);
          this.myClearButtonText = WL.scene.addObject(this.myClearButtonPanel);
          this.myClearButtonCursorTarget = WL.scene.addObject(this.myClearButtonPanel);
          this.myUpButtonPanel = WL.scene.addObject(this.myButtonsPanel);
          this.myUpButtonBackground = WL.scene.addObject(this.myUpButtonPanel);
          this.myUpButtonText = WL.scene.addObject(this.myUpButtonPanel);
          this.myUpButtonCursorTarget = WL.scene.addObject(this.myUpButtonPanel);
          this.myDownButtonPanel = WL.scene.addObject(this.myButtonsPanel);
          this.myDownButtonBackground = WL.scene.addObject(this.myDownButtonPanel);
          this.myDownButtonText = WL.scene.addObject(this.myDownButtonPanel);
          this.myDownButtonCursorTarget = WL.scene.addObject(this.myDownButtonPanel);
        }
        _createPointerSkeleton() {
          this.myPointerCursorTarget = WL.scene.addObject(this.myPivotObject);
        }
        //Transforms
        _setTransforms() {
          this.myPivotObject.setDirty();
          this._setMessagesTransforms();
          this._setButtonsTransforms();
          this._setPointerTransform();
        }
        _setMessagesTransforms() {
          this.myMessagesPanel.setTranslationLocal(this._mySetup.myMessagesPanelPosition);
          this.myMessagesBackground.scale(this._mySetup.myMessagesBackgroundScale);
          this.myMessagesTextsPanel.setTranslationLocal(this._mySetup.myMessagesTextsPanelPosition);
          this.myMessagesTextsPanel.scale(this._mySetup.myMessagesTextsPanelScale);
          for (let key in PP.ConsoleVRWidget.MessageType) {
            this.myMessagesTexts[PP.ConsoleVRWidget.MessageType[key]].setTranslationLocal(this._mySetup.myMessagesTextPositions[PP.ConsoleVRWidget.MessageType[key]]);
          }
          this.myNotifyIconPanel.setTranslationLocal(this._mySetup.myNotifyIconPanelPositions[this._myAdditionalSetup.myHandedness]);
          this.myNotifyIconBackground.scale(this._mySetup.myNotifyIconBackgroundScale);
          this.myNotifyIconCursorTarget.setTranslationLocal(this._mySetup.myNotifyIconCursorTargetPosition);
        }
        _setButtonsTransforms() {
          this.myButtonsPanel.setTranslationLocal(this._mySetup.myButtonsPanelPosition);
          for (let key in PP.ConsoleVRWidget.MessageType) {
            this.myFilterButtonsPanels[PP.ConsoleVRWidget.MessageType[key]].setTranslationLocal(this._mySetup.myFilterButtonsPositions[PP.ConsoleVRWidget.MessageType[key]]);
            this.myFilterButtonsBackgrounds[PP.ConsoleVRWidget.MessageType[key]].scale(this._mySetup.myButtonBackgroundScale);
            this.myFilterButtonsTexts[PP.ConsoleVRWidget.MessageType[key]].setTranslationLocal(this._mySetup.myButtonTextPosition);
            this.myFilterButtonsTexts[PP.ConsoleVRWidget.MessageType[key]].scale(this._mySetup.myButtonTextScale);
            this.myFilterButtonsCursorTargets[PP.ConsoleVRWidget.MessageType[key]].setTranslationLocal(this._mySetup.myButtonCursorTargetPosition);
          }
          {
            this.myClearButtonPanel.setTranslationLocal(this._mySetup.myClearButtonPosition);
            this.myClearButtonBackground.scale(this._mySetup.myButtonBackgroundScale);
            this.myClearButtonText.setTranslationLocal(this._mySetup.myButtonTextPosition);
            this.myClearButtonText.scale(this._mySetup.myButtonTextScale);
            this.myClearButtonCursorTarget.setTranslationLocal(this._mySetup.myButtonCursorTargetPosition);
          }
          {
            this.myUpButtonPanel.setTranslationLocal(this._mySetup.myUpButtonPosition);
            this.myUpButtonBackground.scale(this._mySetup.myButtonBackgroundScale);
            this.myUpButtonText.setTranslationLocal(this._mySetup.myButtonTextPosition);
            this.myUpButtonText.scale(this._mySetup.myButtonTextScale);
            this.myUpButtonCursorTarget.setTranslationLocal(this._mySetup.myButtonCursorTargetPosition);
          }
          {
            this.myDownButtonPanel.setTranslationLocal(this._mySetup.myDownButtonPosition);
            this.myDownButtonBackground.scale(this._mySetup.myButtonBackgroundScale);
            this.myDownButtonText.setTranslationLocal(this._mySetup.myButtonTextPosition);
            this.myDownButtonText.scale(this._mySetup.myButtonTextScale);
            this.myDownButtonCursorTarget.setTranslationLocal(this._mySetup.myButtonCursorTargetPosition);
          }
        }
        _setPointerTransform() {
          this.myPointerCursorTarget.setTranslationLocal(this._mySetup.myPointerCursorTargetPosition);
        }
        //Components
        _addComponents() {
          this._addMessagesComponents();
          this._addButtonsComponents();
          this._addPointerComponents();
        }
        _addMessagesComponents() {
          let messagesBackgroundMeshComp = this.myMessagesBackground.addComponent("mesh");
          messagesBackgroundMeshComp.mesh = this._myPlaneMesh;
          messagesBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          messagesBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;
          this.myMessagesTextComponents = [];
          for (let key in PP.ConsoleVRWidget.MessageType) {
            let textComp = this.myMessagesTexts[PP.ConsoleVRWidget.MessageType[key]].addComponent("text");
            textComp.alignment = this._mySetup.myMessagesTextAlignment;
            textComp.justification = this._mySetup.myMessagesTextJustification;
            textComp.material = this._myAdditionalSetup.myTextMaterial.clone();
            textComp.material.color = this._mySetup.myMessagesTextColors[PP.ConsoleVRWidget.MessageType[key]];
            textComp.lineSpacing = 1.2;
            textComp.text = this._mySetup.myMessagesTextStartString;
            this.myMessagesTextComponents[PP.ConsoleVRWidget.MessageType[key]] = textComp;
          }
          this.myNotifyIconBackgroundComponent = this.myNotifyIconBackground.addComponent("mesh");
          this.myNotifyIconBackgroundComponent.mesh = this._myPlaneMesh;
          this.myNotifyIconBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myNotifyIconBackgroundComponent.material.color = this._mySetup.myNotifyIconColor;
          this.myNotifyIconCursorTargetComponent = this.myNotifyIconCursorTarget.addComponent("cursor-target");
          this.myNotifyIconCollisionComponent = this.myNotifyIconCursorTarget.addComponent("collision");
          this.myNotifyIconCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myNotifyIconCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myNotifyIconCollisionComponent.extents = this._mySetup.myNotifyIconCollisionExtents;
        }
        _addButtonsComponents() {
          this.myFilterButtonsBackgroundComponents = [];
          this.myFilterButtonsTextComponents = [];
          this.myFilterButtonsCursorTargetComponents = [];
          this.myFilterButtonsCollisionComponents = [];
          for (let key in PP.ConsoleVRWidget.MessageType) {
            let buttonBackgroundMeshComp = this.myFilterButtonsBackgrounds[PP.ConsoleVRWidget.MessageType[key]].addComponent("mesh");
            buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
            buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
            buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;
            let buttonTextComp = this.myFilterButtonsTexts[PP.ConsoleVRWidget.MessageType[key]].addComponent("text");
            this._setupButtonTextComponent(buttonTextComp);
            buttonTextComp.material.color = this._mySetup.myFilterButtonsTextColors[PP.ConsoleVRWidget.MessageType[key]];
            buttonTextComp.text = this._mySetup.myFilterButtonsTextLabel[PP.ConsoleVRWidget.MessageType[key]];
            let buttonCursorTargetComp = this.myFilterButtonsCursorTargets[PP.ConsoleVRWidget.MessageType[key]].addComponent("cursor-target");
            let buttonCollisionComp = this.myFilterButtonsCursorTargets[PP.ConsoleVRWidget.MessageType[key]].addComponent("collision");
            buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
            buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
            buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;
            this.myFilterButtonsBackgroundComponents[PP.ConsoleVRWidget.MessageType[key]] = buttonBackgroundMeshComp;
            this.myFilterButtonsTextComponents[PP.ConsoleVRWidget.MessageType[key]] = buttonTextComp;
            this.myFilterButtonsCursorTargetComponents[PP.ConsoleVRWidget.MessageType[key]] = buttonCursorTargetComp;
            this.myFilterButtonsCollisionComponents[PP.ConsoleVRWidget.MessageType[key]] = buttonCollisionComp;
          }
          {
            let buttonBackgroundMeshComp = this.myClearButtonBackground.addComponent("mesh");
            buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
            buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
            buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;
            let buttonTextComp = this.myClearButtonText.addComponent("text");
            this._setupButtonTextComponent(buttonTextComp);
            buttonTextComp.text = this._mySetup.myClearButtonTextLabel;
            let buttonCursorTargetComp = this.myClearButtonCursorTarget.addComponent("cursor-target");
            let buttonCollisionComp = this.myClearButtonCursorTarget.addComponent("collision");
            buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
            buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
            buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;
            this.myClearButtonBackgroundComponent = buttonBackgroundMeshComp;
            this.myClearButtonTextComponent = buttonTextComp;
            this.myClearButtonCursorTargetComponent = buttonCursorTargetComp;
            this.myClearButtonCollisionComponent = buttonCollisionComp;
          }
          {
            let buttonBackgroundMeshComp = this.myUpButtonBackground.addComponent("mesh");
            buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
            buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
            buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;
            let buttonTextComp = this.myUpButtonText.addComponent("text");
            this._setupButtonTextComponent(buttonTextComp);
            buttonTextComp.text = this._mySetup.myUpButtonTextLabel;
            let buttonCursorTargetComp = this.myUpButtonCursorTarget.addComponent("cursor-target");
            let buttonCollisionComp = this.myUpButtonCursorTarget.addComponent("collision");
            buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
            buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
            buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;
            this.myUpButtonBackgroundComponent = buttonBackgroundMeshComp;
            this.myUpButtonTextComponent = buttonTextComp;
            this.myUpButtonCursorTargetComponent = buttonCursorTargetComp;
            this.myUpButtonCollisionComponent = buttonCollisionComp;
          }
          {
            let buttonBackgroundMeshComp = this.myDownButtonBackground.addComponent("mesh");
            buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
            buttonBackgroundMeshComp.material = this._myAdditionalSetup.myPlaneMaterial.clone();
            buttonBackgroundMeshComp.material.color = this._mySetup.myBackgroundColor;
            let buttonTextComp = this.myDownButtonText.addComponent("text");
            this._setupButtonTextComponent(buttonTextComp);
            buttonTextComp.text = this._mySetup.myDownButtonTextLabel;
            let buttonCursorTargetComp = this.myDownButtonCursorTarget.addComponent("cursor-target");
            let buttonCollisionComp = this.myDownButtonCursorTarget.addComponent("collision");
            buttonCollisionComp.collider = this._mySetup.myButtonsCollisionCollider;
            buttonCollisionComp.group = 1 << this._mySetup.myButtonsCollisionGroup;
            buttonCollisionComp.extents = this._mySetup.myButtonsCollisionExtents;
            this.myDownButtonBackgroundComponent = buttonBackgroundMeshComp;
            this.myDownButtonTextComponent = buttonTextComp;
            this.myDownButtonCursorTargetComponent = buttonCursorTargetComp;
            this.myDownButtonCollisionComponent = buttonCollisionComp;
          }
        }
        _addPointerComponents() {
          this.myPointerCursorTargetComponent = this.myPointerCursorTarget.addComponent("cursor-target");
          this.myPointerCursorTargetComponent.isSurface = true;
          let collisionComp = this.myPointerCursorTarget.addComponent("collision");
          collisionComp.collider = this._mySetup.myPointerCollisionCollider;
          collisionComp.group = 1 << this._mySetup.myPointerCollisionGroup;
          collisionComp.extents = this._mySetup.myPointerCollisionExtents;
          this.myPointerCollisionComponent = collisionComp;
        }
        _setupButtonTextComponent(textComponent) {
          textComponent.alignment = this._mySetup.myTextAlignment;
          textComponent.justification = this._mySetup.myTextJustification;
          textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
          textComponent.material.color = this._mySetup.myTextColor;
          textComponent.text = "";
        }
        _onXRSessionStart() {
          this._setTransformForVR();
        }
        _onXRSessionEnd() {
          this._setTransformForNonVR();
        }
        _setTransformForVR() {
          this.myNotifyIconPanel.setTranslationLocal(this._mySetup.myNotifyIconPanelPositions[this._myAdditionalSetup.myHandedness]);
        }
        _setTransformForNonVR() {
          this.myNotifyIconPanel.setTranslationLocal(this._mySetup.myNotifyIconPanelPositions[PP.ToolHandedness.NONE]);
        }
      };
    }
  });

  // js/pp/tool/console_vr/console_vr_widget.js
  var require_console_vr_widget = __commonJS({
    "js/pp/tool/console_vr/console_vr_widget.js"() {
      PP.ConsoleVRWidget = class ConsoleVRWidget {
        constructor() {
          this._myWidgetFrame = new PP.WidgetFrame("C", 0);
          this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));
          this._mySetup = new PP.ConsoleVRWidgetSetup();
          this._myAdditionalSetup = null;
          this._myUI = new PP.ConsoleVRWidgetUI();
          this._myMessages = [];
          this._myOldBrowserConsole = [];
          this._myOldConsoleVR = [];
          this._myTypeFilters = [];
          for (let key in PP.ConsoleVRWidget.MessageType) {
            this._myTypeFilters[PP.ConsoleVRWidget.MessageType[key]] = false;
          }
          this._myScrollUp = false;
          this._myScrollDown = false;
          this._myScrollOffset = 0;
          this._myScrollTimer = 0;
          this._myScrollThumbstickTimer = 0;
          this._myPulseTimer = 0;
          this._myGamepadScrollActive = true;
          if (this._mySetup.myGamepadScrollOnlyOnHover) {
            this._myGamepadScrollActive = false;
          }
        }
        setVisible(visible) {
          this._myWidgetFrame.setVisible(visible);
        }
        isVisible() {
          return this._myWidgetFrame.isVisible();
        }
        start(parentObject, additionalSetup) {
          this._myLeftGamepad = PP.myLeftGamepad;
          this._myRightGamepad = PP.myRightGamepad;
          this._myAdditionalSetup = additionalSetup;
          this._myWidgetFrame.start(parentObject, additionalSetup);
          this._myUI.build(this._myWidgetFrame.getWidgetObject(), this._mySetup, additionalSetup);
          this._myUI.setVisible(this._myWidgetFrame.myIsWidgetVisible);
          this._setNotifyIconActive(false);
          this._addListeners();
          this._overrideConsolesFunctions();
        }
        //This must be done only when all the setup is complete, to avoid issues with other part of the code calling the console and then triggering the console vr while not ready yet
        _overrideConsolesFunctions() {
          this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.LOG] = console.log;
          this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.ERROR] = console.error;
          this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.WARN] = console.warn;
          this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.INFO] = console.info;
          this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.DEBUG] = console.debug;
          this._myOldBrowserConsole[PP.ConsoleVRWidget.ConsoleFunction.ASSERT] = console.assert;
          this._myOldBrowserConsoleClear = console.clear;
          if (this._myAdditionalSetup.myOverrideBrowserConsole) {
            console.log = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.LOG, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.error = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.ERROR, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.warn = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.WARN, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.info = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.INFO, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.debug = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.DEBUG, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.assert = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.ASSERT, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            console.clear = this._clearConsole.bind(this, true, PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE);
            window.addEventListener("error", function(errorEvent) {
              if (errorEvent.error != null) {
                this._consolePrint(PP.ConsoleVRWidget.ConsoleFunction.ERROR, PP.ConsoleVRWidget.Sender.WINDOW, "Uncaught", errorEvent.error.stack);
              } else {
                this._consolePrint(PP.ConsoleVRWidget.ConsoleFunction.ERROR, PP.ConsoleVRWidget.Sender.WINDOW, "Uncaught", errorEvent.message);
              }
            }.bind(this));
            window.addEventListener("unhandledrejection", function(errorEvent) {
              this._consolePrint(PP.ConsoleVRWidget.ConsoleFunction.ERROR, PP.ConsoleVRWidget.Sender.WINDOW, "Uncaught (in promise)", errorEvent.reason);
            }.bind(this));
          }
          this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.LOG] = PP.ConsoleVR.log;
          this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.ERROR] = PP.ConsoleVR.error;
          this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.WARN] = PP.ConsoleVR.warn;
          this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.INFO] = PP.ConsoleVR.info;
          this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.DEBUG] = PP.ConsoleVR.debug;
          this._myOldConsoleVR[PP.ConsoleVRWidget.ConsoleFunction.ASSERT] = PP.ConsoleVR.assert;
          this._myOldConsoleVRClear = PP.ConsoleVR.clear;
          PP.ConsoleVR.log = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.LOG, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
          PP.ConsoleVR.error = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.ERROR, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
          PP.ConsoleVR.warn = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.WARN, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
          PP.ConsoleVR.info = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.INFO, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
          PP.ConsoleVR.debug = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.DEBUG, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
          PP.ConsoleVR.assert = this._consolePrint.bind(this, PP.ConsoleVRWidget.ConsoleFunction.ASSERT, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
          PP.ConsoleVR.clear = this._clearConsole.bind(this, true, PP.ConsoleVRWidget.Sender.CONSOLE_VR);
        }
        update(dt) {
          this._myWidgetFrame.update(dt);
          if (this._myWidgetFrame.myIsWidgetVisible) {
            this._updateScroll(dt);
          }
          this._updateGamepadsExtraActions(dt);
        }
        //Text section
        _updateText(messageType) {
          let consoleText = "";
          if (!this._myTypeFilters[messageType]) {
            let linesCount = 0;
            let i = this._myMessages.length - 1;
            let scrollLinesToSkip = Math.round(this._myScrollOffset);
            while (i >= 0 && linesCount < this._mySetup.myMaxLines) {
              let message = this._myMessages[i];
              if (this._myTypeFilters[message.myType]) {
                i -= 1;
                continue;
              }
              let messageLines = message.myLines.length;
              let linesToSkip = 0;
              if (scrollLinesToSkip > 0) {
                let additionalEmptyLines = 0;
                if (i != this._myMessages.length - 1) {
                  additionalEmptyLines = this._mySetup.myLinesBetweenMessages;
                }
                if (scrollLinesToSkip >= messageLines + additionalEmptyLines) {
                  scrollLinesToSkip -= messageLines + additionalEmptyLines;
                  linesToSkip = messageLines + additionalEmptyLines;
                } else {
                  linesToSkip = scrollLinesToSkip;
                  scrollLinesToSkip = 0;
                }
              }
              if (i != this._myMessages.length - 1) {
                let emptyLinesToSkip = this._mySetup.myLinesBetweenMessages - Math.max(this._mySetup.myLinesBetweenMessages - linesToSkip, 0);
                let emptyLinesToShow = this._mySetup.myLinesBetweenMessages - emptyLinesToSkip;
                if (linesCount + emptyLinesToShow > this._mySetup.myMaxLines) {
                  emptyLinesToShow = this._myMaxLines - linesCount;
                }
                for (let j = 0; j < emptyLinesToShow; j++) {
                  consoleText = "\n".concat(consoleText);
                }
                linesCount += emptyLinesToShow;
                linesToSkip -= emptyLinesToSkip;
              }
              let linesToShow = messageLines - linesToSkip;
              if (linesCount + linesToShow > this._mySetup.myMaxLines) {
                linesToShow = this._mySetup.myMaxLines - linesCount;
              }
              if (linesToShow > 0) {
                if (message.myType == messageType) {
                  let linesToPrint = message.myLines.slice(messageLines - linesToShow - linesToSkip, messageLines - linesToSkip);
                  let text = linesToPrint.join("\n");
                  consoleText = text.concat("\n").concat(consoleText);
                  linesCount += linesToShow;
                } else {
                  for (let j = 0; j < linesToShow; j++) {
                    consoleText = "\n".concat(consoleText);
                  }
                  linesCount += linesToShow;
                }
              }
              i -= 1;
            }
          }
          consoleText = this._mySetup.myMessagesTextStartString.concat(consoleText);
          this._myUI.myMessagesTextComponents[messageType].text = consoleText;
        }
        _consolePrint(consoleFunction, sender, ...args) {
          if (consoleFunction != PP.ConsoleVRWidget.ConsoleFunction.ASSERT || args.length > 0 && !args[0]) {
            let message = this._argsToMessage(consoleFunction, ...args);
            this._addMessage(message);
            if (this._myMessages.length >= this._mySetup.myMaxMessages + this._mySetup.myMaxMessagesDeletePad) {
              this._myMessages = this._myMessages.slice(this._myMessages.length - this._mySetup.myMaxMessages);
              this._clampScrollOffset();
            }
            this._updateAllTexts();
            this._pulseGamepad();
          }
          switch (sender) {
            case PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE:
              this._myOldBrowserConsole[consoleFunction].apply(console, args);
              break;
            case PP.ConsoleVRWidget.Sender.CONSOLE_VR:
              this._myOldConsoleVR[consoleFunction].apply(PP.ConsoleVR, args);
              break;
            default:
              this._myOldBrowserConsole[consoleFunction].apply(console, args);
              break;
          }
        }
        _argsToMessage(consoleFunction, ...args) {
          if (consoleFunction == PP.ConsoleVRWidget.ConsoleFunction.ASSERT) {
            args = args.slice(1);
            args.splice(0, 0, this._mySetup.myAssertStartString);
          }
          let messageType = this._consoleFunctionToMessageType(consoleFunction);
          let formattedText = this._formatArgs(...args);
          let lines = this._splitLongLines(formattedText);
          if (messageType == PP.ConsoleVRWidget.MessageType.DEBUG) {
            messageType = PP.ConsoleVRWidget.MessageType.LOG;
          } else if (messageType == PP.ConsoleVRWidget.MessageType.EXCEPTION || messageType == PP.ConsoleVRWidget.MessageType.ASSERT) {
            messageType = PP.ConsoleVRWidget.MessageType.ERROR;
          }
          let message = new PP.ConsoleVRWidget.Message(messageType, lines);
          return message;
        }
        _consoleFunctionToMessageType(consoleFunction) {
          let messageType = PP.ConsoleVRWidget.MessageType.LOG;
          if (consoleFunction < PP.ConsoleVRWidget.ConsoleFunction.DEBUG) {
            messageType = consoleFunction;
          } else if (consoleFunction == PP.ConsoleVRWidget.ConsoleFunction.DEBUG) {
            messageType = PP.ConsoleVRWidget.MessageType.LOG;
          } else {
            messageType = PP.ConsoleVRWidget.MessageType.ERROR;
          }
          return messageType;
        }
        //Here the formatting using placeholder like %d could be implemented in the future
        _formatArgs(...args) {
          let stringifiedArgs = [];
          for (let i = 0; i < args.length; i++) {
            if (args[i] === void 0) {
              stringifiedArgs.push("undefined");
            } else {
              stringifiedArgs.push(this._stringifyItem(args[i]));
            }
          }
          let formattedString = stringifiedArgs.join(" ");
          return formattedString;
        }
        _stringifyItem(item) {
          if (typeof item === "object") {
            let stringifiedItem = null;
            let linesBetweenItems = 2;
            try {
              stringifiedItem = JSON.stringify(item, this._jsonReplacer.bind(this), linesBetweenItems);
            } catch (error) {
              let cache = /* @__PURE__ */ new WeakSet();
              stringifiedItem = JSON.stringify(item, function(key, value) {
                if (typeof value === "object" && value !== null) {
                  if (cache.has(value)) {
                    return "<stringify error: object already stringified>";
                  }
                  cache.add(value);
                }
                return this._jsonReplacer(key, value);
              }.bind(this), linesBetweenItems);
            }
            stringifiedItem = stringifiedItem.replaceAll('"[', "[");
            stringifiedItem = stringifiedItem.replaceAll("'[", "[");
            stringifiedItem = stringifiedItem.replaceAll(']"', "]");
            stringifiedItem = stringifiedItem.replaceAll("]'", "]");
            return stringifiedItem;
          }
          return item;
        }
        _splitLongLines(messageText) {
          let linesToSplit = messageText.split("\n");
          let lines = [];
          for (let i = 0; i < linesToSplit.length; i++) {
            let lineToSplit = linesToSplit[i];
            if (lineToSplit.length > this._mySetup.myMaxCharactersPerLine) {
              let spacesAtStart = this._getSpacesAtStart(lineToSplit);
              let spaceToAdd = this._mySetup.myTabString.concat(spacesAtStart);
              let lineSplits = 0;
              while (lineToSplit.length > this._mySetup.myMaxCharactersPerLine && lineSplits < this._mySetup.myMaxLineSplits) {
                let firstSub = lineToSplit.substr(0, this._mySetup.myMaxCharactersPerLine - 1);
                let secondSub = lineToSplit.substr(this._mySetup.myMaxCharactersPerLine - 1);
                secondSub = spaceToAdd.concat(secondSub);
                lines.push(firstSub);
                lineToSplit = secondSub;
                lineSplits++;
              }
              lines.push(lineToSplit);
            } else {
              lines.push(lineToSplit);
            }
          }
          return lines;
        }
        _getSpacesAtStart(text) {
          let spaces = "";
          let i = 0;
          while (i < text.length && text[i] == " ") {
            spaces = spaces.concat(" ");
            i++;
          }
          return spaces;
        }
        _addMessage(message) {
          let hasSameInfoAsPrev = false;
          if (this._myMessages.length > 0) {
            let lastMessage = this._myMessages[this._myMessages.length - 1];
            if (lastMessage.hasSameInfo(message)) {
              lastMessage.increaseCount();
              hasSameInfoAsPrev = true;
            }
          }
          if (!hasSameInfoAsPrev) {
            this._myMessages.push(message);
          }
          this._adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev);
          this._updateNotifyIcon(message);
        }
        //if you have scrolled, new messages does not move the scroll position
        _adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev) {
          if (!hasSameInfoAsPrev && !this._myTypeFilters[message.myType] && this._myScrollOffset > 0) {
            this._myScrollOffset += message.myLines.length + this._mySetup.myLinesBetweenMessages;
          }
        }
        _updateAllTexts() {
          if (this._myWidgetFrame.myIsWidgetVisible) {
            for (let key in PP.ConsoleVRWidget.MessageType) {
              this._updateText(PP.ConsoleVRWidget.MessageType[key]);
            }
          }
        }
        _updateNotifyIcon(message) {
          if (!this._myTypeFilters[message.myType] && this._myScrollOffset > 0) {
            this._setNotifyIconActive(true);
          }
        }
        _updateScroll(dt) {
          if (this._myScrollUp) {
            this._myScrollTimer += dt;
            while (this._myScrollTimer > this._mySetup.myScrollDelay) {
              this._myScrollTimer -= this._mySetup.myScrollDelay;
              this._myScrollOffset += this._mySetup.myScrollAmount;
            }
          } else if (this._myScrollDown) {
            this._myScrollTimer += dt;
            while (this._myScrollTimer > this._mySetup.myScrollDelay) {
              this._myScrollTimer -= this._mySetup.myScrollDelay;
              this._myScrollOffset -= this._mySetup.myScrollAmount;
            }
          }
          this._clampScrollOffset();
          if (this._myScrollUp || this._myScrollDown) {
            this._updateAllTexts();
          }
          if (this._myScrollOffset == 0) {
            this._setNotifyIconActive(false);
          }
        }
        _clampScrollOffset() {
          let maxScroll = this._getMaxScrollOffset();
          this._myScrollOffset = Math.min(Math.max(this._myScrollOffset, 0), maxScroll);
        }
        _getMaxScrollOffset() {
          return Math.max(this._getLinesCount() - this._mySetup.myMaxLines, 0);
        }
        _getLinesCount() {
          let linesCount = 0;
          for (let message of this._myMessages) {
            if (!this._myTypeFilters[message.myType]) {
              linesCount += message.myLines.length + this._mySetup.myLinesBetweenMessages;
            }
          }
          linesCount -= this._mySetup.myLinesBetweenMessages;
          linesCount = Math.max(linesCount, 0);
          return linesCount;
        }
        //Listener section
        _addListeners() {
          let ui = this._myUI;
          for (let key in PP.ConsoleVRWidget.MessageType) {
            let cursorTarget = ui.myFilterButtonsCursorTargetComponents[PP.ConsoleVRWidget.MessageType[key]];
            let backgroundMaterial = ui.myFilterButtonsBackgroundComponents[PP.ConsoleVRWidget.MessageType[key]].material;
            let textMaterial = ui.myFilterButtonsTextComponents[PP.ConsoleVRWidget.MessageType[key]].material;
            cursorTarget.addTripleClickFunction(this._resetFilters.bind(this, PP.ConsoleVRWidget.MessageType[key]));
            cursorTarget.addDoubleClickFunction(this._filterAllButOne.bind(this, PP.ConsoleVRWidget.MessageType[key], textMaterial));
            cursorTarget.addClickFunction(this._toggleFilter.bind(this, PP.ConsoleVRWidget.MessageType[key], textMaterial));
            cursorTarget.addHoverFunction(this._filterHover.bind(this, PP.ConsoleVRWidget.MessageType[key], backgroundMaterial));
            cursorTarget.addUnHoverFunction(this._filterUnHover.bind(this, PP.ConsoleVRWidget.MessageType[key], backgroundMaterial));
          }
          {
            let cursorTarget = ui.myClearButtonCursorTargetComponent;
            let backgroundMaterial = ui.myClearButtonBackgroundComponent.material;
            cursorTarget.addClickFunction(this._clearConsole.bind(this, false, null));
            cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
            cursorTarget.addUnHoverFunction(this._genericUnHover.bind(this, backgroundMaterial));
          }
          {
            let cursorTarget = ui.myUpButtonCursorTargetComponent;
            let backgroundMaterial = ui.myUpButtonBackgroundComponent.material;
            cursorTarget.addDoubleClickFunction(this._instantScrollUp.bind(this, true));
            cursorTarget.addDownFunction(this._setScrollUp.bind(this, true));
            cursorTarget.addUpFunction(this._setScrollUp.bind(this, false));
            cursorTarget.addUnHoverFunction(this._setScrollUp.bind(this, false));
            cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
            cursorTarget.addUnHoverFunction(this._genericUnHover.bind(this, backgroundMaterial));
          }
          {
            let cursorTarget = ui.myDownButtonCursorTargetComponent;
            let backgroundMaterial = ui.myDownButtonBackgroundComponent.material;
            cursorTarget.addDoubleClickFunction(this._instantScrollDown.bind(this));
            cursorTarget.addDownFunction(this._setScrollDown.bind(this, true));
            cursorTarget.addUpFunction(this._setScrollDown.bind(this, false));
            cursorTarget.addUnHoverFunction(this._setScrollDown.bind(this, false));
            cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
            cursorTarget.addUnHoverFunction(this._genericUnHover.bind(this, backgroundMaterial));
          }
          {
            let cursorTarget = ui.myNotifyIconCursorTargetComponent;
            let backgroundMaterial = ui.myNotifyIconBackgroundComponent.material;
            cursorTarget.addClickFunction(this._instantScrollDown.bind(this));
            cursorTarget.addHoverFunction(this._genericHover.bind(this, backgroundMaterial));
            cursorTarget.addUnHoverFunction(this._notifyIconUnHover.bind(this));
          }
          ui.myPointerCursorTargetComponent.addHoverFunction(this._setGamepadScrollActive.bind(this, true));
          ui.myPointerCursorTargetComponent.addUnHoverFunction(this._setGamepadScrollActive.bind(this, false));
        }
        _resetFilters(messageType) {
          if (this._myWidgetFrame.myIsWidgetVisible) {
            for (let key in PP.ConsoleVRWidget.MessageType) {
              let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[PP.ConsoleVRWidget.MessageType[key]].material;
              let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[PP.ConsoleVRWidget.MessageType[key]].material;
              this._myTypeFilters[PP.ConsoleVRWidget.MessageType[key]] = false;
              filterTextMaterial.color = this._mySetup.myMessageTypeColors[PP.ConsoleVRWidget.MessageType[key]];
              if (PP.ConsoleVRWidget.MessageType[key] != messageType) {
                backgroundMaterial.color = this._mySetup.myBackgroundColor;
              }
            }
            this._clampScrollOffset();
            this._updateAllTexts();
          }
        }
        _filterAllButOne(messageType) {
          if (this._myWidgetFrame.myIsWidgetVisible) {
            for (let key in PP.ConsoleVRWidget.MessageType) {
              let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[PP.ConsoleVRWidget.MessageType[key]].material;
              let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[PP.ConsoleVRWidget.MessageType[key]].material;
              if (PP.ConsoleVRWidget.MessageType[key] != messageType) {
                this._myTypeFilters[PP.ConsoleVRWidget.MessageType[key]] = true;
                backgroundMaterial.color = this._mySetup.myFilterButtonDisabledBackgroundColor;
                filterTextMaterial.color = this._mySetup.myFilterButtonDisabledTextColor;
              } else {
                this._myTypeFilters[PP.ConsoleVRWidget.MessageType[key]] = false;
                filterTextMaterial.color = this._mySetup.myMessageTypeColors[messageType];
              }
            }
            this._clampScrollOffset();
            this._updateAllTexts();
          }
        }
        _toggleFilter(messageType, textMaterial) {
          if (this._myWidgetFrame.myIsWidgetVisible) {
            this._myTypeFilters[messageType] = !this._myTypeFilters[messageType];
            if (this._myTypeFilters[messageType]) {
              textMaterial.color = this._mySetup.myFilterButtonDisabledTextColor;
            } else {
              textMaterial.color = this._mySetup.myMessageTypeColors[messageType];
            }
            this._clampScrollOffset();
            this._updateAllTexts();
          }
        }
        _clearConsole(codeDrivenClear = false, sender = null) {
          if (this._myWidgetFrame.myIsWidgetVisible || codeDrivenClear) {
            this._myMessages = [];
            this._clampScrollOffset();
            this._updateAllTexts();
            if (codeDrivenClear) {
              switch (sender) {
                case PP.ConsoleVRWidget.Sender.BROWSER_CONSOLE:
                  this._myOldBrowserConsoleClear.apply(console);
                  break;
                case PP.ConsoleVRWidget.Sender.CONSOLE_VR:
                  this._myOldConsoleVRClear.apply(PP.ConsoleVR);
                  break;
                default:
                  break;
              }
            } else if (this._mySetup.myClearBrowserConsoleWhenClearPressed) {
              PP.ConsoleVR._myRealClear();
            }
          }
        }
        _setScrollUp(value) {
          if (this._myWidgetFrame.myIsWidgetVisible || !value) {
            if (value) {
              this._myScrollTimer = 0;
            }
            this._myScrollUp = value;
          }
        }
        _setScrollDown(value) {
          if (this._myWidgetFrame.myIsWidgetVisible || !value) {
            if (value) {
              this._myScrollTimer = 0;
            }
            this._myScrollDown = value;
          }
        }
        _instantScrollUp() {
          if (this._myWidgetFrame.myIsWidgetVisible) {
            this._myScrollOffset = this._getMaxScrollOffset();
            this._updateAllTexts();
          }
        }
        _instantScrollDown() {
          if (this._myWidgetFrame.myIsWidgetVisible) {
            this._myScrollOffset = 0;
            this._setNotifyIconActive(false);
            this._updateAllTexts();
          }
        }
        _setNotifyIconActive(active) {
          this._myUI.myNotifyIconPanel.pp_setActiveHierarchy(active && this._myWidgetFrame.myIsWidgetVisible);
        }
        _notifyIconUnHover() {
          let material = this._myUI.myNotifyIconBackgroundComponent.material;
          material.color = this._mySetup.myNotifyIconColor;
        }
        _filterHover(messageType, material) {
          this._genericHover(material);
        }
        _filterUnHover(messageType, material) {
          if (this._myTypeFilters[messageType]) {
            material.color = this._mySetup.myFilterButtonDisabledBackgroundColor;
          } else {
            material.color = this._mySetup.myBackgroundColor;
          }
        }
        _genericHover(material) {
          material.color = this._mySetup.myButtonHoverColor;
        }
        _genericUnHover(material) {
          material.color = this._mySetup.myBackgroundColor;
        }
        //Gamepad section
        _updateGamepadsExtraActions(dt) {
          if (this._myLeftGamepad && this._myRightGamepad) {
            if (this._myLeftGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressStart() && this._myRightGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).myIsPressed || this._myRightGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressStart() && this._myLeftGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).myIsPressed) {
              this._toggleVisibility();
            }
            this._myPulseTimer = Math.max(this._myPulseTimer - dt, 0);
            this._updateScrollWithThumbstick(dt);
          }
        }
        _toggleVisibility() {
          this._myWidgetFrame.toggleVisibility();
        }
        _widgetVisibleChanged(visible) {
          this._myUI.setVisible(visible);
          if (visible) {
            this._updateAllTexts();
          }
        }
        _updateScrollWithThumbstick(dt) {
          if (this._myWidgetFrame.myIsWidgetVisible && this._myGamepadScrollActive) {
            let axes = [0, 0];
            if (this._mySetup.myScrollThumbstickHandedness == PP.ToolHandedness.LEFT) {
              axes = this._myLeftGamepad.getAxesInfo().myAxes;
            } else if (this._mySetup.myScrollThumbstickHandedness == PP.ToolHandedness.RIGHT) {
              axes = this._myRightGamepad.getAxesInfo().myAxes;
            }
            if (Math.abs(axes[1]) > this._mySetup.myScrollThumbstickMinThreshold) {
              this._myScrollThumbstickTimer += dt;
              while (this._myScrollThumbstickTimer > this._mySetup.myScrollThumbstickDelay) {
                this._myScrollThumbstickTimer -= this._mySetup.myScrollThumbstickDelay;
                let normalizedScrollAmount = (Math.abs(axes[1]) - this._mySetup.myScrollThumbstickMinThreshold) / (1 - this._mySetup.myScrollThumbstickMinThreshold);
                this._myScrollOffset += Math.sign(axes[1]) * normalizedScrollAmount * this._mySetup.myScrollThumbstickAmount;
              }
              this._clampScrollOffset();
              this._updateAllTexts();
            } else {
              this._myScrollThumbstickTimer = 0;
            }
          }
        }
        _pulseGamepad() {
          if (this._myLeftGamepad && this._myRightGamepad) {
            let pulseType = this._myAdditionalSetup.myPulseOnNewMessage;
            let pulseEnabled = pulseType == PP.ConsoleVRWidget.PulseOnNewMessage.ALWAYS || !this._myWidgetFrame.myIsWidgetVisible && pulseType == PP.ConsoleVRWidget.PulseOnNewMessage.WHEN_HIDDEN;
            if (pulseEnabled && this._myPulseTimer == 0) {
              if (this._myAdditionalSetup.myHandedness == PP.ToolHandedness.RIGHT) {
                this._myRightGamepad.pulse(this._mySetup.myPulseIntensity, this._mySetup.myPulseDuration);
              } else {
                this._myLeftGamepad.pulse(this._mySetup.myPulseIntensity, this._mySetup.myPulseDuration);
              }
              this._myPulseTimer = this._mySetup.myPulseDelay;
            }
          }
        }
        _isSimpleArray(array) {
          if (this._isSpecialSimpleArray(array)) {
            return true;
          } else if (Array.isArray(array)) {
            let isBuiltIn = true;
            for (let element of array) {
              if (element instanceof Object) {
                isBuiltIn = false;
                break;
              }
            }
            return isBuiltIn;
          }
          return false;
        }
        _isSpecialSimpleArray(item) {
          return item && item.constructor && (item.constructor.name == "Uint32Array" || item.constructor.name == "Int32Array" || item.constructor.name == "Float32Array" || item.constructor.name == "Float64Array");
        }
        _setGamepadScrollActive(active) {
          this._myGamepadScrollActive = active;
          if (!this._mySetup.myGamepadScrollOnlyOnHover) {
            this._myGamepadScrollActive = true;
          }
        }
        _jsonReplacer(key, value) {
          if (value instanceof Map) {
            return Array.from(value.entries());
          } else if (this._isSimpleArray(value)) {
            let array = value;
            if (this._isSpecialSimpleArray(array)) {
              let arrayCopy = [];
              for (let i = 0; i < array.length; i++) {
                arrayCopy[i] = array[i];
              }
              array = arrayCopy;
            }
            let stringifiedArray = JSON.stringify(array);
            stringifiedArray = stringifiedArray.split(",").join(", ");
            return stringifiedArray;
          } else {
            return value;
          }
        }
      };
      PP.ConsoleVRWidget.AdditionalSetup = class ConsoleVRWidgetAdditionalSetup {
        constructor() {
          this.myHandedness = PP.ToolHandedness.NONE;
          this.myOverrideBrowserConsole = false;
          this.myShowOnStart = false;
          this.myShowVisibilityButton = false;
          this.myPulseOnNewMessage = PP.ConsoleVRWidget.PulseOnNewMessage.NEVER;
          this.myPlaneMaterial = null;
          this.myTextMaterial = null;
        }
      };
      PP.ConsoleVRWidget.ConsoleFunction = {
        INFO: 0,
        WARN: 1,
        ERROR: 2,
        LOG: 3,
        DEBUG: 4,
        ASSERT: 5
      };
      PP.ConsoleVRWidget.Sender = {
        BROWSER_CONSOLE: 0,
        CONSOLE_VR: 1,
        WINDOW: 2
      };
      PP.ConsoleVRWidget.PulseOnNewMessage = {
        NEVER: 0,
        ALWAYS: 1,
        WHEN_HIDDEN: 2
      };
      PP.ConsoleVRWidget.MessageType = {
        INFO: 0,
        WARN: 1,
        ERROR: 2,
        LOG: 3
      };
      PP.ConsoleVRWidget.Message = class ConsoleVRWidgetMessage {
        constructor(messageType, messageLines) {
          this.myType = messageType;
          this.myLines = messageLines;
          this._myOriginalText = messageLines.join("\n");
          this._myMessagesCount = 1;
        }
        hasSameInfo(message) {
          return this._myOriginalText == message._myOriginalText && this.myType == message.myType;
        }
        increaseCount() {
          this._myMessagesCount += 1;
          let countString = "(x".concat(this._myMessagesCount).concat(") ");
          let text = this._myOriginalText.slice(0);
          text = countString.concat(text);
          this.myLines = text.split("\n");
        }
      };
    }
  });

  // js/pp/tool/console_vr/console_vr.js
  var require_console_vr = __commonJS({
    "js/pp/tool/console_vr/console_vr.js"() {
      PP.ConsoleVR = {
        _myRealLog: console.log,
        _myRealError: console.error,
        _myRealWarn: console.warn,
        _myRealInfo: console.info,
        _myRealDebug: console.debug,
        _myRealAssert: console.assert,
        _myRealClear: console.clear,
        _myForwardToBrowserConsole: true,
        log: function(...args) {
          if (this._myForwardToBrowserConsole) {
            this._myRealLog.apply(console, args);
          }
        },
        error: function(...args) {
          if (this._myForwardToBrowserConsole) {
            this._myRealError.apply(console, args);
          }
        },
        warn: function(...args) {
          if (this._myForwardToBrowserConsole) {
            this._myRealWarn.apply(console, args);
          }
        },
        info: function(...args) {
          if (this._myForwardToBrowserConsole) {
            this._myRealInfo.apply(console, args);
          }
        },
        debug: function(...args) {
          if (this._myForwardToBrowserConsole) {
            this._myRealDebug.apply(console, args);
          }
        },
        assert: function(...args) {
          if (this._myForwardToBrowserConsole) {
            this._myRealAssert.apply(console, args);
          }
        },
        clear: function() {
          if (this._myForwardToBrowserConsole) {
            this._myRealClear.apply(console);
          }
        },
        setForwardToBrowserConsole: function(forwardToBrowserConsole) {
          this._myForwardToBrowserConsole = forwardToBrowserConsole;
        },
        isForwardToBrowserConsole: function() {
          return this._myForwardToBrowserConsole;
        }
      };
    }
  });

  // js/pp/tool/console_vr/console_vr_component.js
  var require_console_vr_component = __commonJS({
    "js/pp/tool/console_vr/console_vr_component.js"() {
      WL.registerComponent("pp-console-vr", {
        _myHandedness: { type: WL.Type.Enum, values: ["none", "left", "right"], default: "none" },
        _myOverrideBrowserConsole: { type: WL.Type.Bool, default: true },
        _myShowOnStart: { type: WL.Type.Bool, default: false },
        _myShowVisibilityButton: { type: WL.Type.Bool, default: false },
        _myPulseOnNewMessage: { type: WL.Type.Enum, values: ["never", "always", "when hidden"], default: "never" }
      }, {
        init: function() {
          this._myWidget = new PP.ConsoleVRWidget();
          this._myStarted = false;
        },
        start: function() {
          let additionalSetup = new PP.ConsoleVRWidget.AdditionalSetup();
          additionalSetup.myHandedness = [null, "left", "right"][this._myHandedness];
          additionalSetup.myOverrideBrowserConsole = this._myOverrideBrowserConsole;
          additionalSetup.myShowOnStart = this._myShowOnStart;
          additionalSetup.myShowVisibilityButton = this._myShowVisibilityButton;
          additionalSetup.myPulseOnNewMessage = this._myPulseOnNewMessage;
          additionalSetup.myPlaneMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
          additionalSetup.myTextMaterial = PP.myDefaultResources.myMaterials.myText.clone();
          this._myWidget.start(this.object, additionalSetup);
          this._myWidgetVisibleBackup = this._myWidget.isVisible();
          this._mySetVisibleNextUpdate = false;
          this._myStarted = true;
        },
        update: function(dt) {
          if (this._mySetVisibleNextUpdate) {
            this._mySetVisibleNextUpdate = false;
            this._myWidget.setVisible(false);
            this._myWidget.setVisible(this._myWidgetVisibleBackup);
          }
          this._myWidget.update(dt);
        },
        onActivate() {
          this._mySetVisibleNextUpdate = true;
        },
        onDeactivate() {
          if (this._myStarted) {
            this._myWidgetVisibleBackup = this._myWidget.isVisible();
            this._myWidget.setVisible(false);
          }
        }
      });
    }
  });

  // js/pp/tool/easy_tune/easy_object_tuners/easy_object_tuner.js
  var require_easy_object_tuner = __commonJS({
    "js/pp/tool/easy_tune/easy_object_tuners/easy_object_tuner.js"() {
      PP.EasyObjectTuner = class EasyObjectTuner {
        constructor(object, variableName, setAsDefault, useTuneTarget) {
          this._myObject = object;
          this._myUseTuneTarget = useTuneTarget;
          this._mySetAsDefault = setAsDefault;
          this._myEasyObject = this._myObject;
          if (this._myUseTuneTarget) {
            this._myEasyObject = PP.myEasyTuneTarget;
          }
          this._myPrevEasyObject = null;
          let variableNamePrefix = this._getVariableNamePrefix();
          if (variableName == "") {
            this._myEasyTuneVariableName = variableNamePrefix.concat(this._myObject.objectId);
          } else {
            this._myEasyTuneVariableName = variableNamePrefix.concat(variableName);
          }
        }
        start() {
          let easyTuneVariable = this._createEasyTuneVariable(this._myEasyTuneVariableName);
          PP.myEasyTuneVariables.add(easyTuneVariable);
          if (this._mySetAsDefault) {
            PP.setEasyTuneWidgetActiveVariable(this._myEasyTuneVariableName);
          }
        }
        update(dt) {
          if (PP.myEasyTuneVariables.isActive(this._myEasyTuneVariableName)) {
            if (this._myUseTuneTarget) {
              this._myEasyObject = PP.myEasyTuneTarget;
            }
            if (this._myPrevEasyObject != this._myEasyObject) {
              this._myPrevEasyObject = this._myEasyObject;
              if (this._myEasyObject) {
                let value = this._getObjectValue(this._myEasyObject);
                PP.myEasyTuneVariables.set(this._myEasyTuneVariableName, value, true);
              } else {
                let value = this._getDefaultValue();
                PP.myEasyTuneVariables.set(this._myEasyTuneVariableName, value, true);
              }
            }
            if (this._myEasyObject) {
              this._updateObjectValue(this._myEasyObject, PP.myEasyTuneVariables.get(this._myEasyTuneVariableName));
            }
          }
        }
        updateVariableValue(value) {
          PP.myEasyTuneVariables.set(this._myEasyTuneVariableName, value);
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_object_tuners/easy_light_attenuation.js
  var require_easy_light_attenuation = __commonJS({
    "js/pp/tool/easy_tune/easy_object_tuners/easy_light_attenuation.js"() {
      WL.registerComponent("pp-easy-light-attenuation", {
        _myVariableName: { type: WL.Type.String, default: "" },
        _mySetAsDefault: { type: WL.Type.Bool, default: false },
        _myUseTuneTarget: { type: WL.Type.Bool, default: false }
      }, {
        init: function() {
          this._myEasyObjectTuner = new PP.EasyLightAttenuation(this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
        },
        start: function() {
          this._myEasyObjectTuner.start();
        },
        update: function(dt) {
          this._myEasyObjectTuner.update(dt);
        }
      });
      PP.EasyLightAttenuation = class EasyLightAttenuation extends PP.EasyObjectTuner {
        constructor(object, variableName, setAsDefault, useTuneTarget) {
          super(object, variableName, setAsDefault, useTuneTarget);
        }
        _getVariableNamePrefix() {
          let nameFirstPart = "Light Attenuation ";
          return nameFirstPart;
        }
        _createEasyTuneVariable(variableName) {
          return new PP.EasyTuneNumber(variableName, this._getDefaultValue(), 0.01, 3, 0, 1);
        }
        _getObjectValue(object) {
          let attenuation = this._getLightAttenuation(object);
          return attenuation;
        }
        _getDefaultValue() {
          return 0;
        }
        _updateObjectValue(object, value) {
          let attenuation = value;
          let light = object.pp_getComponent("light");
          if (light) {
            light.color[3] = attenuation;
          }
        }
        _getLightAttenuation(object) {
          let attenuation = this._getDefaultValue();
          let light = object.pp_getComponent("light");
          if (light) {
            attenuation = light.color[3];
          }
          return attenuation;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_object_tuners/easy_light_color.js
  var require_easy_light_color = __commonJS({
    "js/pp/tool/easy_tune/easy_object_tuners/easy_light_color.js"() {
      WL.registerComponent("pp-easy-light-color", {
        _myVariableName: { type: WL.Type.String, default: "" },
        _mySetAsDefault: { type: WL.Type.Bool, default: false },
        _myUseTuneTarget: { type: WL.Type.Bool, default: false },
        _myColorModel: { type: WL.Type.Enum, values: ["rgb", "hsv"] }
      }, {
        init: function() {
          this._myEasyObjectTuner = new PP.EasyLightColor(this._myColorModel, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
        },
        start: function() {
          this._myEasyObjectTuner.start();
        },
        update: function(dt) {
          this._myEasyObjectTuner.update(dt);
        }
      });
      PP.EasyLightColor = class EasyLightColor extends PP.EasyObjectTuner {
        constructor(colorModel, object, variableName, setAsDefault, useTuneTarget) {
          super(object, variableName, setAsDefault, useTuneTarget);
          this._myColorModel = colorModel;
        }
        _getVariableNamePrefix() {
          let nameFirstPart = null;
          if (this._myColorModel == 0) {
            nameFirstPart = "Light RGB ";
          } else {
            nameFirstPart = "Light HSV ";
          }
          return nameFirstPart;
        }
        _createEasyTuneVariable(variableName) {
          return new PP.EasyTuneIntArray(variableName, this._getDefaultValue(), 100, 0, 255);
        }
        _getObjectValue(object) {
          let color = null;
          let lightColor = this._getLightColor(object);
          if (lightColor) {
            if (this._myColorModel == 0) {
              color = PP.ColorUtils.rgbCodeToHuman(lightColor);
            } else {
              color = PP.ColorUtils.hsvCodeToHuman(PP.ColorUtils.rgbToHsv(lightColor));
            }
          } else {
            color = this._getDefaultValue();
          }
          return color;
        }
        _getDefaultValue() {
          return PP.vec3_create();
        }
        _updateObjectValue(object, value) {
          let color = value;
          if (this._myColorModel == 0) {
            color = PP.ColorUtils.rgbHumanToCode(color);
          } else {
            color = PP.ColorUtils.hsvToRgb(PP.ColorUtils.hsvHumanToCode(color));
          }
          let light = object.pp_getComponent("light");
          if (light) {
            light.color[0] = color[0];
            light.color[1] = color[1];
            light.color[2] = color[2];
          }
          if (PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).isPressStart() && PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).myIsPressed || PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).isPressStart() && PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).myIsPressed) {
            let hsvColor = PP.ColorUtils.color1To255(PP.ColorUtils.rgbToHsv(color));
            let rgbColor = PP.ColorUtils.color1To255(color);
            console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
          }
        }
        _getLightColor(object) {
          let color = null;
          let light = object.pp_getComponent("light");
          if (light) {
            color = light.color.slice(0, 3);
          }
          return color;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_object_tuners/easy_mesh_color.js
  var require_easy_mesh_color = __commonJS({
    "js/pp/tool/easy_tune/easy_object_tuners/easy_mesh_color.js"() {
      WL.registerComponent("pp-easy-mesh-color", {
        _myVariableName: { type: WL.Type.String, default: "" },
        _myUseTuneTarget: { type: WL.Type.Bool, default: false },
        _mySetAsDefault: { type: WL.Type.Bool, default: false },
        _myColorModel: { type: WL.Type.Enum, values: ["rgb", "hsv"], default: "hsv" },
        _myColorType: { type: WL.Type.Enum, values: ["color", "diffuse color", "ambient color", "specular color", "emissive color", "fog color", "ambient factor"], default: "color" }
      }, {
        init: function() {
          this._myEasyObjectTuner = new PP.EasyMeshColor(this._myColorModel, this._myColorType, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
        },
        start: function() {
          this._myEasyObjectTuner.start();
        },
        update: function(dt) {
          this._myEasyObjectTuner.update(dt);
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type, {
            "_myVariableName": this._myVariableName,
            "_mySetAsDefault": this._mySetAsDefault,
            "_myUseTuneTarget": this._myUseTuneTarget,
            "_myColorModel": this._myColorModel,
            "_myColorType": this._myColorType
          });
          clonedComponent.active = this.active;
          return clonedComponent;
        }
      });
      PP.EasyMeshColor = class EasyMeshColor extends PP.EasyObjectTuner {
        constructor(colorModel, colorType, object, variableName, setAsDefault, useTuneTarget) {
          super(object, variableName, setAsDefault, useTuneTarget);
          this._myColorModel = colorModel;
          this._myColorType = colorType;
          this._myColorVariableNames = ["color", "diffuseColor", "ambientColor", "specularColor", "emissiveColor", "fogColor", "ambientFactor"];
        }
        _getVariableNamePrefix() {
          let nameFirstPart = null;
          if (this._myColorModel == 0) {
            nameFirstPart = "Mesh RGB ";
          } else {
            nameFirstPart = "Mesh HSV ";
          }
          return nameFirstPart;
        }
        _createEasyTuneVariable(variableName) {
          if (this._myColorType == 6) {
            return new PP.EasyTuneNumberArray(variableName, this._getDefaultValue(), 0.1, 3, 0, 1);
          }
          return new PP.EasyTuneIntArray(variableName, this._getDefaultValue(), 100, 0, 255);
        }
        _getObjectValue(object) {
          let color = null;
          let meshMaterial = this._getMeshMaterial(object);
          if (meshMaterial) {
            if (this._myColorType != 6) {
              color = meshMaterial[this._myColorVariableNames[this._myColorType]].pp_clone();
              if (this._myColorModel == 0) {
                color = PP.ColorUtils.rgbCodeToHuman(color);
              } else {
                color = PP.ColorUtils.hsvCodeToHuman(PP.ColorUtils.rgbToHsv(color));
              }
            } else {
              color = [meshMaterial[this._myColorVariableNames[this._myColorType]]];
            }
          } else {
            color = this._getDefaultValue();
          }
          return color;
        }
        _getDefaultValue() {
          if (this._myColorType == 6) {
            return [0];
          }
          return PP.vec4_create();
        }
        _updateObjectValue(object, value) {
          let color = value;
          if (this._myColorType != 6) {
            if (this._myColorModel == 0) {
              color = PP.ColorUtils.rgbHumanToCode(color);
            } else {
              color = PP.ColorUtils.hsvToRgb(PP.ColorUtils.hsvHumanToCode(color));
            }
          }
          let meshMaterial = this._getMeshMaterial(object);
          if (meshMaterial) {
            meshMaterial[this._myColorVariableNames[this._myColorType]] = color;
          }
          if (this._myColorType != 6) {
            if (PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).isPressStart() && PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).myIsPressed || PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).isPressStart() && PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).myIsPressed) {
              let hsvColor = PP.ColorUtils.color1To255(PP.ColorUtils.rgbToHsv(color));
              let rgbColor = PP.ColorUtils.color1To255(color);
              console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
            }
          }
        }
        _getMeshMaterial(object) {
          let material = null;
          let mesh = object.pp_getComponentHierarchy("mesh");
          if (mesh) {
            material = mesh.material;
          }
          return material;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_object_tuners/easy_mesh_ambient_factor.js
  var require_easy_mesh_ambient_factor = __commonJS({
    "js/pp/tool/easy_tune/easy_object_tuners/easy_mesh_ambient_factor.js"() {
      WL.registerComponent("pp-easy-mesh-ambient-factor", {
        _myVariableName: { type: WL.Type.String, default: "" },
        _myUseTuneTarget: { type: WL.Type.Bool, default: false },
        _mySetAsDefault: { type: WL.Type.Bool, default: false }
      }, {
        init: function() {
          this._myEasyObjectTuner = new PP.EasyMeshAmbientFactor(this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
        },
        start: function() {
          this._myEasyObjectTuner.start();
        },
        update: function(dt) {
          this._myEasyObjectTuner.update(dt);
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type, {
            "_myVariableName": this._myVariableName,
            "_mySetAsDefault": this._mySetAsDefault,
            "_myUseTuneTarget": this._myUseTuneTarget
          });
          clonedComponent.active = this.active;
          return clonedComponent;
        }
      });
      PP.EasyMeshAmbientFactor = class EasyMeshAmbientFactor extends PP.EasyObjectTuner {
        constructor(object, variableName, setAsDefault, useTuneTarget) {
          super(object, variableName, setAsDefault, useTuneTarget);
        }
        _getVariableNamePrefix() {
          let nameFirstPart = null;
          if (this._myColorModel == 0) {
            nameFirstPart = "Mesh AF ";
          } else {
            nameFirstPart = "Mesh AF ";
          }
          return nameFirstPart;
        }
        _createEasyTuneVariable(variableName) {
          return new PP.EasyTuneNumber(variableName, this._getDefaultValue(), 0.1, 3, 0, 1);
        }
        _getObjectValue(object) {
          let ambientFactor = null;
          let meshMaterial = this._getMeshMaterial(object);
          if (meshMaterial) {
            ambientFactor = meshMaterial.ambientFactor;
          } else {
            ambientFactor = this._getDefaultValue();
          }
          return ambientFactor;
        }
        _getDefaultValue() {
          return 0;
        }
        _updateObjectValue(object, value) {
          let ambientFactor = value;
          let meshMaterial = this._getMeshMaterial(object);
          if (meshMaterial) {
            meshMaterial.ambientFactor = ambientFactor;
          }
        }
        _getMeshMaterial(object) {
          let material = null;
          let mesh = object.pp_getComponentHierarchy("mesh");
          if (mesh) {
            material = mesh.material;
          }
          return material;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_object_tuners/easy_scale.js
  var require_easy_scale = __commonJS({
    "js/pp/tool/easy_tune/easy_object_tuners/easy_scale.js"() {
      WL.registerComponent("pp-easy-scale", {
        _myVariableName: { type: WL.Type.String, default: "" },
        _mySetAsDefault: { type: WL.Type.Bool, default: false },
        _myUseTuneTarget: { type: WL.Type.Bool, default: false },
        _myIsLocal: { type: WL.Type.Bool, default: false },
        _myScaleAsOne: { type: WL.Type.Bool, default: true }
        // Edit all scale values together
      }, {
        init: function() {
          this._myEasyObjectTuner = new PP.EasyScale(this._myIsLocal, this._myScaleAsOne, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
        },
        start: function() {
          this._myEasyObjectTuner.start();
        },
        update: function(dt) {
          this._myEasyObjectTuner.update(dt);
        }
      });
      PP.EasyScale = class EasyScale extends PP.EasyObjectTuner {
        constructor(isLocal, scaleAsOne, object, variableName, setAsDefault, useTuneTarget) {
          super(object, variableName, setAsDefault, useTuneTarget);
          this._myIsLocal = isLocal;
          this._myScaleAsOne = scaleAsOne;
        }
        _getVariableNamePrefix() {
          return "Scale ";
        }
        _createEasyTuneVariable(variableName) {
          return new PP.EasyTuneNumberArray(variableName, this._getDefaultValue(), 1, 3, 1e-3, null, this._myScaleAsOne);
        }
        _getObjectValue(object) {
          return this._myIsLocal ? object.pp_getScaleLocal() : object.pp_getScaleWorld();
        }
        _getDefaultValue() {
          return PP.vec3_create(1, 1, 1);
        }
        _updateObjectValue(object, value) {
          if (this._myIsLocal) {
            object.pp_setScaleLocal(value);
          } else {
            object.pp_setScaleWorld(value);
          }
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_object_tuners/easy_set_tune_target_child_number.js
  var require_easy_set_tune_target_child_number = __commonJS({
    "js/pp/tool/easy_tune/easy_object_tuners/easy_set_tune_target_child_number.js"() {
      WL.registerComponent("pp-easy-set-tune-target-child-number", {
        _myVariableName: { type: WL.Type.String, default: "" },
        _mySetAsDefault: { type: WL.Type.Bool, default: false }
      }, {
        init: function() {
        },
        start: function() {
          this._myEasyTuneVariableName = "Target Child ";
          if (this._myVariableName == "") {
            this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this.object.objectId);
          } else {
            this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this._myVariableName);
          }
          let childrenCount = this.object.pp_getChildren().length;
          let min4 = 1;
          let max4 = childrenCount;
          if (childrenCount == 0) {
            min4 = 0;
            max4 = 0;
          }
          PP.myEasyTuneVariables.add(new PP.EasyTuneInt(this._myEasyTuneVariableName, 0, 10, min4, max4));
          if (this._mySetAsDefault) {
            PP.setEasyTuneWidgetActiveVariable(this._myEasyTuneVariableName);
          }
          this._myCurrentChildIndex = -1;
          this._myCurrentChildrenCount = childrenCount;
        },
        update: function() {
          if (PP.myEasyTuneVariables.isActive(this._myEasyTuneVariableName)) {
            let childrenCount = this.object.pp_getChildren().length;
            if (childrenCount != this._myCurrentChildrenCount) {
              this._myCurrentChildrenCount = childrenCount;
              let min4 = 1;
              let max4 = childrenCount;
              if (childrenCount == 0) {
                min4 = 0;
                max4 = 0;
              }
              let easyTuneVariable = PP.myEasyTuneVariables.getEasyTuneVariable(this._myEasyTuneVariableName);
              easyTuneVariable.setMin(min4);
              easyTuneVariable.setMax(max4);
            }
            let childIndex = PP.myEasyTuneVariables.get(this._myEasyTuneVariableName);
            if (childIndex != this._myCurrentChildIndex) {
              if (childIndex == 0 && this._myCurrentChildIndex != -1) {
                PP.myEasyTuneTarget = null;
              } else if (childIndex > 0) {
                PP.myEasyTuneTarget = this.object.pp_getChildren()[childIndex - 1];
              }
              this._myCurrentChildIndex = childIndex;
            }
          }
        }
      });
    }
  });

  // js/pp/tool/easy_tune/easy_object_tuners/easy_set_tune_target_grab.js
  var require_easy_set_tune_target_grab = __commonJS({
    "js/pp/tool/easy_tune/easy_object_tuners/easy_set_tune_target_grab.js"() {
      WL.registerComponent("pp-easy-set-tune-target-grab", {}, {
        init: function() {
        },
        start: function() {
          this._myGrabber = this.object.pp_getComponent("pp-grabber-hand");
        },
        update: function() {
        },
        _onRelease: function(grabber, grabbable) {
          PP.myEasyTuneTarget = grabbable.object;
        },
        _onGrab: function(grabber, grabbable) {
        },
        onActivate() {
          this._myGrabber.registerGrabEventListener(this, this._onGrab.bind(this));
          this._myGrabber.registerThrowEventListener(this, this._onRelease.bind(this));
        },
        onDeactivate() {
          if (this._myGrabber != null) {
            this._myGrabber.unregisterGrabEventListener(this);
            this._myGrabber.unregisterThrowEventListener(this);
          }
        }
      });
    }
  });

  // js/pp/tool/easy_tune/easy_object_tuners/easy_transform.js
  var require_easy_transform = __commonJS({
    "js/pp/tool/easy_tune/easy_object_tuners/easy_transform.js"() {
      WL.registerComponent("pp-easy-transform", {
        _myVariableName: { type: WL.Type.String, default: "" },
        _mySetAsDefault: { type: WL.Type.Bool, default: false },
        _myUseTuneTarget: { type: WL.Type.Bool, default: false },
        _myIsLocal: { type: WL.Type.Bool, default: false },
        _myScaleAsOne: { type: WL.Type.Bool, default: true }
        // Edit all scale values together
      }, {
        init: function() {
          this._myEasyObjectTuner = new PP.EasyTransform(this._myIsLocal, this._myScaleAsOne, this.object, this._myVariableName, this._mySetAsDefault, this._myUseTuneTarget);
        },
        start: function() {
          this._myEasyObjectTuner.start();
        },
        update: function(dt) {
          this._myEasyObjectTuner.update(dt);
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type, {
            "_myVariableName": this._myVariableName,
            "_mySetAsDefault": this._mySetAsDefault,
            "_myUseTuneTarget": this._myUseTuneTarget,
            "_myIsLocal": this._myIsLocal
          });
          clonedComponent.active = this.active;
          return clonedComponent;
        }
      });
      PP.EasyTransform = class EasyTransform extends PP.EasyObjectTuner {
        constructor(isLocal, scaleAsOne, object, variableName, setAsDefault, useTuneTarget) {
          super(object, variableName, setAsDefault, useTuneTarget);
          this._myIsLocal = isLocal;
          this._myScaleAsOne = scaleAsOne;
        }
        _getVariableNamePrefix() {
          return "Transform ";
        }
        _createEasyTuneVariable(variableName) {
          return new PP.EasyTuneTransform(variableName, this._getDefaultValue(), this._myScaleAsOne);
        }
        _getObjectValue(object) {
          return this._myIsLocal ? object.pp_getTransformLocal() : object.pp_getTransformWorld();
        }
        _getDefaultValue() {
          return PP.mat4_create();
        }
        _updateObjectValue(object, value) {
          if (this._myIsLocal) {
            object.pp_setTransformLocal(value);
          } else {
            object.pp_setTransformWorld(value);
          }
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget.js
  var require_easy_tune_base_widget = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget.js"() {
      PP.EasyTuneBaseWidgetParams = class EasyTuneBaseWidgetParams {
        constructor() {
          this.myVariablesImportCallback = null;
          this.myVariablesExportCallback = null;
        }
      };
      PP.EasyTuneBaseWidget = class EasyTuneBaseWidget {
        constructor(params) {
          this._mySetup = null;
          this._myUI = null;
          this._myParams = params;
          this._myAdditionalSetup = null;
          this._myVariable = null;
          this._myIsVisible = true;
          this._myScrollVariableRequestCallbacks = /* @__PURE__ */ new Map();
          this._myAppendToVariableName = "";
          this._myScrollVariableActive = false;
          this._myScrollDirection = 0;
          this._myScrollVariableTimer = 0;
          this._myHasScrolled = false;
          this._myResetImportLabelTimer = new PP.Timer(0, false);
          this._myResetExportLabelTimer = new PP.Timer(0, false);
        }
        setVisible(visible) {
          if (visible) {
            this._refreshUI();
          }
          this._myUI.setVisible(visible);
          this._myIsVisible = visible;
        }
        setEasyTuneVariable(variable, appendToVariableName) {
          this._myVariable = variable;
          if (typeof appendToVariableName !== "undefined") {
            this._myAppendToVariableName = appendToVariableName;
          } else {
            this._myAppendToVariableName = "";
          }
          this._setEasyTuneVariableHook();
          this._refreshUI();
        }
        isScrollVariableActive() {
          return this._myScrollVariableActive;
        }
        getScrollVariableDirection() {
          return this._myScrollDirection;
        }
        setScrollVariableActive(active, scrollDirection) {
          this._myScrollVariableActive = active;
          this._myScrollDirection = scrollDirection;
          this._myScrollVariableTimer = this._mySetup.myScrollVariableDelay;
          this._myHasScrolled = false;
        }
        getWidget() {
          return this;
        }
        syncWidget(otherEasyTuneWidget) {
          if (otherEasyTuneWidget != null) {
            if (otherEasyTuneWidget._myResetImportLabelTimer.isRunning()) {
              this._myResetImportLabelTimer.start(otherEasyTuneWidget._myResetImportLabelTimer.getTimeLeft());
            } else {
              this._myResetImportLabelTimer.reset();
            }
            if (otherEasyTuneWidget._myResetExportLabelTimer.isRunning()) {
              this._myResetExportLabelTimer.start(otherEasyTuneWidget._myResetExportLabelTimer.getTimeLeft());
            } else {
              this._myResetExportLabelTimer.reset();
            }
            this._myUI.myImportButtonTextComponent.text = otherEasyTuneWidget._myUI.myImportButtonTextComponent.text;
            this._myUI.myExportButtonTextComponent.text = otherEasyTuneWidget._myUI.myExportButtonTextComponent.text;
            this.setScrollVariableActive(otherEasyTuneWidget.isScrollVariableActive(), otherEasyTuneWidget.getScrollVariableDirection());
          } else {
            this._myResetImportLabelTimer.reset();
            this._myUI.myImportButtonTextComponent.text = this._mySetup.myImportButtonText;
            this._myResetExportLabelTimer.reset();
            this._myUI.myExportButtonTextComponent.text = this._mySetup.myExportButtonText;
          }
        }
        onImportSuccess() {
          this._myUI.myImportButtonTextComponent.text = this._mySetup.myImportSuccessButtonText;
          this._myResetImportLabelTimer.start(this._mySetup.myImportExportResetLabelSeconds);
        }
        onImportFailure() {
          this._myUI.myImportButtonTextComponent.text = this._mySetup.myImportFailureButtonText;
          this._myResetImportLabelTimer.start(this._mySetup.myImportExportResetLabelSeconds);
        }
        onExportSuccess() {
          this._myUI.myExportButtonTextComponent.text = this._mySetup.myExportSuccessButtonText;
          this._myResetExportLabelTimer.start(this._mySetup.myImportExportResetLabelSeconds);
        }
        onExportFailure() {
          this._myUI.myExportButtonTextComponent.text = this._mySetup.myExportFailureButtonText;
          this._myResetExportLabelTimer.start(this._mySetup.myImportExportResetLabelSeconds);
        }
        registerScrollVariableRequestEventListener(id, callback) {
          this._myScrollVariableRequestCallbacks.set(id, callback);
        }
        unregisterScrollVariableRequestEventListener(id) {
          this._myScrollVariableRequestCallbacks.delete(id);
        }
        start(parentObject, additionalSetup) {
          this._myAdditionalSetup = additionalSetup;
          this._mySetup.build();
          this._myResetImportLabelTimer.setDuration(this._mySetup.myImportExportResetLabelSeconds);
          this._myResetExportLabelTimer.setDuration(this._mySetup.myImportExportResetLabelSeconds);
          this._myUI.build(parentObject, this._mySetup, additionalSetup);
          this._myUI.setImportExportButtonsActive(this._myAdditionalSetup.myEnableVariablesImportExportButtons);
          this._startHook(parentObject, additionalSetup);
          this._addListeners();
        }
        update(dt) {
          if (this._isActive()) {
            this._updateHook(dt);
            this._updateScrollVariable(dt);
            this._updateImportExportLabel(dt);
          }
        }
        // Hooks
        _setEasyTuneVariableHook() {
        }
        _refreshUIHook() {
        }
        _startHook(parentObject, additionalSetup) {
        }
        _addListenersHook() {
        }
        _updateHook(dt) {
        }
        // Hooks end
        _refreshUI() {
          if (this._myVariable) {
            if (this._myVariable.myName != null) {
              this._myUI.myVariableLabelTextComponent.text = this._myVariable.myName.concat(this._myAppendToVariableName);
            } else {
              let name = "Unknown";
              this._myUI.myVariableLabelTextComponent.text = name.concat(this._myAppendToVariableName);
            }
            this._refreshUIHook();
          }
        }
        _updateScrollVariable(dt) {
          if (this._myScrollVariableActive) {
            if (this._myScrollVariableTimer <= 0) {
              this._scrollVariableRequest(this._myScrollDirection);
              this._myScrollVariableTimer = this._mySetup.myScrollVariableDelay;
              this._myHasScrolled = true;
            } else {
              this._myScrollVariableTimer -= dt;
            }
          }
        }
        _updateImportExportLabel(dt) {
          if (this._myResetImportLabelTimer.isRunning(dt)) {
            this._myResetImportLabelTimer.update(dt);
            if (this._myResetImportLabelTimer.isDone()) {
              this._myResetImportLabelTimer.reset();
              this._myUI.myImportButtonTextComponent.text = this._mySetup.myImportButtonText;
            }
          }
          if (this._myResetExportLabelTimer.isRunning(dt)) {
            this._myResetExportLabelTimer.update(dt);
            if (this._myResetExportLabelTimer.isDone()) {
              this._myResetExportLabelTimer.reset();
              this._myUI.myExportButtonTextComponent.text = this._mySetup.myExportButtonText;
            }
          }
        }
        _isActive() {
          return this._myIsVisible && this._myVariable;
        }
        _addListeners() {
          let ui = this._myUI;
          ui.myNextButtonCursorTargetComponent.addDownFunction(this._setScrollVariableActive.bind(this, true, 1, false));
          ui.myNextButtonCursorTargetComponent.addDownOnHoverFunction(this._setScrollVariableActive.bind(this, true, 1, false));
          ui.myNextButtonCursorTargetComponent.addUpFunction(this._setScrollVariableActive.bind(this, false, 0, false));
          ui.myNextButtonCursorTargetComponent.addUpWithNoDownFunction(this._setScrollVariableActive.bind(this, false, 0, true));
          ui.myNextButtonCursorTargetComponent.addUnHoverFunction(this._setScrollVariableActive.bind(this, false, 0, true));
          ui.myNextButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myNextButtonBackgroundComponent.material));
          ui.myNextButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myNextButtonBackgroundComponent.material));
          ui.myPreviousButtonCursorTargetComponent.addDownFunction(this._setScrollVariableActive.bind(this, true, -1, false));
          ui.myPreviousButtonCursorTargetComponent.addDownOnHoverFunction(this._setScrollVariableActive.bind(this, true, -1, false));
          ui.myPreviousButtonCursorTargetComponent.addUpFunction(this._setScrollVariableActive.bind(this, false, 0, false));
          ui.myPreviousButtonCursorTargetComponent.addUpWithNoDownFunction(this._setScrollVariableActive.bind(this, false, 0, true));
          ui.myPreviousButtonCursorTargetComponent.addUnHoverFunction(this._setScrollVariableActive.bind(this, false, 0, true));
          ui.myPreviousButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
          ui.myPreviousButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
          ui.myImportButtonCursorTargetComponent.addUpFunction(this._importVariables.bind(this));
          ui.myImportButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myImportButtonBackgroundComponent.material));
          ui.myImportButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myImportButtonBackgroundComponent.material));
          ui.myExportButtonCursorTargetComponent.addUpFunction(this._exportVariables.bind(this));
          ui.myExportButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myExportButtonBackgroundComponent.material));
          ui.myExportButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myExportButtonBackgroundComponent.material));
          this._addListenersHook();
        }
        _setScrollVariableActive(active, scrollDirection, skipForceScroll) {
          if (this._isActive() || !active) {
            let forceScroll = !active && !this._myHasScrolled && !skipForceScroll;
            let oldScrollDirection = this._myScrollDirection;
            this.setScrollVariableActive(active, scrollDirection);
            if (forceScroll) {
              this._scrollVariableRequest(oldScrollDirection);
            }
          }
        }
        _scrollVariableRequest(amount) {
          if (this._isActive() && amount != 0) {
            for (let callback of this._myScrollVariableRequestCallbacks.values()) {
              callback(amount);
            }
          }
        }
        _genericHover(material) {
          material.color = this._mySetup.myButtonHoverColor;
        }
        _genericUnHover(material) {
          material.color = this._mySetup.myBackgroundColor;
        }
        _importVariables() {
          if (this._myUI.myImportButtonTextComponent.text == this._mySetup.myImportButtonText) {
            this._myUI.myImportButtonTextComponent.text = this._mySetup.myImportingButtonText;
            this._myResetImportLabelTimer.reset();
            this._myParams.myVariablesImportCallback();
          }
        }
        _exportVariables() {
          if (this._myUI.myExportButtonTextComponent.text == this._mySetup.myExportButtonText) {
            this._myUI.myExportButtonTextComponent.text = this._mySetup.myExportingButtonText;
            this._myResetExportLabelTimer.reset();
            this._myParams.myVariablesExportCallback();
          }
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_ui.js
  var require_easy_tune_base_widget_ui = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_ui.js"() {
      PP.EasyTuneBaseWidgetUI = class EasyTuneBaseWidgetUI {
        build(parentObject, setup, additionalSetup) {
          this._myParentObject = parentObject;
          this._mySetup = setup;
          this._myAdditionalSetup = additionalSetup;
          this._myImportExportButtonsActive = true;
          this._myPlaneMesh = PP.myDefaultResources.myMeshes.myPlane;
          this._buildHook();
          this._createSkeleton();
          this._setTransforms();
          this._addComponents();
          this._setTransformForNonVR();
          if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        }
        setVisible(visible) {
          this.myPivotObject.pp_setActiveHierarchy(visible);
          if (visible) {
            this.setImportExportButtonsActive(this._myImportExportButtonsActive);
          }
          this._setVisibleHook(visible);
        }
        setImportExportButtonsActive(active) {
          this._myImportExportButtonsActive = active;
          this.myImportExportPanel.pp_setActiveHierarchy(this._myImportExportButtonsActive);
        }
        // Hooks
        _buildHook() {
        }
        _setVisibleHook(visible) {
        }
        _createSkeletonHook() {
        }
        _setTransformHook() {
        }
        _addComponentsHook() {
        }
        // Hooks end
        // Skeleton
        _createSkeleton() {
          this.myPivotObject = WL.scene.addObject(this._myParentObject);
          this.myBackPanel = WL.scene.addObject(this.myPivotObject);
          this.myBackBackground = WL.scene.addObject(this.myBackPanel);
          this.myDisplayPanel = WL.scene.addObject(this.myPivotObject);
          this.myVariableLabelPanel = WL.scene.addObject(this.myDisplayPanel);
          this.myVariableLabelText = WL.scene.addObject(this.myVariableLabelPanel);
          this.myVariableLabelCursorTarget = WL.scene.addObject(this.myVariableLabelPanel);
          this.myNextButtonPanel = WL.scene.addObject(this.myVariableLabelPanel);
          this.myNextButtonBackground = WL.scene.addObject(this.myNextButtonPanel);
          this.myNextButtonText = WL.scene.addObject(this.myNextButtonPanel);
          this.myNextButtonCursorTarget = WL.scene.addObject(this.myNextButtonPanel);
          this.myPreviousButtonPanel = WL.scene.addObject(this.myVariableLabelPanel);
          this.myPreviousButtonBackground = WL.scene.addObject(this.myPreviousButtonPanel);
          this.myPreviousButtonText = WL.scene.addObject(this.myPreviousButtonPanel);
          this.myPreviousButtonCursorTarget = WL.scene.addObject(this.myPreviousButtonPanel);
          this.myImportExportPanel = WL.scene.addObject(this.myPivotObject);
          this.myImportButtonPanel = WL.scene.addObject(this.myImportExportPanel);
          this.myImportButtonBackground = WL.scene.addObject(this.myImportButtonPanel);
          this.myImportButtonText = WL.scene.addObject(this.myImportButtonPanel);
          this.myImportButtonCursorTarget = WL.scene.addObject(this.myImportButtonPanel);
          this.myExportButtonPanel = WL.scene.addObject(this.myImportExportPanel);
          this.myExportButtonBackground = WL.scene.addObject(this.myExportButtonPanel);
          this.myExportButtonText = WL.scene.addObject(this.myExportButtonPanel);
          this.myExportButtonCursorTarget = WL.scene.addObject(this.myExportButtonPanel);
          this.myPointerCursorTarget = WL.scene.addObject(this.myPivotObject);
          this._createSkeletonHook();
        }
        // Transforms
        _setTransforms() {
          this.myPivotObject.setTranslationLocal(this._mySetup.myPivotObjectPositions[this._myAdditionalSetup.myHandedness]);
          this.myBackPanel.setTranslationLocal(this._mySetup.myBackPanelPosition);
          this.myBackBackground.scale(this._mySetup.myBackBackgroundScale);
          this.myDisplayPanel.setTranslationLocal(this._mySetup.myDisplayPanelPosition);
          this.myVariableLabelPanel.setTranslationLocal(this._mySetup.myVariableLabelPanelPosition);
          this.myVariableLabelText.scale(this._mySetup.myVariableLabelTextScale);
          this.myVariableLabelCursorTarget.setTranslationLocal(this._mySetup.myVariableLabelCursorTargetPosition);
          this.myNextButtonPanel.setTranslationLocal(this._mySetup.myRightSideButtonPosition);
          this.myNextButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
          this.myNextButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
          this.myNextButtonText.scale(this._mySetup.mySideButtonTextScale);
          this.myNextButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          this.myPreviousButtonPanel.setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
          this.myPreviousButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
          this.myPreviousButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
          this.myPreviousButtonText.scale(this._mySetup.mySideButtonTextScale);
          this.myPreviousButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          this.myImportExportPanel.setTranslationLocal(this._mySetup.myImportExportPanelPosition);
          this.myImportButtonPanel.setTranslationLocal(this._mySetup.myImportButtonPosition);
          this.myImportButtonBackground.scale(this._mySetup.myImportExportButtonBackgroundScale);
          this.myImportButtonText.setTranslationLocal(this._mySetup.myImportExportButtonTextPosition);
          this.myImportButtonText.scale(this._mySetup.myImportExportButtonTextScale);
          this.myImportButtonCursorTarget.setTranslationLocal(this._mySetup.myImportExportButtonCursorTargetPosition);
          this.myExportButtonPanel.setTranslationLocal(this._mySetup.myExportButtonPosition);
          this.myExportButtonBackground.scale(this._mySetup.myImportExportButtonBackgroundScale);
          this.myExportButtonText.setTranslationLocal(this._mySetup.myImportExportButtonTextPosition);
          this.myExportButtonText.scale(this._mySetup.myImportExportButtonTextScale);
          this.myExportButtonCursorTarget.setTranslationLocal(this._mySetup.myImportExportButtonCursorTargetPosition);
          this.myPointerCursorTarget.setTranslationLocal(this._mySetup.myPointerCursorTargetPosition);
          this._setTransformHook();
        }
        // Components
        _addComponents() {
          this.myBackBackgroundComponent = this.myBackBackground.addComponent("mesh");
          this.myBackBackgroundComponent.mesh = this._myPlaneMesh;
          this.myBackBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myBackBackgroundComponent.material.color = this._mySetup.myBackBackgroundColor;
          this.myVariableLabelTextComponent = this.myVariableLabelText.addComponent("text");
          this._setupTextComponent(this.myVariableLabelTextComponent);
          this.myVariableLabelTextComponent.text = " ";
          this.myVariableLabelCursorTargetComponent = this.myVariableLabelCursorTarget.addComponent("cursor-target");
          this.myVariableLabelCollisionComponent = this.myVariableLabelCursorTarget.addComponent("collision");
          this.myVariableLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myVariableLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myVariableLabelCollisionComponent.extents = this._mySetup.myVariableLabelCollisionExtents;
          this.myNextButtonBackgroundComponent = this.myNextButtonBackground.addComponent("mesh");
          this.myNextButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myNextButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myNextButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myNextButtonTextComponent = this.myNextButtonText.addComponent("text");
          this._setupTextComponent(this.myNextButtonTextComponent);
          this.myNextButtonTextComponent.text = this._mySetup.myNextButtonText;
          this.myNextButtonCursorTargetComponent = this.myNextButtonCursorTarget.addComponent("cursor-target");
          this.myNextButtonCollisionComponent = this.myNextButtonCursorTarget.addComponent("collision");
          this.myNextButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myNextButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myNextButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myPreviousButtonBackgroundComponent = this.myPreviousButtonBackground.addComponent("mesh");
          this.myPreviousButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myPreviousButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myPreviousButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myPreviousButtonTextComponent = this.myPreviousButtonText.addComponent("text");
          this._setupTextComponent(this.myPreviousButtonTextComponent);
          this.myPreviousButtonTextComponent.text = this._mySetup.myPreviousButtonText;
          this.myPreviousButtonCursorTargetComponent = this.myPreviousButtonCursorTarget.addComponent("cursor-target");
          this.myPreviousButtonCollisionComponent = this.myPreviousButtonCursorTarget.addComponent("collision");
          this.myPreviousButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myPreviousButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myPreviousButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myImportButtonBackgroundComponent = this.myImportButtonBackground.addComponent("mesh");
          this.myImportButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myImportButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myImportButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myImportButtonTextComponent = this.myImportButtonText.addComponent("text");
          this._setupTextComponent(this.myImportButtonTextComponent);
          this.myImportButtonTextComponent.text = this._mySetup.myImportButtonText;
          this.myImportButtonCursorTargetComponent = this.myImportButtonCursorTarget.addComponent("cursor-target");
          this.myImportButtonCollisionComponent = this.myImportButtonCursorTarget.addComponent("collision");
          this.myImportButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myImportButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myImportButtonCollisionComponent.extents = this._mySetup.myImportExportButtonCollisionExtents;
          this.myExportButtonBackgroundComponent = this.myExportButtonBackground.addComponent("mesh");
          this.myExportButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myExportButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myExportButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myExportButtonTextComponent = this.myExportButtonText.addComponent("text");
          this._setupTextComponent(this.myExportButtonTextComponent);
          this.myExportButtonTextComponent.text = this._mySetup.myExportButtonText;
          this.myExportButtonCursorTargetComponent = this.myExportButtonCursorTarget.addComponent("cursor-target");
          this.myExportButtonCollisionComponent = this.myExportButtonCursorTarget.addComponent("collision");
          this.myExportButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myExportButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myExportButtonCollisionComponent.extents = this._mySetup.myImportExportButtonCollisionExtents;
          this.myPointerCollisionComponent = this.myPointerCursorTarget.addComponent("collision");
          this.myPointerCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myPointerCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myPointerCollisionComponent.extents = this._mySetup.myPointerCollisionExtents;
          this._addComponentsHook();
        }
        _setupTextComponent(textComponent) {
          textComponent.alignment = this._mySetup.myTextAlignment;
          textComponent.justification = this._mySetup.myTextJustification;
          textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
          textComponent.material.color = this._mySetup.myTextColor;
          textComponent.text = "";
        }
        _onXRSessionStart() {
          this._setTransformForVR();
        }
        _onXRSessionEnd() {
          this._setTransformForNonVR();
        }
        _setTransformForVR() {
          this.myPivotObject.setTranslationLocal(this._mySetup.myPivotObjectPositions[this._myAdditionalSetup.myHandedness]);
        }
        _setTransformForNonVR() {
          this.myPivotObject.setTranslationLocal(this._mySetup.myPivotObjectPositions[PP.ToolHandedness.NONE]);
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_setup.js
  var require_easy_tune_base_widget_setup = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_setup.js"() {
      PP.EasyTuneBaseWidgetSetup = class EasyTuneBaseWidgetSetup {
        constructor() {
        }
        build() {
          this._initializeBuildSetup();
          this._initializeRuntimeSetup();
        }
        // Hooks
        _getBackPanelMaxY() {
          return this.myDisplayPanelPosition[1] + this.myVariableLabelPanelPosition[1] + this.mySideButtonBackgroundScale[1] + this._mySideButtonDistanceFromBorder * 1.25;
        }
        _getBackPanelMinY() {
          return this.myDisplayPanelPosition[1] - this._mySideButtonDistanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
        }
        _getBackPanelMaxX() {
          return this._mySideButtonPanelHalfWidth;
        }
        _getBackPanelMinX() {
          return -this._mySideButtonPanelHalfWidth;
        }
        // small Z offset to avoid glitching with other widgets
        _getPivotZOffset() {
          return 0;
        }
        _initializeBuildSetupHook() {
        }
        _initializeRuntimeSetupHook() {
        }
        // Hooks end
        _initializeBuildSetup() {
          this.myBackgroundColor = [46 / 255, 46 / 255, 46 / 255, 1];
          this.myCursorTargetCollisionCollider = WL.Collider.Box;
          this.myCursorTargetCollisionGroup = 7;
          this.myCursorTargetCollisionThickness = 1e-3;
          this.myDefaultTextColor = [255 / 255, 255 / 255, 255 / 255, 1];
          this.myTextAlignment = WL.Alignment.Center;
          this.myTextJustification = WL.Justification.Middle;
          this.myTextColor = this.myDefaultTextColor;
          this.myLabelTextScale = PP.vec3_create(0.19, 0.19, 0.19);
          this.myButtonTextScale = PP.vec3_create(0.18, 0.18, 0.18);
          this._myPanelZOffset = 0.01;
          this._myColliderZOffset = 0.017;
          this._mySideButtonDistanceFromBorder = 0.0125;
          this._mySideButtonPanelHalfWidth = 0.2;
          this.myPivotObjectPositions = [];
          this.myPivotObjectPositions[PP.ToolHandedness.NONE] = PP.vec3_create(0, 0, this._getPivotZOffset());
          this.myPivotObjectPositions[PP.ToolHandedness.LEFT] = PP.vec3_create(-0.04, 0.02, this._getPivotZOffset());
          this.myPivotObjectPositions[PP.ToolHandedness.RIGHT] = PP.vec3_create(-0.08, 0.02, this._getPivotZOffset());
          this.mySideButtonBackgroundScale = PP.vec3_create(0.015, 0.015, 1);
          this.mySideButtonTextScale = this.myButtonTextScale;
          this.mySideButtonTextPosition = PP.vec3_create(0, 0, 7e-3);
          this.mySideButtonCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.mySideButtonCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
          this.mySideButtonCollisionExtents = this.mySideButtonBackgroundScale.slice(0);
          this.mySideButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
          this.myLeftSideButtonPosition = PP.vec3_create(0, 0, -1e-5);
          this.myLeftSideButtonPosition[0] = -this._mySideButtonPanelHalfWidth + this.mySideButtonBackgroundScale[0] + this._mySideButtonDistanceFromBorder;
          this.myRightSideButtonPosition = PP.vec3_create(0, 0, -1e-5);
          this.myRightSideButtonPosition[0] = -this.myLeftSideButtonPosition[0];
          this.myDisplayPanelPosition = PP.vec3_create(0, 0.1, 0);
          this.myVariableLabelPanelPosition = PP.vec3_create(0, 0.025, this._myPanelZOffset);
          this.myVariableLabelTextScale = this.myLabelTextScale;
          this.myVariableLabelCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myVariableLabelCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
          this.myVariableLabelCollisionExtents = PP.vec3_create(0.065, 0.0175, 1);
          this.myVariableLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;
          this.myNextButtonText = ">";
          this.myPreviousButtonText = "<";
          this._initializeBuildSetupHook();
          {
            let maxX = this._getBackPanelMaxX();
            let minX = this._getBackPanelMinX();
            let maxY = this._getBackPanelMaxY();
            let minY = this._getBackPanelMinY();
            this.myBackPanelPosition = [(maxX + minX) / 2, (maxY + minY) / 2, 0];
            this.myBackBackgroundScale = [(maxX - minX) / 2, (maxY - minY) / 2, 1];
            this.myBackBackgroundColor = [70 / 255, 70 / 255, 70 / 255, 1];
          }
          this.myImportExportButtonBackgroundScale = PP.vec3_create(0.04, 0.02, 1);
          this.myImportExportButtonTextScale = this.myButtonTextScale;
          this.myImportExportButtonTextPosition = PP.vec3_create(0, 0, 7e-3);
          this.myImportExportPanelPosition = [0, this._getBackPanelMaxY() + this._mySideButtonDistanceFromBorder + this.myImportExportButtonBackgroundScale[1], this._myPanelZOffset];
          this.myImportExportButtonCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myImportExportButtonCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
          this.myImportExportButtonCollisionExtents = this.myImportExportButtonBackgroundScale.slice(0);
          this.myImportExportButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
          this.myImportButtonText = "Import";
          this.myExportButtonText = "Export";
          this.myImportExportResetLabelSeconds = 2;
          this.myImportingButtonText = "...";
          this.myImportSuccessButtonText = "Done";
          this.myImportFailureButtonText = "Error";
          this.myExportingButtonText = "...";
          this.myExportSuccessButtonText = "Done";
          this.myExportFailureButtonText = "Error";
          this.myImportButtonPosition = PP.vec3_create(0, 0, -1e-5);
          this.myImportButtonPosition[0] = -this.myImportExportButtonBackgroundScale[0] - this._mySideButtonDistanceFromBorder / 2;
          this.myExportButtonPosition = PP.vec3_create(0, 0, -1e-5);
          this.myExportButtonPosition[0] = -this.myImportButtonPosition[0];
          this.myPointerCollisionExtents = this.myBackBackgroundScale.slice(0);
          this.myPointerCollisionExtents[2] = this.myCursorTargetCollisionThickness;
          this.myPointerCursorTargetPosition = this.myBackPanelPosition.slice(0);
          this.myPointerCursorTargetPosition[2] = this._myColliderZOffset - 1e-4;
        }
        _initializeRuntimeSetup() {
          this.myButtonHoverColor = [150 / 255, 150 / 255, 150 / 255, 1];
          this.myScrollVariableDelay = 0.5;
          this._initializeRuntimeSetupHook();
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget.js
  var require_easy_tune_bool_array_widget = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget.js"() {
      PP.EasyTuneBoolArrayWidget = class EasyTuneBoolArrayWidget extends PP.EasyTuneBaseWidget {
        constructor(params, arraySize, gamepad) {
          super(params);
          this._mySetup = new PP.EasyTuneBoolArrayWidgetSetup(arraySize);
          this._myUI = new PP.EasyTuneBoolArrayWidgetUI();
          this._myGamepad = gamepad;
          this._myValueEditIndex = 0;
          this._myValueButtonEditIntensity = 0;
          this._myValueButtonEditIntensityTimer = 0;
          this._myValueEditActive = false;
        }
        _refreshUIHook() {
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this._myUI.myValueTextComponents[i].text = this._myVariable.myValue[i] ? "true" : "false";
          }
        }
        _startHook(parentObject, additionalSetup) {
          this._myUI.setAdditionalButtonsActive(additionalSetup.myEnableAdditionalButtons);
        }
        _updateHook(dt) {
          this._updateValue(dt);
        }
        _updateValue(dt) {
          let stickVariableIntensity = 0;
          if (this._myGamepad) {
            stickVariableIntensity = this._myGamepad.getAxesInfo().myAxes[1];
          }
          let valueIntensity = 0;
          if (this._myValueEditActive) {
            valueIntensity = stickVariableIntensity;
          } else if (this._myValueButtonEditIntensity != 0) {
            if (this._myValueButtonEditIntensityTimer <= 0) {
              valueIntensity = this._myValueButtonEditIntensity;
            } else {
              this._myValueButtonEditIntensityTimer -= dt;
            }
          }
          if (Math.abs(valueIntensity) > this._mySetup.myThumbstickToggleThreshold) {
            this._myVariable.myValue[this._myValueEditIndex] = valueIntensity > 0;
            this._refreshUI();
          }
        }
        _addListenersHook() {
          let ui = this._myUI;
          ui.myVariableLabelCursorTargetComponent.addClickFunction(this._resetAllValues.bind(this));
          ui.myVariableLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myVariableLabelText));
          ui.myVariableLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myVariableLabelText, this._mySetup.myVariableLabelTextScale));
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            ui.myValueIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, 1));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, i, 1));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, -1));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, i, -1));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
            ui.myValueCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, i));
            ui.myValueCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], true));
            ui.myValueCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], false));
          }
        }
        _setValueEditIntensity(index, value) {
          if (this._isActive() || value == 0) {
            if (value != 0) {
              this._myValueButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
              this._myValueEditIndex = index;
            }
            this._myValueButtonEditIntensity = value;
          }
        }
        _setValueEditActive(index, text, active) {
          if (this._isActive() || !active) {
            if (active) {
              this._myValueEditIndex = index;
              text.scale(this._mySetup.myTextHoverScaleMultiplier);
            } else {
              text.scalingWorld = this._mySetup.myValueTextScale;
            }
            this._myValueEditActive = active;
          }
        }
        _resetValue(index) {
          if (this._isActive()) {
            this._myVariable.myValue[index] = this._myVariable.myDefaultValue[index];
            this._myUI.myValueTextComponents[index].text = this._myVariable.myValue[index] ? "true" : "false";
          }
        }
        _resetAllValues() {
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this._resetValue(i);
          }
        }
        _genericTextHover(text) {
          text.scale(this._mySetup.myTextHoverScaleMultiplier);
        }
        _genericTextUnHover(text, originalScale) {
          text.scalingWorld = originalScale;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_ui.js
  var require_easy_tune_bool_array_widget_ui = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_ui.js"() {
      PP.EasyTuneBoolArrayWidgetUI = class EasyTuneBoolArrayWidgetUI extends PP.EasyTuneBaseWidgetUI {
        setAdditionalButtonsActive(active) {
          this._myAdditionalButtonsActive = active;
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValueIncreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
            this.myValueDecreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
          }
        }
        _buildHook() {
          this._myAdditionalButtonsActive = true;
        }
        _createSkeletonHook() {
          this.myValuesPanel = WL.scene.addObject(this.myDisplayPanel);
          this.myValuePanels = [];
          this.myValueTexts = [];
          this.myValueCursorTargets = [];
          this.myValueIncreaseButtonPanels = [];
          this.myValueIncreaseButtonBackgrounds = [];
          this.myValueIncreaseButtonTexts = [];
          this.myValueIncreaseButtonCursorTargets = [];
          this.myValueDecreaseButtonPanels = [];
          this.myValueDecreaseButtonBackgrounds = [];
          this.myValueDecreaseButtonTexts = [];
          this.myValueDecreaseButtonCursorTargets = [];
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValuePanels[i] = WL.scene.addObject(this.myValuesPanel);
            this.myValueTexts[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueCursorTargets[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueIncreaseButtonPanels[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueIncreaseButtonBackgrounds[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);
            this.myValueIncreaseButtonTexts[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);
            this.myValueIncreaseButtonCursorTargets[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);
            this.myValueDecreaseButtonPanels[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueDecreaseButtonBackgrounds[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
            this.myValueDecreaseButtonTexts[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
            this.myValueDecreaseButtonCursorTargets[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
          }
        }
        _setTransformHook() {
          this.myValuesPanel.setTranslationLocal(this._mySetup.myValuesPanelPosition);
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValuePanels[i].setTranslationLocal(this._mySetup.myValuePanelsPositions[i]);
            this.myValueTexts[i].scale(this._mySetup.myValueTextScale);
            this.myValueCursorTargets[i].setTranslationLocal(this._mySetup.myValueCursorTargetPosition);
            this.myValueIncreaseButtonPanels[i].setTranslationLocal(this._mySetup.myRightSideButtonPosition);
            this.myValueIncreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myValueIncreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myValueIncreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myValueIncreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
            this.myValueDecreaseButtonPanels[i].setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
            this.myValueDecreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myValueDecreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myValueDecreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myValueDecreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          }
        }
        _addComponentsHook() {
          this.myValueTextComponents = [];
          this.myValueCursorTargetComponents = [];
          this.myValueCollisionComponents = [];
          this.myValueIncreaseButtonBackgroundComponents = [];
          this.myValueIncreaseButtonTextComponents = [];
          this.myValueIncreaseButtonCursorTargetComponents = [];
          this.myValueIncreaseButtonCollisionComponents = [];
          this.myValueDecreaseButtonBackgroundComponents = [];
          this.myValueDecreaseButtonTextComponents = [];
          this.myValueDecreaseButtonCursorTargetComponents = [];
          this.myValueDecreaseButtonCollisionComponents = [];
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValueTextComponents[i] = this.myValueTexts[i].addComponent("text");
            this._setupTextComponent(this.myValueTextComponents[i]);
            this.myValueTextComponents[i].text = " ";
            this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].addComponent("cursor-target");
            this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].addComponent("collision");
            this.myValueCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;
            this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].addComponent("mesh");
            this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myValueIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
            this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].addComponent("text");
            this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
            this.myValueIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;
            this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].addComponent("cursor-target");
            this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].addComponent("collision");
            this.myValueIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
            this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].addComponent("mesh");
            this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myValueDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
            this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].addComponent("text");
            this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
            this.myValueDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;
            this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].addComponent("cursor-target");
            this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].addComponent("collision");
            this.myValueDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
          }
        }
        _setVisibleHook(visible) {
          if (visible) {
            this.setAdditionalButtonsActive(this._myAdditionalButtonsActive);
          }
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_setup.js
  var require_easy_tune_bool_array_widget_setup = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_setup.js"() {
      PP.EasyTuneBoolArrayWidgetSetup = class EasyTuneBoolArrayWidgetSetup extends PP.EasyTuneBaseWidgetSetup {
        constructor(arraySize) {
          super();
          this.myArraySize = arraySize;
        }
        _getBackPanelMinY() {
          let valuePanelLastPosition = this.myValuePanelsPositions[this.myArraySize - 1] ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
          return super._getBackPanelMinY() + this.myValuesPanelPosition[1] + valuePanelLastPosition;
        }
        _getPivotZOffset() {
          return 802713e-8;
        }
        _initializeBuildSetupHook() {
          this.myIncreaseButtonText = "+";
          this.myDecreaseButtonText = "-";
          this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
          this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
          this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
          this.myValueTextScale = PP.vec3_create(0.4, 0.4, 0.4);
          this.myValueCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
          this.myValueCollisionExtents = PP.vec3_create(0.065, 0.02, 1);
          this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
          this.myValuePanelsPositions = [];
          this.myValuePanelsPositions[0] = PP.vec3_create(0, 0, 0);
          for (let i = 1; i < this.myArraySize; i++) {
            this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].slice(0);
            this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
          }
        }
        _initializeRuntimeSetupHook() {
          this.myTextHoverScaleMultiplier = PP.vec3_create(1.25, 1.25, 1.25);
          this.myThumbstickToggleThreshold = 0.6;
          this.myButtonEditDelay = 0;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_selector.js
  var require_easy_tune_bool_array_widget_selector = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_selector.js"() {
      PP.EasyTuneBoolArrayWidgetSelector = class EasyTuneBoolArrayWidgetSelector {
        constructor(params, gamepad) {
          this._myGamepad = gamepad;
          this._myParentObject = null;
          this._myParams = params;
          this._myAdditionalSetup = null;
          this._myWidgets = /* @__PURE__ */ new Map();
          this._myVariable = null;
          this._myIsVisible = true;
          this._myAppendToVariableName = null;
          this._myScrollVariableRequestCallbacks = /* @__PURE__ */ new Map();
          this._myCurrentArraySize = 0;
        }
        setEasyTuneVariable(variable, appendToVariableName) {
          this._myVariable = variable;
          this._myCurrentArraySize = this._myVariable.myValue.length;
          this._myAppendToVariableName = appendToVariableName;
          if (!this._myWidgets.has(this._myCurrentArraySize)) {
            this._createWidget(this._myCurrentArraySize);
          }
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.setEasyTuneVariable(variable, appendToVariableName);
          }
          this.setVisible(this._myIsVisible);
        }
        setVisible(visible) {
          for (let widget of this._myWidgets.values()) {
            widget.setVisible(false);
          }
          if (this._myVariable) {
            this._sizeChangedCheck();
            let widget = this._myWidgets.get(this._myCurrentArraySize);
            if (widget) {
              widget.setVisible(visible);
            }
          }
          this._myIsVisible = visible;
        }
        isScrollVariableActive() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            return widget.isScrollVariableActive();
          }
          return false;
        }
        getScrollVariableDirection() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            return widget.getScrollVariableDirection();
          }
          return 0;
        }
        setScrollVariableActive(active, scrollDirection) {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.setScrollVariableActive(active, scrollDirection);
          }
        }
        getWidget() {
          return this._myWidgets.get(this._myCurrentArraySize);
        }
        registerScrollVariableRequestEventListener(id, callback) {
          this._myScrollVariableRequestCallbacks.set(id, callback);
        }
        unregisterScrollVariableRequestEventListener(id) {
          this._myScrollVariableRequestCallbacks.delete(id);
        }
        start(parentObject, additionalSetup) {
          this._myParentObject = parentObject;
          this._myAdditionalSetup = additionalSetup;
          this._createWidget(1);
          if (this._myVariable) {
            this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
          }
        }
        update(dt) {
          if (this._isActive()) {
            this._sizeChangedCheck();
            let widget = this._myWidgets.get(this._myCurrentArraySize);
            if (widget) {
              widget.update(dt);
            }
          }
        }
        onImportSuccess() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.onImportSuccess();
          }
        }
        onImportFailure() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.onImportFailure();
          }
        }
        onExportSuccess() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.onExportSuccess();
          }
        }
        onExportFailure() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.onExportFailure();
          }
        }
        _isActive() {
          return this._myIsVisible && this._myVariable;
        }
        _scrollVariableRequest(amount) {
          for (let callback of this._myScrollVariableRequestCallbacks.values()) {
            callback(amount);
          }
        }
        _createWidget(arraySize) {
          this._myWidgets.set(arraySize, new PP.EasyTuneBoolArrayWidget(this._myParams, arraySize, this._myGamepad));
          this._myWidgets.get(arraySize).start(this._myParentObject, this._myAdditionalSetup);
          this._myWidgets.get(arraySize).setVisible(false);
          this._myWidgets.get(arraySize).registerScrollVariableRequestEventListener(this, this._scrollVariableRequest.bind(this));
        }
        _sizeChangedCheck() {
          if (this._myVariable.myValue.length != this._myCurrentArraySize) {
            this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
          }
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget.js
  var require_easy_tune_none_widget = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget.js"() {
      PP.EasyTuneNoneWidget = class EasyTuneNoneWidget extends PP.EasyTuneBaseWidget {
        constructor(params) {
          super(params);
          this._mySetup = new PP.EasyTuneNoneWidgetSetup();
          this._myUI = new PP.EasyTuneNoneWidgetUI();
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_ui.js
  var require_easy_tune_none_widget_ui = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_ui.js"() {
      PP.EasyTuneNoneWidgetUI = class EasyTuneNoneWidgetUI extends PP.EasyTuneBaseWidgetUI {
        _createSkeletonHook() {
          this.myTypeNotSupportedPanel = WL.scene.addObject(this.myDisplayPanel);
          this.myTypeNotSupportedText = WL.scene.addObject(this.myTypeNotSupportedPanel);
          this.myTypeNotSupportedCursorTarget = WL.scene.addObject(this.myTypeNotSupportedPanel);
        }
        _setTransformHook() {
          this.myTypeNotSupportedPanel.setTranslationLocal(this._mySetup.myTypeNotSupportedPanelPosition);
          this.myTypeNotSupportedText.scale(this._mySetup.myTypeNotSupportedTextScale);
        }
        _addComponentsHook() {
          this.myTypeNotSupportedTextComponent = this.myTypeNotSupportedText.addComponent("text");
          this._setupTextComponent(this.myTypeNotSupportedTextComponent);
          this.myTypeNotSupportedTextComponent.text = this._mySetup.myTypeNotSupportedText;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_setup.js
  var require_easy_tune_none_widget_setup = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_setup.js"() {
      PP.EasyTuneNoneWidgetSetup = class EasyTuneNoneWidgetSetup extends PP.EasyTuneBaseWidgetSetup {
        _getBackPanelMinY() {
          return super._getBackPanelMinY() + this.myTypeNotSupportedPanelPosition[1];
        }
        _getPivotZOffset() {
          return 804713e-8;
        }
        _initializeBuildSetupHook() {
          this.myTypeNotSupportedPanelPosition = PP.vec3_create(0, -0.03, this._myPanelZOffset);
          this.myTypeNotSupportedTextScale = PP.vec3_create(0.275, 0.275, 0.275);
          this.myTypeNotSupportedText = "Type Not Supported";
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget.js
  var require_easy_tune_number_array_widget = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget.js"() {
      PP.EasyTuneNumberArrayWidget = class EasyTuneNumberArrayWidget extends PP.EasyTuneBaseWidget {
        constructor(params, arraySize, gamepad) {
          super(params);
          this._myGamepad = gamepad;
          this._mySetup = new PP.EasyTuneNumberArrayWidgetSetup(arraySize);
          this._myUI = new PP.EasyTuneNumberArrayWidgetUI();
          this._myValueEditIndex = -1;
          this._myValueButtonEditIntensity = 0;
          this._myValueButtonEditIntensityTimer = 0;
          this._myStepButtonEditIntensity = 0;
          this._myStepButtonEditIntensityTimer = 0;
          this._myValueEditActive = false;
          this._myStepEditActive = false;
          this._myValueRealValue = 0;
          this._myStepMultiplierValue = 0;
          this._myStepFastEdit = false;
        }
        _setEasyTuneVariableHook() {
          if (this._myValueEditIndex >= 0) {
            this._myValueRealValue = this._myVariable.myValue[this._myValueEditIndex];
          }
        }
        _refreshUIHook() {
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this._myUI.myValueTextComponents[i].text = this._myVariable.myValue[i].toFixed(this._myVariable.myDecimalPlaces);
          }
          this._myUI.myStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myStepPerSecond);
        }
        _startHook(parentObject, additionalSetup) {
          this._myUI.setAdditionalButtonsActive(additionalSetup.myEnableAdditionalButtons);
        }
        _updateHook(dt) {
          this._updateValue(dt);
        }
        _updateValue(dt) {
          let stickVariableIntensity = 0;
          if (this._myGamepad) {
            let y = this._myGamepad.getAxesInfo().myAxes[1];
            if (Math.abs(y) > this._mySetup.myEditThumbstickMinThreshold) {
              let normalizedEditAmount = (Math.abs(y) - this._mySetup.myEditThumbstickMinThreshold) / (1 - this._mySetup.myEditThumbstickMinThreshold);
              stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
            }
          }
          let valueIntensity = 0;
          if (this._myValueEditActive) {
            valueIntensity = stickVariableIntensity;
          } else if (this._myValueButtonEditIntensity != 0) {
            if (this._myValueButtonEditIntensityTimer <= 0) {
              valueIntensity = this._myValueButtonEditIntensity;
            } else {
              this._myValueButtonEditIntensityTimer -= dt;
            }
          }
          if (valueIntensity != 0) {
            let amountToAdd = valueIntensity * this._myVariable.myStepPerSecond * dt;
            this._myValueRealValue += amountToAdd;
            if (this._myVariable.myMin != null && this._myVariable.myMax != null) {
              this._myValueRealValue = Math.pp_clamp(this._myValueRealValue, this._myVariable.myMin, this._myVariable.myMax);
            } else if (this._myVariable.myMin != null) {
              this._myValueRealValue = Math.max(this._myValueRealValue, this._myVariable.myMin);
            } else if (this._myVariable.myMax != null) {
              this._myValueRealValue = Math.min(this._myValueRealValue, this._myVariable.myMax);
            }
            let decimalPlacesMultiplier = Math.pow(10, this._myVariable.myDecimalPlaces);
            if (this._myVariable.myEditAllValuesTogether) {
              let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
              let difference = newValue - this._myVariable.myValue[this._myValueEditIndex];
              for (let i = 0; i < this._mySetup.myArraySize; i++) {
                this._myVariable.myValue[i] = Math.round((this._myVariable.myValue[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                if (this._myVariable.myMin != null && this._myVariable.myMax != null) {
                  this._myVariable.myValue[i] = Math.pp_clamp(this._myVariable.myValue[i], this._myVariable.myMin, this._myVariable.myMax);
                } else if (this._myVariable.myMin != null) {
                  this._myVariable.myValue[i] = Math.max(this._myVariable.myValue[i], this._myVariable.myMin);
                } else if (this._myVariable.myMax != null) {
                  this._myVariable.myValue[i] = Math.min(this._myVariable.myValue[i], this._myVariable.myMax);
                }
                this._myUI.myValueTextComponents[i].text = this._myVariable.myValue[i].toFixed(this._myVariable.myDecimalPlaces);
              }
            } else {
              this._myVariable.myValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
              if (this._myVariable.myMin != null && this._myVariable.myMax != null) {
                this._myVariable.myValue[this._myValueEditIndex] = Math.pp_clamp(this._myVariable.myValue[this._myValueEditIndex], this._myVariable.myMin, this._myVariable.myMax);
              } else if (this._myVariable.myMin != null) {
                this._myVariable.myValue[this._myValueEditIndex] = Math.max(this._myVariable.myValue[this._myValueEditIndex], this._myVariable.myMin);
              } else if (this._myVariable.myMax != null) {
                this._myVariable.myValue[this._myValueEditIndex] = Math.min(this._myVariable.myValue[this._myValueEditIndex], this._myVariable.myMax);
              }
              this._myUI.myValueTextComponents[this._myValueEditIndex].text = this._myVariable.myValue[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
            }
          } else {
            this._myValueRealValue = this._myVariable.myValue[this._myValueEditIndex];
          }
          let stepIntensity = 0;
          if (this._myStepEditActive) {
            stepIntensity = stickVariableIntensity;
          } else if (this._myStepButtonEditIntensity != 0) {
            if (this._myStepButtonEditIntensityTimer <= 0) {
              stepIntensity = this._myStepButtonEditIntensity;
            } else {
              this._myStepButtonEditIntensityTimer -= dt;
            }
          }
          if (stepIntensity != 0) {
            let amountToAdd = 0;
            if (this._myStepFastEdit) {
              amountToAdd = Math.sign(stepIntensity) * 1;
              this._myStepFastEdit = false;
            } else {
              amountToAdd = stepIntensity * this._mySetup.myStepMultiplierStepPerSecond * dt;
            }
            this._myStepMultiplierValue += amountToAdd;
            if (Math.abs(this._myStepMultiplierValue) >= 1) {
              if (Math.sign(this._myStepMultiplierValue) > 0) {
                this._myStepMultiplierValue -= 1;
                this._changeStep(this._myVariable.myStepPerSecond * 10);
              } else {
                this._myStepMultiplierValue += 1;
                this._changeStep(this._myVariable.myStepPerSecond * 0.1);
              }
            }
          } else {
            this._myStepMultiplierValue = 0;
            this._myStepFastEdit = true;
          }
        }
        _addListenersHook() {
          let ui = this._myUI;
          ui.myVariableLabelCursorTargetComponent.addClickFunction(this._resetAllValues.bind(this));
          ui.myVariableLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myVariableLabelText));
          ui.myVariableLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myVariableLabelText, this._mySetup.myVariableLabelTextScale));
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            ui.myValueIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, 1));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, i, 1));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, i, -1));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, i, -1));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, i, 0));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
            ui.myValueIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
            ui.myValueDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
            ui.myValueCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, i));
            ui.myValueCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], true));
            ui.myValueCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, i, ui.myValueTexts[i], false));
          }
          ui.myStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this));
          ui.myStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, ui.myStepText, true));
          ui.myStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, ui.myStepText, false));
          ui.myStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 1));
          ui.myStepIncreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 1));
          ui.myStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0));
          ui.myStepIncreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 0));
          ui.myStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 0));
          ui.myStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, -1));
          ui.myStepDecreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, -1));
          ui.myStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0));
          ui.myStepDecreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 0));
          ui.myStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 0));
          ui.myStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
          ui.myStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
          ui.myStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
          ui.myStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
        }
        _setValueEditIntensity(index, value) {
          if (this._isActive() || value == 0) {
            if (value != 0) {
              this._myValueButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
              this._myValueRealValue = this._myVariable.myValue[index];
              this._myValueEditIndex = index;
            }
            this._myValueButtonEditIntensity = value;
          }
        }
        _setStepEditIntensity(value) {
          if (this._isActive() || value == 0) {
            if (value != 0) {
              this._myStepButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
            }
            this._myStepButtonEditIntensity = value;
          }
        }
        _setValueEditActive(index, text, active) {
          if (this._isActive() || !active) {
            if (active) {
              this._myValueRealValue = this._myVariable.myValue[index];
              this._myValueEditIndex = index;
              text.scale(this._mySetup.myTextHoverScaleMultiplier);
            } else {
              text.scalingWorld = this._mySetup.myValueTextScale;
            }
            this._myValueEditActive = active;
          }
        }
        _setStepEditActive(text, active) {
          if (this._isActive() || !active) {
            if (active) {
              text.scale(this._mySetup.myTextHoverScaleMultiplier);
            } else {
              text.scalingWorld = this._mySetup.myStepTextScale;
            }
            this._myStepEditActive = active;
          }
        }
        _resetValue(index) {
          if (this._isActive()) {
            this._myVariable.myValue[index] = this._myVariable.myDefaultValue[index];
            this._myUI.myValueTextComponents[index].text = this._myVariable.myValue[index].toFixed(this._myVariable.myDecimalPlaces);
          }
        }
        _resetAllValues() {
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this._resetValue(i);
          }
        }
        _resetStep() {
          if (this._isActive()) {
            this._changeStep(this._myVariable.myDefaultStepPerSecond);
          }
        }
        _changeStep(step) {
          step = Math.pp_roundDecimal(step, 10);
          this._myVariable.myStepPerSecond = step;
          this._myUI.myStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myStepPerSecond);
        }
        _genericTextHover(text) {
          text.scale(this._mySetup.myTextHoverScaleMultiplier);
        }
        _genericTextUnHover(text, originalScale) {
          text.scalingWorld = originalScale;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_ui.js
  var require_easy_tune_number_array_widget_ui = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_ui.js"() {
      PP.EasyTuneNumberArrayWidgetUI = class EasyTuneNumberArrayWidgetUI extends PP.EasyTuneBaseWidgetUI {
        setAdditionalButtonsActive(active) {
          this._myAdditionalButtonsActive = active;
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValueIncreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
            this.myValueDecreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
          }
          this.myStepIncreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
          this.myStepDecreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
        }
        _buildHook() {
          this._myAdditionalButtonsActive = true;
        }
        _createSkeletonHook() {
          this.myValuesPanel = WL.scene.addObject(this.myDisplayPanel);
          this.myValuePanels = [];
          this.myValueTexts = [];
          this.myValueCursorTargets = [];
          this.myValueIncreaseButtonPanels = [];
          this.myValueIncreaseButtonBackgrounds = [];
          this.myValueIncreaseButtonTexts = [];
          this.myValueIncreaseButtonCursorTargets = [];
          this.myValueDecreaseButtonPanels = [];
          this.myValueDecreaseButtonBackgrounds = [];
          this.myValueDecreaseButtonTexts = [];
          this.myValueDecreaseButtonCursorTargets = [];
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValuePanels[i] = WL.scene.addObject(this.myValuesPanel);
            this.myValueTexts[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueCursorTargets[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueIncreaseButtonPanels[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueIncreaseButtonBackgrounds[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);
            this.myValueIncreaseButtonTexts[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);
            this.myValueIncreaseButtonCursorTargets[i] = WL.scene.addObject(this.myValueIncreaseButtonPanels[i]);
            this.myValueDecreaseButtonPanels[i] = WL.scene.addObject(this.myValuePanels[i]);
            this.myValueDecreaseButtonBackgrounds[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
            this.myValueDecreaseButtonTexts[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
            this.myValueDecreaseButtonCursorTargets[i] = WL.scene.addObject(this.myValueDecreaseButtonPanels[i]);
          }
          this.myStepPanel = WL.scene.addObject(this.myPivotObject);
          this.myStepText = WL.scene.addObject(this.myStepPanel);
          this.myStepCursorTarget = WL.scene.addObject(this.myStepPanel);
          this.myStepIncreaseButtonPanel = WL.scene.addObject(this.myStepPanel);
          this.myStepIncreaseButtonBackground = WL.scene.addObject(this.myStepIncreaseButtonPanel);
          this.myStepIncreaseButtonText = WL.scene.addObject(this.myStepIncreaseButtonPanel);
          this.myStepIncreaseButtonCursorTarget = WL.scene.addObject(this.myStepIncreaseButtonPanel);
          this.myStepDecreaseButtonPanel = WL.scene.addObject(this.myStepPanel);
          this.myStepDecreaseButtonBackground = WL.scene.addObject(this.myStepDecreaseButtonPanel);
          this.myStepDecreaseButtonText = WL.scene.addObject(this.myStepDecreaseButtonPanel);
          this.myStepDecreaseButtonCursorTarget = WL.scene.addObject(this.myStepDecreaseButtonPanel);
        }
        _setTransformHook() {
          this.myValuesPanel.setTranslationLocal(this._mySetup.myValuesPanelPosition);
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValuePanels[i].setTranslationLocal(this._mySetup.myValuePanelsPositions[i]);
            this.myValueTexts[i].scale(this._mySetup.myValueTextScale);
            this.myValueCursorTargets[i].setTranslationLocal(this._mySetup.myValueCursorTargetPosition);
            this.myValueIncreaseButtonPanels[i].setTranslationLocal(this._mySetup.myRightSideButtonPosition);
            this.myValueIncreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myValueIncreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myValueIncreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myValueIncreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
            this.myValueDecreaseButtonPanels[i].setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
            this.myValueDecreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myValueDecreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myValueDecreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myValueDecreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          }
          this.myStepPanel.setTranslationLocal(this._mySetup.myStepPanelPosition);
          this.myStepText.scale(this._mySetup.myStepTextScale);
          this.myStepCursorTarget.setTranslationLocal(this._mySetup.myStepCursorTargetPosition);
          this.myStepIncreaseButtonPanel.setTranslationLocal(this._mySetup.myRightSideButtonPosition);
          this.myStepIncreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
          this.myStepIncreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
          this.myStepIncreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
          this.myStepIncreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          this.myStepDecreaseButtonPanel.setTranslationLocal(this._mySetup.myLeftSideButtonPosition);
          this.myStepDecreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
          this.myStepDecreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
          this.myStepDecreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
          this.myStepDecreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
        }
        _addComponentsHook() {
          this.myValueTextComponents = [];
          this.myValueCursorTargetComponents = [];
          this.myValueCollisionComponents = [];
          this.myValueIncreaseButtonBackgroundComponents = [];
          this.myValueIncreaseButtonTextComponents = [];
          this.myValueIncreaseButtonCursorTargetComponents = [];
          this.myValueIncreaseButtonCollisionComponents = [];
          this.myValueDecreaseButtonBackgroundComponents = [];
          this.myValueDecreaseButtonTextComponents = [];
          this.myValueDecreaseButtonCursorTargetComponents = [];
          this.myValueDecreaseButtonCollisionComponents = [];
          for (let i = 0; i < this._mySetup.myArraySize; i++) {
            this.myValueTextComponents[i] = this.myValueTexts[i].addComponent("text");
            this._setupTextComponent(this.myValueTextComponents[i]);
            this.myValueTextComponents[i].text = " ";
            this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].addComponent("cursor-target");
            this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].addComponent("collision");
            this.myValueCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;
            this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].addComponent("mesh");
            this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myValueIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
            this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].addComponent("text");
            this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
            this.myValueIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;
            this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].addComponent("cursor-target");
            this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].addComponent("collision");
            this.myValueIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
            this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].addComponent("mesh");
            this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myValueDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
            this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].addComponent("text");
            this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
            this.myValueDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;
            this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].addComponent("cursor-target");
            this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].addComponent("collision");
            this.myValueDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myValueDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
          }
          this.myStepTextComponent = this.myStepText.addComponent("text");
          this._setupTextComponent(this.myStepTextComponent);
          this.myStepTextComponent.text = " ";
          this.myStepCursorTargetComponent = this.myStepCursorTarget.addComponent("cursor-target");
          this.myStepCollisionComponent = this.myStepCursorTarget.addComponent("collision");
          this.myStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
          this.myStepIncreaseButtonBackgroundComponent = this.myStepIncreaseButtonBackground.addComponent("mesh");
          this.myStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myStepIncreaseButtonTextComponent = this.myStepIncreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myStepIncreaseButtonTextComponent);
          this.myStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
          this.myStepIncreaseButtonCursorTargetComponent = this.myStepIncreaseButtonCursorTarget.addComponent("cursor-target");
          this.myStepIncreaseButtonCollisionComponent = this.myStepIncreaseButtonCursorTarget.addComponent("collision");
          this.myStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myStepDecreaseButtonBackgroundComponent = this.myStepDecreaseButtonBackground.addComponent("mesh");
          this.myStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myStepDecreaseButtonTextComponent = this.myStepDecreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myStepDecreaseButtonTextComponent);
          this.myStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
          this.myStepDecreaseButtonCursorTargetComponent = this.myStepDecreaseButtonCursorTarget.addComponent("cursor-target");
          this.myStepDecreaseButtonCollisionComponent = this.myStepDecreaseButtonCursorTarget.addComponent("collision");
          this.myStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
        }
        _setVisibleHook(visible) {
          if (visible) {
            this.setAdditionalButtonsActive(this._myAdditionalButtonsActive);
          }
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_setup.js
  var require_easy_tune_number_array_widget_setup = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_setup.js"() {
      PP.EasyTuneNumberArrayWidgetSetup = class EasyTuneNumberArrayWidgetSetup extends PP.EasyTuneBaseWidgetSetup {
        constructor(arraySize) {
          super();
          this.myArraySize = arraySize;
        }
        _getBackPanelMinY() {
          return this.myStepPanelPosition[1] - this._mySideButtonDistanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
        }
        _getPivotZOffset() {
          return 803713e-8;
        }
        _initializeBuildSetupHook() {
          this.myIncreaseButtonText = "+";
          this.myDecreaseButtonText = "-";
          this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
          this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
          this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
          this.myValueTextScale = PP.vec3_create(0.4, 0.4, 0.4);
          this.myValueCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
          this.myValueCollisionExtents = PP.vec3_create(0.065, 0.02, 1);
          this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
          this.myValuePanelsPositions = [];
          this.myValuePanelsPositions[0] = PP.vec3_create(0, 0, 0);
          for (let i = 1; i < this.myArraySize; i++) {
            this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].slice(0);
            this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
          }
          let valuePanelLastPosition = this.myValuePanelsPositions[this.myArraySize - 1] ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
          this.myStepPanelPosition = [0, this.myDisplayPanelPosition[1] + this.myValuesPanelPosition[1] + valuePanelLastPosition - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
          this.myStepTextScale = this.myLabelTextScale;
          this.myStepStartString = "Step: ";
          this.myStepCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myStepCursorTargetPosition[2] = this._myColliderZOffset - this.myStepPanelPosition[2];
          this.myStepCollisionExtents = PP.vec3_create(0.065, 0.0175, 1);
          this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;
        }
        _initializeRuntimeSetupHook() {
          this.myTextHoverScaleMultiplier = PP.vec3_create(1.25, 1.25, 1.25);
          this.myEditThumbstickMinThreshold = 0.35;
          this.myStepMultiplierStepPerSecond = 2.25;
          this.myButtonEditDelay = 0;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_widget_selector.js
  var require_easy_tune_number_widget_selector = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_widget_selector.js"() {
      PP.EasyTuneNumberArrayWidgetSelector = class EasyTuneNumberArrayWidgetSelector {
        constructor(params, gamepad) {
          this._myGamepad = gamepad;
          this._myParentObject = null;
          this._myParams = params;
          this._myAdditionalSetup = null;
          this._myWidgets = /* @__PURE__ */ new Map();
          this._myVariable = null;
          this._myIsVisible = true;
          this._myAppendToVariableName = null;
          this._myScrollVariableRequestCallbacks = /* @__PURE__ */ new Map();
          this._myCurrentArraySize = 0;
        }
        setEasyTuneVariable(variable, appendToVariableName) {
          this._myVariable = variable;
          this._myCurrentArraySize = this._myVariable.myValue.length;
          this._myAppendToVariableName = appendToVariableName;
          if (!this._myWidgets.has(this._myCurrentArraySize)) {
            this._createWidget(this._myCurrentArraySize);
          }
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.setEasyTuneVariable(variable, appendToVariableName);
          }
          this.setVisible(this._myIsVisible);
        }
        setVisible(visible) {
          for (let widget of this._myWidgets.values()) {
            widget.setVisible(false);
          }
          if (this._myVariable) {
            this._sizeChangedCheck();
            let widget = this._myWidgets.get(this._myCurrentArraySize);
            if (widget) {
              widget.setVisible(visible);
            }
          }
          this._myIsVisible = visible;
        }
        isScrollVariableActive() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            return widget.isScrollVariableActive();
          }
          return false;
        }
        getScrollVariableDirection() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            return widget.getScrollVariableDirection();
          }
          return 0;
        }
        setScrollVariableActive(active, scrollDirection) {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.setScrollVariableActive(active, scrollDirection);
          }
        }
        getWidget() {
          return this._myWidgets.get(this._myCurrentArraySize);
        }
        registerScrollVariableRequestEventListener(id, callback) {
          this._myScrollVariableRequestCallbacks.set(id, callback);
        }
        unregisterScrollVariableRequestEventListener(id) {
          this._myScrollVariableRequestCallbacks.delete(id);
        }
        start(parentObject, additionalSetup) {
          this._myParentObject = parentObject;
          this._myAdditionalSetup = additionalSetup;
          this._createWidget(1);
          if (this._myVariable) {
            this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
          }
        }
        update(dt) {
          if (this._isActive()) {
            this._sizeChangedCheck();
            let widget = this._myWidgets.get(this._myCurrentArraySize);
            if (widget) {
              widget.update(dt);
            }
          }
        }
        onImportSuccess() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.onImportSuccess();
          }
        }
        onImportFailure() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.onImportFailure();
          }
        }
        onExportSuccess() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.onExportSuccess();
          }
        }
        onExportFailure() {
          let widget = this._myWidgets.get(this._myCurrentArraySize);
          if (widget) {
            widget.onExportFailure();
          }
        }
        _isActive() {
          return this._myIsVisible && this._myVariable;
        }
        _scrollVariableRequest(amount) {
          for (let callback of this._myScrollVariableRequestCallbacks.values()) {
            callback(amount);
          }
        }
        _createWidget(arraySize) {
          this._myWidgets.set(arraySize, new PP.EasyTuneNumberArrayWidget(this._myParams, arraySize, this._myGamepad));
          this._myWidgets.get(arraySize).start(this._myParentObject, this._myAdditionalSetup);
          this._myWidgets.get(arraySize).setVisible(false);
          this._myWidgets.get(arraySize).registerScrollVariableRequestEventListener(this, this._scrollVariableRequest.bind(this));
        }
        _sizeChangedCheck() {
          if (this._myVariable.myValue.length != this._myCurrentArraySize) {
            this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
          }
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget.js
  var require_easy_tune_transform_widget = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget.js"() {
      PP.EasyTuneTransformWidget = class EasyTuneTransformWidget extends PP.EasyTuneBaseWidget {
        constructor(params, gamepad) {
          super(params);
          this._myGamepad = gamepad;
          this._mySetup = new PP.EasyTuneTransformWidgetSetup();
          this._myUI = new PP.EasyTuneTransformWidgetUI();
          this._myValueButtonEditIntensity = 0;
          this._myValueButtonEditIntensityTimer = 0;
          this._myStepButtonEditIntensity = 0;
          this._myStepButtonEditIntensityTimer = 0;
          this._myValueEditActive = false;
          this._myStepEditActive = false;
          this._myValueRealValue = 0;
          this._myComponentStepValue = 0;
          this._myStepMultiplierValue = 0;
          this._myStepFastEdit = false;
          this._myValueEditIndex = -1;
          this._myComponentIndex = 0;
          this._myStepIndex = 0;
        }
        _setEasyTuneVariableHook() {
          if (this._myValueEditIndex >= 0) {
            switch (this._myComponentIndex) {
              case 0:
                this._myValueRealValue = this._myVariable.myPosition[this._myValueEditIndex];
                this._myComponentStepValue = this._myVariable.myPositionStepPerSecond;
                break;
              case 1:
                this._myValueRealValue = this._myVariable.myRotation[this._myValueEditIndex];
                this._myComponentStepValue = this._myVariable.myRotationStepPerSecond;
                break;
              case 2:
                this._myValueRealValue = this._myVariable.myScale[this._myValueEditIndex];
                this._myComponentStepValue = this._myVariable.myScaleStepPerSecond;
                break;
            }
          }
        }
        _refreshUIHook() {
          for (let i = 0; i < 3; i++) {
            this._myUI.myPositionTextComponents[i].text = this._myVariable.myPosition[i].toFixed(this._myVariable.myDecimalPlaces);
          }
          this._myUI.myPositionStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myPositionStepPerSecond);
          for (let i = 0; i < 3; i++) {
            this._myUI.myRotationTextComponents[i].text = this._myVariable.myRotation[i].toFixed(this._myVariable.myDecimalPlaces);
          }
          this._myUI.myRotationStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myRotationStepPerSecond);
          for (let i = 0; i < 3; i++) {
            this._myUI.myScaleTextComponents[i].text = this._myVariable.myScale[i].toFixed(this._myVariable.myDecimalPlaces);
          }
          this._myUI.myScaleStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myScaleStepPerSecond);
        }
        _startHook(parentObject, additionalSetup) {
          this._myUI.setAdditionalButtonsActive(additionalSetup.myEnableAdditionalButtons);
        }
        _updateHook(dt) {
          this._updateValue(dt);
        }
        _updateValue(dt) {
          let stickVariableIntensity = 0;
          if (this._myGamepad) {
            let y = this._myGamepad.getAxesInfo().myAxes[1];
            if (Math.abs(y) > this._mySetup.myEditThumbstickMinThreshold) {
              let normalizedEditAmount = (Math.abs(y) - this._mySetup.myEditThumbstickMinThreshold) / (1 - this._mySetup.myEditThumbstickMinThreshold);
              stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
            }
          }
          let valueIntensity = 0;
          if (this._myValueEditActive) {
            valueIntensity = stickVariableIntensity;
          } else if (this._myValueButtonEditIntensity != 0) {
            if (this._myValueButtonEditIntensityTimer <= 0) {
              valueIntensity = this._myValueButtonEditIntensity;
            } else {
              this._myValueButtonEditIntensityTimer -= dt;
            }
          }
          if (valueIntensity != 0) {
            let amountToAdd = valueIntensity * this._myComponentStepValue * dt;
            this._myValueRealValue += amountToAdd;
            let decimalPlacesMultiplier = Math.pow(10, this._myVariable.myDecimalPlaces);
            switch (this._myComponentIndex) {
              case 0:
                this._myVariable.myPosition[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                this._myUI.myPositionTextComponents[this._myValueEditIndex].text = this._myVariable.myPosition[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
                break;
              case 1:
                if (this._myValueRealValue > 180) {
                  while (this._myValueRealValue > 180) {
                    this._myValueRealValue -= 180;
                  }
                  this._myValueRealValue = -180 + this._myValueRealValue;
                }
                if (this._myValueRealValue < -180) {
                  while (this._myValueRealValue < -180) {
                    this._myValueRealValue += 180;
                  }
                  this._myValueRealValue = 180 - this._myValueRealValue;
                }
                this._myVariable.myRotation[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                this._myUI.myRotationTextComponents[this._myValueEditIndex].text = this._myVariable.myRotation[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
                break;
              case 2:
                if (this._myValueRealValue <= 0) {
                  this._myValueRealValue = 1 / decimalPlacesMultiplier;
                }
                if (this._myVariable.myScaleAsOne) {
                  let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                  let difference = newValue - this._myVariable.myScale[this._myValueEditIndex];
                  for (let i = 0; i < 3; i++) {
                    this._myVariable.myScale[i] = Math.round((this._myVariable.myScale[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                    this._myVariable.myScale[i] = Math.max(this._myVariable.myScale[i], 1 / decimalPlacesMultiplier);
                    this._myUI.myScaleTextComponents[i].text = this._myVariable.myScale[i].toFixed(this._myVariable.myDecimalPlaces);
                  }
                } else {
                  this._myVariable.myScale[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                  this._myVariable.myScale[this._myValueEditIndex] = Math.max(this._myVariable.myScale[this._myValueEditIndex], 1 / decimalPlacesMultiplier);
                  this._myUI.myScaleTextComponents[this._myValueEditIndex].text = this._myVariable.myScale[this._myValueEditIndex].toFixed(this._myVariable.myDecimalPlaces);
                }
                break;
            }
          } else {
            switch (this._myComponentIndex) {
              case 0:
                this._myValueRealValue = this._myVariable.myPosition[this._myValueEditIndex];
                break;
              case 1:
                this._myValueRealValue = this._myVariable.myRotation[this._myValueEditIndex];
                break;
              case 2:
                this._myValueRealValue = this._myVariable.myScale[this._myValueEditIndex];
                break;
            }
          }
          let stepIntensity = 0;
          if (this._myStepEditActive) {
            stepIntensity = stickVariableIntensity;
          } else if (this._myStepButtonEditIntensity != 0) {
            if (this._myStepButtonEditIntensityTimer <= 0) {
              stepIntensity = this._myStepButtonEditIntensity;
            } else {
              this._myStepButtonEditIntensityTimer -= dt;
            }
          }
          if (stepIntensity != 0) {
            let amountToAdd = 0;
            if (this._myStepFastEdit) {
              amountToAdd = Math.sign(stepIntensity) * 1;
              this._myStepFastEdit = false;
            } else {
              amountToAdd = stepIntensity * this._mySetup.myStepMultiplierStepPerSecond * dt;
            }
            this._myStepMultiplierValue += amountToAdd;
            if (Math.abs(this._myStepMultiplierValue) >= 1) {
              let stepValue = 0;
              switch (this._myStepIndex) {
                case 0:
                  stepValue = this._myVariable.myPositionStepPerSecond;
                  break;
                case 1:
                  stepValue = this._myVariable.myRotationStepPerSecond;
                  break;
                case 2:
                  stepValue = this._myVariable.myScaleStepPerSecond;
                  break;
                default:
                  stepValue = 0;
              }
              if (Math.sign(this._myStepMultiplierValue) > 0) {
                this._myStepMultiplierValue -= 1;
                this._changeStep(this._myStepIndex, stepValue * 10);
              } else {
                this._myStepMultiplierValue += 1;
                this._changeStep(this._myStepIndex, stepValue * 0.1);
              }
            }
          } else {
            this._myStepMultiplierValue = 0;
            this._myStepFastEdit = true;
          }
        }
        _addListenersHook() {
          let ui = this._myUI;
          ui.myVariableLabelCursorTargetComponent.addClickFunction(this._resetAllValues.bind(this));
          ui.myVariableLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myVariableLabelText));
          ui.myVariableLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myVariableLabelText, this._mySetup.myVariableLabelTextScale));
          ui.myPositionLabelCursorTargetComponent.addClickFunction(this._resetComponentValues.bind(this, 0));
          ui.myPositionLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myPositionLabelText));
          ui.myPositionLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myPositionLabelText, this._mySetup.myComponentLabelTextScale));
          for (let i = 0; i < 3; i++) {
            ui.myPositionIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 0, i, 1));
            ui.myPositionIncreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 0, i, 1));
            ui.myPositionIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
            ui.myPositionIncreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
            ui.myPositionIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
            ui.myPositionDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 0, i, -1));
            ui.myPositionDecreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 0, i, -1));
            ui.myPositionDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
            ui.myPositionDecreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
            ui.myPositionDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 0, i, 0));
            ui.myPositionIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
            ui.myPositionIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
            ui.myPositionDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
            ui.myPositionDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
            ui.myPositionCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, 0, i));
            ui.myPositionCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, 0, i, ui.myPositionTexts[i], true));
            ui.myPositionCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, 0, i, ui.myPositionTexts[i], false));
          }
          ui.myRotationLabelCursorTargetComponent.addClickFunction(this._resetComponentValues.bind(this, 1));
          ui.myRotationLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myRotationLabelText));
          ui.myRotationLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myRotationLabelText, this._mySetup.myComponentLabelTextScale));
          for (let i = 0; i < 3; i++) {
            ui.myRotationIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 1, i, 1));
            ui.myRotationIncreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 1, i, 1));
            ui.myRotationIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
            ui.myRotationIncreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
            ui.myRotationIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
            ui.myRotationDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 1, i, -1));
            ui.myRotationDecreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 1, i, -1));
            ui.myRotationDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
            ui.myRotationDecreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
            ui.myRotationDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 1, i, 0));
            ui.myRotationIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
            ui.myRotationIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
            ui.myRotationDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
            ui.myRotationDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
            ui.myRotationCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, 1, i));
            ui.myRotationCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, 1, i, ui.myRotationTexts[i], true));
            ui.myRotationCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, 1, i, ui.myRotationTexts[i], false));
          }
          ui.myScaleLabelCursorTargetComponent.addClickFunction(this._resetComponentValues.bind(this, 2));
          ui.myScaleLabelCursorTargetComponent.addHoverFunction(this._genericTextHover.bind(this, ui.myScaleLabelText));
          ui.myScaleLabelCursorTargetComponent.addUnHoverFunction(this._genericTextUnHover.bind(this, ui.myScaleLabelText, this._mySetup.myComponentLabelTextScale));
          for (let i = 0; i < 3; i++) {
            ui.myScaleIncreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 2, i, 1));
            ui.myScaleIncreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 2, i, 1));
            ui.myScaleIncreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
            ui.myScaleIncreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
            ui.myScaleIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
            ui.myScaleDecreaseButtonCursorTargetComponents[i].addDownFunction(this._setValueEditIntensity.bind(this, 2, i, -1));
            ui.myScaleDecreaseButtonCursorTargetComponents[i].addDownOnHoverFunction(this._setValueEditIntensity.bind(this, 2, i, -1));
            ui.myScaleDecreaseButtonCursorTargetComponents[i].addUpFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
            ui.myScaleDecreaseButtonCursorTargetComponents[i].addUpWithNoDownFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
            ui.myScaleDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._setValueEditIntensity.bind(this, 2, i, 0));
            ui.myScaleIncreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
            ui.myScaleIncreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
            ui.myScaleDecreaseButtonCursorTargetComponents[i].addHoverFunction(this._genericHover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
            ui.myScaleDecreaseButtonCursorTargetComponents[i].addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
            ui.myScaleCursorTargetComponents[i].addClickFunction(this._resetValue.bind(this, 2, i));
            ui.myScaleCursorTargetComponents[i].addHoverFunction(this._setValueEditActive.bind(this, 2, i, ui.myScaleTexts[i], true));
            ui.myScaleCursorTargetComponents[i].addUnHoverFunction(this._setValueEditActive.bind(this, 2, i, ui.myScaleTexts[i], false));
          }
          ui.myPositionStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this, 0));
          ui.myPositionStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, 0, ui.myPositionStepText, true));
          ui.myPositionStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, 0, ui.myPositionStepText, false));
          ui.myPositionStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 0, 1));
          ui.myPositionStepIncreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 0, 1));
          ui.myPositionStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0, 0));
          ui.myPositionStepIncreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 0, 0));
          ui.myPositionStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 0, 0));
          ui.myPositionStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 0, -1));
          ui.myPositionStepDecreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 0, -1));
          ui.myPositionStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 0, 0));
          ui.myPositionStepDecreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 0, 0));
          ui.myPositionStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 0, 0));
          ui.myPositionStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
          ui.myPositionStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
          ui.myPositionStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
          ui.myPositionStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
          ui.myRotationStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this, 1));
          ui.myRotationStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, 1, ui.myRotationStepText, true));
          ui.myRotationStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, 1, ui.myRotationStepText, false));
          ui.myRotationStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 1, 1));
          ui.myRotationStepIncreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 1, 1));
          ui.myRotationStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 1, 0));
          ui.myRotationStepIncreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 1, 0));
          ui.myRotationStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 1, 0));
          ui.myRotationStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 1, -1));
          ui.myRotationStepDecreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 1, -1));
          ui.myRotationStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 1, 0));
          ui.myRotationStepDecreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 1, 0));
          ui.myRotationStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 1, 0));
          ui.myRotationStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
          ui.myRotationStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
          ui.myRotationStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
          ui.myRotationStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
          ui.myScaleStepCursorTargetComponent.addClickFunction(this._resetStep.bind(this, 2));
          ui.myScaleStepCursorTargetComponent.addHoverFunction(this._setStepEditActive.bind(this, 2, ui.myScaleStepText, true));
          ui.myScaleStepCursorTargetComponent.addUnHoverFunction(this._setStepEditActive.bind(this, 2, ui.myScaleStepText, false));
          ui.myScaleStepIncreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 2, 1));
          ui.myScaleStepIncreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 2, 1));
          ui.myScaleStepIncreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 2, 0));
          ui.myScaleStepIncreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 2, 0));
          ui.myScaleStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 2, 0));
          ui.myScaleStepDecreaseButtonCursorTargetComponent.addDownFunction(this._setStepEditIntensity.bind(this, 2, -1));
          ui.myScaleStepDecreaseButtonCursorTargetComponent.addDownOnHoverFunction(this._setStepEditIntensity.bind(this, 2, -1));
          ui.myScaleStepDecreaseButtonCursorTargetComponent.addUpFunction(this._setStepEditIntensity.bind(this, 2, 0));
          ui.myScaleStepDecreaseButtonCursorTargetComponent.addUpWithNoDownFunction(this._setStepEditIntensity.bind(this, 2, 0));
          ui.myScaleStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._setStepEditIntensity.bind(this, 2, 0));
          ui.myScaleStepIncreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
          ui.myScaleStepIncreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
          ui.myScaleStepDecreaseButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
          ui.myScaleStepDecreaseButtonCursorTargetComponent.addUnHoverFunction(this._genericUnHover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
        }
        _setValueEditIntensity(componentIndex, index, value) {
          if (this._isActive() || value == 0) {
            if (value != 0) {
              switch (componentIndex) {
                case 0:
                  this._myValueRealValue = this._myVariable.myPosition[index];
                  this._myComponentStepValue = this._myVariable.myPositionStepPerSecond;
                  break;
                case 1:
                  this._myValueRealValue = this._myVariable.myRotation[index];
                  this._myComponentStepValue = this._myVariable.myRotationStepPerSecond;
                  break;
                case 2:
                  this._myValueRealValue = this._myVariable.myScale[index];
                  this._myComponentStepValue = this._myVariable.myScaleStepPerSecond;
                  break;
              }
              this._myValueButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
              this._myValueEditIndex = index;
              this._myComponentIndex = componentIndex;
            }
            this._myValueButtonEditIntensity = value;
          }
        }
        _setStepEditIntensity(index, value) {
          if (this._isActive() || value == 0) {
            if (value != 0) {
              this._myStepButtonEditIntensityTimer = this._mySetup.myButtonEditDelay;
            }
            this._myStepButtonEditIntensity = value;
            this._myStepIndex = index;
          }
        }
        _setValueEditActive(componentIndex, index, text, active) {
          if (this._isActive() || !active) {
            if (active) {
              switch (componentIndex) {
                case 0:
                  this._myValueRealValue = this._myVariable.myPosition[index];
                  this._myComponentStepValue = this._myVariable.myPositionStepPerSecond;
                  break;
                case 1:
                  this._myValueRealValue = this._myVariable.myRotation[index];
                  this._myComponentStepValue = this._myVariable.myRotationStepPerSecond;
                  break;
                case 2:
                  this._myValueRealValue = this._myVariable.myScale[index];
                  this._myComponentStepValue = this._myVariable.myScaleStepPerSecond;
                  break;
              }
              this._myValueEditIndex = index;
              this._myComponentIndex = componentIndex;
              text.scale(this._mySetup.myTextHoverScaleMultiplier);
            } else {
              text.scalingWorld = this._mySetup.myValueTextScale;
            }
            this._myValueEditActive = active;
          }
        }
        _setStepEditActive(index, text, active) {
          if (this._isActive() || !active) {
            if (active) {
              text.scale(this._mySetup.myTextHoverScaleMultiplier);
            } else {
              text.scalingWorld = this._mySetup.myStepTextScale;
            }
            this._myStepEditActive = active;
            this._myStepIndex = index;
          }
        }
        _resetValue(componentIndex, index) {
          if (this._isActive()) {
            switch (componentIndex) {
              case 0:
                this._myVariable.myPosition[index] = this._myVariable.myDefaultPosition[index];
                this._myUI.myPositionTextComponents[index].text = this._myVariable.myPosition[index].toFixed(this._myVariable.myDecimalPlaces);
                break;
              case 1:
                this._myVariable.myRotation[index] = this._myVariable.myDefaultRotation[index];
                this._myUI.myRotationTextComponents[index].text = this._myVariable.myRotation[index].toFixed(this._myVariable.myDecimalPlaces);
                break;
              case 2:
                this._myVariable.myScale[index] = this._myVariable.myDefaultScale[index];
                this._myUI.myScaleTextComponents[index].text = this._myVariable.myScale[index].toFixed(this._myVariable.myDecimalPlaces);
                break;
            }
          }
        }
        _resetAllValues() {
          for (let i = 0; i < 3; i++) {
            this._resetComponentValues(i);
          }
        }
        _resetComponentValues(index) {
          for (let i = 0; i < 3; i++) {
            this._resetValue(index, i);
          }
        }
        _resetStep(index) {
          if (this._isActive()) {
            let defaultValue = 0;
            switch (index) {
              case 0:
                defaultValue = this._myVariable.myDefaultPositionStepPerSecond;
                break;
              case 1:
                defaultValue = this._myVariable.myDefaultRotationStepPerSecond;
                break;
              case 2:
                defaultValue = this._myVariable.myDefaultScaleStepPerSecond;
                break;
              default:
                defaultValue = 0;
            }
            this._changeStep(index, defaultValue);
          }
        }
        _changeStep(index, step) {
          step = Math.pp_roundDecimal(step, 10);
          switch (index) {
            case 0:
              this._myVariable.myPositionStepPerSecond = step;
              this._myUI.myPositionStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myPositionStepPerSecond);
              break;
            case 1:
              this._myVariable.myRotationStepPerSecond = step;
              this._myUI.myRotationStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myRotationStepPerSecond);
              break;
            case 2:
              this._myVariable.myScaleStepPerSecond = step;
              this._myUI.myScaleStepTextComponent.text = this._mySetup.myStepStartString.concat(this._myVariable.myScaleStepPerSecond);
              break;
          }
        }
        _genericTextHover(text) {
          text.scale(this._mySetup.myTextHoverScaleMultiplier);
        }
        _genericTextUnHover(text, originalScale) {
          text.scalingWorld = originalScale;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_ui.js
  var require_easy_tune_transform_widget_ui = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_ui.js"() {
      PP.EasyTuneTransformWidgetUI = class EasyTuneTransformWidgetUI extends PP.EasyTuneBaseWidgetUI {
        setAdditionalButtonsActive(active) {
          this._myAdditionalButtonsActive = active;
          for (let i = 0; i < 3; i++) {
            this.myPositionIncreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
            this.myPositionDecreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
          }
          this.myPositionStepIncreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
          this.myPositionStepDecreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
          for (let i = 0; i < 3; i++) {
            this.myRotationIncreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
            this.myRotationDecreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
          }
          this.myRotationStepIncreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
          this.myRotationStepDecreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
          for (let i = 0; i < 3; i++) {
            this.myScaleIncreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
            this.myScaleDecreaseButtonPanels[i].pp_setActiveHierarchy(this._myAdditionalButtonsActive);
          }
          this.myScaleStepIncreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
          this.myScaleStepDecreaseButtonPanel.pp_setActiveHierarchy(this._myAdditionalButtonsActive);
        }
        _buildHook() {
          this._myAdditionalButtonsActive = true;
        }
        _createSkeletonHook() {
          this.myPositionPanel = WL.scene.addObject(this.myDisplayPanel);
          this.myPositionLabelText = WL.scene.addObject(this.myPositionPanel);
          this.myPositionLabelCursorTarget = WL.scene.addObject(this.myPositionPanel);
          this.myPositionPanels = [];
          this.myPositionTexts = [];
          this.myPositionCursorTargets = [];
          this.myPositionIncreaseButtonPanels = [];
          this.myPositionIncreaseButtonBackgrounds = [];
          this.myPositionIncreaseButtonTexts = [];
          this.myPositionIncreaseButtonCursorTargets = [];
          this.myPositionDecreaseButtonPanels = [];
          this.myPositionDecreaseButtonBackgrounds = [];
          this.myPositionDecreaseButtonTexts = [];
          this.myPositionDecreaseButtonCursorTargets = [];
          for (let i = 0; i < 3; i++) {
            this.myPositionPanels[i] = WL.scene.addObject(this.myPositionPanel);
            this.myPositionTexts[i] = WL.scene.addObject(this.myPositionPanels[i]);
            this.myPositionCursorTargets[i] = WL.scene.addObject(this.myPositionPanels[i]);
            this.myPositionIncreaseButtonPanels[i] = WL.scene.addObject(this.myPositionPanels[i]);
            this.myPositionIncreaseButtonBackgrounds[i] = WL.scene.addObject(this.myPositionIncreaseButtonPanels[i]);
            this.myPositionIncreaseButtonTexts[i] = WL.scene.addObject(this.myPositionIncreaseButtonPanels[i]);
            this.myPositionIncreaseButtonCursorTargets[i] = WL.scene.addObject(this.myPositionIncreaseButtonPanels[i]);
            this.myPositionDecreaseButtonPanels[i] = WL.scene.addObject(this.myPositionPanels[i]);
            this.myPositionDecreaseButtonBackgrounds[i] = WL.scene.addObject(this.myPositionDecreaseButtonPanels[i]);
            this.myPositionDecreaseButtonTexts[i] = WL.scene.addObject(this.myPositionDecreaseButtonPanels[i]);
            this.myPositionDecreaseButtonCursorTargets[i] = WL.scene.addObject(this.myPositionDecreaseButtonPanels[i]);
          }
          this.myRotationPanel = WL.scene.addObject(this.myDisplayPanel);
          this.myRotationLabelText = WL.scene.addObject(this.myRotationPanel);
          this.myRotationLabelCursorTarget = WL.scene.addObject(this.myRotationPanel);
          this.myRotationPanels = [];
          this.myRotationTexts = [];
          this.myRotationCursorTargets = [];
          this.myRotationIncreaseButtonPanels = [];
          this.myRotationIncreaseButtonBackgrounds = [];
          this.myRotationIncreaseButtonTexts = [];
          this.myRotationIncreaseButtonCursorTargets = [];
          this.myRotationDecreaseButtonPanels = [];
          this.myRotationDecreaseButtonBackgrounds = [];
          this.myRotationDecreaseButtonTexts = [];
          this.myRotationDecreaseButtonCursorTargets = [];
          for (let i = 0; i < 3; i++) {
            this.myRotationPanels[i] = WL.scene.addObject(this.myRotationPanel);
            this.myRotationTexts[i] = WL.scene.addObject(this.myRotationPanels[i]);
            this.myRotationCursorTargets[i] = WL.scene.addObject(this.myRotationPanels[i]);
            this.myRotationIncreaseButtonPanels[i] = WL.scene.addObject(this.myRotationPanels[i]);
            this.myRotationIncreaseButtonBackgrounds[i] = WL.scene.addObject(this.myRotationIncreaseButtonPanels[i]);
            this.myRotationIncreaseButtonTexts[i] = WL.scene.addObject(this.myRotationIncreaseButtonPanels[i]);
            this.myRotationIncreaseButtonCursorTargets[i] = WL.scene.addObject(this.myRotationIncreaseButtonPanels[i]);
            this.myRotationDecreaseButtonPanels[i] = WL.scene.addObject(this.myRotationPanels[i]);
            this.myRotationDecreaseButtonBackgrounds[i] = WL.scene.addObject(this.myRotationDecreaseButtonPanels[i]);
            this.myRotationDecreaseButtonTexts[i] = WL.scene.addObject(this.myRotationDecreaseButtonPanels[i]);
            this.myRotationDecreaseButtonCursorTargets[i] = WL.scene.addObject(this.myRotationDecreaseButtonPanels[i]);
          }
          this.myScalePanel = WL.scene.addObject(this.myDisplayPanel);
          this.myScaleLabelText = WL.scene.addObject(this.myScalePanel);
          this.myScaleLabelCursorTarget = WL.scene.addObject(this.myScalePanel);
          this.myScalePanels = [];
          this.myScaleTexts = [];
          this.myScaleCursorTargets = [];
          this.myScaleIncreaseButtonPanels = [];
          this.myScaleIncreaseButtonBackgrounds = [];
          this.myScaleIncreaseButtonTexts = [];
          this.myScaleIncreaseButtonCursorTargets = [];
          this.myScaleDecreaseButtonPanels = [];
          this.myScaleDecreaseButtonBackgrounds = [];
          this.myScaleDecreaseButtonTexts = [];
          this.myScaleDecreaseButtonCursorTargets = [];
          for (let i = 0; i < 3; i++) {
            this.myScalePanels[i] = WL.scene.addObject(this.myScalePanel);
            this.myScaleTexts[i] = WL.scene.addObject(this.myScalePanels[i]);
            this.myScaleCursorTargets[i] = WL.scene.addObject(this.myScalePanels[i]);
            this.myScaleIncreaseButtonPanels[i] = WL.scene.addObject(this.myScalePanels[i]);
            this.myScaleIncreaseButtonBackgrounds[i] = WL.scene.addObject(this.myScaleIncreaseButtonPanels[i]);
            this.myScaleIncreaseButtonTexts[i] = WL.scene.addObject(this.myScaleIncreaseButtonPanels[i]);
            this.myScaleIncreaseButtonCursorTargets[i] = WL.scene.addObject(this.myScaleIncreaseButtonPanels[i]);
            this.myScaleDecreaseButtonPanels[i] = WL.scene.addObject(this.myScalePanels[i]);
            this.myScaleDecreaseButtonBackgrounds[i] = WL.scene.addObject(this.myScaleDecreaseButtonPanels[i]);
            this.myScaleDecreaseButtonTexts[i] = WL.scene.addObject(this.myScaleDecreaseButtonPanels[i]);
            this.myScaleDecreaseButtonCursorTargets[i] = WL.scene.addObject(this.myScaleDecreaseButtonPanels[i]);
          }
          this.myPositionStepPanel = WL.scene.addObject(this.myPositionPanel);
          this.myPositionStepText = WL.scene.addObject(this.myPositionStepPanel);
          this.myPositionStepCursorTarget = WL.scene.addObject(this.myPositionStepPanel);
          this.myPositionStepIncreaseButtonPanel = WL.scene.addObject(this.myPositionStepPanel);
          this.myPositionStepIncreaseButtonBackground = WL.scene.addObject(this.myPositionStepIncreaseButtonPanel);
          this.myPositionStepIncreaseButtonText = WL.scene.addObject(this.myPositionStepIncreaseButtonPanel);
          this.myPositionStepIncreaseButtonCursorTarget = WL.scene.addObject(this.myPositionStepIncreaseButtonPanel);
          this.myPositionStepDecreaseButtonPanel = WL.scene.addObject(this.myPositionStepPanel);
          this.myPositionStepDecreaseButtonBackground = WL.scene.addObject(this.myPositionStepDecreaseButtonPanel);
          this.myPositionStepDecreaseButtonText = WL.scene.addObject(this.myPositionStepDecreaseButtonPanel);
          this.myPositionStepDecreaseButtonCursorTarget = WL.scene.addObject(this.myPositionStepDecreaseButtonPanel);
          this.myRotationStepPanel = WL.scene.addObject(this.myRotationPanel);
          this.myRotationStepText = WL.scene.addObject(this.myRotationStepPanel);
          this.myRotationStepCursorTarget = WL.scene.addObject(this.myRotationStepPanel);
          this.myRotationStepIncreaseButtonPanel = WL.scene.addObject(this.myRotationStepPanel);
          this.myRotationStepIncreaseButtonBackground = WL.scene.addObject(this.myRotationStepIncreaseButtonPanel);
          this.myRotationStepIncreaseButtonText = WL.scene.addObject(this.myRotationStepIncreaseButtonPanel);
          this.myRotationStepIncreaseButtonCursorTarget = WL.scene.addObject(this.myRotationStepIncreaseButtonPanel);
          this.myRotationStepDecreaseButtonPanel = WL.scene.addObject(this.myRotationStepPanel);
          this.myRotationStepDecreaseButtonBackground = WL.scene.addObject(this.myRotationStepDecreaseButtonPanel);
          this.myRotationStepDecreaseButtonText = WL.scene.addObject(this.myRotationStepDecreaseButtonPanel);
          this.myRotationStepDecreaseButtonCursorTarget = WL.scene.addObject(this.myRotationStepDecreaseButtonPanel);
          this.myScaleStepPanel = WL.scene.addObject(this.myScalePanel);
          this.myScaleStepText = WL.scene.addObject(this.myScaleStepPanel);
          this.myScaleStepCursorTarget = WL.scene.addObject(this.myScaleStepPanel);
          this.myScaleStepIncreaseButtonPanel = WL.scene.addObject(this.myScaleStepPanel);
          this.myScaleStepIncreaseButtonBackground = WL.scene.addObject(this.myScaleStepIncreaseButtonPanel);
          this.myScaleStepIncreaseButtonText = WL.scene.addObject(this.myScaleStepIncreaseButtonPanel);
          this.myScaleStepIncreaseButtonCursorTarget = WL.scene.addObject(this.myScaleStepIncreaseButtonPanel);
          this.myScaleStepDecreaseButtonPanel = WL.scene.addObject(this.myScaleStepPanel);
          this.myScaleStepDecreaseButtonBackground = WL.scene.addObject(this.myScaleStepDecreaseButtonPanel);
          this.myScaleStepDecreaseButtonText = WL.scene.addObject(this.myScaleStepDecreaseButtonPanel);
          this.myScaleStepDecreaseButtonCursorTarget = WL.scene.addObject(this.myScaleStepDecreaseButtonPanel);
        }
        _setTransformHook() {
          this.myPositionPanel.setTranslationLocal(this._mySetup.myPositionPanelPosition);
          this.myPositionLabelText.scale(this._mySetup.myComponentLabelTextScale);
          this.myPositionLabelCursorTarget.setTranslationLocal(this._mySetup.myComponentLabelCursorTargetPosition);
          for (let i = 0; i < 3; i++) {
            this.myPositionPanels[i].setTranslationLocal(this._mySetup.myValuePanelsPositions[i]);
            this.myPositionTexts[i].scale(this._mySetup.myValueTextScale);
            this.myPositionCursorTargets[i].setTranslationLocal(this._mySetup.myValueCursorTargetPosition);
            this.myPositionIncreaseButtonPanels[i].setTranslationLocal(this._mySetup.myIncreaseButtonPosition);
            this.myPositionIncreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myPositionIncreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myPositionIncreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myPositionIncreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
            this.myPositionDecreaseButtonPanels[i].setTranslationLocal(this._mySetup.myDecreaseButtonPosition);
            this.myPositionDecreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myPositionDecreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myPositionDecreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myPositionDecreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          }
          this.myRotationPanel.setTranslationLocal(this._mySetup.myRotationPanelPosition);
          this.myRotationLabelText.scale(this._mySetup.myComponentLabelTextScale);
          this.myRotationLabelCursorTarget.setTranslationLocal(this._mySetup.myComponentLabelCursorTargetPosition);
          for (let i = 0; i < 3; i++) {
            this.myRotationPanels[i].setTranslationLocal(this._mySetup.myValuePanelsPositions[i]);
            this.myRotationTexts[i].scale(this._mySetup.myValueTextScale);
            this.myRotationCursorTargets[i].setTranslationLocal(this._mySetup.myValueCursorTargetPosition);
            this.myRotationIncreaseButtonPanels[i].setTranslationLocal(this._mySetup.myIncreaseButtonPosition);
            this.myRotationIncreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myRotationIncreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myRotationIncreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myRotationIncreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
            this.myRotationDecreaseButtonPanels[i].setTranslationLocal(this._mySetup.myDecreaseButtonPosition);
            this.myRotationDecreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myRotationDecreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myRotationDecreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myRotationDecreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          }
          this.myScalePanel.setTranslationLocal(this._mySetup.myScalePanelPosition);
          this.myScaleLabelText.scale(this._mySetup.myComponentLabelTextScale);
          this.myScaleLabelCursorTarget.setTranslationLocal(this._mySetup.myComponentLabelCursorTargetPosition);
          for (let i = 0; i < 3; i++) {
            this.myScalePanels[i].setTranslationLocal(this._mySetup.myValuePanelsPositions[i]);
            this.myScaleTexts[i].scale(this._mySetup.myValueTextScale);
            this.myScaleCursorTargets[i].setTranslationLocal(this._mySetup.myValueCursorTargetPosition);
            this.myScaleIncreaseButtonPanels[i].setTranslationLocal(this._mySetup.myIncreaseButtonPosition);
            this.myScaleIncreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myScaleIncreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myScaleIncreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myScaleIncreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
            this.myScaleDecreaseButtonPanels[i].setTranslationLocal(this._mySetup.myDecreaseButtonPosition);
            this.myScaleDecreaseButtonBackgrounds[i].scale(this._mySetup.mySideButtonBackgroundScale);
            this.myScaleDecreaseButtonTexts[i].setTranslationLocal(this._mySetup.mySideButtonTextPosition);
            this.myScaleDecreaseButtonTexts[i].scale(this._mySetup.mySideButtonTextScale);
            this.myScaleDecreaseButtonCursorTargets[i].setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          }
          this.myPositionStepPanel.setTranslationLocal(this._mySetup.myStepPanelPosition);
          this.myPositionStepText.scale(this._mySetup.myStepTextScale);
          this.myPositionStepCursorTarget.setTranslationLocal(this._mySetup.myStepCursorTargetPosition);
          this.myPositionStepIncreaseButtonPanel.setTranslationLocal(this._mySetup.myIncreaseButtonPosition);
          this.myPositionStepIncreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
          this.myPositionStepIncreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
          this.myPositionStepIncreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
          this.myPositionStepIncreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          this.myPositionStepDecreaseButtonPanel.setTranslationLocal(this._mySetup.myDecreaseButtonPosition);
          this.myPositionStepDecreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
          this.myPositionStepDecreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
          this.myPositionStepDecreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
          this.myPositionStepDecreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          this.myRotationStepPanel.setTranslationLocal(this._mySetup.myStepPanelPosition);
          this.myRotationStepText.scale(this._mySetup.myStepTextScale);
          this.myRotationStepCursorTarget.setTranslationLocal(this._mySetup.myStepCursorTargetPosition);
          this.myRotationStepIncreaseButtonPanel.setTranslationLocal(this._mySetup.myIncreaseButtonPosition);
          this.myRotationStepIncreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
          this.myRotationStepIncreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
          this.myRotationStepIncreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
          this.myRotationStepIncreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          this.myRotationStepDecreaseButtonPanel.setTranslationLocal(this._mySetup.myDecreaseButtonPosition);
          this.myRotationStepDecreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
          this.myRotationStepDecreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
          this.myRotationStepDecreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
          this.myRotationStepDecreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          this.myScaleStepPanel.setTranslationLocal(this._mySetup.myStepPanelPosition);
          this.myScaleStepText.scale(this._mySetup.myStepTextScale);
          this.myScaleStepCursorTarget.setTranslationLocal(this._mySetup.myStepCursorTargetPosition);
          this.myScaleStepIncreaseButtonPanel.setTranslationLocal(this._mySetup.myIncreaseButtonPosition);
          this.myScaleStepIncreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
          this.myScaleStepIncreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
          this.myScaleStepIncreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
          this.myScaleStepIncreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
          this.myScaleStepDecreaseButtonPanel.setTranslationLocal(this._mySetup.myDecreaseButtonPosition);
          this.myScaleStepDecreaseButtonBackground.scale(this._mySetup.mySideButtonBackgroundScale);
          this.myScaleStepDecreaseButtonText.setTranslationLocal(this._mySetup.mySideButtonTextPosition);
          this.myScaleStepDecreaseButtonText.scale(this._mySetup.mySideButtonTextScale);
          this.myScaleStepDecreaseButtonCursorTarget.setTranslationLocal(this._mySetup.mySideButtonCursorTargetPosition);
        }
        _addComponentsHook() {
          this.myPositionLabelTextComponent = this.myPositionLabelText.addComponent("text");
          this._setupTextComponent(this.myPositionLabelTextComponent);
          this.myPositionLabelTextComponent.text = this._mySetup.myPositionText;
          this.myPositionLabelCursorTargetComponent = this.myPositionLabelCursorTarget.addComponent("cursor-target");
          this.myPositionLabelCollisionComponent = this.myPositionLabelCursorTarget.addComponent("collision");
          this.myPositionLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myPositionLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myPositionLabelCollisionComponent.extents = this._mySetup.myComponentLabelCollisionExtents;
          this.myPositionTextComponents = [];
          this.myPositionCursorTargetComponents = [];
          this.myPositionCollisionComponents = [];
          this.myPositionIncreaseButtonBackgroundComponents = [];
          this.myPositionIncreaseButtonTextComponents = [];
          this.myPositionIncreaseButtonCursorTargetComponents = [];
          this.myPositionIncreaseButtonCollisionComponents = [];
          this.myPositionDecreaseButtonBackgroundComponents = [];
          this.myPositionDecreaseButtonTextComponents = [];
          this.myPositionDecreaseButtonCursorTargetComponents = [];
          this.myPositionDecreaseButtonCollisionComponents = [];
          for (let i = 0; i < 3; i++) {
            this.myPositionTextComponents[i] = this.myPositionTexts[i].addComponent("text");
            this._setupTextComponent(this.myPositionTextComponents[i]);
            this.myPositionTextComponents[i].text = " ";
            this.myPositionCursorTargetComponents[i] = this.myPositionCursorTargets[i].addComponent("cursor-target");
            this.myPositionCollisionComponents[i] = this.myPositionCursorTargets[i].addComponent("collision");
            this.myPositionCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myPositionCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myPositionCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;
            this.myPositionIncreaseButtonBackgroundComponents[i] = this.myPositionIncreaseButtonBackgrounds[i].addComponent("mesh");
            this.myPositionIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myPositionIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myPositionIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
            this.myPositionIncreaseButtonTextComponents[i] = this.myPositionIncreaseButtonTexts[i].addComponent("text");
            this._setupTextComponent(this.myPositionIncreaseButtonTextComponents[i]);
            this.myPositionIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;
            this.myPositionIncreaseButtonCursorTargetComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].addComponent("cursor-target");
            this.myPositionIncreaseButtonCollisionComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].addComponent("collision");
            this.myPositionIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myPositionIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myPositionIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
            this.myPositionDecreaseButtonBackgroundComponents[i] = this.myPositionDecreaseButtonBackgrounds[i].addComponent("mesh");
            this.myPositionDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myPositionDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myPositionDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
            this.myPositionDecreaseButtonTextComponents[i] = this.myPositionDecreaseButtonTexts[i].addComponent("text");
            this._setupTextComponent(this.myPositionDecreaseButtonTextComponents[i]);
            this.myPositionDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;
            this.myPositionDecreaseButtonCursorTargetComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].addComponent("cursor-target");
            this.myPositionDecreaseButtonCollisionComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].addComponent("collision");
            this.myPositionDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myPositionDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myPositionDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
          }
          this.myRotationLabelTextComponent = this.myRotationLabelText.addComponent("text");
          this._setupTextComponent(this.myRotationLabelTextComponent);
          this.myRotationLabelTextComponent.text = this._mySetup.myRotationText;
          this.myRotationLabelCursorTargetComponent = this.myRotationLabelCursorTarget.addComponent("cursor-target");
          this.myRotationLabelCollisionComponent = this.myRotationLabelCursorTarget.addComponent("collision");
          this.myRotationLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myRotationLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myRotationLabelCollisionComponent.extents = this._mySetup.myComponentLabelCollisionExtents;
          this.myRotationTextComponents = [];
          this.myRotationCursorTargetComponents = [];
          this.myRotationCollisionComponents = [];
          this.myRotationIncreaseButtonBackgroundComponents = [];
          this.myRotationIncreaseButtonTextComponents = [];
          this.myRotationIncreaseButtonCursorTargetComponents = [];
          this.myRotationIncreaseButtonCollisionComponents = [];
          this.myRotationDecreaseButtonBackgroundComponents = [];
          this.myRotationDecreaseButtonTextComponents = [];
          this.myRotationDecreaseButtonCursorTargetComponents = [];
          this.myRotationDecreaseButtonCollisionComponents = [];
          for (let i = 0; i < 3; i++) {
            this.myRotationTextComponents[i] = this.myRotationTexts[i].addComponent("text");
            this._setupTextComponent(this.myRotationTextComponents[i]);
            this.myRotationTextComponents[i].text = " ";
            this.myRotationCursorTargetComponents[i] = this.myRotationCursorTargets[i].addComponent("cursor-target");
            this.myRotationCollisionComponents[i] = this.myRotationCursorTargets[i].addComponent("collision");
            this.myRotationCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myRotationCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myRotationCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;
            this.myRotationIncreaseButtonBackgroundComponents[i] = this.myRotationIncreaseButtonBackgrounds[i].addComponent("mesh");
            this.myRotationIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myRotationIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myRotationIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
            this.myRotationIncreaseButtonTextComponents[i] = this.myRotationIncreaseButtonTexts[i].addComponent("text");
            this._setupTextComponent(this.myRotationIncreaseButtonTextComponents[i]);
            this.myRotationIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;
            this.myRotationIncreaseButtonCursorTargetComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].addComponent("cursor-target");
            this.myRotationIncreaseButtonCollisionComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].addComponent("collision");
            this.myRotationIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myRotationIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myRotationIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
            this.myRotationDecreaseButtonBackgroundComponents[i] = this.myRotationDecreaseButtonBackgrounds[i].addComponent("mesh");
            this.myRotationDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myRotationDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myRotationDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
            this.myRotationDecreaseButtonTextComponents[i] = this.myRotationDecreaseButtonTexts[i].addComponent("text");
            this._setupTextComponent(this.myRotationDecreaseButtonTextComponents[i]);
            this.myRotationDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;
            this.myRotationDecreaseButtonCursorTargetComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].addComponent("cursor-target");
            this.myRotationDecreaseButtonCollisionComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].addComponent("collision");
            this.myRotationDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myRotationDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myRotationDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
          }
          this.myScaleLabelTextComponent = this.myScaleLabelText.addComponent("text");
          this._setupTextComponent(this.myScaleLabelTextComponent);
          this.myScaleLabelTextComponent.text = this._mySetup.myScaleText;
          this.myScaleLabelCursorTargetComponent = this.myScaleLabelCursorTarget.addComponent("cursor-target");
          this.myScaleLabelCollisionComponent = this.myScaleLabelCursorTarget.addComponent("collision");
          this.myScaleLabelCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myScaleLabelCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myScaleLabelCollisionComponent.extents = this._mySetup.myComponentLabelCollisionExtents;
          this.myScaleTextComponents = [];
          this.myScaleCursorTargetComponents = [];
          this.myScaleCollisionComponents = [];
          this.myScaleIncreaseButtonBackgroundComponents = [];
          this.myScaleIncreaseButtonTextComponents = [];
          this.myScaleIncreaseButtonCursorTargetComponents = [];
          this.myScaleIncreaseButtonCollisionComponents = [];
          this.myScaleDecreaseButtonBackgroundComponents = [];
          this.myScaleDecreaseButtonTextComponents = [];
          this.myScaleDecreaseButtonCursorTargetComponents = [];
          this.myScaleDecreaseButtonCollisionComponents = [];
          for (let i = 0; i < 3; i++) {
            this.myScaleTextComponents[i] = this.myScaleTexts[i].addComponent("text");
            this._setupTextComponent(this.myScaleTextComponents[i]);
            this.myScaleTextComponents[i].text = " ";
            this.myScaleCursorTargetComponents[i] = this.myScaleCursorTargets[i].addComponent("cursor-target");
            this.myScaleCollisionComponents[i] = this.myScaleCursorTargets[i].addComponent("collision");
            this.myScaleCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myScaleCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myScaleCollisionComponents[i].extents = this._mySetup.myValueCollisionExtents;
            this.myScaleIncreaseButtonBackgroundComponents[i] = this.myScaleIncreaseButtonBackgrounds[i].addComponent("mesh");
            this.myScaleIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myScaleIncreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myScaleIncreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
            this.myScaleIncreaseButtonTextComponents[i] = this.myScaleIncreaseButtonTexts[i].addComponent("text");
            this._setupTextComponent(this.myScaleIncreaseButtonTextComponents[i]);
            this.myScaleIncreaseButtonTextComponents[i].text = this._mySetup.myIncreaseButtonText;
            this.myScaleIncreaseButtonCursorTargetComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].addComponent("cursor-target");
            this.myScaleIncreaseButtonCollisionComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].addComponent("collision");
            this.myScaleIncreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myScaleIncreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myScaleIncreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
            this.myScaleDecreaseButtonBackgroundComponents[i] = this.myScaleDecreaseButtonBackgrounds[i].addComponent("mesh");
            this.myScaleDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
            this.myScaleDecreaseButtonBackgroundComponents[i].material = this._myAdditionalSetup.myPlaneMaterial.clone();
            this.myScaleDecreaseButtonBackgroundComponents[i].material.color = this._mySetup.myBackgroundColor;
            this.myScaleDecreaseButtonTextComponents[i] = this.myScaleDecreaseButtonTexts[i].addComponent("text");
            this._setupTextComponent(this.myScaleDecreaseButtonTextComponents[i]);
            this.myScaleDecreaseButtonTextComponents[i].text = this._mySetup.myDecreaseButtonText;
            this.myScaleDecreaseButtonCursorTargetComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].addComponent("cursor-target");
            this.myScaleDecreaseButtonCollisionComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].addComponent("collision");
            this.myScaleDecreaseButtonCollisionComponents[i].collider = this._mySetup.myCursorTargetCollisionCollider;
            this.myScaleDecreaseButtonCollisionComponents[i].group = 1 << this._mySetup.myCursorTargetCollisionGroup;
            this.myScaleDecreaseButtonCollisionComponents[i].extents = this._mySetup.mySideButtonCollisionExtents;
          }
          this.myPositionStepTextComponent = this.myPositionStepText.addComponent("text");
          this._setupTextComponent(this.myPositionStepTextComponent);
          this.myPositionStepTextComponent.text = " ";
          this.myPositionStepCursorTargetComponent = this.myPositionStepCursorTarget.addComponent("cursor-target");
          this.myPositionStepCollisionComponent = this.myPositionStepCursorTarget.addComponent("collision");
          this.myPositionStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myPositionStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myPositionStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
          this.myPositionStepIncreaseButtonBackgroundComponent = this.myPositionStepIncreaseButtonBackground.addComponent("mesh");
          this.myPositionStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myPositionStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myPositionStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myPositionStepIncreaseButtonTextComponent = this.myPositionStepIncreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myPositionStepIncreaseButtonTextComponent);
          this.myPositionStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
          this.myPositionStepIncreaseButtonCursorTargetComponent = this.myPositionStepIncreaseButtonCursorTarget.addComponent("cursor-target");
          this.myPositionStepIncreaseButtonCollisionComponent = this.myPositionStepIncreaseButtonCursorTarget.addComponent("collision");
          this.myPositionStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myPositionStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myPositionStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myPositionStepDecreaseButtonBackgroundComponent = this.myPositionStepDecreaseButtonBackground.addComponent("mesh");
          this.myPositionStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myPositionStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myPositionStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myPositionStepDecreaseButtonTextComponent = this.myPositionStepDecreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myPositionStepDecreaseButtonTextComponent);
          this.myPositionStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
          this.myPositionStepDecreaseButtonCursorTargetComponent = this.myPositionStepDecreaseButtonCursorTarget.addComponent("cursor-target");
          this.myPositionStepDecreaseButtonCollisionComponent = this.myPositionStepDecreaseButtonCursorTarget.addComponent("collision");
          this.myPositionStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myPositionStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myPositionStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myRotationStepTextComponent = this.myRotationStepText.addComponent("text");
          this._setupTextComponent(this.myRotationStepTextComponent);
          this.myRotationStepTextComponent.text = " ";
          this.myRotationStepCursorTargetComponent = this.myRotationStepCursorTarget.addComponent("cursor-target");
          this.myRotationStepCollisionComponent = this.myRotationStepCursorTarget.addComponent("collision");
          this.myRotationStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myRotationStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myRotationStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
          this.myRotationStepIncreaseButtonBackgroundComponent = this.myRotationStepIncreaseButtonBackground.addComponent("mesh");
          this.myRotationStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myRotationStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myRotationStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myRotationStepIncreaseButtonTextComponent = this.myRotationStepIncreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myRotationStepIncreaseButtonTextComponent);
          this.myRotationStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
          this.myRotationStepIncreaseButtonCursorTargetComponent = this.myRotationStepIncreaseButtonCursorTarget.addComponent("cursor-target");
          this.myRotationStepIncreaseButtonCollisionComponent = this.myRotationStepIncreaseButtonCursorTarget.addComponent("collision");
          this.myRotationStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myRotationStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myRotationStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myRotationStepDecreaseButtonBackgroundComponent = this.myRotationStepDecreaseButtonBackground.addComponent("mesh");
          this.myRotationStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myRotationStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myRotationStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myRotationStepDecreaseButtonTextComponent = this.myRotationStepDecreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myRotationStepDecreaseButtonTextComponent);
          this.myRotationStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
          this.myRotationStepDecreaseButtonCursorTargetComponent = this.myRotationStepDecreaseButtonCursorTarget.addComponent("cursor-target");
          this.myRotationStepDecreaseButtonCollisionComponent = this.myRotationStepDecreaseButtonCursorTarget.addComponent("collision");
          this.myRotationStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myRotationStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myRotationStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myScaleStepTextComponent = this.myScaleStepText.addComponent("text");
          this._setupTextComponent(this.myScaleStepTextComponent);
          this.myScaleStepTextComponent.text = " ";
          this.myScaleStepCursorTargetComponent = this.myScaleStepCursorTarget.addComponent("cursor-target");
          this.myScaleStepCollisionComponent = this.myScaleStepCursorTarget.addComponent("collision");
          this.myScaleStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myScaleStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myScaleStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
          this.myScaleStepIncreaseButtonBackgroundComponent = this.myScaleStepIncreaseButtonBackground.addComponent("mesh");
          this.myScaleStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myScaleStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myScaleStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myScaleStepIncreaseButtonTextComponent = this.myScaleStepIncreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myScaleStepIncreaseButtonTextComponent);
          this.myScaleStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
          this.myScaleStepIncreaseButtonCursorTargetComponent = this.myScaleStepIncreaseButtonCursorTarget.addComponent("cursor-target");
          this.myScaleStepIncreaseButtonCollisionComponent = this.myScaleStepIncreaseButtonCursorTarget.addComponent("collision");
          this.myScaleStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myScaleStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myScaleStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myScaleStepDecreaseButtonBackgroundComponent = this.myScaleStepDecreaseButtonBackground.addComponent("mesh");
          this.myScaleStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myScaleStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myScaleStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myScaleStepDecreaseButtonTextComponent = this.myScaleStepDecreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myScaleStepDecreaseButtonTextComponent);
          this.myScaleStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
          this.myScaleStepDecreaseButtonCursorTargetComponent = this.myScaleStepDecreaseButtonCursorTarget.addComponent("cursor-target");
          this.myScaleStepDecreaseButtonCollisionComponent = this.myScaleStepDecreaseButtonCursorTarget.addComponent("collision");
          this.myScaleStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myScaleStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myScaleStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
        }
        _addStepComponents() {
          this.myPositionStepTextComponent = this.myPositionStepText.addComponent("text");
          this._setupTextComponent(this.myPositionStepTextComponent);
          this.myPositionStepTextComponent.text = " ";
          this.myPositionStepCursorTargetComponent = this.myPositionStepCursorTarget.addComponent("cursor-target");
          this.myPositionStepCollisionComponent = this.myPositionStepCursorTarget.addComponent("collision");
          this.myPositionStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myPositionStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myPositionStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
          this.myPositionStepIncreaseButtonBackgroundComponent = this.myPositionStepIncreaseButtonBackground.addComponent("mesh");
          this.myPositionStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myPositionStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myPositionStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myPositionStepIncreaseButtonTextComponent = this.myPositionStepIncreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myPositionStepIncreaseButtonTextComponent);
          this.myPositionStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
          this.myPositionStepIncreaseButtonCursorTargetComponent = this.myPositionStepIncreaseButtonCursorTarget.addComponent("cursor-target");
          this.myPositionStepIncreaseButtonCollisionComponent = this.myPositionStepIncreaseButtonCursorTarget.addComponent("collision");
          this.myPositionStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myPositionStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myPositionStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myPositionStepDecreaseButtonBackgroundComponent = this.myPositionStepDecreaseButtonBackground.addComponent("mesh");
          this.myPositionStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myPositionStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myPositionStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myPositionStepDecreaseButtonTextComponent = this.myPositionStepDecreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myPositionStepDecreaseButtonTextComponent);
          this.myPositionStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
          this.myPositionStepDecreaseButtonCursorTargetComponent = this.myPositionStepDecreaseButtonCursorTarget.addComponent("cursor-target");
          this.myPositionStepDecreaseButtonCollisionComponent = this.myPositionStepDecreaseButtonCursorTarget.addComponent("collision");
          this.myPositionStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myPositionStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myPositionStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myRotationStepTextComponent = this.myRotationStepText.addComponent("text");
          this._setupTextComponent(this.myRotationStepTextComponent);
          this.myRotationStepTextComponent.text = " ";
          this.myRotationStepCursorTargetComponent = this.myRotationStepCursorTarget.addComponent("cursor-target");
          this.myRotationStepCollisionComponent = this.myRotationStepCursorTarget.addComponent("collision");
          this.myRotationStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myRotationStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myRotationStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
          this.myRotationStepIncreaseButtonBackgroundComponent = this.myRotationStepIncreaseButtonBackground.addComponent("mesh");
          this.myRotationStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myRotationStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myRotationStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myRotationStepIncreaseButtonTextComponent = this.myRotationStepIncreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myRotationStepIncreaseButtonTextComponent);
          this.myRotationStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
          this.myRotationStepIncreaseButtonCursorTargetComponent = this.myRotationStepIncreaseButtonCursorTarget.addComponent("cursor-target");
          this.myRotationStepIncreaseButtonCollisionComponent = this.myRotationStepIncreaseButtonCursorTarget.addComponent("collision");
          this.myRotationStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myRotationStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myRotationStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myRotationStepDecreaseButtonBackgroundComponent = this.myRotationStepDecreaseButtonBackground.addComponent("mesh");
          this.myRotationStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myRotationStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myRotationStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myRotationStepDecreaseButtonTextComponent = this.myRotationStepDecreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myRotationStepDecreaseButtonTextComponent);
          this.myRotationStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
          this.myRotationStepDecreaseButtonCursorTargetComponent = this.myRotationStepDecreaseButtonCursorTarget.addComponent("cursor-target");
          this.myRotationStepDecreaseButtonCollisionComponent = this.myRotationStepDecreaseButtonCursorTarget.addComponent("collision");
          this.myRotationStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myRotationStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myRotationStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myScaleStepTextComponent = this.myScaleStepText.addComponent("text");
          this._setupTextComponent(this.myScaleStepTextComponent);
          this.myScaleStepTextComponent.text = " ";
          this.myScaleStepCursorTargetComponent = this.myScaleStepCursorTarget.addComponent("cursor-target");
          this.myScaleStepCollisionComponent = this.myScaleStepCursorTarget.addComponent("collision");
          this.myScaleStepCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myScaleStepCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myScaleStepCollisionComponent.extents = this._mySetup.myStepCollisionExtents;
          this.myScaleStepIncreaseButtonBackgroundComponent = this.myScaleStepIncreaseButtonBackground.addComponent("mesh");
          this.myScaleStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myScaleStepIncreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myScaleStepIncreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myScaleStepIncreaseButtonTextComponent = this.myScaleStepIncreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myScaleStepIncreaseButtonTextComponent);
          this.myScaleStepIncreaseButtonTextComponent.text = this._mySetup.myIncreaseButtonText;
          this.myScaleStepIncreaseButtonCursorTargetComponent = this.myScaleStepIncreaseButtonCursorTarget.addComponent("cursor-target");
          this.myScaleStepIncreaseButtonCollisionComponent = this.myScaleStepIncreaseButtonCursorTarget.addComponent("collision");
          this.myScaleStepIncreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myScaleStepIncreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myScaleStepIncreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
          this.myScaleStepDecreaseButtonBackgroundComponent = this.myScaleStepDecreaseButtonBackground.addComponent("mesh");
          this.myScaleStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myScaleStepDecreaseButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myScaleStepDecreaseButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myScaleStepDecreaseButtonTextComponent = this.myScaleStepDecreaseButtonText.addComponent("text");
          this._setupTextComponent(this.myScaleStepDecreaseButtonTextComponent);
          this.myScaleStepDecreaseButtonTextComponent.text = this._mySetup.myDecreaseButtonText;
          this.myScaleStepDecreaseButtonCursorTargetComponent = this.myScaleStepDecreaseButtonCursorTarget.addComponent("cursor-target");
          this.myScaleStepDecreaseButtonCollisionComponent = this.myScaleStepDecreaseButtonCursorTarget.addComponent("collision");
          this.myScaleStepDecreaseButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myScaleStepDecreaseButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myScaleStepDecreaseButtonCollisionComponent.extents = this._mySetup.mySideButtonCollisionExtents;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_setup.js
  var require_easy_tune_transform_widget_setup = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_setup.js"() {
      PP.EasyTuneTransformWidgetSetup = class EasyTuneTransformWidgetSetup extends PP.EasyTuneBaseWidgetSetup {
        _getBackPanelMinY() {
          return super._getBackPanelMinY() + this.myPositionPanelPosition[1] + this.myStepPanelPosition[1];
        }
        _getBackPanelMaxX() {
          return this.myDisplayPanelPosition[0] + this.myRotationPanelPosition[0] + this.myIncreaseButtonPosition[0] + this.mySideButtonBackgroundScale[0] + this._mySideButtonDistanceFromBorder;
        }
        _getBackPanelMinX() {
          return this.myDisplayPanelPosition[0] + this.myScalePanelPosition[0] + this.myDecreaseButtonPosition[0] - this.mySideButtonBackgroundScale[0] - this._mySideButtonDistanceFromBorder;
        }
        _getPivotZOffset() {
          return 805713e-8;
        }
        _initializeBuildSetupHook() {
          this.myIncreaseButtonText = "+";
          this.myDecreaseButtonText = "-";
          this.myDecreaseButtonPosition = PP.vec3_create(-0.13, 0, -1e-5);
          this.myIncreaseButtonPosition = PP.vec3_create(-this.myDecreaseButtonPosition[0], 0, -1e-5);
          let distanceBetweenComponents = Math.abs(this.myIncreaseButtonPosition[0]) + Math.abs(this.myRightSideButtonPosition[0]);
          let distanceFromVariableLabel = 0.045;
          this.myPositionPanelPosition = [0, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
          this.myRotationPanelPosition = [this.myPositionPanelPosition[0] + distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
          this.myScalePanelPosition = [this.myPositionPanelPosition[0] - distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
          this.myPositionText = "Position";
          this.myRotationText = "Rotation";
          this.myScaleText = "Scale";
          this.myComponentLabelTextScale = this.myLabelTextScale;
          this.myComponentLabelCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myComponentLabelCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
          this.myComponentLabelCollisionExtents = PP.vec3_create(0.065, 0.0175, 1);
          this.myComponentLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;
          this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
          this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
          this.myValueTextScale = PP.vec3_create(0.4, 0.4, 0.4);
          this.myValueCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
          this.myValueCollisionExtents = PP.vec3_create(0.065, 0.02, 1);
          this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
          this.myValuePanelsPositions = [];
          this.myValuePanelsPositions[0] = PP.vec3_create(0, -this._myValuePanelDistanceFromVariableLabelPanel, 0);
          for (let i = 1; i < 3; i++) {
            this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].slice(0);
            this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
          }
          let valuePanelLastPosition = this.myValuePanelsPositions[2][1];
          this.myStepPanelPosition = [0, valuePanelLastPosition - this._myValuePanelDistanceFromVariableLabelPanel, 0];
          this.myStepTextScale = this.myLabelTextScale;
          this.myStepStartString = "Step: ";
          this.myStepCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myStepCursorTargetPosition[2] = this._myColliderZOffset - this.myStepPanelPosition[2];
          this.myStepCollisionExtents = PP.vec3_create(0.065, 0.0175, 1);
          this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;
        }
        _initializeRuntimeSetupHook() {
          this.myTextHoverScaleMultiplier = PP.vec3_create(1.25, 1.25, 1.25);
          this.myEditThumbstickMinThreshold = 0.35;
          this.myStepMultiplierStepPerSecond = 2.25;
          this.myButtonEditDelay = 0;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/easy_tune_widget.js
  var require_easy_tune_widget = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/easy_tune_widget.js"() {
      PP.EasyTuneWidgetAdditionalSetup = class EasyTuneWidgetAdditionalSetup {
        constructor() {
          this.myHandedness = PP.ToolHandedness.NONE;
          this.myShowOnStart = false;
          this.myShowVisibilityButton = false;
          this.myEnableAdditionalButtons = false;
          this.myEnableGamepadScrollVariable = false;
          this.myPlaneMaterial = null;
          this.myTextMaterial = null;
          this.myEnableVariablesImportExportButtons = false;
          this.myVariablesImportCallback = null;
          this.myVariablesExportCallback = null;
        }
      };
      PP.EasyTuneWidget = class EasyTuneWidget {
        constructor() {
          this._myIsStarted = false;
          this._myStartVariable = null;
          this._myWidgetFrame = new PP.WidgetFrame("E", 1);
          this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));
          this._mySetup = new PP.EasyTuneWidgetSetup();
          this._myAdditionalSetup = null;
          this._myWidgets = [];
          this._myEasyTuneVariables = null;
          this._myEasyTuneLastSize = 0;
          this._myVariableNames = null;
          this._myCurrentWidget = null;
          this._myCurrentVariable = null;
          this._myScrollVariableTimer = 0;
          this._myGamepad = null;
          this._myRefreshVariablesTimer = 0;
          this._myDirty = false;
        }
        setActiveVariable(variableName) {
          if (!this._myIsStarted) {
            this._myStartVariable = variableName;
          } else if (this._myEasyTuneVariables.has(variableName)) {
            this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(variableName);
            this._selectCurrentWidget();
          } else {
            console.log("Can't set easy tune active variable");
          }
        }
        refresh() {
          if (this._myWidgetFrame.myIsWidgetVisible) {
            this._myDirty = true;
          }
        }
        setVisible(visible) {
          this._myWidgetFrame.setVisible(visible);
        }
        isVisible() {
          return this._myWidgetFrame.isVisible();
        }
        start(parentObject, additionalSetup, easyTuneVariables) {
          this._myRightGamepad = PP.myRightGamepad;
          this._myLeftGamepad = PP.myLeftGamepad;
          if (this._mySetup.myGamepadHandedness == PP.ToolHandedness.RIGHT) {
            this._myGamepad = this._myRightGamepad;
          } else if (this._mySetup.myGamepadHandedness == PP.ToolHandedness.LEFT) {
            this._myGamepad = this._myLeftGamepad;
          }
          this._myIsStarted = true;
          this._myAdditionalSetup = additionalSetup;
          this._myWidgetFrame.start(parentObject, additionalSetup);
          this._myEasyTuneVariables = easyTuneVariables;
          this._myEasyTuneLastSize = this._myEasyTuneVariables.length();
          this._myVariableNames = this._myEasyTuneVariables.getEasyTuneVariablesNames();
          if (this._myEasyTuneVariables.length() > 0) {
            this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
          }
          if (this._myStartVariable) {
            if (this._myEasyTuneVariables.has(this._myStartVariable)) {
              this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myStartVariable);
            } else {
              console.log("Can't set easy tune active variable");
            }
          }
          this._initializeWidgets();
        }
        update(dt) {
          this._myWidgetFrame.update(dt);
          if (this._myEasyTuneVariables.length() != this._myEasyTuneLastSize || this._myDirty) {
            this._refreshEasyTuneVariables();
          }
          if (this._myWidgetFrame.myIsWidgetVisible && this._myEasyTuneVariables.length() > 0) {
            if (this._mySetup.myRefreshVariablesDelay != null) {
              this._myRefreshVariablesTimer += dt;
              if (this._myRefreshVariablesTimer > this._mySetup.myRefreshVariablesDelay) {
                this._myRefreshVariablesTimer = 0;
                this._refreshEasyTuneVariables();
              }
            }
            if (this._myCurrentWidget) {
              this._myCurrentWidget.update(dt);
            }
            if (this._myAdditionalSetup.myEnableGamepadScrollVariable) {
              this._updateGamepadScrollVariable(dt);
            }
          }
          this._updateGamepadWidgetVisibility();
          this._updateActiveVariable();
        }
        _initializeWidgets() {
          let widgetParams = new PP.EasyTuneBaseWidgetParams();
          widgetParams.myVariablesImportCallback = this._importVariables.bind(this);
          widgetParams.myVariablesExportCallback = this._exportVariables.bind(this);
          this._myWidgets[PP.EasyTuneVariableType.NONE] = new PP.EasyTuneNoneWidget(widgetParams);
          this._myWidgets[PP.EasyTuneVariableType.NUMBER] = new PP.EasyTuneNumberArrayWidgetSelector(widgetParams, this._myGamepad);
          this._myWidgets[PP.EasyTuneVariableType.BOOL] = new PP.EasyTuneBoolArrayWidgetSelector(widgetParams, this._myGamepad);
          this._myWidgets[PP.EasyTuneVariableType.TRANSFORM] = new PP.EasyTuneTransformWidget(widgetParams, this._myGamepad);
          for (let widget of this._myWidgets) {
            if (widget != null) {
              widget.start(this._myWidgetFrame.getWidgetObject(), this._myAdditionalSetup);
              widget.setVisible(false);
              widget.registerScrollVariableRequestEventListener(this, this._scrollVariable.bind(this));
            }
          }
          this._selectCurrentWidget();
        }
        _selectCurrentWidget() {
          if (this._myEasyTuneVariables.length() <= 0) {
            return;
          }
          let prevWidget = null;
          if (this._myCurrentWidget != null) {
            prevWidget = this._myCurrentWidget.getWidget();
          }
          if (this._myCurrentVariable.myType in this._myWidgets) {
            this._myCurrentWidget = this._myWidgets[this._myCurrentVariable.myType];
          } else {
            this._myCurrentWidget = this._myWidgets[PP.EasyTuneVariableType.NONE];
          }
          this._myCurrentWidget.setEasyTuneVariable(this._myCurrentVariable, this._createIndexString());
          this._myCurrentWidget.getWidget().syncWidget(prevWidget);
          if (prevWidget != null) {
            prevWidget.setVisible(false);
          }
          this._myCurrentWidget.setVisible(this._myWidgetFrame.myIsWidgetVisible);
        }
        _refreshEasyTuneVariables() {
          this._myVariableNames = this._myEasyTuneVariables.getEasyTuneVariablesNames();
          this._myEasyTuneLastSize = this._myEasyTuneVariables.length();
          if (this._myEasyTuneVariables.length() > 0) {
            if (this._myCurrentVariable && this._myEasyTuneVariables.has(this._myCurrentVariable.myName)) {
              this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myCurrentVariable.myName);
            } else {
              this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
            }
            this._selectCurrentWidget();
          } else {
            this._myCurrentVariable = null;
            if (this._myCurrentWidget) {
              this._myCurrentWidget.setVisible(false);
              this._myCurrentWidget = null;
            }
          }
          this._myDirty = false;
        }
        _updateGamepadWidgetVisibility() {
          if (this._myGamepad) {
            if (this._myGamepad.getButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).myIsPressed || this._myGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON).myIsPressed) {
              this._toggleVisibility();
            }
          }
        }
        _toggleVisibility() {
          this._myWidgetFrame.toggleVisibility();
        }
        _widgetVisibleChanged(visible) {
          for (let widget of this._myWidgets) {
            if (widget != null) {
              widget.setVisible(false);
            }
          }
          if (this._myCurrentWidget) {
            if (this._myEasyTuneVariables.length() > 0) {
              this._myCurrentWidget.setVisible(visible);
            } else {
              this._myCurrentWidget.setVisible(false);
            }
          }
          if (visible) {
            this._refreshEasyTuneVariables();
          }
        }
        _updateGamepadScrollVariable(dt) {
          if (this._myGamepad && (!this._mySetup.myScrollVariableButtonID || this._myGamepad.getButtonInfo(this._mySetup.myScrollVariableButtonID).myIsPressed)) {
            let x = this._myGamepad.getAxesInfo().myAxes[0];
            let y = this._myGamepad.getAxesInfo().myAxes[1];
            if (Math.abs(x) > this._mySetup.myScrollVariableMinXThreshold && Math.abs(y) < this._mySetup.myScrollVariableMaxYThreshold) {
              this._myScrollVariableTimer += dt;
              while (this._myScrollVariableTimer > this._mySetup.myScrollVariableDelay) {
                this._myScrollVariableTimer -= this._mySetup.myScrollVariableDelay;
                this._scrollVariable(Math.sign(x));
              }
            } else {
              this._myScrollVariableTimer = this._mySetup.myScrollVariableDelay;
            }
          } else {
            this._myScrollVariableTimer = this._mySetup.myScrollVariableDelay;
          }
        }
        _scrollVariable(amount) {
          if (this._myEasyTuneVariables.length() <= 0) {
            return;
          }
          let variableIndex = this._getVariableIndex(this._myCurrentVariable);
          if (variableIndex >= 0) {
            let newIndex = ((variableIndex + amount) % this._myVariableNames.length + this._myVariableNames.length) % this._myVariableNames.length;
            if (this._myEasyTuneVariables.has(this._myVariableNames[newIndex])) {
              this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[newIndex]);
              this._selectCurrentWidget();
            } else {
              this._refreshEasyTuneVariables();
            }
          } else {
            this._refreshEasyTuneVariables();
          }
        }
        _createIndexString() {
          let indexString = " (";
          let index = (this._getVariableIndex(this._myCurrentVariable) + 1).toString();
          let length6 = this._myEasyTuneVariables.length().toString();
          while (index.length < length6.length) {
            index = "0".concat(index);
          }
          indexString = indexString.concat(index).concat(" - ").concat(length6).concat(")");
          return indexString;
        }
        _getVariableIndex(variable) {
          let variableIndex = this._myVariableNames.indexOf(variable.myName);
          return variableIndex;
        }
        _updateActiveVariable() {
          this._myEasyTuneVariables.getEasyTuneVariables().forEach(function(value) {
            value.myIsActive = false;
          });
          if (this._myWidgetFrame.myIsWidgetVisible && this._myCurrentVariable) {
            this._myCurrentVariable.myIsActive = true;
          }
        }
        _importVariables() {
          this._myAdditionalSetup.myVariablesImportCallback(this._onImportSuccess.bind(this), this._onImportFailure.bind(this));
        }
        _exportVariables() {
          this._myAdditionalSetup.myVariablesExportCallback(this._onExportSuccess.bind(this), this._onExportFailure.bind(this));
        }
        _onImportSuccess() {
          if (this._myCurrentWidget) {
            this._myCurrentWidget.onImportSuccess();
          }
        }
        _onImportFailure() {
          if (this._myCurrentWidget) {
            this._myCurrentWidget.onImportFailure();
          }
        }
        _onExportSuccess() {
          if (this._myCurrentWidget) {
            this._myCurrentWidget.onExportSuccess();
          }
        }
        _onExportFailure() {
          if (this._myCurrentWidget) {
            this._myCurrentWidget.onExportFailure();
          }
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_widgets/easy_tune_widget_setup.js
  var require_easy_tune_widget_setup = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_widgets/easy_tune_widget_setup.js"() {
      PP.EasyTuneWidgetSetup = class EasyTuneWidgetSetup {
        constructor() {
          this._initializeRuntimeSetup();
        }
        _initializeRuntimeSetup() {
          this.myGamepadHandedness = PP.ToolHandedness.RIGHT;
          this.myScrollVariableDelay = 0.5;
          this.myScrollVariableMinXThreshold = 0.6;
          this.myScrollVariableMaxYThreshold = 0.25;
          this.myScrollVariableButtonID = null;
          this.myRefreshVariablesDelay = null;
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_variables.js
  var require_easy_tune_variables = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_variables.js"() {
      PP.EasyTuneVariables = class EasyTuneVariables {
        constructor() {
          this._myVariables = /* @__PURE__ */ new Map();
        }
        add(variable) {
          this._myVariables.set(variable.myName, variable);
        }
        remove(variableName) {
          this._myVariables.delete(variableName);
        }
        get(variableName) {
          let variable = this._myVariables.get(variableName);
          if (variable) {
            return variable.getValue();
          }
          return null;
        }
        set(variableName, value, resetDefaultValue = false) {
          let variable = this._myVariables.get(variableName);
          if (variable) {
            variable.setValue(value, resetDefaultValue);
          }
        }
        has(variableName) {
          return this._myVariables.has(variableName);
        }
        length() {
          return this._myVariables.size;
        }
        isActive(variableName) {
          let variable = this._myVariables.get(variableName);
          if (variable) {
            return variable.myIsActive;
          }
          return false;
        }
        getEasyTuneVariable(variableName) {
          return this._myVariables.get(variableName);
        }
        getEasyTuneVariables() {
          return Array.from(this._myVariables.values());
        }
        getEasyTuneVariablesNames() {
          return Array.from(this._myVariables.keys());
        }
        fromJSON(json, resetDefaultValue = false) {
          let objectJSON = JSON.parse(json);
          for (let variable of this._myVariables.values()) {
            let variableValueJSON = objectJSON[variable.myName];
            if (variableValueJSON !== void 0) {
              variable.fromJSON(variableValueJSON, resetDefaultValue);
            }
          }
        }
        toJSON() {
          let objectJSON = {};
          for (let variable of this._myVariables.values()) {
            objectJSON[variable.myName] = variable.toJSON();
          }
          return JSON.stringify(objectJSON);
        }
        registerValueChangedEventListener(variableName, callbackID, callback) {
          this._myVariables.get(variableName).registerValueChangedEventListener(callbackID, callback);
        }
        unregisterValueChangedEventListener(variableName, callbackID, callback) {
          this._myVariables.get(variableName).unregisterValueChangedEventListener(callbackID);
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_variable_types.js
  var require_easy_tune_variable_types = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_variable_types.js"() {
      PP.EasyTuneVariableType = {
        NONE: 0,
        NUMBER: 1,
        BOOL: 2,
        TRANSFORM: 3
      };
      PP.EasyTuneVariable = class EasyTuneVariable {
        constructor(name, type) {
          this.myName = name.slice(0);
          this.myType = type;
          this.myValue = null;
          this.myDefaultValue = null;
          this.myIsActive = false;
          this._myValueChangedCallbacks = /* @__PURE__ */ new Map();
        }
        getValue() {
          return this.myValue;
        }
        setValue(value, resetDefaultValue = false) {
          let oldValue = this.myValue;
          this.myValue = value;
          if (resetDefaultValue) {
            PP.EasyTuneVariable.prototype.setDefaultValue.call(this, value);
          }
          PP.refreshEasyTuneWidget();
          if (oldValue != value) {
            this._triggerValueChangedCallback();
          }
        }
        setDefaultValue(value) {
          this.myDefaultValue = value;
        }
        fromJSON(valueJSON, resetDefaultValue = false) {
          this.setValue(JSON.parse(valueJSON), resetDefaultValue);
        }
        toJSON() {
          return JSON.stringify(this.getValue());
        }
        registerValueChangedEventListener(id, callback) {
          this._myValueChangedCallbacks.set(id, callback);
        }
        unregisterValueChangedEventListener(id) {
          this._myValueChangedCallbacks.delete(id);
        }
        _triggerValueChangedCallback() {
          if (this._myValueChangedCallbacks.size > 0) {
            this._myValueChangedCallbacks.forEach(function(callback) {
              callback(this.myName, this.getValue());
            }.bind(this));
          }
        }
      };
      PP.EasyTuneVariableArray = class EasyTuneVariableArray extends PP.EasyTuneVariable {
        constructor(name, type, value) {
          super(name, type);
          PP.EasyTuneVariableArray.prototype.setValue.call(this, value, true);
        }
        getValue() {
          return this.myValue.slice(0);
        }
        setValue(value, resetDefaultValue = false) {
          let oldValue = this.myValue;
          this.myValue = value.slice(0);
          if (resetDefaultValue) {
            PP.EasyTuneVariableArray.prototype.setDefaultValue.call(this, value);
          }
          PP.refreshEasyTuneWidget();
          if (oldValue == null || !oldValue.pp_equals(value)) {
            this._triggerValueChangedCallback();
          }
        }
        setDefaultValue(value) {
          this.myDefaultValue = value.slice(0);
        }
      };
      PP.EasyTuneNumberArray = class EasyTuneNumberArray extends PP.EasyTuneVariableArray {
        constructor(name, value, stepPerSecond, decimalPlaces, min4 = null, max4 = null, editAllValuesTogether = false) {
          super(name, PP.EasyTuneVariableType.NUMBER, value);
          this.myDecimalPlaces = decimalPlaces;
          this.myStepPerSecond = stepPerSecond;
          this.myDefaultStepPerSecond = this.myStepPerSecond;
          this.myMin = min4;
          this.myMax = max4;
          this.myEditAllValuesTogether = editAllValuesTogether;
          this._clampValue(true);
        }
        setMax(max4) {
          this.myMax = max4;
          this._clampValue(false);
        }
        setMin(min4) {
          this.myMin = min4;
          this._clampValue(false);
        }
        _clampValue(resetDefaultValue) {
          let clampedValue = this.myValue.vec_clamp(this.myMin, this.myMax);
          if (!resetDefaultValue) {
            let clampedDefaultValue = this.myDefaultValue.vec_clamp(this.myMin, this.myMax);
            let defaultValueChanged = !clampedDefaultValue.vec_equals(this.myDefaultValue, 1e-5);
            if (defaultValueChanged) {
              PP.EasyTuneVariableArray.prototype.setDefaultValue.call(this, clampedDefaultValue);
            }
          }
          PP.EasyTuneVariableArray.prototype.setValue.call(this, clampedValue, resetDefaultValue);
        }
      };
      PP.EasyTuneNumber = class EasyTuneNumber extends PP.EasyTuneNumberArray {
        constructor(name, value, stepPerSecond, decimalPlaces, min4, max4) {
          super(name, [value], stepPerSecond, decimalPlaces, min4, max4);
        }
        getValue() {
          return this.myValue[0];
        }
        setValue(value, resetDefaultValue = false) {
          super.setValue([value], resetDefaultValue);
        }
        setDefaultValue(value) {
          super.setValue([value]);
        }
      };
      PP.EasyTuneInt = class EasyTuneInt extends PP.EasyTuneNumber {
        constructor(name, value, stepPerSecond, min4, max4) {
          super(name, value, stepPerSecond, 0, min4, max4);
        }
      };
      PP.EasyTuneIntArray = class EasyTuneIntArray extends PP.EasyTuneNumberArray {
        constructor(name, value, stepPerSecond, min4, max4, editAllValuesTogether) {
          let tempValue = value.slice(0);
          for (let i = 0; i < value.length; i++) {
            tempValue[i] = Math.round(tempValue[i]);
          }
          super(name, tempValue, stepPerSecond, 0, min4 != null ? Math.round(min4) : null, max4 != null ? Math.round(max4) : max4, editAllValuesTogether);
        }
      };
      PP.EasyTuneBoolArray = class EasyTuneBoolArray extends PP.EasyTuneVariableArray {
        constructor(name, value) {
          super(name, PP.EasyTuneVariableType.BOOL, value);
        }
      };
      PP.EasyTuneBool = class EasyTuneBool extends PP.EasyTuneBoolArray {
        constructor(name, value) {
          super(name, [value]);
        }
        getValue() {
          return this.myValue[0];
        }
        setValue(value, resetDefaultValue = false) {
          super.setValue([value], resetDefaultValue);
        }
        setDefaultValue(value) {
          super.setValue([value]);
        }
      };
      PP.EasyTuneTransform = class EasyTuneTransform extends PP.EasyTuneVariable {
        constructor(name, value, scaleAsOne = true, positionStepPerSecond = 1, rotationStepPerSecond = 50, scaleStepPerSecond = 1) {
          super(name, PP.EasyTuneVariableType.TRANSFORM);
          this.myDecimalPlaces = 3;
          this.myPosition = value.mat4_getPosition();
          this.myRotation = value.mat4_getRotationDegrees();
          this.myScale = value.mat4_getScale();
          let decimalPlacesMultiplier = Math.pow(10, this.myDecimalPlaces);
          for (let i = 0; i < 3; i++) {
            this.myScale[i] = Math.max(this.myScale[i], 1 / decimalPlacesMultiplier);
          }
          this.myScaleAsOne = scaleAsOne;
          this.myPositionStepPerSecond = positionStepPerSecond;
          this.myRotationStepPerSecond = rotationStepPerSecond;
          this.myScaleStepPerSecond = scaleStepPerSecond;
          this.myDefaultPosition = this.myPosition.vec3_clone();
          this.myDefaultRotation = this.myRotation.vec3_clone();
          this.myDefaultScale = this.myScale.vec3_clone();
          this.myDefaultPositionStepPerSecond = this.myPositionStepPerSecond;
          this.myDefaultRotationStepPerSecond = this.myRotationStepPerSecond;
          this.myDefaultScaleStepPerSecond = this.myScaleStepPerSecond;
          this.myTransform = PP.mat4_create();
          this.myTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);
          this.myTempTransform = PP.mat4_create();
        }
        getValue() {
          this.myTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);
          return this.myTransform.slice(0);
        }
        setValue(value, resetDefaultValue = false) {
          this.myTempTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);
          value.mat4_getPosition(this.myPosition);
          value.mat4_getRotationDegrees(this.myRotation);
          value.mat4_getScale(this.myScale);
          this.myTransform.mat4_setPositionRotationDegreesScale(this.myPosition, this.myRotation, this.myScale);
          if (resetDefaultValue) {
            PP.EasyTuneTransform.prototype.setDefaultValue.call(this, value);
          }
          PP.refreshEasyTuneWidget();
          if (!this.myTempTransform.pp_equals(this.myTransform)) {
            this._triggerValueChangedCallback();
          }
        }
        setDefaultValue(value) {
          this.myDefaultPosition = value.mat4_getPosition();
          this.myDefaultRotation = value.mat4_getRotationDegrees();
          this.myDefaultScale = value.mat4_getScale();
        }
        fromJSON(valueJSON, resetDefaultValue = false) {
          this.setValue(JSON.parse(valueJSON), resetDefaultValue);
        }
        toJSON() {
          return this.getValue().vec_toString();
        }
      };
    }
  });

  // js/pp/tool/easy_tune/easy_tune_globals.js
  var require_easy_tune_globals = __commonJS({
    "js/pp/tool/easy_tune/easy_tune_globals.js"() {
      PP.myEasyTuneVariables = new PP.EasyTuneVariables();
      PP.myEasyTuneTarget = null;
      PP.importEasyTuneVariables = function(fileURL = null, resetVariablesDefaultValueOnImport = false, onSuccessCallback = null, onFailureCallback = null) {
        if (fileURL == null || fileURL.length == 0) {
          if (navigator.clipboard) {
            navigator.clipboard.readText().then(
              function(clipboard) {
                PP.myEasyTuneVariables.fromJSON(clipboard, resetVariablesDefaultValueOnImport);
                PP.refreshEasyTuneWidget();
                if (onSuccessCallback != null) {
                  onSuccessCallback();
                }
                console.log("Easy Tune Variables Imported from: clipboard");
                console.log(clipboard);
              },
              function() {
                if (onFailureCallback != null) {
                  onFailureCallback();
                }
                console.error("An error occurred while importing the easy tune variables from: clipboard");
              }
            ).catch(function(reason) {
              if (onFailureCallback != null) {
                onFailureCallback();
              }
              console.error("An error occurred while importing the easy tune variables from: clipboard");
              console.error(reason);
            });
          }
        } else {
          let replacedFileURL = PP._importExportEasyTuneVariablesReplaceFileURLParams(fileURL);
          fetch(replacedFileURL).then(
            function(response) {
              if (response.ok) {
                response.text().then(
                  function(text) {
                    PP.myEasyTuneVariables.fromJSON(text, resetVariablesDefaultValueOnImport);
                    PP.refreshEasyTuneWidget();
                    if (onSuccessCallback != null) {
                      onSuccessCallback();
                    }
                    console.log("Easy Tune Variables Imported from:", replacedFileURL);
                    console.log(text);
                  },
                  function(response2) {
                    if (onFailureCallback != null) {
                      onFailureCallback();
                    }
                    console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
                    console.error(response2);
                  }
                );
              } else {
                if (onFailureCallback != null) {
                  onFailureCallback();
                }
                console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
                console.error(response);
              }
            },
            function(response) {
              if (onFailureCallback != null) {
                onFailureCallback();
              }
              console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
              console.error(response);
            }
          ).catch(function(reason) {
            if (onFailureCallback != null) {
              onFailureCallback();
            }
            console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
            console.error(reason);
          });
        }
        PP.refreshEasyTuneWidget();
      };
      PP.exportEasyTuneVariables = function(fileURL = null, onSuccessCallback = null, onFailureCallback = null) {
        let jsonVariables = PP.myEasyTuneVariables.toJSON();
        if (fileURL == null || fileURL.length == 0) {
          if (navigator.clipboard) {
            navigator.clipboard.writeText(jsonVariables).then(
              function() {
                if (onSuccessCallback != null) {
                  onSuccessCallback();
                }
                console.log("Easy Tune Variables Exported to: clipboard");
                console.log(jsonVariables);
              },
              function() {
                if (onFailureCallback != null) {
                  onFailureCallback();
                }
                console.error("An error occurred while exporting the easy tune variables to: clipboard");
              }
            ).catch(function(reason) {
              if (onFailureCallback != null) {
                onFailureCallback();
              }
              console.error("An error occurred while exporting the easy tune variables to: clipboard");
              console.error(reason);
            });
          }
        } else {
          let replacedFileURL = PP._importExportEasyTuneVariablesReplaceFileURLParams(fileURL);
          fetch(replacedFileURL, {
            headers: {
              "Accept": "application/json",
              "Content-Type": "application/json"
            },
            method: "POST",
            body: jsonVariables
          }).then(
            function(response) {
              if (response.ok) {
                if (onSuccessCallback != null) {
                  onSuccessCallback();
                }
                console.log("Easy Tune Variables Exported to:", replacedFileURL);
                console.log(jsonVariables);
              } else {
                if (onFailureCallback != null) {
                  onFailureCallback();
                }
                console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
                console.error(response);
              }
            },
            function(response) {
              if (onFailureCallback != null) {
                onFailureCallback();
              }
              console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
              console.error(response);
            }
          ).catch(function(reason) {
            if (onFailureCallback != null) {
              onFailureCallback();
            }
            console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
            console.error(reason);
          });
        }
      };
      PP.mySetEasyTuneWidgetActiveVariableCallbacks = [];
      PP.setEasyTuneWidgetActiveVariable = function(variableName) {
        for (let callback of PP.mySetEasyTuneWidgetActiveVariableCallbacks) {
          callback(variableName);
        }
      };
      PP.myRefreshEasyTuneWidgetCallbacks = [];
      PP.refreshEasyTuneWidget = function() {
        for (let callback of PP.myRefreshEasyTuneWidgetCallbacks) {
          callback();
        }
      };
      PP._importExportEasyTuneVariablesReplaceFileURLParams = function(fileURL) {
        let params = fileURL.match(/\{.+?\}/g);
        if (params == null || params.length == 0) {
          return fileURL;
        }
        for (let i = 0; i < params.length; i++) {
          params[i] = params[i].replace("{", "");
          params[i] = params[i].replace("}", "");
        }
        let urlSearchParams = new URL(window.location).searchParams;
        let replacedFileURL = fileURL;
        for (let param of params) {
          let searchParamValue = urlSearchParams.get(param);
          if (searchParamValue != null) {
            replacedFileURL = replacedFileURL.replace("{" + param + "}", searchParamValue);
          }
        }
        return replacedFileURL;
      };
    }
  });

  // js/pp/tool/easy_tune/components/easy_tune_component.js
  var require_easy_tune_component = __commonJS({
    "js/pp/tool/easy_tune/components/easy_tune_component.js"() {
      WL.registerComponent("pp-easy-tune", {
        _myHandedness: { type: WL.Type.Enum, values: ["none", "left", "right"], default: "none" },
        _myShowOnStart: { type: WL.Type.Bool, default: false },
        _myShowVisibilityButton: { type: WL.Type.Bool, default: false },
        _myEnableGamepadScrollVariable: { type: WL.Type.Bool, default: true },
        _myEnableVariablesImportExportButtons: { type: WL.Type.Bool, default: false },
        _myVariablesImportURL: { type: WL.Type.String, default: "" },
        // the URL can contain parameters inside brackets, like {param}
        _myVariablesExportURL: { type: WL.Type.String, default: "" },
        // those parameters will be replaced with the same one on the current page url, like www.currentpage.com/?param=2
        _myImportVariablesOnStart: { type: WL.Type.Bool, default: false },
        _myResetVariablesDefaultValueOnImport: { type: WL.Type.Bool, default: false }
      }, {
        init: function() {
          this._myWidget = new PP.EasyTuneWidget();
          PP.mySetEasyTuneWidgetActiveVariableCallbacks.push(function(variableName) {
            this._myWidget.setActiveVariable(variableName);
          }.bind(this));
          PP.myRefreshEasyTuneWidgetCallbacks.push(function() {
            this._myWidget.refresh();
          }.bind(this));
          this._myStarted = false;
        },
        start: function() {
          let additionalSetup = new PP.EasyTuneWidgetAdditionalSetup();
          additionalSetup.myHandedness = [null, "left", "right"][this._myHandedness];
          additionalSetup.myShowOnStart = this._myShowOnStart;
          additionalSetup.myShowVisibilityButton = this._myShowVisibilityButton;
          additionalSetup.myEnableAdditionalButtons = true;
          additionalSetup.myEnableGamepadScrollVariable = this._myEnableGamepadScrollVariable;
          additionalSetup.myPlaneMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
          additionalSetup.myTextMaterial = PP.myDefaultResources.myMaterials.myText.clone();
          additionalSetup.myEnableVariablesImportExportButtons = this._myEnableVariablesImportExportButtons;
          additionalSetup.myVariablesImportCallback = function(onSuccessCallback, onFailureCallback) {
            PP.importEasyTuneVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, onSuccessCallback, onFailureCallback);
          }.bind(this);
          additionalSetup.myVariablesExportCallback = function(onSuccessCallback, onFailureCallback) {
            PP.exportEasyTuneVariables(this._myVariablesExportURL, onSuccessCallback, onFailureCallback);
          }.bind(this);
          this._myWidget.start(this.object, additionalSetup, PP.myEasyTuneVariables);
          this._myWidgetVisibleBackup = this._myWidget.isVisible();
          this._mySetVisibleNextUpdate = false;
          this._myStarted = true;
          this._myFirstUpdate = true;
        },
        update: function(dt) {
          if (this._myFirstUpdate) {
            this._myFirstUpdate = false;
            if (this._myImportVariablesOnStart) {
              PP.importEasyTuneVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport);
            }
          }
          if (this._mySetVisibleNextUpdate) {
            this._mySetVisibleNextUpdate = false;
            this._myWidget.setVisible(false);
            this._myWidget.setVisible(this._myWidgetVisibleBackup);
          }
          this._myWidget.update(dt);
        },
        onActivate() {
          this._mySetVisibleNextUpdate = true;
        },
        onDeactivate() {
          if (this._myStarted) {
            this._myWidgetVisibleBackup = this._myWidget.isVisible();
            this._myWidget.setVisible(false);
          }
        }
      });
    }
  });

  // js/pp/tool/easy_tune/components/easy_tune_import_variables.js
  var require_easy_tune_import_variables = __commonJS({
    "js/pp/tool/easy_tune/components/easy_tune_import_variables.js"() {
      WL.registerComponent("pp-easy-tune-import-variables", {
        _myVariablesImportURL: { type: WL.Type.String, default: "" },
        _myResetVariablesDefaultValueOnImport: { type: WL.Type.Bool, default: true }
      }, {
        init: function() {
        },
        start: function() {
          this._myFirstUpdate = true;
        },
        update: function(dt) {
          if (this._myFirstUpdate) {
            this._myFirstUpdate = false;
            PP.importEasyTuneVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport);
          }
        }
      });
    }
  });

  // js/pp/tool/widget_frame/widget_frame_setup.js
  var require_widget_frame_setup = __commonJS({
    "js/pp/tool/widget_frame/widget_frame_setup.js"() {
      PP.WidgetFrameSetup = class WidgetFrameSetup {
        constructor(widgetLetterID, buttonsColumnIndex) {
          this._initializeBuildSetup(widgetLetterID, buttonsColumnIndex);
          this._initializeRuntimeSetup();
        }
        _initializeBuildSetup(widgetLetterID, buttonsColumnIndex) {
          this.myBackgroundColor = [46 / 255, 46 / 255, 46 / 255, 1];
          this.myCursorTargetCollisionCollider = 2;
          this.myCursorTargetCollisionGroup = 7;
          this.myCursorTargetCollisionThickness = 1e-3;
          this.myDefaultTextColor = [255 / 255, 255 / 255, 255 / 255, 1];
          this.myTextAlignment = 2;
          this.myTextJustification = 2;
          this.myTextColor = this.myDefaultTextColor;
          this.myButtonTextScale = PP.vec3_create(0.18, 0.18, 0.18);
          this.myVisibilityButtonBackgroundScale = PP.vec3_create(0.015, 0.015, 1);
          this.myVisibilityButtonTextPosition = PP.vec3_create(0, 0, 7e-3);
          this.myVisibilityButtonTextScale = this.myButtonTextScale;
          let distanceBetweenToolsVisibilityButtons = 0.01;
          let buttonXOffset = this.myVisibilityButtonBackgroundScale[0] * (2 * buttonsColumnIndex) + distanceBetweenToolsVisibilityButtons * buttonsColumnIndex;
          this.myVisibilityButtonPosition = [];
          this.myVisibilityButtonPosition[PP.ToolHandedness.NONE] = {};
          this.myVisibilityButtonPosition[PP.ToolHandedness.NONE].myPosition = [-0.3 + buttonXOffset, -0.205, 0.035];
          this.myVisibilityButtonPosition[PP.ToolHandedness.LEFT] = {};
          this.myVisibilityButtonPosition[PP.ToolHandedness.LEFT].myPosition = [-0.2 + buttonXOffset, 0.025, 0.015];
          this.myVisibilityButtonPosition[PP.ToolHandedness.RIGHT] = {};
          this.myVisibilityButtonPosition[PP.ToolHandedness.RIGHT].myPosition = [0.2 - buttonXOffset, 0.025, 0.015];
          this.myVisibilityButtonText = widgetLetterID;
          this.myVisibilityButtonCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myVisibilityButtonCursorTargetPosition[2] = this.myVisibilityButtonTextPosition[2];
          this.myVisibilityButtonCollisionExtents = this.myVisibilityButtonBackgroundScale.slice(0);
          this.myVisibilityButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
          this.myFlagButtonBackgroundScale = PP.vec3_create(0.0125, 0.0125, 1);
          this.myFlagButtonTextPosition = PP.vec3_create(0, 0, 7e-3);
          this.myFlagButtonTextScale = PP.vec3_create(0.15, 0.15, 0.15);
          let distanceBetweenFlagButtons = 75e-4;
          let pinFlagIndex = 0;
          let pinButtonYOffset = this.myVisibilityButtonBackgroundScale[1] + this.myFlagButtonBackgroundScale[1] + distanceBetweenFlagButtons + this.myFlagButtonBackgroundScale[1] * (2 * pinFlagIndex) + distanceBetweenFlagButtons * pinFlagIndex;
          this.myPinButtonPosition = [];
          this.myPinButtonPosition[PP.ToolHandedness.NONE] = {};
          this.myPinButtonPosition[PP.ToolHandedness.NONE].myPosition = this.myVisibilityButtonPosition[PP.ToolHandedness.NONE].myPosition.slice(0);
          this.myPinButtonPosition[PP.ToolHandedness.NONE].myPosition[1] += pinButtonYOffset;
          this.myPinButtonPosition[PP.ToolHandedness.LEFT] = {};
          this.myPinButtonPosition[PP.ToolHandedness.LEFT].myPosition = this.myVisibilityButtonPosition[PP.ToolHandedness.LEFT].myPosition.slice(0);
          this.myPinButtonPosition[PP.ToolHandedness.LEFT].myPosition[1] += pinButtonYOffset;
          this.myPinButtonPosition[PP.ToolHandedness.RIGHT] = {};
          this.myPinButtonPosition[PP.ToolHandedness.RIGHT].myPosition = this.myVisibilityButtonPosition[PP.ToolHandedness.RIGHT].myPosition.slice(0);
          this.myPinButtonPosition[PP.ToolHandedness.RIGHT].myPosition[1] += pinButtonYOffset;
          this.myPinButtonText = "P";
          this.myPinButtonCursorTargetPosition = PP.vec3_create(0, 0, 0);
          this.myPinButtonCursorTargetPosition[2] = this.myFlagButtonTextPosition[2];
          this.myPinButtonCollisionExtents = this.myFlagButtonBackgroundScale.slice(0);
          this.myPinButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
        }
        _initializeRuntimeSetup() {
          this._initializeObjectsTransforms();
          this.myButtonHoverColor = [150 / 255, 150 / 255, 150 / 255, 1];
          this.myButtonDisabledTextColor = this.myBackgroundColor;
          this.myButtonDisabledBackgroundColor = [110 / 255, 110 / 255, 110 / 255, 1];
        }
        _initializeObjectsTransforms() {
          this.myPivotObjectTransforms = this._createDefaultObjectTransforms();
          this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.LEFT].myRotation = PP.quat_create(-0.645, 0.425, 0.25, 0.584);
          this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.LEFT].myRotation.quat_normalize(this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.LEFT].myRotation);
          this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.RIGHT].myRotation = PP.quat_create(-0.645, -0.425, -0.25, 0.584);
          this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.RIGHT].myRotation.quat_normalize(this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.RIGHT].myRotation);
          this.myPivotObjectTransforms[PP.ToolInputSourceType.TRACKED_HAND][PP.ToolHandedness.LEFT].myRotation = PP.quat_create(-0.645, 0.425, 0.25, 0.584);
          this.myPivotObjectTransforms[PP.ToolInputSourceType.TRACKED_HAND][PP.ToolHandedness.LEFT].myRotation.quat_normalize(this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.LEFT].myRotation);
          this.myPivotObjectTransforms[PP.ToolInputSourceType.TRACKED_HAND][PP.ToolHandedness.RIGHT].myRotation = PP.quat_create(-0.645, -0.425, -0.25, 0.584);
          this.myPivotObjectTransforms[PP.ToolInputSourceType.TRACKED_HAND][PP.ToolHandedness.RIGHT].myRotation.quat_normalize(this.myPivotObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.RIGHT].myRotation);
          this.myWidgetObjectTransforms = this._createDefaultObjectTransforms();
          this.myWidgetObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.LEFT].myPosition = PP.vec3_create(0.1, 0.23, -0.02);
          this.myWidgetObjectTransforms[PP.ToolInputSourceType.GAMEPAD][PP.ToolHandedness.RIGHT].myPosition = PP.vec3_create(0.07, 0.23, -0.02);
          this.myWidgetObjectTransforms[PP.ToolInputSourceType.TRACKED_HAND][PP.ToolHandedness.LEFT].myPosition = PP.vec3_create(0.1, 0.23, -0.02);
          this.myWidgetObjectTransforms[PP.ToolInputSourceType.TRACKED_HAND][PP.ToolHandedness.RIGHT].myPosition = PP.vec3_create(0.07, 0.23, -0.02);
          this._myPivotObjectDistanceFromNonVRHead = 0.6;
        }
        _createDefaultObjectTransforms() {
          let defaultObjectTransforms = [];
          for (let inputSourceTypeKey in PP.ToolInputSourceType) {
            let inputSourceType = PP.ToolInputSourceType[inputSourceTypeKey];
            defaultObjectTransforms[inputSourceType] = [];
            for (let handednessKey in PP.ToolHandedness) {
              let handedness = PP.ToolHandedness[handednessKey];
              defaultObjectTransforms[inputSourceType][handedness] = {};
              defaultObjectTransforms[inputSourceType][handedness].myPosition = PP.vec3_create(0, 0, 0);
              defaultObjectTransforms[inputSourceType][handedness].myRotation = PP.quat_create(0, 0, 0, 1);
            }
          }
          return defaultObjectTransforms;
        }
      };
    }
  });

  // js/pp/tool/widget_frame/widget_frame_ui.js
  var require_widget_frame_ui = __commonJS({
    "js/pp/tool/widget_frame/widget_frame_ui.js"() {
      PP.WidgetFrameUI = class WidgetFrameUI {
        constructor() {
          this._myInputSourceType = null;
          this._myParentObject = null;
          this._myIsPinned = false;
          this._myWidgetVisible = true;
          this._myVisibilityButtonVisible = true;
        }
        build(parentObject, setup, additionalSetup) {
          this._myParentObject = parentObject;
          this._mySetup = setup;
          this._myAdditionalSetup = additionalSetup;
          this._myPlaneMesh = PP.MeshUtils.createPlaneMesh();
          this._createSkeleton();
          this._setTransforms();
          this._addComponents();
          this._setTransformForNonVR();
          if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        }
        setWidgetVisible(visible) {
          this._myWidgetVisible = visible;
          this.myFlagsButtonPanel.pp_setActiveHierarchy(visible);
          if (visible) {
            this._updateObjectsTransforms(true);
          }
        }
        setVisibilityButtonVisible(visible) {
          this._myVisibilityButtonVisible = visible;
          this.myVisibilityButtonPanel.pp_setActiveHierarchy(visible);
        }
        setPinned(pinned) {
          if (pinned != this._myIsPinned) {
            this._myIsPinned = pinned;
            if (this._myIsPinned) {
              this.myPivotObject.pp_setParent(null);
            } else {
              this.myPivotObject.pp_setParent(this.myFixForwardObject);
              if (!PP.XRUtils.isSessionActive()) {
                this._setTransformForNonVR();
              }
              this._updateObjectsTransforms(true);
            }
          }
        }
        update(dt) {
          this._updateObjectsTransforms(false);
        }
        _updateObjectsTransforms(forceRefreshObjectsTransforms) {
          if (PP.XRUtils.isSessionActive()) {
            let inputSourceType = PP.InputUtils.getInputSourceTypeByHandedness(this._myAdditionalSetup.myHandedness);
            if (inputSourceType != this._myInputSourceType || forceRefreshObjectsTransforms) {
              this._myInputSourceType = inputSourceType;
              if (!this._myIsPinned) {
                this.myPivotObject.setTranslationLocal(this._mySetup.myPivotObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myPosition);
                this.myPivotObject.resetRotation();
                this.myPivotObject.rotateObject(this._mySetup.myPivotObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myRotation);
                this.myWidgetObject.setTranslationLocal(this._mySetup.myWidgetObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myPosition);
                this.myWidgetObject.resetRotation();
                this.myWidgetObject.rotateObject(this._mySetup.myWidgetObjectTransforms[this._myInputSourceType][this._myAdditionalSetup.myHandedness].myRotation);
                this.myVisibilityButtonPanel.setTranslationLocal(this._mySetup.myVisibilityButtonPosition[this._myAdditionalSetup.myHandedness].myPosition);
                this.myPinButtonPanel.setTranslationLocal(this._mySetup.myPinButtonPosition[this._myAdditionalSetup.myHandedness].myPosition);
              }
            }
          } else {
            this.myVisibilityButtonPanel.pp_setActiveHierarchy(this._myWidgetVisible || this._myVisibilityButtonVisible);
          }
        }
        //Skeleton
        _createSkeleton() {
          this.myFixForwardObject = WL.scene.addObject(this._myParentObject);
          this.myFixForwardObject.pp_rotateObject(PP.vec3_create(0, 180, 0));
          this.myPivotObject = WL.scene.addObject(this.myFixForwardObject);
          this.myWidgetObject = WL.scene.addObject(this.myPivotObject);
          this.myVisibilityButtonPanel = WL.scene.addObject(this.myPivotObject);
          this.myVisibilityButtonBackground = WL.scene.addObject(this.myVisibilityButtonPanel);
          this.myVisibilityButtonText = WL.scene.addObject(this.myVisibilityButtonPanel);
          this.myVisibilityButtonCursorTarget = WL.scene.addObject(this.myVisibilityButtonPanel);
          this.myFlagsButtonPanel = WL.scene.addObject(this.myPivotObject);
          this.myPinButtonPanel = WL.scene.addObject(this.myFlagsButtonPanel);
          this.myPinButtonBackground = WL.scene.addObject(this.myPinButtonPanel);
          this.myPinButtonText = WL.scene.addObject(this.myPinButtonPanel);
          this.myPinButtonCursorTarget = WL.scene.addObject(this.myPinButtonPanel);
          this.myNonVRParentObject = WL.scene.addObject(PP.myPlayerObjects.myNonVRCamera);
          this.myNonVRParentObject.pp_translateLocal(PP.vec3_create(0, 0, -this._mySetup._myPivotObjectDistanceFromNonVRHead));
          this.myNonVRParentObject.pp_lookToLocal(PP.vec3_create(0, 0, 1), PP.vec3_create(0, 1, 0));
        }
        //Transforms
        _setTransforms() {
          this.myPivotObject.setDirty();
          this.myVisibilityButtonPanel.setTranslationLocal(this._mySetup.myVisibilityButtonPosition[this._myAdditionalSetup.myHandedness].myPosition);
          this.myVisibilityButtonBackground.scale(this._mySetup.myVisibilityButtonBackgroundScale);
          this.myVisibilityButtonText.setTranslationLocal(this._mySetup.myVisibilityButtonTextPosition);
          this.myVisibilityButtonText.scale(this._mySetup.myVisibilityButtonTextScale);
          this.myVisibilityButtonCursorTarget.setTranslationLocal(this._mySetup.myVisibilityButtonCursorTargetPosition);
          this.myPinButtonPanel.setTranslationLocal(this._mySetup.myPinButtonPosition[this._myAdditionalSetup.myHandedness].myPosition);
          this.myPinButtonBackground.scale(this._mySetup.myFlagButtonBackgroundScale);
          this.myPinButtonText.setTranslationLocal(this._mySetup.myFlagButtonTextPosition);
          this.myPinButtonText.scale(this._mySetup.myFlagButtonTextScale);
          this.myPinButtonCursorTarget.setTranslationLocal(this._mySetup.myPinButtonCursorTargetPosition);
        }
        //Components
        _addComponents() {
          this.myVisibilityButtonBackgroundComponent = this.myVisibilityButtonBackground.addComponent("mesh");
          this.myVisibilityButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myVisibilityButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myVisibilityButtonBackgroundComponent.material.color = this._mySetup.myBackgroundColor;
          this.myVisibilityButtonTextComponent = this.myVisibilityButtonText.addComponent("text");
          this._setupButtonTextComponent(this.myVisibilityButtonTextComponent);
          this.myVisibilityButtonTextComponent.text = this._mySetup.myVisibilityButtonText;
          this.myVisibilityButtonCursorTargetComponent = this.myVisibilityButtonCursorTarget.addComponent("cursor-target");
          this.myVisibilityButtonCollisionComponent = this.myVisibilityButtonCursorTarget.addComponent("collision");
          this.myVisibilityButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myVisibilityButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myVisibilityButtonCollisionComponent.extents = this._mySetup.myVisibilityButtonCollisionExtents;
          this.myPinButtonBackgroundComponent = this.myPinButtonBackground.addComponent("mesh");
          this.myPinButtonBackgroundComponent.mesh = this._myPlaneMesh;
          this.myPinButtonBackgroundComponent.material = this._myAdditionalSetup.myPlaneMaterial.clone();
          this.myPinButtonBackgroundComponent.material.color = this._mySetup.myButtonDisabledBackgroundColor;
          this.myPinButtonTextComponent = this.myPinButtonText.addComponent("text");
          this._setupButtonTextComponent(this.myPinButtonTextComponent);
          this.myPinButtonTextComponent.material.color = this._mySetup.myButtonDisabledTextColor;
          this.myPinButtonTextComponent.text = this._mySetup.myPinButtonText;
          this.myPinButtonCursorTargetComponent = this.myPinButtonCursorTarget.addComponent("cursor-target");
          this.myPinButtonCollisionComponent = this.myPinButtonCursorTarget.addComponent("collision");
          this.myPinButtonCollisionComponent.collider = this._mySetup.myCursorTargetCollisionCollider;
          this.myPinButtonCollisionComponent.group = 1 << this._mySetup.myCursorTargetCollisionGroup;
          this.myPinButtonCollisionComponent.extents = this._mySetup.myPinButtonCollisionExtents;
        }
        _setupButtonTextComponent(textComponent) {
          textComponent.alignment = this._mySetup.myTextAlignment;
          textComponent.justification = this._mySetup.myTextJustification;
          textComponent.material = this._myAdditionalSetup.myTextMaterial.clone();
          textComponent.material.color = this._mySetup.myTextColor;
          textComponent.text = "";
        }
        _onXRSessionStart() {
          this.myVisibilityButtonPanel.pp_setActiveHierarchy(this._myVisibilityButtonVisible);
          this._setTransformForVR();
        }
        _onXRSessionEnd() {
          this._setTransformForNonVR();
        }
        _setTransformForVR() {
          this.myFixForwardObject.pp_setParent(this._myParentObject);
          this.myFixForwardObject.pp_resetTransformLocal();
          this.myFixForwardObject.pp_rotateObject(PP.vec3_create(0, 180, 0));
          this._updateObjectsTransforms(true);
        }
        _setTransformForNonVR() {
          if (!this._myIsPinned) {
            this.myFixForwardObject.pp_setParent(this.myNonVRParentObject);
            this.myFixForwardObject.pp_resetTransformLocal();
            this.myPivotObject.setTranslationLocal(this._mySetup.myPivotObjectTransforms[PP.ToolInputSourceType.NONE][PP.ToolHandedness.NONE].myPosition);
            this.myPivotObject.resetRotation();
            this.myPivotObject.rotateObject(this._mySetup.myPivotObjectTransforms[PP.ToolInputSourceType.NONE][PP.ToolHandedness.NONE].myRotation);
            this.myWidgetObject.setTranslationLocal(this._mySetup.myWidgetObjectTransforms[PP.ToolInputSourceType.NONE][PP.ToolHandedness.NONE].myPosition);
            this.myWidgetObject.resetRotation();
            this.myWidgetObject.rotateObject(this._mySetup.myWidgetObjectTransforms[PP.ToolInputSourceType.NONE][PP.ToolHandedness.NONE].myRotation);
            this.myVisibilityButtonPanel.setTranslationLocal(this._mySetup.myVisibilityButtonPosition[PP.ToolHandedness.NONE].myPosition);
            this.myPinButtonPanel.setTranslationLocal(this._mySetup.myPinButtonPosition[PP.ToolHandedness.NONE].myPosition);
          }
        }
      };
    }
  });

  // js/pp/tool/widget_frame/widget_frame.js
  var require_widget_frame = __commonJS({
    "js/pp/tool/widget_frame/widget_frame.js"() {
      PP.WidgetFrame = class WidgetFrame {
        constructor(widgetLetterID, buttonsColumnIndex) {
          this.myIsWidgetVisible = true;
          this.myIsPinned = false;
          this._mySetup = new PP.WidgetFrameSetup(widgetLetterID, buttonsColumnIndex);
          this._myAdditionalSetup = null;
          this._myUI = new PP.WidgetFrameUI();
          this._myShowVisibilityButton = false;
          this._myWidgetVisibleChangedCallbacks = /* @__PURE__ */ new Map();
          this._myPinChangedCallbacks = /* @__PURE__ */ new Map();
        }
        getWidgetObject() {
          return this._myUI.myWidgetObject;
        }
        setVisible(visible) {
          this.myIsWidgetVisible = !visible;
          this._toggleVisibility(false, true);
        }
        isVisible() {
          return this.myIsWidgetVisible;
        }
        toggleVisibility() {
          this._toggleVisibility(false, true);
        }
        togglePin() {
          this._togglePin(false);
        }
        registerWidgetVisibleChangedEventListener(id, callback) {
          this._myWidgetVisibleChangedCallbacks.set(id, callback);
        }
        unregisterWidgetVisibleChangedEventListener(id) {
          this._myWidgetVisibleChangedCallbacks.delete(id);
        }
        registerPinChangedEventListener(id, callback) {
          this._myPinChangedCallbacks.set(id, callback);
        }
        unregisterPinChangedEventListener(id) {
          this._myPinChangedCallbacks.delete(id);
        }
        start(parentObject, additionalSetup) {
          this._myAdditionalSetup = additionalSetup;
          this._myUI.build(parentObject, this._mySetup, additionalSetup);
          this._myUI.setVisibilityButtonVisible(additionalSetup.myShowVisibilityButton);
          this._myShowVisibilityButton = additionalSetup.myShowVisibilityButton;
          if (!additionalSetup.myShowOnStart) {
            this._toggleVisibility(false, false);
          }
          this._addListeners();
        }
        update(dt) {
          this._myUI.update(dt);
        }
        _addListeners() {
          let ui = this._myUI;
          ui.myPinButtonCursorTargetComponent.addClickFunction(this._togglePin.bind(this, true));
          ui.myPinButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myPinButtonBackgroundComponent.material));
          ui.myPinButtonCursorTargetComponent.addUnHoverFunction(this._pinUnHover.bind(this, ui.myPinButtonBackgroundComponent.material));
          ui.myVisibilityButtonCursorTargetComponent.addClickFunction(this._toggleVisibility.bind(this, true, true));
          ui.myVisibilityButtonCursorTargetComponent.addHoverFunction(this._genericHover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
          ui.myVisibilityButtonCursorTargetComponent.addUnHoverFunction(this._visibilityUnHover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
        }
        _toggleVisibility(isButton, notify) {
          this.myIsWidgetVisible = !this.myIsWidgetVisible;
          this._myUI.setWidgetVisible(this.myIsWidgetVisible);
          let textMaterial = this._myUI.myVisibilityButtonTextComponent.material;
          let backgroundMaterial = this._myUI.myVisibilityButtonBackgroundComponent.material;
          if (this.myIsWidgetVisible) {
            textMaterial.color = this._mySetup.myDefaultTextColor;
            if (!isButton) {
              backgroundMaterial.color = this._mySetup.myBackgroundColor;
            }
          } else {
            textMaterial.color = this._mySetup.myButtonDisabledTextColor;
            if (!isButton) {
              backgroundMaterial.color = this._mySetup.myButtonDisabledBackgroundColor;
            }
          }
          if (notify) {
            for (let callback of this._myWidgetVisibleChangedCallbacks.values()) {
              callback(this.myIsWidgetVisible);
            }
          }
          this._myUI.setVisibilityButtonVisible(this._myShowVisibilityButton);
        }
        _togglePin(isButton) {
          if (this.myIsWidgetVisible) {
            this.myIsPinned = !this.myIsPinned;
            this._myUI.setPinned(this.myIsPinned);
            let textMaterial = this._myUI.myPinButtonTextComponent.material;
            let backgroundMaterial = this._myUI.myPinButtonBackgroundComponent.material;
            if (this.myIsPinned) {
              textMaterial.color = this._mySetup.myDefaultTextColor;
              if (!isButton) {
                backgroundMaterial.color = this._mySetup.myBackgroundColor;
              }
            } else {
              textMaterial.color = this._mySetup.myButtonDisabledTextColor;
              if (!isButton) {
                backgroundMaterial.color = this._mySetup.myButtonDisabledBackgroundColor;
              }
            }
            for (let callback of this._myPinChangedCallbacks.values()) {
              callback(this.myIsPinned);
            }
          }
        }
        _genericHover(material) {
          material.color = this._mySetup.myButtonHoverColor;
        }
        _visibilityUnHover(material) {
          if (this.myIsWidgetVisible) {
            material.color = this._mySetup.myBackgroundColor;
          } else {
            material.color = this._mySetup.myButtonDisabledBackgroundColor;
          }
        }
        _pinUnHover(material) {
          if (this.myIsPinned) {
            material.color = this._mySetup.myBackgroundColor;
          } else {
            material.color = this._mySetup.myButtonDisabledBackgroundColor;
          }
        }
      };
    }
  });

  // js/locomotion/locomotion_utils.js
  var require_locomotion_utils = __commonJS({
    "js/locomotion/locomotion_utils.js"() {
      LocomotionUtils = {
        EPSILON_NUMBER: Math.PP_EPSILON_NUMBER,
        EPSILON_DEGREES: Math.PP_EPSILON_DEGREES,
        computeSurfacePerceivedAngle: function() {
          let forwardOnSurface = PP.vec3_create();
          let verticalDirection = PP.vec3_create();
          return function computeSurfacePerceivedAngle(surfaceNormal, forward, up, isGround = true) {
            let surfacePerceivedAngle = 0;
            verticalDirection.vec3_copy(up);
            if (!isGround) {
              verticalDirection.vec3_negate(verticalDirection);
            }
            let surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
            if (surfaceAngle <= Math.PP_EPSILON_DEGREES) {
              surfaceAngle = 0;
            } else if (surfaceAngle >= 180 - Math.PP_EPSILON_DEGREES) {
              surfaceAngle = 180;
            }
            forwardOnSurface = forward.vec3_projectOnPlaneAlongAxis(surfaceNormal, up, forwardOnSurface);
            surfacePerceivedAngle = forwardOnSurface.vec3_angle(forward);
            let isFartherOnUp = forwardOnSurface.vec3_isFartherAlongAxis(forward, up);
            if (!isFartherOnUp && isGround || isFartherOnUp && !isGround) {
              surfacePerceivedAngle *= -1;
            }
            if (Math.abs(surfacePerceivedAngle) >= surfaceAngle) {
              if (surfaceAngle != 0 && surfaceAngle != 180) {
                surfacePerceivedAngle = surfaceAngle * Math.pp_sign(surfacePerceivedAngle);
              } else {
                surfacePerceivedAngle = surfaceAngle;
              }
            }
            return surfacePerceivedAngle;
          };
        }()
      };
    }
  });

  // js/locomotion/player_head_manager.js
  var require_player_head_manager = __commonJS({
    "js/locomotion/player_head_manager.js"() {
      PlayerHeadManagerParams = class PlayerHeadManagerParams {
        constructor() {
          this.mySessionChangeResyncEnabled = false;
          this.myBlurEndResyncEnabled = false;
          this.myBlurEndResyncRotation = false;
          this.myNextEnterSessionResyncHeight = false;
          this.myEnterSessionResyncHeight = false;
          this.myExitSessionResyncHeight = false;
          this.myExitSessionResyncVerticalAngle = false;
          this.myExitSessionRemoveRightTilt = false;
          this.myExitSessionAdjustMaxVerticalAngle = false;
          this.myExitSessionMaxVerticalAngle = 0;
          this.myHeightOffsetVRWithFloor = null;
          this.myHeightOffsetVRWithoutFloor = null;
          this.myHeightOffsetNonVR = null;
          this.myNextEnterSessionFloorHeight = null;
          this.myEnterSessionFloorHeight = null;
          this.myRotateFeetKeepUp = false;
          this.myForeheadExtraHeight = 0;
          this.myDebugActive = false;
        }
      };
      PlayerHeadManager = class PlayerHeadManager {
        constructor(params = new PlayerHeadManagerParams()) {
          this._myParams = params;
          this._myCurrentHead = PP.myPlayerObjects.myNonVRHead;
          this._mySessionChangeResyncHeadTransform = null;
          this._myBlurRecoverHeadTransform = null;
          this._myCurrentHeadTransformQuat = PP.quat2_create();
          this._myPreviousHeadTransformQuat = PP.quat2_create();
          this._myDelaySessionChangeResyncCounter = 0;
          this._myDelayBlurEndResyncCounter = 0;
          this._myDelayBlurEndResyncTimer = new PP.Timer(5, false);
          this._myVisibilityHidden = false;
          this._mySessionActive = false;
          this._mySessionBlurred = false;
          this._myIsSyncedDelayCounter = 0;
          this._myResyncCounterFrames = 3;
          this._myIsSyncedDelayCounterFrames = 1;
        }
        start() {
          this._updateHeightOffset();
          if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        }
        getParams() {
          return this._myParams;
        }
        paramsUpdated() {
          this._updateHeightOffset();
        }
        getPlayer() {
          return PP.myPlayerObjects.myPlayer;
        }
        getHead() {
          return this._myCurrentHead;
        }
        getHeightHead() {
          return this.getHeightEyes() + this._myParams.myForeheadExtraHeight;
        }
        getHeightEyes() {
        }
        getTransformFeetQuat(outTransformFeetQuat = PP.quat2_create()) {
        }
        getTransformHeadQuat(outTransformFeetQuat = PP.quat2_create()) {
          return this.getHead().pp_getTransformQuat(outTransformFeetQuat);
        }
        getPositionFeet(outPositionFeet = PP.vec3_create()) {
        }
        getPositionHead(outPositionHead = PP.vec3_create()) {
          return this._myCurrentHead.pp_getPosition(outPositionHead);
        }
        getRotationFeetQuat(outRotationFeetQuat = PP.quat_create()) {
        }
        getRotationHeadQuat(outRotationHeadQuat = PP.quat_create()) {
          return this.getHead().pp_getRotationQuat(outRotationHeadQuat);
        }
        isSynced() {
          return this._myIsSyncedDelayCounter == 0 && this._myDelaySessionChangeResyncCounter == 0 && this._myDelayBlurEndResyncCounter == 0 && !this._myDelayBlurEndResyncTimer.isRunning() && !this._mySessionBlurred;
        }
        setHeight(height, setOnlyForActiveOne = false) {
          if (!setOnlyForActiveOne || !this._mySessionActive) {
            this._myParams.myHeightOffsetNonVR = height;
          }
          if (!setOnlyForActiveOne || this._mySessionActive) {
            this._myParams.myHeightOffsetVRWithoutFloor = height;
            if (this._myParams.myHeightOffsetVRWithFloor == null) {
              this._myParams.myHeightOffsetVRWithFloor = 0;
            }
            let isFloor = PP.XRUtils.isReferenceSpaceLocalFloor() || PP.XRUtils.isDeviceEmulated() && Global.myIsLocalhost;
            if (this._mySessionActive && isFloor) {
              this._myParams.myHeightOffsetVRWithFloor = this._myParams.myHeightOffsetVRWithFloor + (height - this.getHeight());
            } else if (!this._mySessionActive) {
              this._myParams.myNextEnterSessionFloorHeight = height;
            }
          }
          this._updateHeightOffset();
        }
        moveFeet(movement) {
        }
        moveHead(movement) {
          this.moveFeet(movement);
        }
        teleportPositionHead(teleportPosition) {
        }
        teleportPositionFeet(teleportPosition) {
        }
        teleportPlayerToHeadTransformQuat(headTransformQuat) {
        }
        rotateFeetQuat(rotationQuat, keepUpOverride = null) {
        }
        rotateHeadQuat(rotationQuat) {
        }
        canRotateFeet() {
          return true;
        }
        canRotateHead() {
          return !this._mySessionActive;
        }
        setRotationFeetQuat(rotationQuat, keepUpOverride = null) {
        }
        setRotationHeadQuat() {
        }
        lookAtFeet(position, up = null, keepUpOverride = null) {
        }
        lookToFeet(direction, up = null, keepUpOverride = null) {
        }
        lookAtHead(position, up = null) {
        }
        lookToHead(direction, up = null) {
        }
        update(dt) {
          if (this._myIsSyncedDelayCounter != 0) {
            this._myIsSyncedDelayCounter--;
            this._myIsSyncedDelayCounter = Math.max(0, this._myIsSyncedDelayCounter);
          }
          if (this._myDelaySessionChangeResyncCounter > 0) {
            this._myDelaySessionChangeResyncCounter--;
            if (this._myDelaySessionChangeResyncCounter == 0) {
              this._sessionChangeResync();
              this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
            }
          }
          if (this._myDelayBlurEndResyncCounter > 0 && !this._myDelayBlurEndResyncTimer.isRunning()) {
            this._myDelayBlurEndResyncCounter--;
            if (this._myDelayBlurEndResyncCounter == 0) {
              this._blurEndResync();
              this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
            }
          }
          if (this._myDelayBlurEndResyncTimer.isRunning()) {
            if (this._myDelayBlurEndResyncCounter > 0) {
              this._myDelayBlurEndResyncCounter--;
            } else {
              this._myDelayBlurEndResyncTimer.update(dt);
              if (this._myDelayBlurEndResyncTimer.isDone()) {
                this._blurEndResync();
                this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
              }
            }
          }
          if (this.isSynced()) {
            this._myPreviousHeadTransformQuat.quat2_copy(this._myCurrentHeadTransformQuat);
            this._myCurrentHead.pp_getTransformQuat(this._myCurrentHeadTransformQuat);
          }
          if (this._myParams.myDebugActive) {
            this._debugUpdate(dt);
          }
        }
        _debugUpdate(dt) {
          PP.myDebugVisualManager.drawLineEnd(0, this.getPositionFeet(), this.getPositionHead(), PP.vec4_create(1, 0, 0, 1), 0.01);
          console.error(this.getHeightEyes());
        }
      };
      PlayerHeadManager.prototype.getHeightEyes = function() {
        let headPosition = PP.vec3_create();
        return function getHeightEyes() {
          headPosition = this._myCurrentHead.pp_getPosition(headPosition);
          let eyesHeight = this._getPositionHeight(headPosition);
          return eyesHeight;
        };
      }();
      PlayerHeadManager.prototype.getTransformFeetQuat = function() {
        let feetPosition = PP.vec3_create();
        let feetRotationQuat = PP.quat_create();
        return function getTransformFeetQuat(outTransformFeetQuat = PP.quat2_create()) {
          outTransformFeetQuat.quat2_setPositionRotationQuat(this.getPositionFeet(feetPosition), this.getRotationFeetQuat(feetRotationQuat));
          return outTransformFeetQuat;
        };
      }();
      PlayerHeadManager.prototype.getRotationFeetQuat = function() {
        let playerUp = PP.vec3_create();
        let headForward = PP.vec3_create();
        return function getRotationFeetQuat(outRotationFeetQuat = PP.quat_create()) {
          playerUp = PP.myPlayerObjects.myPlayer.pp_getUp(playerUp);
          headForward = this._myCurrentHead.pp_getForward(headForward);
          let angleWithUp = headForward.vec3_angle(playerUp);
          let mingAngle = 10;
          if (angleWithUp < mingAngle) {
            headForward = this._myCurrentHead.pp_getDown(headForward);
          } else if (angleWithUp > 180 - mingAngle) {
            headForward = this._myCurrentHead.pp_getUp(headForward);
          }
          headForward = headForward.vec3_removeComponentAlongAxis(playerUp, headForward);
          headForward.vec3_normalize(headForward);
          outRotationFeetQuat.quat_setUp(playerUp, headForward);
          return outRotationFeetQuat;
        };
      }();
      PlayerHeadManager.prototype.getPositionFeet = function() {
        let headPosition = PP.vec3_create();
        let playerUp = PP.vec3_create();
        return function getPositionFeet(outPositionFeet = PP.vec3_create()) {
          headPosition = this._myCurrentHead.pp_getPosition(headPosition);
          let headHeight = this._getPositionHeight(headPosition);
          playerUp = PP.myPlayerObjects.myPlayer.pp_getUp(playerUp);
          outPositionFeet = headPosition.vec3_sub(playerUp.vec3_scale(headHeight, outPositionFeet), outPositionFeet);
          return outPositionFeet;
        };
      }();
      PlayerHeadManager.prototype.moveFeet = function(movement) {
        PP.myPlayerObjects.myPlayer.pp_translate(movement);
      };
      PlayerHeadManager.prototype.rotateFeetQuat = function() {
        let playerUp = PP.vec3_create();
        let rotationAxis = PP.vec3_create();
        let currentHeadPosition = PP.vec3_create();
        let currentFeetRotation = PP.quat_create();
        let newFeetRotation = PP.quat_create();
        let fixedNewFeetRotation = PP.quat_create();
        let newFeetForward = PP.vec3_create();
        let fixedRotation = PP.quat_create();
        let newHeadPosition = PP.vec3_create();
        let headAdjustmentMovement = PP.vec3_create();
        return function rotateFeetQuat(rotationQuat, keepUpOverride = null) {
          let angle3 = rotationQuat.quat_getAngleRadians();
          if (angle3 <= 1e-5) {
            return;
          }
          currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
          playerUp = PP.myPlayerObjects.myPlayer.pp_getUp(playerUp);
          rotationAxis = rotationQuat.quat_getAxis(rotationAxis);
          if (!rotationAxis.vec3_isOnAxis(playerUp) && (keepUpOverride == null && this._myParams.myFeetRotationKeepUp || keepUpOverride)) {
            currentFeetRotation = this.getRotationFeetQuat(currentFeetRotation);
            newFeetRotation = currentFeetRotation.quat_rotateQuat(rotationQuat, newFeetRotation);
            newFeetForward = newFeetRotation.quat_getForward(newFeetForward);
            fixedNewFeetRotation.quat_copy(newFeetRotation);
            fixedNewFeetRotation.quat_setUp(playerUp, newFeetForward);
            fixedRotation = currentFeetRotation.quat_rotationToQuat(fixedNewFeetRotation, fixedRotation);
          } else {
            fixedRotation.quat_copy(rotationQuat);
          }
          PP.myPlayerObjects.myPlayer.pp_rotateAroundQuat(fixedRotation, currentHeadPosition);
          newHeadPosition = this._myCurrentHead.pp_getPosition(newHeadPosition);
          headAdjustmentMovement = currentHeadPosition.vec3_sub(newHeadPosition, headAdjustmentMovement);
          if (headAdjustmentMovement.vec3_length() > 1e-5) {
            this.moveFeet(headAdjustmentMovement);
          }
        };
      }();
      PlayerHeadManager.prototype.rotateHeadQuat = function() {
        let newHeadRotation = PP.quat_create();
        let newHeadUp = PP.vec3_create();
        return function rotateHeadQuat(rotationQuat) {
          if (this.canRotateHead()) {
            this._myCurrentHead.pp_rotateQuat(rotationQuat);
            newHeadRotation = this._myCurrentHead.pp_getRotationQuat(newHeadRotation);
            PP.myPlayerObjects.myHead.pp_setRotationQuat(newHeadRotation);
            newHeadRotation = newHeadRotation.quat_rotateAxisRadians(Math.PI, newHeadRotation.quat_getUp(newHeadUp), newHeadRotation);
            PP.myPlayerObjects.myNonVRCamera.pp_setRotationQuat(newHeadRotation);
          }
        };
      }();
      PlayerHeadManager.prototype.setRotationFeetQuat = function() {
        let currentRotationQuat = PP.quat_create();
        let rotationQuatToRotate = PP.quat_create();
        return function setRotationFeetQuat(rotationQuat, keepUpOverride = null) {
          currentRotationQuat = this.getRotationFeetQuat(currentRotationQuat);
          rotationQuatToRotate = currentRotationQuat.quat_rotationToQuat(rotationQuat, rotationQuatToRotate);
          this.rotateFeetQuat(rotationQuatToRotate, keepUpOverride);
        };
      }();
      PlayerHeadManager.prototype.setRotationHeadQuat = function() {
        let currentRotationQuat = PP.quat_create();
        let rotationQuatToRotate = PP.quat_create();
        return function setRotationHeadQuat(rotationQuat) {
          currentRotationQuat = this.getRotationHeadQuat(currentRotationQuat);
          rotationQuatToRotate = currentRotationQuat.quat_rotationToQuat(rotationQuat, rotationQuatToRotate);
          this.rotateHeadQuat(rotationQuatToRotate);
        };
      }();
      PlayerHeadManager.prototype.teleportPositionHead = function() {
        let currentHeadPosition = PP.vec3_create();
        let teleportMovementToPerform = PP.vec3_create();
        return function teleportPositionHead(teleportPosition) {
          currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
          teleportMovementToPerform = teleportPosition.vec3_sub(currentHeadPosition, teleportMovementToPerform);
          this.moveFeet(teleportMovementToPerform);
        };
      }();
      PlayerHeadManager.prototype.teleportPositionFeet = function() {
        let currentFeetPosition = PP.vec3_create();
        let teleportMovementToPerform = PP.vec3_create();
        return function teleportPositionFeet(teleportPosition) {
          currentFeetPosition = this.getPositionFeet(currentFeetPosition);
          teleportMovementToPerform = teleportPosition.vec3_sub(currentFeetPosition, teleportMovementToPerform);
          this.moveFeet(teleportMovementToPerform);
        };
      }();
      PlayerHeadManager.prototype.teleportPlayerToHeadTransformQuat = function() {
        let headPosition = PP.vec3_create();
        let playerUp = PP.vec3_create();
        let flatCurrentPlayerPosition = PP.vec3_create();
        let flatNewPlayerPosition = PP.vec3_create();
        let teleportMovement = PP.vec3_create();
        let playerForward = PP.vec3_create();
        let headForward = PP.vec3_create();
        let headForwardNegated = PP.vec3_create();
        let rotationToPerform = PP.quat_create();
        return function teleportPlayerToHeadTransformQuat(headTransformQuat) {
          headPosition = headTransformQuat.quat2_getPosition(headPosition);
          playerUp = PP.myPlayerObjects.myPlayer.pp_getUp(playerUp);
          flatCurrentPlayerPosition = PP.myPlayerObjects.myPlayer.pp_getPosition(flatCurrentPlayerPosition).vec3_removeComponentAlongAxis(playerUp, flatCurrentPlayerPosition);
          flatNewPlayerPosition = headPosition.vec3_removeComponentAlongAxis(playerUp, flatNewPlayerPosition);
          teleportMovement = flatNewPlayerPosition.vec3_sub(flatCurrentPlayerPosition, teleportMovement);
          PP.myPlayerObjects.myPlayer.pp_translate(teleportMovement);
          playerForward = PP.myPlayerObjects.myPlayer.pp_getForward(playerForward);
          headForward = headTransformQuat.quat2_getForward(headForward);
          headForwardNegated = headForward.vec3_negate(headForwardNegated);
          rotationToPerform = playerForward.vec3_rotationToPivotedQuat(headForwardNegated, playerUp, rotationToPerform);
          PP.myPlayerObjects.myPlayer.pp_rotateQuat(rotationToPerform);
        };
      }();
      PlayerHeadManager.prototype.lookAtFeet = function() {
        let direction = PP.vec3_create();
        let feetPosition = PP.vec3_create();
        return function lookAtFeet(position, up = null, keepUpOverride = null) {
          feetPosition = this.getPositionFeet(feetPosition);
          direction = position.vec3_sub(feetPosition, direction).vec3_normalize(direction);
          this.lookToFeet(direction, up, keepUpOverride);
        };
      }();
      PlayerHeadManager.prototype.lookToFeet = function() {
        let feetRotation = PP.quat_create();
        return function lookToFeet(direction, up = null, keepUpOverride = null) {
          feetRotation = this.getRotationFeetQuat(feetRotation);
          feetRotation.quat_setForward(direction, up);
          this.setRotationFeetQuat(feetRotation, keepUpOverride);
        };
      }();
      PlayerHeadManager.prototype.lookAtHead = function() {
        let direction = PP.vec3_create();
        let headPosition = PP.vec3_create();
        return function lookAtHead(position, up = null) {
          headPosition = this.getPositionHead(headPosition);
          direction = position.vec3_sub(headPosition, direction).vec3_normalize(direction);
          this.lookToHead(direction, up);
        };
      }();
      PlayerHeadManager.prototype.lookToHead = function() {
        let headRotation = PP.quat_create();
        return function lookToHead(direction, up = null) {
          headRotation = this.getRotationHeadQuat(headRotation);
          headRotation.quat_setForward(direction, up);
          this.setRotationHeadQuat(headRotation);
        };
      }();
      PlayerHeadManager.prototype._getPositionHeight = function() {
        let playerPosition = PP.vec3_create();
        let playerUp = PP.vec3_create();
        let heightVector = PP.vec3_create();
        return function _getPositionHeight(position) {
          playerPosition = PP.myPlayerObjects.myPlayer.pp_getPosition(playerPosition);
          playerUp = PP.myPlayerObjects.myPlayer.pp_getUp(playerUp);
          heightVector = position.vec3_sub(playerPosition, heightVector).vec3_componentAlongAxis(playerUp, heightVector);
          let height = heightVector.vec3_length();
          if (!playerUp.vec3_isConcordant(heightVector)) {
            height = -height;
          }
          return height;
        };
      }();
      PlayerHeadManager.prototype._onXRSessionStart = function() {
        return function _onXRSessionStart(session) {
          this._myBlurRecoverHeadTransform = null;
          this._myVisibilityHidden = false;
          this._myDelaySessionChangeResyncCounter = 0;
          this._myDelayBlurEndResyncCounter = 0;
          this._myDelayBlurEndResyncTimer.reset();
          session.requestReferenceSpace(WebXR.refSpace).then(function(referenceSpace) {
            if (referenceSpace.addEventListener != null) {
              referenceSpace.addEventListener("reset", this._onViewReset.bind(this));
            }
          }.bind(this));
          session.addEventListener("visibilitychange", function(event) {
            if (event.session.visibilityState != "visible") {
              if (!this._mySessionBlurred) {
                this._onXRSessionBlurStart(event.session);
              }
              this._myVisibilityHidden = session.visibilityState == "hidden";
            } else {
              if (this._mySessionBlurred) {
                this._onXRSessionBlurEnd(event.session);
              }
              this._myVisibilityHidden = false;
            }
          }.bind(this));
          if (this._myParams.mySessionChangeResyncEnabled) {
            if (this._myDelaySessionChangeResyncCounter == 0) {
              let previousHeadObject = this._myCurrentHead;
              this._mySessionChangeResyncHeadTransform = previousHeadObject.pp_getTransformQuat();
            }
            this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
          } else {
            this._myDelaySessionChangeResyncCounter = 0;
            this._mySessionChangeResyncHeadTransform = null;
          }
          this._myCurrentHead = PP.myPlayerObjects.myVRHead;
          this._mySessionActive = true;
          this._mySessionBlurred = false;
          this._updateHeightOffset();
        };
      }();
      PlayerHeadManager.prototype._onXRSessionEnd = function() {
        return function _onXRSessionEnd(session) {
          if (this._myParams.mySessionChangeResyncEnabled) {
            if (this._myDelaySessionChangeResyncCounter == 0) {
              let previousHeadTransform = this._myCurrentHead.pp_getTransformQuat();
              if (this._myBlurRecoverHeadTransform != null) {
                previousHeadTransform = this._myBlurRecoverHeadTransform;
              }
              this._mySessionChangeResyncHeadTransform = previousHeadTransform;
            }
            this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
          } else {
            this._myDelaySessionChangeResyncCounter = 0;
            this._mySessionChangeResyncHeadTransform = null;
          }
          this._myBlurRecoverHeadTransform = null;
          this._myVisibilityHidden = false;
          this._myDelayBlurEndResyncCounter = 0;
          this._myDelayBlurEndResyncTimer.reset();
          this._myCurrentHead = PP.myPlayerObjects.myNonVRHead;
          this._mySessionActive = false;
          this._mySessionBlurred = false;
          this._updateHeightOffset();
        };
      }();
      PlayerHeadManager.prototype._onXRSessionBlurStart = function() {
        return function _onXRSessionBlurStart(session) {
          if (this._myParams.myBlurEndResyncEnabled && this._myBlurRecoverHeadTransform == null && this._mySessionActive) {
            if (this._myDelaySessionChangeResyncCounter > 0) {
              this._myBlurRecoverHeadTransform = this._mySessionChangeResyncHeadTransform;
            } else {
              this._myBlurRecoverHeadTransform = this._myCurrentHead.pp_getTransformQuat();
            }
          } else if (!this._mySessionActive || !this._myParams.myBlurEndResyncEnabled) {
            this._myBlurRecoverHeadTransform = null;
          }
          this._myDelayBlurEndResyncCounter = 0;
          this._mySessionBlurred = true;
        };
      }();
      PlayerHeadManager.prototype._onXRSessionBlurEnd = function() {
        return function _onXRSessionBlurEnd(session) {
          if (this._myDelaySessionChangeResyncCounter == 0) {
            if (this._myParams.myBlurEndResyncEnabled && this._myBlurRecoverHeadTransform != null && this._mySessionActive) {
              this._myDelayBlurEndResyncCounter = this._myResyncCounterFrames;
              if (this._myVisibilityHidden) {
              }
            } else {
              this._myBlurRecoverHeadTransform = null;
              this._myDelayBlurEndResyncCounter = 0;
            }
          } else {
            this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
            this._myBlurRecoverHeadTransform = null;
          }
          this._mySessionBlurred = false;
        };
      }();
      PlayerHeadManager.prototype._onViewReset = function() {
        return function _onViewReset() {
          if (this._mySessionActive && this.isSynced()) {
            this.teleportPlayerToHeadTransformQuat(this._myPreviousHeadTransformQuat);
          }
        };
      }();
      PlayerHeadManager.prototype._blurEndResync = function() {
        let playerUp = PP.vec3_create();
        let currentHeadPosition = PP.vec3_create();
        let recoverHeadPosition = PP.vec3_create();
        let flatCurrentHeadPosition = PP.vec3_create();
        let flatRecoverHeadPosition = PP.vec3_create();
        let recoverMovement = PP.vec3_create();
        let recoverHeadForward = PP.vec3_create();
        let currentHeadForward = PP.vec3_create();
        let rotationToPerform = PP.quat_create();
        return function _blurEndResync() {
          if (this._myBlurRecoverHeadTransform != null) {
            if (this._mySessionChangeResyncHeadTransform != null) {
              this._myBlurRecoverHeadTransform = null;
              this._sessionChangeResync();
            } else {
              playerUp = PP.myPlayerObjects.myPlayer.pp_getUp(playerUp);
              currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
              recoverHeadPosition = this._myBlurRecoverHeadTransform.quat2_getPosition(recoverHeadPosition);
              flatCurrentHeadPosition = currentHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatCurrentHeadPosition);
              flatRecoverHeadPosition = recoverHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatRecoverHeadPosition);
              recoverMovement = flatRecoverHeadPosition.vec3_sub(flatCurrentHeadPosition, recoverMovement);
              this.moveFeet(recoverMovement);
              recoverHeadForward = this._myBlurRecoverHeadTransform.quat2_getForward(recoverHeadForward);
              currentHeadForward = this._myCurrentHead.pp_getForward(currentHeadForward);
              rotationToPerform = currentHeadForward.vec3_rotationToPivotedQuat(recoverHeadForward, playerUp, rotationToPerform);
              if (this._myParams.myBlurEndResyncRotation) {
                this.rotateFeetQuat(rotationToPerform);
              }
              this._myBlurRecoverHeadTransform = null;
            }
          }
        };
      }();
      PlayerHeadManager.prototype._sessionChangeResync = function() {
        let currentHeadPosition = PP.vec3_create();
        let resyncHeadPosition = PP.vec3_create();
        let resyncHeadRotation = PP.quat_create();
        let playerUp = PP.vec3_create();
        let flatCurrentHeadPosition = PP.vec3_create();
        let flatResyncHeadPosition = PP.vec3_create();
        let resyncMovement = PP.vec3_create();
        let resyncHeadForward = PP.vec3_create();
        let resyncHeadUp = PP.vec3_create();
        let resyncHeadRight = PP.vec3_create();
        let playerPosition = PP.vec3_create();
        let newPlayerPosition = PP.vec3_create();
        let fixedHeadRight = PP.vec3_create();
        let fixedHeadRightNegate = PP.vec3_create();
        let fixedHeadUp = PP.vec3_create();
        let fixedHeadForward = PP.vec3_create();
        let fixedHeadRotation = PP.quat_create();
        return function _sessionChangeResync() {
          if (this._myBlurRecoverHeadTransform == null && this._mySessionChangeResyncHeadTransform != null) {
            if (this._mySessionActive) {
              currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
              resyncHeadPosition = this._mySessionChangeResyncHeadTransform.quat2_getPosition(resyncHeadPosition);
              resyncHeadRotation = this._mySessionChangeResyncHeadTransform.quat2_getRotationQuat(resyncHeadRotation);
              playerUp = PP.myPlayerObjects.myPlayer.pp_getUp(playerUp);
              flatCurrentHeadPosition = currentHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatCurrentHeadPosition);
              flatResyncHeadPosition = resyncHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatResyncHeadPosition);
              resyncMovement = flatResyncHeadPosition.vec3_sub(flatCurrentHeadPosition, resyncMovement);
              this.moveFeet(resyncMovement);
              let isFloor = PP.XRUtils.isReferenceSpaceLocalFloor() || PP.XRUtils.isDeviceEmulated() && Global.myIsLocalhost;
              if (this._myParams.myEnterSessionResyncHeight || this._myParams.myNextEnterSessionResyncHeight) {
                this._myParams.myNextEnterSessionResyncHeight = false;
                let resyncHeadHeight = this._getPositionHeight(resyncHeadPosition);
                let currentHeadHeight = this._getPositionHeight(currentHeadPosition);
                this._myParams.myHeightOffsetVRWithoutFloor = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
                if (this._myParams.myHeightOffsetVRWithFloor == null) {
                  this._myParams.myHeightOffsetVRWithFloor = 0;
                }
                this._myParams.myHeightOffsetVRWithFloor = this._myParams.myHeightOffsetVRWithFloor + (resyncHeadHeight - currentHeadHeight);
                this._updateHeightOffset();
              } else if (isFloor && (this._myParams.myNextEnterSessionFloorHeight != null || this._myParams.myEnterSessionFloorHeight != null)) {
                let floorHeight = this._myParams.myNextEnterSessionFloorHeight != null ? this._myParams.myNextEnterSessionFloorHeight : this._myParams.myEnterSessionFloorHeight;
                floorHeight -= this._myParams.myForeheadExtraHeight;
                let currentHeadHeight = this._getPositionHeight(currentHeadPosition);
                if (this._myParams.myHeightOffsetVRWithFloor == null) {
                  this._myParams.myHeightOffsetVRWithFloor = 0;
                }
                this._myParams.myHeightOffsetVRWithFloor = this._myParams.myHeightOffsetVRWithFloor + (floorHeight - currentHeadHeight);
                this._updateHeightOffset();
              }
              this._resyncHeadRotationForward(resyncHeadRotation);
            } else {
              playerUp = PP.myPlayerObjects.myPlayer.pp_getUp(playerUp);
              resyncHeadPosition = this._mySessionChangeResyncHeadTransform.quat2_getPosition(resyncHeadPosition);
              flatResyncHeadPosition = resyncHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatResyncHeadPosition);
              playerPosition = PP.myPlayerObjects.myPlayer.pp_getPosition(playerPosition);
              newPlayerPosition = flatResyncHeadPosition.vec3_add(playerPosition.vec3_componentAlongAxis(playerUp, newPlayerPosition), newPlayerPosition);
              PP.myPlayerObjects.myPlayer.pp_setPosition(newPlayerPosition);
              PP.myPlayerObjects.myNonVRCamera.pp_resetPositionLocal();
              if (this._myParams.myExitSessionResyncHeight) {
                let resyncHeadHeight = this._getPositionHeight(resyncHeadPosition);
                this._myParams.myHeightOffsetNonVR = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
                this._updateHeightOffset();
              }
              resyncHeadRotation = this._mySessionChangeResyncHeadTransform.quat2_getRotationQuat(resyncHeadRotation);
              if (this._myParams.myExitSessionRemoveRightTilt || this._myParams.myExitSessionAdjustMaxVerticalAngle || !this._myParams.myExitSessionResyncVerticalAngle) {
                resyncHeadForward = resyncHeadRotation.quat_getForward(resyncHeadForward);
                resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
                fixedHeadRight = resyncHeadForward.vec3_cross(playerUp, fixedHeadRight);
                fixedHeadRight.vec3_normalize(fixedHeadRight);
                if (!resyncHeadUp.vec3_isConcordant(playerUp)) {
                  let angleForwardUp = resyncHeadForward.vec3_angle(playerUp);
                  let negateAngle = 45;
                  if (angleForwardUp > 180 - negateAngle || angleForwardUp < negateAngle) {
                    fixedHeadRight.vec3_negate(fixedHeadRight);
                  }
                }
                if (fixedHeadRight.vec3_isZero(1e-6)) {
                  fixedHeadRight = resyncHeadRotation.quat_getRight(fixedHeadRight);
                }
                fixedHeadUp = fixedHeadRight.vec3_cross(resyncHeadForward, fixedHeadUp);
                fixedHeadUp.vec3_normalize(fixedHeadUp);
                fixedHeadForward = fixedHeadUp.vec3_cross(fixedHeadRight, fixedHeadForward);
                fixedHeadForward.vec3_normalize(fixedHeadForward);
                fixedHeadRotation.quat_fromAxes(fixedHeadRight.vec3_negate(fixedHeadRightNegate), fixedHeadUp, fixedHeadForward);
                resyncHeadRotation.quat_copy(fixedHeadRotation);
              }
              if (this._myParams.myExitSessionAdjustMaxVerticalAngle || !this._myParams.myExitSessionResyncVerticalAngle) {
                resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
                resyncHeadRight = resyncHeadRotation.quat_getRight(resyncHeadRight);
                let maxVerticalAngle = Math.max(0, this._myParams.myExitSessionMaxVerticalAngle - 1e-4);
                if (!this._myParams.myExitSessionResyncVerticalAngle) {
                  maxVerticalAngle = 0;
                }
                let angleWithUp = Math.pp_angleClamp(resyncHeadUp.vec3_angleSigned(playerUp, resyncHeadRight));
                if (Math.abs(angleWithUp) > maxVerticalAngle) {
                  let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
                  resyncHeadRotation = resyncHeadRotation.quat_rotateAxis(fixAngle, resyncHeadRight, resyncHeadRotation);
                }
              }
              this.setRotationHeadQuat(resyncHeadRotation);
            }
            if (this._mySessionActive) {
              this._myParams.myNextEnterSessionFloorHeight = null;
              this._myFirstEnterSessionResyncDone = true;
            }
            this._mySessionChangeResyncHeadTransform = null;
          }
        };
      }();
      PlayerHeadManager.prototype._resyncHeadRotationForward = function() {
        let playerUp = PP.vec3_create();
        let resyncHeadForward = PP.vec3_create();
        let resyncHeadUp = PP.vec3_create();
        let fixedResyncHeadRotation = PP.quat_create();
        return function _resyncHeadRotationForward(resyncHeadRotation) {
          playerUp = PP.myPlayerObjects.myPlayer.pp_getUp(playerUp);
          resyncHeadForward = resyncHeadRotation.quat_getForward(resyncHeadForward);
          resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
          fixedResyncHeadRotation.quat_copy(resyncHeadRotation);
          fixedResyncHeadRotation.quat_setUp(playerUp, resyncHeadForward);
          if (!resyncHeadUp.vec3_isConcordant(playerUp)) {
            fixedResyncHeadRotation.quat_rotateAxis(180, playerUp, fixedResyncHeadRotation);
          }
          this.setRotationFeetQuat(fixedResyncHeadRotation);
          return;
        };
      }();
      PlayerHeadManager.prototype._updateHeightOffset = function() {
        return function _updateHeightOffset() {
          if (this._mySessionActive) {
            if (PP.XRUtils.isDeviceEmulated() && Global.myIsLocalhost) {
              this._setPlayerPivotHeightOffset(0, 0);
            } else if (PP.XRUtils.isReferenceSpaceLocalFloor()) {
              this._setPlayerPivotHeightOffset(this._myParams.myHeightOffsetVRWithFloor, 0);
            } else {
              this._setPlayerPivotHeightOffset(this._myParams.myHeightOffsetVRWithoutFloor, this._myParams.myForeheadExtraHeight);
            }
          } else {
            this._setPlayerPivotHeightOffset(this._myParams.myHeightOffsetNonVR, this._myParams.myForeheadExtraHeight);
          }
        };
      }();
      PlayerHeadManager.prototype._setPlayerPivotHeightOffset = function() {
        let playerPivotPosition = PP.vec3_create();
        return function _setPlayerPivotHeightOffset(offset, amountToRemove) {
          if (offset != null) {
            playerPivotPosition = PP.myPlayerObjects.myPlayerPivot.pp_getPositionLocal(playerPivotPosition);
            PP.myPlayerObjects.myPlayerPivot.pp_setPositionLocal([playerPivotPosition[0], offset - amountToRemove, playerPivotPosition[2]]);
          }
        };
      }();
      Object.defineProperty(PlayerHeadManager.prototype, "getHeightEyes", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "getTransformFeetQuat", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "getPositionFeet", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "moveFeet", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "rotateFeetQuat", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "rotateHeadQuat", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "teleportPositionHead", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "teleportPositionFeet", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "teleportPlayerToHeadTransformQuat", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "_getPositionHeight", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionStart", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionEnd", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionBlurStart", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionBlurEnd", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "_onViewReset", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "_blurEndResync", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "_sessionChangeResync", { enumerable: false });
      Object.defineProperty(PlayerHeadManager.prototype, "_setPlayerPivotHeightOffset", { enumerable: false });
    }
  });

  // js/locomotion/player_transform_manager.js
  var require_player_transform_manager = __commonJS({
    "js/locomotion/player_transform_manager.js"() {
      PlayerTransformManagerSyncFlag = {
        BODY_COLLIDING: 0,
        HEAD_COLLIDING: 1,
        FAR: 2,
        FLOATING: 3
      };
      PlayerTransformManagerParams = class PlayerTransformManagerParams {
        constructor() {
          this.myPlayerHeadManager = null;
          this.myMovementCollisionCheckParams = null;
          this.myTeleportCollisionCheckParams = null;
          this.myTeleportCollisionCheckParamsCopyFromMovement = false;
          this.myTeleportCollisionCheckParamsCheck360 = false;
          this.mySyncEnabledFlagMap = /* @__PURE__ */ new Map();
          this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
          this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, true);
          this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
          this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
          this.mySyncPositionFlagMap = /* @__PURE__ */ new Map();
          this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
          this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
          this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
          this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
          this.mySyncPositionHeadFlagMap = /* @__PURE__ */ new Map();
          this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
          this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, true);
          this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
          this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
          this.mySyncRotationFlagMap = /* @__PURE__ */ new Map();
          this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
          this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
          this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
          this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
          this.mySyncHeightFlagMap = /* @__PURE__ */ new Map();
          this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
          this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
          this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
          this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
          this.myIsLeaningValidAboveDistance = false;
          this.myLeaningValidDistance = 0;
          this.myIsFloatingValidIfVerticalMovement = false;
          this.myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
          this.myIsFloatingValidIfRealOnGround = false;
          this.myIsFloatingValidIfSteepGround = false;
          this.myIsFloatingValidIfVerticalMovementAndSteepGround = false;
          this.myFloatingSplitCheckEnabled = false;
          this.myFloatingSplitCheckMaxLength = 0;
          this.myFloatingSplitCheckMaxSteps = null;
          this.myFloatingSplitCheckStepEqualLength = false;
          this.myFloatingSplitCheckStepEqualLengthMinLength = 0;
          this.myIsMaxDistanceFromRealToSyncEnabled = false;
          this.myMaxDistanceFromRealToSync = 0;
          this.myHeadRadius = 0;
          this.myHeadCollisionBlockLayerFlags = new PP.PhysicsLayerFlags();
          this.myHeadCollisionObjectsToIgnore = [];
          this.myRotateOnlyIfSynced = false;
          this.myResetRealResetRotationIfUpChanged = true;
          this.myRealMovementAllowVerticalAdjustments = false;
          this.myUpdateRealPositionValid = false;
          this.myUpdatePositionValid = false;
          this.myMinHeight = null;
          this.myMaxHeight = null;
          this.myIsBodyCollidingWhenHeightBelowValue = null;
          this.myIsBodyCollidingWhenHeightAboveValue = null;
          this.myIsBodyCollidingExtraCheckCallback = null;
          this.myIsLeaningExtraCheckCallback = null;
          this.myIsHoppingExtraCheckCallback = null;
          this.myIsFarExtraCheckCallback = null;
          this.myResetToValidOnEnterSession = false;
          this.myResetToValidOnExitSession = false;
          this.myAlwaysResetRealPositionNonVR = false;
          this.myAlwaysResetRealRotationNonVR = false;
          this.myAlwaysResetRealHeightNonVR = false;
          this.myAlwaysResetRealPositionVR = false;
          this.myAlwaysResetRealRotationVR = false;
          this.myAlwaysResetRealHeightVR = false;
          this.myNeverResetRealPositionNonVR = false;
          this.myNeverResetRealRotationNonVR = false;
          this.myNeverResetRealHeightNonVR = false;
          this.myNeverResetRealPositionVR = false;
          this.myNeverResetRealRotationVR = false;
          this.myNeverResetRealHeightVR = false;
          this.myResetRealOnMove = false;
          this.myResetRealOnTeleport = false;
          this.mySyncPositionDisabled = false;
          this.myDebugActive = false;
        }
      };
      PlayerTransformManager = class PlayerTransformManager {
        constructor(params) {
          this._myParams = params;
          this._myRealMovementCollisionCheckParams = null;
          this._generateRealMovementParamsFromMovementParams();
          this._myCollisionRuntimeParams = new CollisionRuntimeParams();
          this._myRealCollisionRuntimeParams = new CollisionRuntimeParams();
          if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
            this._generateTeleportParamsFromMovementParams();
          }
          this._myHeadCollisionCheckParams = null;
          this._setupHeadCollisionCheckParams();
          this._myValidPosition = PP.vec3_create();
          this._myValidRotationQuat = new PP.quat_create();
          this._myValidHeight = 0;
          this._myValidPositionHead = PP.vec3_create();
          this._myIsBodyColliding = false;
          this._myIsHeadColliding = false;
          this._myIsLeaning = false;
          this._myIsHopping = false;
          this._myIsFar = false;
          this._myLastValidMovementDirection = PP.vec3_create();
          this._myIsRealPositionValid = false;
          this._myIsPositionValid = false;
          this._myResetRealOnSynced = false;
        }
        start() {
          this.resetToReal(true);
          if (WL.xrSession) {
            this._onXRSessionStart(true, WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this, false));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        }
        // update should be before to check the new valid transform and if the head new transform is fine
        // then update movements, so that they will use the proper transform
        // pre/post update?
        // for sliding if previous frame no horizontal movement then reset sliding on pre update
        // in generale capire come fare per risolvere i problemi quando c' un move solo verticale che sputtana i dati dello sliding precedente
        // che servono per far slidare bene anche dopo, magari un flag per dire non aggiornare le cose relative al movimento orizzontale
        // o un move check solo verticale
        update(dt) {
        }
        move(movement, outCollisionRuntimeParams = null, forceMove = false) {
        }
        teleportPosition(position, outCollisionRuntimeParams = null, forceTeleport = false) {
        }
        teleportTransformQuat(transformQuat3, outCollisionRuntimeParams = null, forceTeleport = false) {
        }
        rotateQuat(rotationQuat) {
        }
        setRotationQuat(rotationQuat) {
        }
        setHeight(height, forceSet = false) {
        }
        getPlayer() {
          return this._myParams.myPlayerHeadManager.getPlayer();
        }
        getHead() {
          return this._myParams.myPlayerHeadManager.getHead();
        }
        getTransformQuat(outTransformQuat = PP.quat2_create()) {
          return outTransformQuat.quat2_setPositionRotationQuat(this.getPosition(), this.getRotationQuat());
        }
        getPosition(outPosition = PP.vec3_create()) {
          return outPosition.vec3_copy(this._myValidPosition);
        }
        getRotationQuat(outRotation = PP.quat_create()) {
          return outRotation.quat_copy(this._myValidRotationQuat);
        }
        getPositionHead(outPosition = PP.vec3_create()) {
          return outPosition.vec3_copy(this._myValidPositionHead);
        }
        getTransformHeadQuat(outTransformQuat = PP.quat2_create()) {
          return outTransformQuat.quat2_setPositionRotationQuat(this.getPositionHead(), this.getRotationQuat());
        }
        getHeight() {
          return this._myValidHeight;
        }
        getTransformRealQuat(outTransformQuat = PP.quat2_create()) {
          return this.getPlayerHeadManager().getTransformFeetQuat(outTransformQuat);
        }
        getTransformHeadRealQuat(outTransformQuat = PP.quat2_create()) {
          return this.getPlayerHeadManager().getTransformHeadQuat(outTransformQuat);
        }
        getPositionReal(outPosition = PP.vec3_create()) {
          return this.getPlayerHeadManager().getPositionFeet(outPosition);
        }
        getPositionHeadReal(outPosition = PP.vec3_create()) {
          return this.getPlayerHeadManager().getPositionHead(outPosition);
        }
        getRotationRealQuat(outRotation = PP.quat_create()) {
          return this.getPlayerHeadManager().getRotationFeetQuat(outRotation);
        }
        getHeightReal() {
          return this._myParams.myPlayerHeadManager.getHeightHead();
        }
        isSynced(syncFlagMap = null) {
          let isBodyColliding = this.isBodyColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING));
          let isHeadColliding = this.isHeadColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING));
          let isFar = this.isFar() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FAR));
          let isFloating = this.isFloating() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING));
          return !isBodyColliding && !isHeadColliding && !isFar && !isFloating;
        }
        resetReal(resetPosition = true, resetRotation = true, resetHeight = true, updateRealFlags = false) {
        }
        updateReal() {
          this._updateReal(0, false);
        }
        resetToReal(updateRealFlags = false) {
          this._myValidPosition = this.getPositionReal(this._myValidPosition);
          this._myValidPositionHead = this.getPositionHeadReal(this._myValidPositionHead);
          this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
          this._myValidHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
          if (updateRealFlags) {
            this._updateReal(0, false);
          }
        }
        isBodyColliding() {
          return this._myIsBodyColliding;
        }
        isHeadColliding() {
          return this._myIsHeadColliding;
        }
        isFloating() {
          return this.isLeaning() || this.isHopping();
        }
        isLeaning() {
          return this._myIsLeaning;
        }
        isHopping() {
          return this._myIsHopping;
        }
        isFar() {
          return this._myIsFar;
        }
        getDistanceToReal() {
        }
        getDistanceToRealHead() {
        }
        getPlayerHeadManager() {
          return this._myParams.myPlayerHeadManager;
        }
        getParams() {
          return this._myParams;
        }
        getMovementCollisionCheckParams() {
          return this._myParams.myMovementCollisionCheckParams;
        }
        getTeleportCollisionCheckParams() {
          return this._myParams.myTeleportCollisionCheckParams;
        }
        collisionCheckParamsUpdated() {
          if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
            this._generateTeleportParamsFromMovementParams();
          }
          this._generateRealMovementParamsFromMovementParams();
        }
        isPositionValid() {
          return this._myIsPositionValid;
        }
        isRealPositionValid() {
          return this._myIsRealPositionValid;
        }
        getCollisionRuntimeParams() {
          return this._myCollisionRuntimeParams;
        }
        getRealCollisionRuntimeParams() {
          return this._myRealCollisionRuntimeParams;
        }
        _updateCollisionHeight() {
          let validHeight = this.getHeight();
          let realHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
          this._myParams.myMovementCollisionCheckParams.myHeight = validHeight;
          this._myParams.myTeleportCollisionCheckParams.myHeight = validHeight;
          this._myRealMovementCollisionCheckParams.myHeight = realHeight;
        }
        _setupHeadCollisionCheckParams() {
          this._myHeadCollisionCheckParams = new CollisionCheckParams();
          let params = this._myHeadCollisionCheckParams;
          params.myRadius = this._myParams.myHeadRadius;
          params.myDistanceFromFeetToIgnore = 0;
          params.myDistanceFromHeadToIgnore = 0;
          params.mySplitMovementEnabled = true;
          params.mySplitMovementMaxLength = 0.5;
          params.mySplitMovementMaxStepsEnabled = true;
          params.mySplitMovementMaxSteps = 2;
          params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
          params.mySplitMovementStopWhenVerticalMovementCanceled = true;
          params.myHorizontalMovementCheckEnabled = true;
          params.myHorizontalMovementRadialStepAmount = 1;
          params.myHorizontalMovementCheckDiagonalOutward = true;
          params.myHorizontalMovementCheckDiagonalInward = true;
          params.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = true;
          params.myHorizontalMovementCheckVerticalDiagonalUpwardInward = true;
          params.myHorizontalPositionCheckEnabled = true;
          params.myHalfConeAngle = 180;
          params.myHalfConeSliceAmount = 3;
          params.myCheckConeBorder = true;
          params.myCheckConeRay = true;
          params.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = false;
          params.myHorizontalPositionCheckVerticalDirectionType = 0;
          params.myHeight = params.myRadius;
          params.myPositionOffsetLocal.vec3_set(0, -params.myRadius / 2, 0);
          params.myCheckHeight = true;
          params.myCheckHeightVerticalMovement = true;
          params.myCheckHeightVerticalPosition = true;
          params.myHeightCheckStepAmountMovement = 2;
          params.myHeightCheckStepAmountPosition = 2;
          params.myCheckHeightTopMovement = true;
          params.myCheckHeightTopPosition = true;
          params.myCheckVerticalStraight = true;
          params.myCheckVerticalFixedForwardEnabled = true;
          params.myCheckVerticalFixedForward = PP.vec3_create(0, 0, 1);
          params.myCheckHorizontalFixedForwardEnabled = true;
          params.myCheckHorizontalFixedForward = PP.vec3_create(0, 0, 1);
          params.myVerticalMovementCheckEnabled = true;
          params.myVerticalPositionCheckEnabled = true;
          params.myGroundCircumferenceAddCenter = true;
          params.myGroundCircumferenceSliceAmount = 6;
          params.myGroundCircumferenceStepAmount = 2;
          params.myGroundCircumferenceRotationPerStep = 30;
          params.myFeetRadius = params.myRadius;
          params.myHorizontalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
          params.myHorizontalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
          params.myVerticalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
          params.myVerticalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
          params.myDebugActive = false;
          params.myDebugHorizontalMovementActive = true;
          params.myDebugHorizontalPositionActive = false;
          params.myDebugVerticalMovementActive = false;
          params.myDebugVerticalPositionActive = false;
          params.myDebugSlidingActive = false;
          params.myDebugGroundInfoActive = false;
          params.myDebugCeilingInfoActive = false;
          params.myDebugRuntimeParamsActive = false;
          params.myDebugMovementActive = false;
        }
        _generateTeleportParamsFromMovementParams() {
          if (this._myParams.myTeleportCollisionCheckParams == null) {
            this._myParams.myTeleportCollisionCheckParams = new CollisionCheckParams();
          }
          if (this._myParams.myTeleportCollisionCheckParamsCheck360) {
            this._myParams.myTeleportCollisionCheckParams = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myParams.myMovementCollisionCheckParams, this._myParams.myTeleportCollisionCheckParams);
          } else {
            this._myParams.myTeleportCollisionCheckParams.copy(this._myParams.myMovementCollisionCheckParams);
          }
        }
        _generateRealMovementParamsFromMovementParams() {
          if (this._myRealMovementCollisionCheckParams == null) {
            this._myRealMovementCollisionCheckParams = new CollisionCheckParams();
          }
          let params = this._myRealMovementCollisionCheckParams;
          params.copy(this._myParams.myMovementCollisionCheckParams);
          params.mySplitMovementEnabled = true;
          params.mySplitMovementMaxLength = 0.5;
          params.mySplitMovementMaxStepsEnabled = true;
          params.mySplitMovementMaxSteps = 2;
          params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
          params.mySplitMovementStopWhenVerticalMovementCanceled = true;
          params.mySlidingEnabled = false;
          if (!this._myParams.myRealMovementAllowVerticalAdjustments) {
            params.mySnapOnGroundEnabled = false;
            params.mySnapOnCeilingEnabled = false;
            params.myGroundPopOutEnabled = false;
            params.myCeilingPopOutEnabled = false;
            params.myAdjustVerticalMovementWithGroundAngleDownhill = false;
            params.myAdjustVerticalMovementWithGroundAngleUphill = false;
            params.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
            params.myAdjustVerticalMovementWithCeilingAngleUphill = false;
            params.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
            params.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
            params.myVerticalMovementReduceEnabled = false;
          }
          params.myIsOnGroundIfInsideHit = true;
          params.myDebugActive = false;
          params.myDebugHorizontalMovementActive = false;
          params.myDebugHorizontalPositionActive = false;
          params.myDebugVerticalMovementActive = false;
          params.myDebugVerticalPositionActive = false;
          params.myDebugSlidingActive = false;
          params.myDebugGroundInfoActive = true;
          params.myDebugCeilingInfoActive = true;
          params.myDebugRuntimeParamsActive = false;
          params.myDebugMovementActive = false;
        }
        _onXRSessionStart(manualStart, session) {
          if (this._myParams.myResetToValidOnEnterSession) {
            this._myResetRealOnSynced = true;
          }
        }
        _onXRSessionEnd() {
          if (this._myParams.myResetToValidOnExitSession) {
            this._myResetRealOnSynced = true;
          }
        }
        _debugUpdate(dt) {
          PP.myDebugVisualManager.drawPoint(0, this._myValidPosition, PP.vec4_create(1, 0, 0, 1), 0.05);
          PP.myDebugVisualManager.drawLineEnd(0, this._myValidPosition, this.getPositionReal(), PP.vec4_create(1, 0, 0, 1), 0.05);
          PP.myDebugVisualManager.drawLine(0, this._myValidPosition, this._myValidRotationQuat.quat_getForward(), 0.15, PP.vec4_create(0, 1, 0, 1), 0.025);
          PP.myDebugVisualManager.drawPoint(0, this._myValidPositionHead, PP.vec4_create(1, 1, 0, 1), 0.05);
        }
      };
      PlayerTransformManager.prototype.getDistanceToReal = function() {
        let realPosition = PP.vec3_create();
        return function getDistanceToReal() {
          realPosition = this.getPositionReal(realPosition);
          return realPosition.vec3_distance(this.getPosition());
        };
      }();
      PlayerTransformManager.prototype.getDistanceToRealHead = function() {
        let realPosition = PP.vec3_create();
        return function getDistanceToRealHead() {
          realPosition = this.getPositionHeadReal(realPosition);
          return realPosition.vec3_distance(this.getPositionHead());
        };
      }();
      PlayerTransformManager.prototype.resetReal = function() {
        let realUp = PP.vec3_create();
        let validUp = PP.vec3_create();
        let position = PP.vec3_create();
        let rotationQuat = PP.quat_create();
        return function resetReal(resetPosition = true, resetRotation = true, resetHeight = true, updateRealFlags = false) {
          let playerHeadManager = this.getPlayerHeadManager();
          if (resetPosition) {
            playerHeadManager.teleportPositionFeet(this.getPosition(position));
          }
          realUp = this.getPlayerHeadManager().getRotationFeetQuat(rotationQuat).quat_getUp(realUp);
          validUp = this.getRotationQuat(rotationQuat).quat_getUp(validUp);
          if (resetRotation || realUp.vec3_angle(validUp) > Math.PP_EPSILON_DEGREES && this._myParams.myResetRealResetRotationIfUpChanged) {
            playerHeadManager.setRotationFeetQuat(this.getRotationQuat(rotationQuat), false);
          }
          if (resetHeight) {
            playerHeadManager.setHeight(this.getHeight(), true);
          }
          if (updateRealFlags) {
            this._updateReal(0, false);
          }
        };
      }();
      PlayerTransformManager.prototype.update = function() {
        let transformQuat3 = PP.quat2_create();
        let collisionRuntimeParams = new CollisionRuntimeParams();
        let transformUp = PP.vec3_create();
        let horizontalDirection = PP.vec3_create();
        let rotationQuat = PP.quat_create();
        return function update(dt) {
          if (this._myResetRealOnSynced) {
            if (this.getPlayerHeadManager().isSynced()) {
              this._myResetRealOnSynced = false;
              if (PP.XRUtils.isSessionActive()) {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionVR,
                  !this._myParams.myNeverResetRealRotationVR,
                  !this._myParams.myNeverResetRealHeightVR,
                  false
                );
              } else {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionNonVR,
                  !this._myParams.myNeverResetRealRotationNonVR,
                  !this._myParams.myNeverResetRealHeightNonVR,
                  false
                );
              }
            }
          }
          this._updateReal(dt);
          if (this._myParams.myUpdatePositionValid) {
            transformQuat3 = this.getTransformQuat(transformQuat3);
            transformUp = transformQuat3.quat2_getUp(transformUp);
            rotationQuat = transformQuat3.quat2_getRotationQuat(rotationQuat);
            horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
            if (!horizontalDirection.vec3_isZero(1e-5)) {
              horizontalDirection.vec3_normalize(horizontalDirection);
              rotationQuat.quat_setForward(horizontalDirection);
              transformQuat3.quat2_setRotationQuat(rotationQuat);
            }
            let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugActive;
            this._myParams.myMovementCollisionCheckParams.myDebugActive = false;
            CollisionCheckGlobal.positionCheck(true, transformQuat3, this._myParams.myMovementCollisionCheckParams, collisionRuntimeParams);
            this._myParams.myMovementCollisionCheckParams.myDebugActive = debugBackup;
            this._myIsPositionValid = collisionRuntimeParams.myIsPositionOk;
          }
          if (this._myParams.myDebugActive) {
            this._debugUpdate(dt);
          }
        };
      }();
      PlayerTransformManager.prototype._updateReal = function() {
        let movementToCheck = PP.vec3_create();
        let position = PP.vec3_create();
        let positionReal = PP.vec3_create();
        let transformQuat3 = PP.quat2_create();
        let collisionRuntimeParams = new CollisionRuntimeParams();
        let newPosition = PP.vec3_create();
        let newPositionHead = PP.vec3_create();
        let movementStep = PP.vec3_create();
        let currentMovementStep = PP.vec3_create();
        let transformUp = PP.vec3_create();
        let verticalMovement = PP.vec3_create();
        let movementChecked = PP.vec3_create();
        let newFeetPosition = PP.vec3_create();
        let floatingTransformQuat = PP.quat2_create();
        let horizontalDirection = PP.vec3_create();
        let rotationQuat = PP.quat_create();
        return function _updateReal(dt, resetRealEnabled = true) {
          if (this.getPlayerHeadManager().isSynced()) {
            this._updateCollisionHeight();
            this._myIsBodyColliding = false;
            this._myIsHeadColliding = false;
            this._myIsLeaning = false;
            this._myIsHopping = false;
            this._myIsFar = false;
            movementToCheck = this.getPositionReal(positionReal).vec3_sub(this.getPosition(position), movementToCheck);
            if (movementToCheck.vec3_length() > 1e-4) {
              this._myLastValidMovementDirection = movementToCheck.vec3_normalize(this._myLastValidMovementDirection);
            }
            if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FAR)) {
              if (this._myParams.myIsMaxDistanceFromRealToSyncEnabled && movementToCheck.vec3_length() > this._myParams.myMaxDistanceFromRealToSync) {
                this._myIsFar = true;
              } else if (this._myParams.myIsFarExtraCheckCallback != null && this._myParams.myIsFarExtraCheckCallback(this)) {
                this._myIsFar = true;
              }
            }
            collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
            collisionRuntimeParams.myIsOnGround = true;
            transformQuat3 = this.getTransformQuat(transformQuat3);
            newPosition.vec3_copy(this._myValidPosition);
            if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING)) {
              CollisionCheckGlobal.move(movementToCheck, transformQuat3, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
              if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
                if (Math.pp_clamp(
                  this._myRealMovementCollisionCheckParams.myHeight,
                  this._myParams.myIsBodyCollidingWhenHeightBelowValue,
                  this._myParams.myIsBodyCollidingWhenHeightAboveValue
                ) != this._myRealMovementCollisionCheckParams.myHeight) {
                  this._myIsBodyColliding = true;
                } else {
                  if (this._myParams.myIsBodyCollidingExtraCheckCallback != null && this._myParams.myIsBodyCollidingExtraCheckCallback(this)) {
                    this._myIsBodyColliding = true;
                  } else {
                    this._myIsBodyColliding = false;
                    newPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
                  }
                }
              } else {
                this._myIsBodyColliding = true;
              }
            }
            if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING)) {
              if (!this._myIsBodyColliding) {
                movementToCheck = newPosition.vec3_sub(position, movementToCheck);
              } else {
                movementToCheck = positionReal.vec3_sub(position, movementToCheck);
              }
              collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
              floatingTransformQuat.quat2_setPositionRotationQuat(this._myValidPosition, this._myValidRotationQuat);
              CollisionCheckGlobal.updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
              if (collisionRuntimeParams.myIsOnGround) {
                transformUp = transformQuat3.quat2_getUp(transformUp);
                verticalMovement = movementToCheck.vec3_componentAlongAxis(transformUp);
                let isVertical = !verticalMovement.vec3_isZero(1e-5);
                if (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovement) {
                  let movementStepAmount = 1;
                  movementStep.vec3_copy(movementToCheck);
                  if (!movementToCheck.vec3_isZero(1e-5) && this._myParams.myFloatingSplitCheckEnabled) {
                    let equalStepLength = movementToCheck.vec3_length() / this._myParams.myFloatingSplitCheckMaxSteps;
                    if (!this._myParams.myFloatingSplitCheckStepEqualLength || equalStepLength < this._myParams.myFloatingSplitCheckStepEqualLengthMinLength) {
                      let maxLength = this._myParams.myFloatingSplitCheckStepEqualLength ? this._myParams.myFloatingSplitCheckStepEqualLengthMinLength : this._myParams.myFloatingSplitCheckMaxLength;
                      movementStepAmount = Math.ceil(movementToCheck.vec3_length() / maxLength);
                      if (movementStepAmount > 1) {
                        movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(maxLength, movementStep);
                        movementStepAmount = this._myParams.myFloatingSplitCheckMaxSteps != null ? Math.min(movementStepAmount, this._myParams.myFloatingSplitCheckMaxSteps) : movementStepAmount;
                      }
                      movementStepAmount = Math.max(1, movementStepAmount);
                      if (movementStepAmount == 1) {
                        movementStep.vec3_copy(movementToCheck);
                      }
                    } else {
                      movementStepAmount = this._myParams.myFloatingSplitCheckMaxSteps;
                      if (movementStepAmount > 1) {
                        movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(equalStepLength, movementStep);
                      }
                    }
                  }
                  let isOnValidGroundAngle = collisionRuntimeParams.myGroundAngle <= this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4;
                  movementChecked.vec3_zero();
                  newFeetPosition.vec3_copy(this._myValidPosition);
                  collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
                  let atLeastOneNotOnGround = false;
                  let isOneOnGroundBetweenNoGround = false;
                  let isLastOnGround = false;
                  let isOneOnSteepGround = false;
                  for (let i = 0; i < movementStepAmount; i++) {
                    if (movementStepAmount == 1 || i != movementStepAmount - 1) {
                      currentMovementStep.vec3_copy(movementStep);
                    } else {
                      currentMovementStep = movementToCheck.vec3_sub(movementChecked, currentMovementStep);
                    }
                    newFeetPosition = newFeetPosition.vec3_add(currentMovementStep, newFeetPosition);
                    floatingTransformQuat.quat2_setPositionRotationQuat(newFeetPosition, this._myValidRotationQuat);
                    collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
                    CollisionCheckGlobal.updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
                    movementChecked = movementChecked.vec3_add(currentMovementStep, movementChecked);
                    if (!collisionRuntimeParams.myIsOnGround) {
                      atLeastOneNotOnGround = true;
                    } else {
                      if (collisionRuntimeParams.myGroundAngle > this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4) {
                        isOneOnSteepGround = true;
                      }
                      if (atLeastOneNotOnGround) {
                        isOneOnGroundBetweenNoGround = true;
                      }
                      if (i == movementStepAmount - 1) {
                        isLastOnGround = true;
                      }
                    }
                  }
                  let isFloatingOnSteepGroundFail = isOneOnSteepGround && isOnValidGroundAngle && !this._myParams.myIsFloatingValidIfSteepGround && (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovementAndSteepGround);
                  if (atLeastOneNotOnGround || isFloatingOnSteepGroundFail) {
                    if (isOneOnGroundBetweenNoGround) {
                      this._myIsHopping = true;
                    } else {
                      this._myIsLeaning = true;
                    }
                  } else {
                    this._myIsLeaning = false;
                    this._myIsHopping = false;
                    if (this._myParams.myIsLeaningExtraCheckCallback != null && this._myParams.myIsLeaningExtraCheckCallback(this)) {
                      this._myIsLeaning = true;
                    } else if (this._myParams.myIsHoppingExtraCheckCallback != null && this._myParams.myIsHoppingExtraCheckCallback(this)) {
                      this._myIsHopping = true;
                    }
                  }
                  if (this._myIsLeaning) {
                    let distance4 = movementToCheck.vec3_length();
                    if (this._myParams.myIsLeaningValidAboveDistance && distance4 > this._myParams.myLeaningValidDistance) {
                      this._myIsLeaning = false;
                    }
                  }
                  if (this._myIsLeaning || this._myIsHopping) {
                    if (isLastOnGround && this._myParams.myIsFloatingValidIfRealOnGround) {
                      this._myIsLeaning = false;
                      this._myIsHopping = false;
                    } else if (isLastOnGround && isVertical && this._myParams.myIsFloatingValidIfVerticalMovementAndRealOnGround) {
                      this._myIsLeaning = false;
                      this._myIsHopping = false;
                    }
                  }
                }
              }
            }
            movementToCheck = this.getPositionHeadReal(positionReal).vec3_sub(this.getPositionHead(position), movementToCheck);
            collisionRuntimeParams.reset();
            transformQuat3 = this.getTransformHeadQuat(transformQuat3);
            newPositionHead.vec3_copy(this._myValidPositionHead);
            if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING)) {
              CollisionCheckGlobal.move(movementToCheck, transformQuat3, this._myHeadCollisionCheckParams, collisionRuntimeParams);
              if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
                this._myIsHeadColliding = false;
                newPositionHead.vec3_copy(collisionRuntimeParams.myNewPosition);
              } else {
                this._myIsHeadColliding = true;
              }
            }
            if (this.isSynced(this._myParams.mySyncPositionFlagMap) && !this._myParams.mySyncPositionDisabled) {
              this._myValidPosition.vec3_copy(newPosition);
            }
            if (this.isSynced(this._myParams.mySyncPositionHeadFlagMap)) {
              this._myValidPositionHead = this.getPositionHeadReal(newPositionHead);
            }
            if (this.isSynced(this._myParams.mySyncRotationFlagMap)) {
              this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
            }
            if (this.isSynced(this._myParams.mySyncHeightFlagMap)) {
              this._myValidHeight = this._myRealMovementCollisionCheckParams.myHeight;
              this._updateCollisionHeight();
            }
            if (resetRealEnabled) {
              if (PP.XRUtils.isSessionActive()) {
                let resetPosition = (this.isSynced(this._myParams.mySyncPositionFlagMap) || this._myParams.myAlwaysResetRealPositionVR) && !this._myParams.myNeverResetRealPositionVR;
                let resetRotation = (this.isSynced(this._myParams.mySyncRotationFlagMap) || this._myParams.myAlwaysResetRealRotationVR) && !this._myParams.myNeverResetRealRotationVR;
                let resetHeight = (this.isSynced(this._myParams.mySyncHeightFlagMap) || this._myParams.myAlwaysResetRealHeightVR) && !this._myParams.myNeverResetRealHeightVR;
                this.resetReal(resetPosition, resetRotation, resetHeight, false);
              } else {
                let resetPosition = (this.isSynced(this._myParams.mySyncPositionFlagMap) || this._myParams.myAlwaysResetRealPositionNonVR) && !this._myParams.myNeverResetRealPositionNonVR;
                let resetRotation = (this.isSynced(this._myParams.mySyncRotationFlagMap) || this._myParams.myAlwaysResetRealRotationNonVR) && !this._myParams.myNeverResetRealRotationNonVR;
                let resetHeight = (this.isSynced(this._myParams.mySyncHeightFlagMap) || this._myParams.myAlwaysResetRealHeightNonVR) && !this._myParams.myNeverResetRealHeightNonVR;
                this.resetReal(resetPosition, resetRotation, resetHeight, false);
              }
            }
            if (this._myParams.myUpdateRealPositionValid) {
              transformQuat3 = this.getTransformRealQuat(transformQuat3);
              transformUp = transformQuat3.quat2_getUp(transformUp);
              rotationQuat = transformQuat3.quat2_getRotationQuat(rotationQuat);
              horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
              if (!horizontalDirection.vec3_isZero(1e-5)) {
                horizontalDirection.vec3_normalize(horizontalDirection);
                rotationQuat.quat_setForward(horizontalDirection);
                transformQuat3.quat2_setRotationQuat(rotationQuat);
              }
              let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugActive;
              this._myParams.myMovementCollisionCheckParams.myDebugActive = false;
              CollisionCheckGlobal.positionCheck(true, transformQuat3, this._myParams.myMovementCollisionCheckParams, this._myRealCollisionRuntimeParams);
              this._myIsRealPositionValid = this._myRealCollisionRuntimeParams.myIsPositionOk;
              this._myParams.myMovementCollisionCheckParams.myDebugActive = debugBackup;
            }
          }
        };
      }();
      PlayerTransformManager.prototype.move = function() {
        let transformQuat3 = PP.quat2_create();
        let fixedMovement = PP.vec3_create();
        return function move(movement, outCollisionRuntimeParams = null, forceMove = false) {
          transformQuat3 = this.getTransformQuat(transformQuat3);
          CollisionCheckGlobal.move(movement, transformQuat3, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
          if (outCollisionRuntimeParams != null) {
            outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
          }
          if (!forceMove) {
            fixedMovement.vec3_copy(this._myCollisionRuntimeParams.myFixedMovement);
          } else {
            fixedMovement.vec3_copy(movement);
          }
          if (!fixedMovement.vec3_isZero(1e-5)) {
            this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
            this.getPlayerHeadManager().moveFeet(fixedMovement);
          }
          if (this._myParams.myResetRealOnMove) {
            if (!this.isSynced()) {
              if (PP.XRUtils.isSessionActive()) {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionVR,
                  !this._myParams.myNeverResetRealRotationVR,
                  !this._myParams.myNeverResetRealHeightVR,
                  false
                );
              } else {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionNonVR,
                  !this._myParams.myNeverResetRealRotationNonVR,
                  !this._myParams.myNeverResetRealHeightNonVR,
                  false
                );
              }
            }
          }
        };
      }();
      PlayerTransformManager.prototype.teleportPosition = function() {
        let teleportTransformQuat = PP.quat2_create();
        return function teleportPosition(teleportPosition, outCollisionRuntimeParams = null, forceTeleport = false) {
          teleportTransformQuat = this.getTransformQuat(teleportTransformQuat);
          teleportTransformQuat.quat2_setPosition(teleportPosition);
          this.teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams, forceTeleport);
        };
      }();
      PlayerTransformManager.prototype.teleportTransformQuat = function() {
        let currentPosition = PP.vec3_create();
        let teleportPositionVec = PP.vec3_create();
        let teleportRotation = PP.quat_create();
        let rotatedTransformQuat = PP.quat2_create();
        let fixedMovement = PP.vec3_create();
        return function teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
          currentPosition = this.getPosition(currentPosition);
          teleportPositionVec = teleportTransformQuat.quat2_getPosition(teleportPositionVec);
          teleportRotation = teleportTransformQuat.quat2_getRotationQuat(teleportRotation);
          rotatedTransformQuat.quat2_setPositionRotationQuat(currentPosition, teleportRotation);
          CollisionCheckGlobal.teleport(teleportPositionVec, rotatedTransformQuat, this._myParams.myTeleportCollisionCheckParams, this._myCollisionRuntimeParams);
          if (outCollisionRuntimeParams != null) {
            outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
          }
          fixedMovement.vec3_zero();
          if (!forceTeleport) {
            if (!this._myCollisionRuntimeParams.myTeleportCanceled) {
              fixedMovement = this._myCollisionRuntimeParams.myFixedTeleportPosition.vec3_sub(currentPosition, fixedMovement);
              this.getPlayerHeadManager().setRotationFeetQuat(teleportRotation);
            }
          } else {
            fixedMovement = teleportPositionVec.vec3_sub(currentPosition, fixedMovement);
            this.getPlayerHeadManager().setRotationFeetQuat(teleportRotation);
          }
          if (!fixedMovement.vec3_isZero(1e-5)) {
            this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
            this.getPlayerHeadManager().moveFeet(fixedMovement);
          }
          if (this._myParams.myResetRealOnTeleport) {
            if (!this.isSynced()) {
              if (PP.XRUtils.isSessionActive()) {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionVR,
                  !this._myParams.myNeverResetRealRotationVR,
                  !this._myParams.myNeverResetRealHeightVR,
                  false
                );
              } else {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionNonVR,
                  !this._myParams.myNeverResetRealRotationNonVR,
                  !this._myParams.myNeverResetRealHeightNonVR,
                  false
                );
              }
            }
          }
        };
      }();
      PlayerTransformManager.prototype.rotateQuat = function() {
        return function rotateQuat(rotationQuat) {
          this._myValidRotationQuat.quat_rotateQuat(rotationQuat, this._myValidRotationQuat);
          this.getPlayerHeadManager().rotateFeetQuat(rotationQuat);
        };
      }();
      PlayerTransformManager.prototype.setRotationQuat = function() {
        let rotationToPerform = PP.quat_create();
        return function setRotationQuat(rotationQuat) {
          rotationToPerform = this._myValidRotationQuat.quat_rotationToQuat(rotationQuat, rotationToPerform);
          this.rotateQuat(rotationToPerform);
        };
      }();
      PlayerTransformManager.prototype.setHeight = function() {
        let transformQuat3 = PP.quat2_create();
        return function setHeight(height, forceSet = false) {
          let fixedHeight = Math.pp_clamp(height, this._myParams.myMinHeight, this._myParams.myMaxHeight);
          let previousHeight = this.getHeight();
          this._myValidHeight = fixedHeight;
          this._updateCollisionHeight();
          transformQuat3 = this.getTransformQuat(transformQuat3);
          CollisionCheckGlobal.positionCheck(true, transformQuat3, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
          if (this._myCollisionRuntimeParams.myIsPositionOk || forceSet) {
            this.getPlayerHeadManager().setHeight(this.getHeight(), true);
          } else {
            this._myValidHeight = previousHeight;
          }
          this._updateCollisionHeight();
        };
      }();
    }
  });

  // js/locomotion/player_locomotion_rotate.js
  var require_player_locomotion_rotate2 = __commonJS({
    "js/locomotion/player_locomotion_rotate.js"() {
      PlayerLocomotionRotateParams = class PlayerLocomotionRotateParams {
        constructor() {
          this.myPlayerHeadManager = null;
          this.myMaxRotationSpeed = 0;
          this.myIsSnapTurn = false;
          this.mySnapTurnOnlyVR = false;
          this.mySmoothSnapActive = true;
          this.mySmoothSnapSpeedDegrees = 240;
          this.myRotationMinStickIntensityThreshold = 0;
          this.mySnapTurnActivateThreshold = 0;
          this.mySnapTurnResetThreshold = 0;
          this.myClampVerticalAngle = true;
          this.myMaxVerticalAngle = 0;
          this.myHandedness = PP.Handedness.RIGHT;
        }
      };
      PlayerLocomotionRotate = class PlayerLocomotionRotate {
        constructor(params) {
          this._myParams = params;
          this._mySnapCharge = false;
          this._mySmoothSnapHorizontalRunning = false;
          this._mySmoothSnapHorizontalAngleToPerform = 0;
          this._mySmoothSnapVerticalRunning = false;
          this._mySmoothSnapVerticalAngleToPerform = 0;
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Teleport Smooth Speed", this._myParams.mySmoothSnapSpeedDegrees, 10, 3, 0));
        }
        start() {
        }
        stop() {
          this._mySmoothSnapHorizontalRunning = false;
          this._mySmoothSnapHorizontalAngleToPerform = 0;
          this._mySmoothSnapVerticalRunning = false;
          this._mySmoothSnapVerticalAngleToPerform = 0;
        }
        update(dt) {
          this._myParams.mySmoothSnapSpeedDegrees = PP.myEasyTuneVariables.get("Teleport Smooth Speed");
          this._rotateHeadHorizontally(dt);
          if (this._myParams.myPlayerHeadManager.canRotateHead()) {
            this._rotateHeadVertically(dt);
          }
        }
      };
      PlayerLocomotionRotate.prototype._rotateHeadHorizontally = function() {
        let playerUp = PP.vec3_create();
        let headRotation = PP.quat_create();
        return function _rotateHeadHorizontally(dt) {
          playerUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
          headRotation.quat_identity();
          let axes = PP.myGamepads[this._myParams.myHandedness].getAxesInfo().getAxes();
          if (!this._myParams.myIsSnapTurn || this._myParams.mySnapTurnOnlyVR && !PP.XRUtils.isSessionActive()) {
            if (Math.abs(axes[0]) > this._myParams.myRotationMinStickIntensityThreshold) {
              let rotationIntensity = -axes[0];
              let speed = Math.pp_lerp(0, this._myParams.myMaxRotationSpeed, Math.abs(rotationIntensity)) * Math.pp_sign(rotationIntensity);
              headRotation.quat_fromAxis(speed * dt, playerUp);
            }
          } else {
            if (!this._mySnapCharge) {
              if (Math.abs(axes.vec2_length()) < this._myParams.mySnapTurnResetThreshold) {
                this._mySnapCharge = true;
              }
            } else if (!this._mySmoothSnapHorizontalRunning) {
              if (Math.abs(axes[0]) > this._myParams.mySnapTurnActivateThreshold) {
                let angleToRotate = -Math.pp_sign(axes[0]) * this._myParams.mySnapTurnAngle;
                if (!this._myParams.mySmoothSnapActive) {
                  headRotation.quat_fromAxis(angleToRotate, playerUp);
                } else {
                  this._mySmoothSnapHorizontalRunning = true;
                  this._mySmoothSnapHorizontalAngleToPerform = angleToRotate;
                }
                this._mySnapCharge = false;
              }
            }
          }
          if (this._mySmoothSnapHorizontalRunning) {
            let angleToRotate = Math.pp_sign(this._mySmoothSnapHorizontalAngleToPerform) * (this._myParams.mySmoothSnapSpeedDegrees * dt);
            if (Math.abs(angleToRotate) > Math.abs(this._mySmoothSnapHorizontalAngleToPerform) - LocomotionUtils.EPSILON_NUMBER) {
              angleToRotate = this._mySmoothSnapHorizontalAngleToPerform;
            }
            headRotation.quat_fromAxis(angleToRotate, playerUp);
            this._mySmoothSnapHorizontalAngleToPerform -= angleToRotate;
            if (Math.abs(this._mySmoothSnapHorizontalAngleToPerform) < LocomotionUtils.EPSILON_NUMBER) {
              this._mySmoothSnapHorizontalRunning = false;
              this._mySmoothSnapHorizontalAngleToPerform = 0;
            }
          }
          if (headRotation.quat_getAngle() > LocomotionUtils.EPSILON_DEGREES) {
            if (PP.myGamepads[PP.InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
              this._myParams.myPlayerHeadManager.rotateFeetQuat(headRotation);
            } else {
              this._myParams.myPlayerTransformManager.rotateQuat(headRotation);
            }
          }
        };
      }();
      PlayerLocomotionRotate.prototype._rotateHeadVertically = function() {
        let headForward = PP.vec3_create();
        let headUp = PP.vec3_create();
        let referenceUp = PP.vec3_create();
        let referenceUpNegate = PP.vec3_create();
        let referenceRight = PP.vec3_create();
        let newUp = PP.vec3_create();
        let headRotation = PP.quat_create();
        return function _rotateHeadVertically(dt) {
          let head = this._myParams.myPlayerHeadManager.getHead();
          headForward = head.pp_getForward(headForward);
          headUp = head.pp_getUp(headUp);
          referenceUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(referenceUp);
          referenceUpNegate = referenceUp.vec3_negate(referenceUpNegate);
          referenceRight = headForward.vec3_cross(referenceUp, referenceRight);
          let minAngle = 1;
          if (headForward.vec3_angle(referenceUp) < minAngle) {
            referenceRight = headUp.vec3_negate(referenceRight).vec3_cross(referenceUp, referenceRight);
          } else if (headForward.vec3_angle(referenceUpNegate) < minAngle) {
            referenceRight = headUp.vec3_cross(referenceUp, referenceRight);
          } else if (!headUp.vec3_isConcordant(referenceUp)) {
            referenceRight.vec3_negate(referenceRight);
          }
          referenceRight.vec3_normalize(referenceRight);
          let axes = PP.myGamepads[this._myParams.myHandedness].getAxesInfo().getAxes();
          let angleToRotate = 0;
          if (!this._myParams.myIsSnapTurn || this._myParams.mySnapTurnOnlyVR && !PP.XRUtils.isSessionActive()) {
            if (Math.abs(axes[1]) > this._myParams.myRotationMinStickIntensityThreshold) {
              let rotationIntensity = axes[1];
              angleToRotate = Math.pp_lerp(0, this._myParams.myMaxRotationSpeed, Math.abs(rotationIntensity)) * Math.pp_sign(rotationIntensity) * dt;
            }
          } else {
            if (!this._mySnapCharge) {
              if (Math.abs(axes.vec2_length()) < this._myParams.mySnapTurnResetThreshold) {
                this._mySnapCharge = true;
              }
            } else if (!this._mySmoothSnapVerticalRunning) {
              if (Math.abs(axes[1]) > this._myParams.mySnapTurnActivateThreshold) {
                angleToRotate = Math.pp_sign(axes[1]) * this._myParams.mySnapTurnAngle;
                let angleWithUp = Math.pp_angleClamp(headUp.vec3_angleSigned(referenceUp, referenceRight));
                let snapStep = Math.round(angleWithUp / this._myParams.mySnapTurnAngle);
                let snapAngle = Math.pp_angleClamp(snapStep * this._myParams.mySnapTurnAngle);
                let angleToAlign = -Math.pp_angleDistanceSigned(angleWithUp, snapAngle);
                if (Math.abs(angleToAlign) > 1) {
                  if (Math.pp_sign(angleToRotate) == Math.pp_sign(angleToAlign)) {
                    angleToRotate = angleToAlign;
                  } else {
                    angleToRotate = -Math.pp_sign(angleToAlign) * this._myParams.mySnapTurnAngle + angleToAlign;
                  }
                } else if (Math.abs(angleToAlign) > LocomotionUtils.EPSILON_DEGREES) {
                  angleToRotate += angleToAlign;
                }
                if (this._myParams.mySmoothSnapActive) {
                  this._mySmoothSnapVerticalRunning = true;
                  this._mySmoothSnapVerticalAngleToPerform = angleToRotate;
                }
                this._mySnapCharge = false;
              }
            }
          }
          if (this._mySmoothSnapVerticalRunning) {
            angleToRotate = Math.pp_sign(this._mySmoothSnapVerticalAngleToPerform) * (this._myParams.mySmoothSnapSpeedDegrees * dt);
            if (Math.abs(angleToRotate) > Math.abs(this._mySmoothSnapVerticalAngleToPerform) - LocomotionUtils.EPSILON_NUMBER) {
              angleToRotate = this._mySmoothSnapVerticalAngleToPerform;
            }
            this._mySmoothSnapVerticalAngleToPerform -= angleToRotate;
            if (Math.abs(this._mySmoothSnapVerticalAngleToPerform) < LocomotionUtils.EPSILON_NUMBER) {
              this._mySmoothSnapVerticalRunning = false;
              this._mySmoothSnapVerticalAngleToPerform = 0;
            }
          }
          if (angleToRotate != 0) {
            headRotation.quat_fromAxis(angleToRotate, referenceRight);
            this._myParams.myPlayerHeadManager.rotateHeadQuat(headRotation);
            if (this._myParams.myClampVerticalAngle) {
              let maxVerticalAngle = this._myParams.myMaxVerticalAngle - 1e-4;
              newUp = head.pp_getUp(newUp);
              let angleWithUp = Math.pp_angleClamp(newUp.vec3_angleSigned(referenceUp, referenceRight));
              if (Math.abs(angleWithUp) > maxVerticalAngle) {
                let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
                headRotation.quat_fromAxis(fixAngle, referenceRight);
                this._myParams.myPlayerHeadManager.rotateHeadQuat(headRotation);
              }
            }
          }
        };
      }();
      Object.defineProperty(PlayerLocomotionRotate.prototype, "_rotateHeadHorizontally", { enumerable: false });
      Object.defineProperty(PlayerLocomotionRotate.prototype, "_rotateHeadVertically", { enumerable: false });
    }
  });

  // js/locomotion/player_locomotion_movement.js
  var require_player_locomotion_movement = __commonJS({
    "js/locomotion/player_locomotion_movement.js"() {
      PlayerLocomotionMovementRuntimeParams = class PlayerLocomotionMovementRuntimeParams {
        constructor() {
          this.myIsFlying = false;
          this.myCollisionRuntimeParams = null;
          this.myIsTeleportDetecting = false;
          this.myIsTeleporting = false;
          this.myTeleportJustPerformed = false;
        }
      };
      PlayerLocomotionMovement = class PlayerLocomotionMovement {
        constructor(locomotionRuntimeParams) {
          this._myLocomotionRuntimeParams = locomotionRuntimeParams;
        }
        start() {
        }
        stop() {
        }
        canStop() {
          return true;
        }
      };
    }
  });

  // js/locomotion/player_locomotion_smooth.js
  var require_player_locomotion_smooth2 = __commonJS({
    "js/locomotion/player_locomotion_smooth.js"() {
      PlayerLocomotionSmoothParams = class PlayerLocomotionSmoothParams {
        constructor() {
          this.myPlayerHeadManager = null;
          this.myPlayerTransformManager = null;
          this.myCollisionCheckParams = null;
          this.myMaxSpeed = 0;
          this.myMovementMinStickIntensityThreshold = 0;
          this.myFlyEnabled = false;
          this.myMinAngleToFlyUpNonVR = 0;
          this.myMinAngleToFlyDownNonVR = 0;
          this.myMinAngleToFlyUpVR = 0;
          this.myMinAngleToFlyDownVR = 0;
          this.myMinAngleToFlyRight = 0;
          this.myGravityAcceleration = 0;
          this.myVRDirectionReferenceType = PlayerLocomotionDirectionReferenceType.HEAD;
          this.myVRDirectionReferenceObject = null;
          this.myHandedness = PP.Handedness.LEFT;
        }
      };
      PlayerLocomotionSmooth = class PlayerLocomotionSmooth extends PlayerLocomotionMovement {
        constructor(params, locomotionRuntimeParams) {
          super(locomotionRuntimeParams);
          this._myParams = params;
          this._myDirectionReference = PP.myPlayerObjects.myHead;
          this._myStickIdleTimer = new PP.Timer(0.25, false);
          let directionConverterNonVRParams = new PP.Direction2DTo3DConverterParams();
          directionConverterNonVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled;
          directionConverterNonVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled;
          directionConverterNonVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpNonVR;
          directionConverterNonVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownNonVR;
          directionConverterNonVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
          directionConverterNonVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
          let directionConverterVRParams = new PP.Direction2DTo3DConverterParams();
          directionConverterVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled;
          directionConverterVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled;
          directionConverterVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpVR;
          directionConverterVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownVR;
          directionConverterVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
          directionConverterVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
          this._myDirectionConverterNonVR = new PP.Direction2DTo3DConverter(directionConverterNonVRParams);
          this._myDirectionConverterVR = new PP.Direction2DTo3DConverter(directionConverterVRParams);
          this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
          this._myLocomotionRuntimeParams.myIsFlying = false;
          if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        }
        update(dt) {
        }
      };
      PlayerLocomotionSmooth.prototype.update = function() {
        let playerUp = PP.vec3_create();
        let headMovement = PP.vec3_create();
        let direction = PP.vec3_create();
        let directionOnUp = PP.vec3_create();
        let verticalMovement = PP.vec3_create();
        let feetTransformQuat = PP.quat2_create();
        let directionReferenceTransformQuat = PP.quat2_create();
        return function update(dt) {
          playerUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
          headMovement.vec3_zero();
          let axes = PP.myGamepads[this._myParams.myHandedness].getAxesInfo().getAxes();
          axes[0] = Math.abs(axes[0]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[0] : 0;
          axes[1] = Math.abs(axes[1]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[1] : 0;
          if (!axes.vec2_isZero()) {
            this._myStickIdleTimer.start();
            direction = this._myCurrentDirectionConverter.convertTransformQuat(axes, this._myDirectionReference.pp_getTransformQuat(directionReferenceTransformQuat), playerUp, direction);
            if (!direction.vec3_isZero()) {
              this._myLocomotionRuntimeParams.myIsFlying = this._myLocomotionRuntimeParams.myIsFlying || direction.vec3_componentAlongAxis(playerUp, directionOnUp).vec3_length() > 1e-6;
              if (!this._myLocomotionRuntimeParams.myIsFlying) {
                direction = direction.vec3_removeComponentAlongAxis(playerUp, direction);
              }
              let movementIntensity = axes.vec2_length();
              if (PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.SELECT).isPressed()) {
                movementIntensity = 0.1;
              }
              let speed = Math.pp_lerp(0, this._myParams.myMaxSpeed, movementIntensity);
              if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsSliding) {
                speed = speed / 2;
              }
              headMovement = direction.vec3_scale(speed * dt, headMovement);
            }
          } else {
            if (this._myStickIdleTimer.isRunning()) {
              this._myStickIdleTimer.update(dt);
              if (this._myStickIdleTimer.isDone()) {
                this._myCurrentDirectionConverter.resetFly();
              }
            }
          }
          if (!PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.SQUEEZE).isPressed()) {
            if (PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).isPressed()) {
              verticalMovement = playerUp.vec3_scale(this._myParams.myMaxSpeed * dt, verticalMovement);
              headMovement = headMovement.vec3_add(verticalMovement, headMovement);
              this._myLocomotionRuntimeParams.myIsFlying = true;
            } else if (PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
              verticalMovement = playerUp.vec3_scale(-this._myParams.myMaxSpeed * dt, verticalMovement);
              headMovement = headMovement.vec3_add(verticalMovement, headMovement);
              this._myLocomotionRuntimeParams.myIsFlying = true;
            }
          }
          if (PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON).isPressEnd(2)) {
            this._myLocomotionRuntimeParams.myIsFlying = false;
          }
          if (PP.myGamepads[PP.InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
            if (!PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressed()) {
              let gravityEnabled = false;
              if (!this._myLocomotionRuntimeParams.myIsFlying && gravityEnabled) {
                let gravity = -2;
                verticalMovement = playerUp.vec3_scale(gravity * dt, verticalMovement);
                headMovement = headMovement.vec3_add(verticalMovement, headMovement);
              }
              if (PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.SQUEEZE).isPressed()) {
                headMovement.vec3_zero();
              }
              feetTransformQuat = this._myParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
              globalDT = dt;
              CollisionCheckGlobal.move(headMovement, feetTransformQuat, this._myParams.myCollisionCheckParams, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
              headMovement.vec3_copy(this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myFixedMovement);
            }
            if (!headMovement.vec3_isZero(1e-6)) {
              this._myParams.myPlayerHeadManager.moveFeet(headMovement);
            }
          } else {
            if (!PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressed()) {
              if (!this._myLocomotionRuntimeParams.myIsFlying) {
                let gravity = -2;
                verticalMovement = playerUp.vec3_scale(gravity * dt, verticalMovement);
                headMovement = headMovement.vec3_add(verticalMovement, headMovement);
              }
              if (PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.SQUEEZE).isPressed()) {
                headMovement.vec3_zero();
              }
              feetTransformQuat = this._myParams.myPlayerTransformManager.getTransformQuat(feetTransformQuat);
              globalDT = dt;
              this._myParams.myPlayerTransformManager.move(headMovement, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
            } else {
              this._myParams.myPlayerTransformManager.move(headMovement, this._myLocomotionRuntimeParams.myCollisionRuntimeParams, true);
            }
          }
          if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
            this._myLocomotionRuntimeParams.myIsFlying = false;
            this._myCurrentDirectionConverter.resetFly();
          }
        };
      }();
      globalDT = 0;
      PlayerLocomotionSmooth.prototype._onXRSessionStart = function() {
        return function _onXRSessionStart(session) {
          switch (this._myParams.myVRDirectionReferenceType) {
            case 0:
              this._myDirectionReference = PP.myPlayerHeadManager.myHead;
              break;
            case 1:
              this._myDirectionReference = PP.myPlayerObjects.myHands[this._myParams.myHandedness];
              break;
            case 2:
              this._myDirectionReference = this._myParams.myVRDirectionReferenceObject;
              break;
          }
          this._myCurrentDirectionConverter = this._myDirectionConverterVR;
          this._myCurrentDirectionConverter.resetFly();
        };
      }();
      PlayerLocomotionSmooth.prototype._onXRSessionEnd = function() {
        return function _onXRSessionEnd(session) {
          this._myDirectionReference = PP.myPlayerObjects.myHead;
          this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
          this._myCurrentDirectionConverter.resetFly();
        };
      }();
      Object.defineProperty(PlayerLocomotionSmooth.prototype, "update", { enumerable: false });
      Object.defineProperty(PlayerLocomotionSmooth.prototype, "_onXRSessionStart", { enumerable: false });
      Object.defineProperty(PlayerLocomotionSmooth.prototype, "_onXRSessionEnd", { enumerable: false });
    }
  });

  // js/locomotion/player_obscure_manager.js
  var require_player_obscure_manager = __commonJS({
    "js/locomotion/player_obscure_manager.js"() {
      PlayerObscureManagerParams = class PlayerObscureManagerParams {
        constructor() {
          this.myPlayerTransformManager = null;
          this.myObscureObject = null;
          this.myObscureMaterial = null;
          this.myObscureRadius = 0;
          this.myObscureFadeOutSeconds = 0.1;
          this.myObscureFadeInSeconds = 0.1;
          this.myObscureFadeEasingFunction = PP.EasingFunction.linear;
          this.myDistanceToStartObscureWhenHeadColliding = 0;
          this.myDistanceToStartObscureWhenBodyColliding = 0;
          this.myDistanceToStartObscureWhenFloating = 0;
          this.myDistanceToStartObscureWhenFar = 0;
          this.myRelativeDistanceToMaxObscureWhenHeadColliding = 0;
          this.myRelativeDistanceToMaxObscureWhenBodyColliding = 0;
          this.myRelativeDistanceToMaxObscureWhenFloating = 0;
          this.myRelativeDistanceToMaxObscureWhenFar = 0;
          this.myObscureLevelRelativeDistanceEasingFunction = PP.EasingFunction.linear;
        }
      };
      PlayerObscureManager = class PlayerObscureManager {
        constructor(params) {
          this._myParams = params;
          this._myObscureMaterial = null;
          this._myObscureParentObject = null;
          this._myCurrentObscureLevel = 0;
          this._myTargetObscureLevel = 0;
          this._myLastTargetObscureLevel = null;
          this._myLastIsFadingIn = null;
          this._myHeadPosition = PP.vec3_create();
          this._myFadeTimer = new PP.Timer(0, false);
          this._myFSM = new PP.FSM();
          this._myFSM.addState("init");
          this._myFSM.addState("inactive");
          this._myFSM.addState("idle", this._idleUpdate.bind(this));
          this._myFSM.addState("fading", this._fadingUpdate.bind(this));
          this._myFSM.addTransition("init", "inactive", "end", this._setObscureLevel.bind(this, 0));
          this._myFSM.addTransition("inactive", "idle", "start");
          this._myFSM.addTransition("idle", "fading", "fade", this._startFading.bind(this));
          this._myFSM.addTransition("fading", "idle", "done", this._fadingDone.bind(this));
          this._myFSM.addTransition("inactive", "inactive", "stop", this._setObscureLevel.bind(this, 0));
          this._myFSM.addTransition("idle", "inactive", "stop", this._setObscureLevel.bind(this, 0));
          this._myFSM.addTransition("fading", "inactive", "stop", this._setObscureLevel.bind(this, 0));
          this._myFSM.init("init");
          this._setupVisuals();
          this._myFSM.perform("end");
        }
        start() {
          this._myFSM.perform("start");
        }
        stop() {
          this._myFSM.perform("stop");
        }
        update(dt) {
          this._updateObscured();
          this._myFSM.update(dt);
          this._setObscureVisible(this.isObscured());
        }
        isStarted() {
          return !this._myFSM.isInState("inactive");
        }
        isObscured() {
          return this._myCurrentObscureLevel > 0;
        }
        isFading() {
          return this._myFSM.isInState("fading");
        }
        isFadingIn() {
          return this.isFading() && this._myCurrentObscureLevel > this._myTargetObscureLevel;
        }
        isFadingOut() {
          return this.isFading() && this._myCurrentObscureLevel <= this._myTargetObscureLevel;
        }
        getObscureLevel() {
          return this._myCurrentObscureLevel;
        }
        getTargetObscureLevel() {
          return this._myTargetObscureLevel;
        }
        getCurrentObscureLevel() {
          this._myCurrentObscureLevel;
        }
        obscureLevelOverride(obscureLevel, instantFade = false) {
          this._myObscurelevelOverride = obscureLevel;
          if (instantFade && this.isStarted()) {
            this._setObscureLevel(obscureLevel);
          }
        }
        resetObscureLevelOverride() {
          this._myObscurelevelOverride = null;
        }
        _idleUpdate(dt) {
          if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) > Math.PP_EPSILON_NUMBER) {
            this._myFSM.perform("fade");
          }
        }
        _fadingUpdate(dt) {
          if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) <= Math.PP_EPSILON_NUMBER) {
            this._myFSM.perform("done");
            return;
          }
          if (this._myLastTargetObscureLevel != this._myTargetObscureLevel) {
            this._refreshFadeTimer();
            this._myLastTargetObscureLevel = this._myTargetObscureLevel;
          }
          this._myFadeTimer.update(dt);
          let newObscureLevel = this._myParams.myObscureFadeEasingFunction(this._myFadeTimer.getPercentage());
          let isFadingIn = this._myCurrentObscureLevel > this._myTargetObscureLevel;
          if (!isFadingIn) {
            newObscureLevel = Math.min(newObscureLevel, this._myTargetObscureLevel);
          } else {
            newObscureLevel = Math.pp_clamp(1 - newObscureLevel, 0, 1);
            newObscureLevel = Math.max(newObscureLevel, this._myTargetObscureLevel);
          }
          this._setObscureAlpha(newObscureLevel);
          this._myCurrentObscureLevel = newObscureLevel;
          if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) <= Math.PP_EPSILON_NUMBER || this._myFadeTimer.isDone()) {
            this._myFSM.perform("done");
          }
        }
        _startFading() {
          this._myLastTargetObscureLevel = null;
          this._myLastIsFadingIn = null;
        }
        _fadingDone() {
          this._setObscureLevel(this._myTargetObscureLevel);
        }
        _refreshFadeTimer() {
          let isFadingIn = this._myCurrentObscureLevel > this._myTargetObscureLevel;
          if (this._myLastIsFadingIn != isFadingIn) {
            this._setFadeTimerToObscureLevel(isFadingIn);
          }
          this._myLastIsFadingIn = isFadingIn;
        }
        _setFadeTimerToObscureLevel(isFadingIn) {
          let percentage = 0;
          let closestPercentage = 0;
          let steps = 1e3;
          let increment = 1 / steps;
          while (percentage < 1) {
            if (Math.abs(this._myParams.myObscureFadeEasingFunction(percentage) - this._myCurrentObscureLevel) < Math.abs(this._myParams.myObscureFadeEasingFunction(closestPercentage) - this._myCurrentObscureLevel)) {
              closestPercentage = percentage;
            }
            percentage += increment;
          }
          if (Math.abs(this._myParams.myObscureFadeEasingFunction(1) - this._myCurrentObscureLevel) < Math.abs(this._myParams.myObscureFadeEasingFunction(closestPercentage) - this._myCurrentObscureLevel)) {
            closestPercentage = 1;
          }
          if (isFadingIn) {
            this._myFadeTimer.start(this._myParams.myObscureFadeInSeconds);
            this._myFadeTimer.setPercentage(Math.pp_clamp(1 - closestPercentage, 0, 1));
          } else {
            this._myFadeTimer.start(this._myParams.myObscureFadeOutSeconds);
            this._myFadeTimer.setPercentage(Math.pp_clamp(closestPercentage, 0, 1));
          }
        }
        _setObscureLevel(obscureLevel) {
          this._myTargetObscureLevel = obscureLevel;
          this._myCurrentObscureLevel = obscureLevel;
          this._setObscureAlpha(obscureLevel);
          this._setObscureVisible(this.isObscured());
        }
        _setObscureAlpha(alpha) {
          if (this._myParams.myObscureObject == null) {
            PP.MaterialUtils.setAlpha(this._myObscureMaterial, alpha);
          } else {
            PP.MaterialUtils.setObjectAlpha(this._myParams.myObscureObject, alpha);
          }
        }
        _updateObscured() {
          this._myTargetObscureLevel = 0;
          if (this._myObscurelevelOverride != null) {
            this._myTargetObscureLevel = this._myObscurelevelOverride;
          } else {
            if (this._myParams.myPlayerTransformManager.isHeadColliding()) {
              let distance4 = this._myParams.myPlayerTransformManager.getDistanceToRealHead();
              let relativeDistance = distance4 - this._myParams.myDistanceToStartObscureWhenHeadColliding;
              if (relativeDistance >= 0) {
                let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenHeadColliding, 0, 1);
                if (isNaN(relativeDistancePercentage)) {
                  relativeDistancePercentage = 1;
                }
                let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
                this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
              }
            }
            if (this._myParams.myPlayerTransformManager.isBodyColliding()) {
              let distance4 = this._myParams.myPlayerTransformManager.getDistanceToReal();
              let relativeDistance = distance4 - this._myParams.myDistanceToStartObscureWhenBodyColliding;
              if (relativeDistance >= 0) {
                let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenBodyColliding, 0, 1);
                if (isNaN(relativeDistancePercentage)) {
                  relativeDistancePercentage = 1;
                }
                let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
                this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
              }
            }
            if (this._myParams.myPlayerTransformManager.isFloating()) {
              let distance4 = this._myParams.myPlayerTransformManager.getDistanceToReal();
              let relativeDistance = distance4 - this._myParams.myDistanceToStartObscureWhenFloating;
              if (relativeDistance >= 0) {
                let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenFloating, 0, 1);
                if (isNaN(relativeDistancePercentage)) {
                  relativeDistancePercentage = 1;
                }
                let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
                this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
              }
            }
            if (this._myParams.myPlayerTransformManager.isFar()) {
              let distance4 = this._myParams.myPlayerTransformManager.getDistanceToReal();
              let relativeDistance = distance4 - this._myParams.myDistanceToStartObscureWhenFar;
              if (relativeDistance >= 0) {
                let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenFar, 0, 1);
                if (isNaN(relativeDistancePercentage)) {
                  relativeDistancePercentage = 1;
                }
                let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
                this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
              }
            }
            this._myParams.myPlayerTransformManager.getHead().pp_getPosition(this._myHeadPosition);
            if (this._myHeadPosition[1] < 0.15 && this._myHeadPosition[1] > -1) {
              this._myTargetObscureLevel = 1;
            }
          }
        }
        _setupVisuals() {
          this._myObscureMaterial = null;
          if (this._myParams.myObscureMaterial != null) {
            this._myObscureMaterial = this._myParams.myObscureMaterial;
          } else {
            this._myObscureMaterial = PP.myDefaultResources.myMaterials.myFlatTransparentNoDepth.clone();
            this._myObscureMaterial.color = PP.vec4_create(0, 0, 0, 1);
          }
          this._myObscureParentObject = PP.myVisualData.myRootObject.pp_addObject();
          let obscureVisualParams = new PP.VisualMeshParams();
          obscureVisualParams.myMesh = PP.myDefaultResources.myMeshes.myInvertedSphere;
          obscureVisualParams.myMaterial = this._myParams.myObscureMaterial != null ? this._myParams.myObscureMaterial : this._myObscureMaterial;
          obscureVisualParams.myParent = this._myObscureParentObject;
          obscureVisualParams.myIsLocal = true;
          obscureVisualParams.myTransform.mat4_setScale(PP.vec3_create(this._myParams.myObscureRadius, this._myParams.myObscureRadius, this._myParams.myObscureRadius));
          this._myObscureVisual = new PP.VisualMesh(obscureVisualParams);
          if (this._myParams.myObscureObject != null) {
            this._myParams.myObscureObject.pp_setParent(this._myObscureParentObject, false);
            this._myParams.myObscureObject.pp_resetTransformLocal();
          }
          this._setObscureVisible(false);
        }
        _setObscureVisible(visible) {
          if (this._myParams.myObscureObject == null) {
            this._myObscureVisual.setVisible(visible);
          } else {
            this._myObscureVisual.setVisible(false);
            this._myParams.myObscureObject.pp_setActive(visible);
          }
          if (visible) {
            this._myObscureParentObject.pp_setParent(this._myParams.myPlayerTransformManager.getHead(), false);
          } else {
            this._myObscureParentObject.pp_setParent(null, false);
          }
        }
      };
    }
  });

  // js/locomotion/player_locomotion.js
  var require_player_locomotion = __commonJS({
    "js/locomotion/player_locomotion.js"() {
      PlayerLocomotionDirectionReferenceType = {
        HEAD: 0,
        HAND: 1,
        CUSTOM_OBJECT: 2
      };
      transformManager = null;
      PlayerLocomotionParams = class PlayerLocomotionParams {
        constructor() {
          this.myMaxSpeed = 0;
          this.myMaxRotationSpeed = 0;
          this.myCharacterRadius = 0;
          this.myIsSnapTurn = false;
          this.mySnapTurnOnlyVR = false;
          this.mySnapTurnAngle = 0;
          this.mySnapTurnSpeedDegrees = 0;
          this.myFlyEnabled = false;
          this.myMinAngleToFlyUpNonVR = 0;
          this.myMinAngleToFlyDownNonVR = 0;
          this.myMinAngleToFlyUpVR = 0;
          this.myMinAngleToFlyDownVR = 0;
          this.myMinAngleToFlyRight = 0;
          this.myMainHand = PP.Handedness.LEFT;
          this.myVRDirectionReferenceType = PlayerLocomotionDirectionReferenceType.HEAD;
          this.myVRDirectionReferenceObject = null;
          this.myTeleportParableStartReferenceObject = null;
          this.myForeheadExtraHeight = 0;
          this.myTeleportPositionObject = null;
        }
      };
      PlayerLocomotion = class PlayerLocomotion {
        constructor(params) {
          this._myParams = params;
          this._myCollisionCheckParamsMovement = new CollisionCheckParams();
          this._setupCollisionCheckParamsMovement();
          this._myCollisionCheckParamsTeleport = null;
          this._setupCollisionCheckParamsTeleport();
          this._myCollisionRuntimeParams = new CollisionRuntimeParams();
          this._myMovementRuntimeParams = new PlayerLocomotionMovementRuntimeParams();
          this._myMovementRuntimeParams.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
          {
            let params2 = new PlayerHeadManagerParams();
            params2.mySessionChangeResyncEnabled = true;
            params2.myBlurEndResyncEnabled = true;
            params2.myBlurEndResyncRotation = true;
            params2.myEnterSessionResyncHeight = false;
            params2.myExitSessionResyncHeight = false;
            params2.myExitSessionResyncVerticalAngle = true;
            params2.myExitSessionRemoveRightTilt = true;
            params2.myExitSessionAdjustMaxVerticalAngle = true;
            params2.myExitSessionMaxVerticalAngle = 90;
            params2.myHeightOffsetVRWithFloor = 0;
            params2.myHeightOffsetVRWithoutFloor = 1.75;
            params2.myHeightOffsetNonVR = 1.75;
            params2.myForeheadExtraHeight = this._myParams.myForeheadExtraHeight;
            params2.myFeetRotationKeepUp = true;
            params2.myDebugActive = false;
            this._myPlayerHeadManager = new PlayerHeadManager(params2);
          }
          {
            let params2 = new PlayerTransformManagerParams();
            params2.myPlayerHeadManager = this._myPlayerHeadManager;
            params2.myMovementCollisionCheckParams = this._myCollisionCheckParamsMovement;
            params2.myTeleportCollisionCheckParams = null;
            params2.myTeleportCollisionCheckParamsCopyFromMovement = true;
            params2.myTeleportCollisionCheckParamsCheck360 = true;
            params2.myHeadCollisionBlockLayerFlags.copy(params2.myMovementCollisionCheckParams.myHorizontalBlockLayerFlags);
            params2.myHeadCollisionBlockLayerFlags.add(params2.myMovementCollisionCheckParams.myVerticalBlockLayerFlags);
            params2.myHeadCollisionObjectsToIgnore.pp_copy(params2.myMovementCollisionCheckParams.myHorizontalObjectsToIgnore);
            let objectsEqualCallback = (first, second) => first.pp_equals(second);
            for (let objectToIgnore of params2.myMovementCollisionCheckParams.myVerticalObjectsToIgnore) {
              params2.myHeadCollisionObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
            }
            params2.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
            params2.myHeadRadius = 0.15;
            params2.myIsMaxDistanceFromRealToSyncEnabled = true;
            params2.myMaxDistanceFromRealToSync = 100;
            params2.myIsFloatingValidIfVerticalMovement = false;
            params2.myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
            params2.myIsFloatingValidIfSteepGround = false;
            params2.myIsFloatingValidIfVerticalMovementAndSteepGround = false;
            params2.myIsFloatingValidIfRealOnGround = false;
            params2.myIsLeaningValidAboveDistance = true;
            params2.myLeaningValidDistance = 2;
            params2.myFloatingSplitCheckEnabled = true;
            params2.myFloatingSplitCheckMaxLength = 0.2;
            params2.myFloatingSplitCheckMaxSteps = 5;
            params2.myRealMovementAllowVerticalAdjustments = false;
            params2.myUpdateRealPositionValid = true;
            params2.myUpdatePositionValid = true;
            params2.myIsBodyCollidingWhenHeightBelowValue = null;
            params2.myIsBodyCollidingWhenHeightAboveValue = null;
            params2.myResetToValidOnEnterSession = true;
            params2.myResetToValidOnExitSession = true;
            params2.myAlwaysResetRealPositionNonVR = true;
            params2.myAlwaysResetRealRotationNonVR = true;
            params2.myAlwaysResetRealHeightNonVR = true;
            params2.myAlwaysResetRealPositionVR = false;
            params2.myAlwaysResetRealRotationVR = false;
            params2.myAlwaysResetRealHeightVR = false;
            params2.myNeverResetRealPositionNonVR = false;
            params2.myNeverResetRealRotationNonVR = true;
            params2.myNeverResetRealHeightNonVR = false;
            params2.myNeverResetRealPositionVR = false;
            params2.myNeverResetRealRotationVR = false;
            params2.myNeverResetRealHeightVR = true;
            params2.myResetRealOnMove = true;
            params2.myDebugActive = true;
            this._myPlayerTransformManager = new PlayerTransformManager(params2);
            transformManager = this._myPlayerTransformManager;
          }
          {
            let params2 = new PlayerObscureManagerParams();
            params2.myPlayerTransformManager = this._myPlayerTransformManager;
            params2.myObscureObject = null;
            params2.myObscureMaterial = null;
            params2.myObscureRadius = 0.5;
            params2.myObscureFadeOutSeconds = 0.25;
            params2.myObscureFadeInSeconds = 0.25;
            params2.myObscureFadeEasingFunction = PP.EasingFunction.linear;
            params2.myObscureLevelRelativeDistanceEasingFunction = PP.EasingFunction.linear;
            params2.myDistanceToStartObscureWhenBodyColliding = 0.2;
            params2.myDistanceToStartObscureWhenHeadColliding = 0;
            params2.myDistanceToStartObscureWhenFloating = 1;
            params2.myDistanceToStartObscureWhenFar = 1;
            params2.myRelativeDistanceToMaxObscureWhenBodyColliding = 0.5;
            params2.myRelativeDistanceToMaxObscureWhenHeadColliding = 0.1;
            params2.myRelativeDistanceToMaxObscureWhenFloating = 5;
            params2.myRelativeDistanceToMaxObscureWhenFar = 5;
            this._myPlayerObscureManager = new PlayerObscureManager(params2);
          }
          {
            let params2 = new PlayerLocomotionRotateParams();
            params2.myPlayerHeadManager = this._myPlayerHeadManager;
            params2.myPlayerTransformManager = this._myPlayerTransformManager;
            params2.myMaxRotationSpeed = this._myParams.myMaxRotationSpeed;
            params2.myIsSnapTurn = this._myParams.myIsSnapTurn;
            params2.mySnapTurnOnlyVR = this._myParams.mySnapTurnOnlyVR;
            params2.mySnapTurnAngle = this._myParams.mySnapTurnAngle;
            if (this._myParams.mySnapTurnSpeedDegrees > LocomotionUtils.EPSILON_NUMBER) {
              params2.mySmoothSnapActive = true;
              params2.mySmoothSnapSpeedDegrees = this._myParams.mySnapTurnSpeedDegrees;
            } else {
              params2.mySmoothSnapActive = false;
            }
            params2.myRotationMinStickIntensityThreshold = 0.1;
            params2.mySnapTurnActivateThreshold = 0.5;
            params2.mySnapTurnResetThreshold = 0.4;
            params2.myClampVerticalAngle = true;
            params2.myMaxVerticalAngle = 90;
            this._myPlayerLocomotionRotate = new PlayerLocomotionRotate(params2);
            params2.myHandedness = PP.InputUtils.getOppositeHandedness(this._myParams.myMainHand);
          }
          {
            {
              let params2 = new PlayerLocomotionSmoothParams();
              params2.myPlayerHeadManager = this._myPlayerHeadManager;
              params2.myPlayerTransformManager = this._myPlayerTransformManager;
              params2.myCollisionCheckParams = this._myCollisionCheckParamsMovement;
              params2.myHandedness = this._myParams.myMainHand;
              params2.myMaxSpeed = this._myParams.myMaxSpeed;
              params2.myMovementMinStickIntensityThreshold = 0.1;
              params2.myFlyEnabled = this._myParams.myFlyEnabled;
              params2.myMinAngleToFlyUpNonVR = this._myParams.myMinAngleToFlyUpNonVR;
              params2.myMinAngleToFlyDownNonVR = this._myParams.myMinAngleToFlyDownNonVR;
              params2.myMinAngleToFlyUpVR = this._myParams.myMinAngleToFlyUpVR;
              params2.myMinAngleToFlyDownVR = this._myParams.myMinAngleToFlyDownVR;
              params2.myMinAngleToFlyRight = this._myParams.myMinAngleToFlyRight;
              params2.myGravityAcceleration = -20;
              params2.myVRDirectionReferenceType = this._myParams.myVRDirectionReferenceType;
              params2.myVRDirectionReferenceObject = this._myParams.myVRDirectionReferenceObject;
              this._myPlayerLocomotionSmooth = new PlayerLocomotionSmooth(params2, this._myMovementRuntimeParams);
            }
            {
              let params2 = new PlayerLocomotionTeleportParams();
              params2.myPlayerHeadManager = this._myPlayerHeadManager;
              params2.myPlayerTransformManager = this._myPlayerTransformManager;
              params2.myCollisionCheckParams = this._myCollisionCheckParamsTeleport;
              params2.myHandedness = this._myParams.myMainHand;
              params2.myDetectionParams.myMaxDistance = 3;
              params2.myDetectionParams.myMaxHeightDifference = 4;
              params2.myDetectionParams.myGroundAngleToIgnoreUpward = this._myCollisionCheckParamsMovement.myGroundAngleToIgnore;
              params2.myDetectionParams.myMustBeOnGround = true;
              params2.myDetectionParams.myTeleportBlockLayerFlags.setAllFlagsActive(true);
              params2.myDetectionParams.myTeleportFloorLayerFlags.setAllFlagsActive(true);
              params2.myDetectionParams.myTeleportFeetPositionMustBeVisible = false;
              params2.myDetectionParams.myTeleportHeadPositionMustBeVisible = false;
              params2.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible = true;
              params2.myDetectionParams.myTeleportParableStartReferenceObject = this._myParams.myTeleportParableStartReferenceObject;
              params2.myDetectionParams.myVisibilityBlockLayerFlags.setAllFlagsActive(true);
              params2.myVisualizerParams.myTeleportPositionObject = this._myParams.myTeleportPositionObject;
              params2.myPerformTeleportAsMovement = false;
              params2.myTeleportAsMovementRemoveVerticalMovement = true;
              params2.myTeleportAsMovementExtraVerticalMovementPerMeter = -2;
              params2.myGravityAcceleration = 0;
              params2.myDebugActive = false;
              params2.myDebugDetectActive = true;
              params2.myDebugShowActive = true;
              params2.myDebugVisibilityActive = false;
              this._myPlayerLocomotionTeleport = new PlayerLocomotionTeleport(params2, this._myMovementRuntimeParams);
            }
          }
          this._setupLocomotionMovementFSM();
          this._myIdle = false;
        }
        start() {
          this._fixAlmostUp();
          this._myPlayerHeadManager.start();
          this._myPlayerTransformManager.start();
          this._myPlayerObscureManager.start();
          this._myPlayerLocomotionRotate.start();
          this._myLocomotionMovementFSM.perform("start");
        }
        update(dt) {
          this._myPlayerHeadManager.update(dt);
          this._myPlayerTransformManager.update(dt);
          if (PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressEnd(2)) {
            if (this._myLocomotionMovementFSM.isInState("smooth") && this._myPlayerLocomotionSmooth.canStop()) {
              this._myLocomotionMovementFSM.perform("next");
            } else if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
              this._myLocomotionMovementFSM.perform("next");
            }
          }
          if (this._myPlayerHeadManager.isSynced()) {
            this._updateCollisionHeight();
            if (!this._myIdle) {
              this._myPlayerLocomotionRotate.update(dt);
              this._myLocomotionMovementFSM.update(dt);
            }
          }
          if (PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.SELECT).isPressEnd(2)) {
            if (this._myPlayerObscureManager.isFading()) {
              this._myPlayerObscureManager.obscureLevelOverride(this._myPlayerObscureManager.isFadingOut() ? Math.pp_random(0, 0) : Math.pp_random(1, 1));
            } else {
              this._myPlayerObscureManager.obscureLevelOverride(this._myPlayerObscureManager.isObscured() ? Math.pp_random(0, 0) : Math.pp_random(1, 1));
            }
          }
        }
        setIdle(idle) {
          this._myIdle = idle;
          if (idle) {
            this._myLocomotionMovementFSM.perform("idle");
          } else {
            this._myLocomotionMovementFSM.perform("start");
          }
        }
        _updateCollisionHeight() {
          this._myCollisionCheckParamsMovement.myHeight = this._myPlayerHeadManager.getHeightHead();
          if (this._myCollisionCheckParamsMovement.myHeight <= 1e-6) {
            this._myCollisionCheckParamsMovement.myHeight = 0;
          }
          this._myCollisionCheckParamsTeleport.myHeight = this._myCollisionCheckParamsMovement.myHeight;
        }
        _setupCollisionCheckParamsMovement() {
          this._myCollisionCheckParamsMovement.mySplitMovementEnabled = false;
          this._myCollisionCheckParamsMovement.mySplitMovementMaxLength = 0;
          this._myCollisionCheckParamsMovement.myRadius = this._myParams.myCharacterRadius;
          this._myCollisionCheckParamsMovement.myDistanceFromFeetToIgnore = 0.1;
          this._myCollisionCheckParamsMovement.myDistanceFromHeadToIgnore = 0.1;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckEnabled = true;
          this._myCollisionCheckParamsMovement.myHorizontalMovementStepEnabled = false;
          this._myCollisionCheckParamsMovement.myHorizontalMovementStepMaxLength = 0;
          this._myCollisionCheckParamsMovement.myHorizontalMovementRadialStepAmount = 1;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckDiagonalOutward = true;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckDiagonalInward = true;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckStraight = false;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckHorizontalBorder = false;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalStraight = false;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = true;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalDiagonalUpwardInward = true;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = false;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalDiagonalDownwardInward = false;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalStraightDiagonalUpward = false;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalStraightDiagonalDownward = false;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = false;
          this._myCollisionCheckParamsMovement.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = false;
          this._myCollisionCheckParamsMovement.myHorizontalMovementHorizontalStraightCentralCheckEnabled = true;
          this._myCollisionCheckParamsMovement.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = true;
          this._myCollisionCheckParamsMovement.myHorizontalPositionCheckEnabled = true;
          this._myCollisionCheckParamsMovement.myHalfConeAngle = 60;
          this._myCollisionCheckParamsMovement.myHalfConeSliceAmount = 2;
          this._myCollisionCheckParamsMovement.myCheckConeBorder = true;
          this._myCollisionCheckParamsMovement.myCheckConeRay = true;
          this._myCollisionCheckParamsMovement.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = false;
          this._myCollisionCheckParamsMovement.myHorizontalPositionCheckVerticalDirectionType = 2;
          this._myCollisionCheckParamsMovement.myVerticalMovementCheckEnabled = true;
          this._myCollisionCheckParamsMovement.myVerticalPositionCheckEnabled = true;
          this._myCollisionCheckParamsMovement.myVerticalMovementReduceEnabled = true;
          this._myCollisionCheckParamsMovement.myFeetRadius = 0.1;
          this._myCollisionCheckParamsMovement.myAdjustVerticalMovementWithGroundAngleDownhill = true;
          this._myCollisionCheckParamsMovement.myAdjustVerticalMovementWithGroundAngleUphill = true;
          this._myCollisionCheckParamsMovement.myAdjustVerticalMovementWithCeilingAngleUphill = true;
          this._myCollisionCheckParamsMovement.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
          this._myCollisionCheckParamsMovement.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
          this._myCollisionCheckParamsMovement.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = 30;
          this._myCollisionCheckParamsMovement.mySnapOnGroundEnabled = true;
          this._myCollisionCheckParamsMovement.mySnapOnGroundExtraDistance = 0.1;
          this._myCollisionCheckParamsMovement.mySnapOnCeilingEnabled = false;
          this._myCollisionCheckParamsMovement.mySnapOnCeilingExtraDistance = 0.1;
          this._myCollisionCheckParamsMovement.myGroundPopOutEnabled = true;
          this._myCollisionCheckParamsMovement.myGroundPopOutExtraDistance = 0.1;
          this._myCollisionCheckParamsMovement.myCeilingPopOutEnabled = true;
          this._myCollisionCheckParamsMovement.myCeilingPopOutExtraDistance = 0.1;
          this._myCollisionCheckParamsMovement.myGroundCircumferenceAddCenter = true;
          this._myCollisionCheckParamsMovement.myGroundCircumferenceSliceAmount = 8;
          this._myCollisionCheckParamsMovement.myGroundCircumferenceStepAmount = 2;
          this._myCollisionCheckParamsMovement.myGroundCircumferenceRotationPerStep = 22.5;
          this._myCollisionCheckParamsMovement.myVerticalAllowHitInsideCollisionIfOneOk = true;
          this._myCollisionCheckParamsMovement.myCheckHeight = true;
          this._myCollisionCheckParamsMovement.myCheckHeightVerticalMovement = true;
          this._myCollisionCheckParamsMovement.myCheckHeightVerticalPosition = true;
          this._myCollisionCheckParamsMovement.myCheckHeightTopMovement = true;
          this._myCollisionCheckParamsMovement.myCheckHeightTopPosition = true;
          this._myCollisionCheckParamsMovement.myCheckHeightConeOnCollision = true;
          this._myCollisionCheckParamsMovement.myCheckHeightConeOnCollisionKeepHit = false;
          this._myCollisionCheckParamsMovement.myHeightCheckStepAmountMovement = 2;
          this._myCollisionCheckParamsMovement.myHeightCheckStepAmountPosition = 2;
          this._myCollisionCheckParamsMovement.myCheckVerticalFixedForwardEnabled = true;
          this._myCollisionCheckParamsMovement.myCheckVerticalFixedForward = PP.vec3_create(0, 0, 1);
          this._myCollisionCheckParamsMovement.myCheckVerticalBothDirection = true;
          this._myCollisionCheckParamsMovement.myCheckVerticalStraight = true;
          this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalRayOutward = false;
          this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalRayInward = false;
          this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalBorderOutward = false;
          this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalBorderInward = false;
          this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalBorderRayOutward = false;
          this._myCollisionCheckParamsMovement.myCheckVerticalDiagonalBorderRayInward = false;
          this._myCollisionCheckParamsMovement.myCheckVerticalSearchFartherVerticalHit = false;
          this._myCollisionCheckParamsMovement.myGroundAngleToIgnore = 30;
          this._myCollisionCheckParamsMovement.myCeilingAngleToIgnore = 30;
          this._myCollisionCheckParamsMovement.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = 0.1;
          this._myCollisionCheckParamsMovement.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = 0.1;
          this._myCollisionCheckParamsMovement.myHeight = 1;
          this._myCollisionCheckParamsMovement.myComputeGroundInfoEnabled = true;
          this._myCollisionCheckParamsMovement.myComputeCeilingInfoEnabled = true;
          this._myCollisionCheckParamsMovement.myDistanceToBeOnGround = 1e-3;
          this._myCollisionCheckParamsMovement.myDistanceToComputeGroundInfo = 0.1;
          this._myCollisionCheckParamsMovement.myDistanceToBeOnCeiling = 1e-3;
          this._myCollisionCheckParamsMovement.myDistanceToComputeCeilingInfo = 0.1;
          this._myCollisionCheckParamsMovement.myVerticalFixToBeOnGround = 0;
          this._myCollisionCheckParamsMovement.myVerticalFixToComputeGroundInfo = 0;
          this._myCollisionCheckParamsMovement.myVerticalFixToBeOnCeiling = 0;
          this._myCollisionCheckParamsMovement.myVerticalFixToComputeCeilingInfo = 0;
          this._myCollisionCheckParamsMovement.myMustStayOnGround = false;
          this._myCollisionCheckParamsMovement.myMustStayOnCeiling = false;
          this._myCollisionCheckParamsMovement.myRegatherGroundInfoOnSurfaceCheckFail = true;
          this._myCollisionCheckParamsMovement.myRegatherCeilingInfoOnSurfaceCheckFail = true;
          this._myCollisionCheckParamsMovement.mySlidingEnabled = true;
          this._myCollisionCheckParamsMovement.mySlidingHorizontalMovementCheckBetterNormal = true;
          this._myCollisionCheckParamsMovement.mySlidingMaxAttempts = 4;
          this._myCollisionCheckParamsMovement.mySlidingCheckBothDirections = true;
          this._myCollisionCheckParamsMovement.mySlidingFlickeringPreventionType = 1;
          this._myCollisionCheckParamsMovement.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = true;
          this._myCollisionCheckParamsMovement.mySlidingFlickerPreventionCheckAnywayCounter = 4;
          this._myCollisionCheckParamsMovement.mySlidingAdjustSign90Degrees = true;
          this._myCollisionCheckParamsMovement.myHorizontalBlockLayerFlags = new PP.PhysicsLayerFlags();
          this._myCollisionCheckParamsMovement.myHorizontalBlockLayerFlags.setAllFlagsActive(true);
          let physXComponents = PP.myPlayerObjects.myPlayer.pp_getComponentsHierarchy("physx");
          for (let physXComponent of physXComponents) {
            this._myCollisionCheckParamsMovement.myHorizontalObjectsToIgnore.pp_pushUnique(physXComponent.object, (first, second) => first.pp_equals(second));
          }
          this._myCollisionCheckParamsMovement.myVerticalBlockLayerFlags.copy(this._myCollisionCheckParamsMovement.myHorizontalBlockLayerFlags);
          this._myCollisionCheckParamsMovement.myVerticalObjectsToIgnore.pp_copy(this._myCollisionCheckParamsMovement.myHorizontalObjectsToIgnore);
          this._myCollisionCheckParamsMovement.myDebugActive = false;
          this._myCollisionCheckParamsMovement.myDebugHorizontalMovementActive = false;
          this._myCollisionCheckParamsMovement.myDebugHorizontalPositionActive = true;
          this._myCollisionCheckParamsMovement.myDebugVerticalMovementActive = false;
          this._myCollisionCheckParamsMovement.myDebugVerticalPositionActive = false;
          this._myCollisionCheckParamsMovement.myDebugSlidingActive = false;
          this._myCollisionCheckParamsMovement.myDebugGroundInfoActive = false;
          this._myCollisionCheckParamsMovement.myDebugCeilingInfoActive = false;
          this._myCollisionCheckParamsMovement.myDebugRuntimeParamsActive = false;
          this._myCollisionCheckParamsMovement.myDebugMovementActive = false;
        }
        _setupCollisionCheckParamsTeleport() {
          this._myCollisionCheckParamsTeleport = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myCollisionCheckParamsMovement);
          this._myCollisionCheckParamsTeleport.myGroundAngleToIgnore = 60;
          this._myCollisionCheckParamsTeleport.myTeleportMustBeOnIgnorableGroundAngle = true;
          this._myCollisionCheckParamsTeleport.myTeleportMustBeOnGround = true;
        }
        _fixAlmostUp() {
          let defaultUp = PP.vec3_create(0, 1, 0);
          let angleWithDefaultUp = PP.myPlayerObjects.myPlayer.pp_getUp().vec3_angle(defaultUp);
          if (angleWithDefaultUp < 1) {
            let forward = PP.myPlayerObjects.myPlayer.pp_getForward();
            let flatForward = forward.vec3_clone();
            flatForward[1] = 0;
            let defaultForward = PP.vec3_create(0, 0, 1);
            let angleWithDefaultForward = defaultForward.vec3_angleSigned(flatForward, defaultUp);
            PP.myPlayerObjects.myPlayer.pp_resetRotation();
            PP.myPlayerObjects.myPlayer.pp_rotateAxis(angleWithDefaultForward, defaultUp);
          }
        }
        _setupLocomotionMovementFSM() {
          this._myLocomotionMovementFSM = new PP.FSM();
          this._myLocomotionMovementFSM.addState("init");
          this._myLocomotionMovementFSM.addState("smooth", (dt) => this._myPlayerLocomotionSmooth.update(dt));
          this._myLocomotionMovementFSM.addState("teleport", (dt) => this._myPlayerLocomotionTeleport.update(dt));
          this._myLocomotionMovementFSM.addState("idleSmooth");
          this._myLocomotionMovementFSM.addState("idleTeleport");
          this._myLocomotionMovementFSM.addTransition("init", "smooth", "start", function() {
            this._myPlayerLocomotionSmooth.start();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("smooth", "teleport", "next", function() {
            this._myPlayerLocomotionSmooth.stop();
            this._myPlayerLocomotionTeleport.start();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("teleport", "smooth", "next", function() {
            this._myPlayerLocomotionTeleport.stop();
            this._myPlayerLocomotionSmooth.start();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("smooth", "idleSmooth", "idle", function() {
            this._myPlayerLocomotionSmooth.stop();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("teleport", "idleTeleport", "idle", function() {
            this._myPlayerLocomotionTeleport.stop();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("idleSmooth", "smooth", "start", function() {
            this._myPlayerLocomotionSmooth.start();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("idleTeleport", "teleport", "start", function() {
            this._myPlayerLocomotionTeleport.start();
          }.bind(this));
          this._myLocomotionMovementFSM.init("init");
        }
      };
    }
  });

  // js/locomotion/player_locomotion_component.js
  var require_player_locomotion_component = __commonJS({
    "js/locomotion/player_locomotion_component.js"() {
      WL.registerComponent("player-locomotion", {
        _myMaxSpeed: { type: WL.Type.Float, default: 2 },
        _myMaxRotationSpeed: { type: WL.Type.Float, default: 100 },
        _myCharacterRadius: { type: WL.Type.Float, default: 0.3 },
        _myIsSnapTurn: { type: WL.Type.Bool, default: true },
        _mySnapTurnOnlyVR: { type: WL.Type.Bool, default: true },
        _mySnapTurnAngle: { type: WL.Type.Float, default: 30 },
        _mySnapTurnSpeedDegrees: { type: WL.Type.Float, default: 0 },
        _myFlyEnabled: { type: WL.Type.Bool, default: false },
        _myMinAngleToFlyUpNonVR: { type: WL.Type.Float, default: 30 },
        _myMinAngleToFlyDownNonVR: { type: WL.Type.Float, default: 50 },
        _myMinAngleToFlyUpVR: { type: WL.Type.Float, default: 60 },
        _myMinAngleToFlyDownVR: { type: WL.Type.Float, default: 1 },
        _myMinAngleToFlyRight: { type: WL.Type.Float, default: 30 },
        _myMainHand: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myVRDirectionReferenceType: { type: WL.Type.Enum, values: ["head", "hand", "custom object"], default: "hand" },
        _myVRDirectionReferenceObject: { type: WL.Type.Object },
        _myTeleportParableStartReferenceObject: { type: WL.Type.Object },
        _myTeleportPositionObject: { type: WL.Type.Object },
        _myUseCleanedVersion: { type: WL.Type.Bool, default: false }
      }, {
        init() {
        },
        start() {
          CollisionCheckGlobal = new CollisionCheck();
          let params = new PlayerLocomotionParams();
          params.myMaxSpeed = this._myMaxSpeed;
          params.myMaxRotationSpeed = this._myMaxRotationSpeed;
          params.myCharacterRadius = this._myCharacterRadius;
          params.myIsSnapTurn = this._myIsSnapTurn;
          params.mySnapTurnOnlyVR = this._mySnapTurnOnlyVR;
          params.mySnapTurnAngle = this._mySnapTurnAngle;
          params.mySnapTurnSpeedDegrees = this._mySnapTurnSpeedDegrees;
          params.myFlyEnabled = this._myFlyEnabled || Global.myFromAbove;
          params.myMinAngleToFlyUpNonVR = this._myMinAngleToFlyUpNonVR;
          params.myMinAngleToFlyDownNonVR = this._myMinAngleToFlyDownNonVR;
          params.myMinAngleToFlyUpVR = this._myMinAngleToFlyUpVR;
          params.myMinAngleToFlyDownVR = this._myMinAngleToFlyDownVR;
          params.myMinAngleToFlyRight = this._myMinAngleToFlyRight;
          params.myMainHand = PP.InputUtils.getHandednessByIndex(this._myMainHand);
          params.myVRDirectionReferenceType = this._myVRDirectionReferenceType;
          params.myVRDirectionReferenceObject = this._myVRDirectionReferenceObject;
          params.myTeleportParableStartReferenceObject = this._myTeleportParableStartReferenceObject;
          params.myForeheadExtraHeight = 0.1;
          params.myTeleportPositionObject = this._myTeleportPositionObject;
          if (this._myUseCleanedVersion) {
            this._myPlayerLocomotion = new CleanedPlayerLocomotion(params);
          } else {
            this._myPlayerLocomotion = new PlayerLocomotion(params);
          }
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Float 1", 0.15, 0.5, 3));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumberArray("Float Array 1", [1, 2, 3], 0.5, 3));
          PP.myEasyTuneVariables.add(new PP.EasyTuneTransform("Transform 1", PP.mat4_create()));
          PP.myEasyTuneVariables.add(new PP.EasyTuneBool("Bool 1", false));
          this._myStartCounter = 1;
          this._myPlayerLocomotion.start();
          Global.myPlayer = this._myPlayerLocomotion._myPlayerTransformManager;
        },
        update(dt) {
          if (Global.myReady) {
            if (this._myStartCounter > 0) {
              this._myStartCounter--;
              if (this._myStartCounter == 0) {
                if (Global.myIsMazeverseTime) {
                  if (Math.pp_randomInt(0, 99) == 0 && Global.myWinMazeverse) {
                    this._myPlayerLocomotion._myParams.myFlyEnabled = true;
                    this._myPlayerLocomotion._myPlayerLocomotionSmooth._myParams.myFlyEnabled = true;
                    Global.sendAnalytics("event", "debug_movement_enabled", {
                      "value": 1
                    });
                  }
                }
                Global.myPlayerLocomotion = this._myPlayerLocomotion;
                Global.myPlayer.resetReal(true, false, false, true);
                Global.myPlayer.resetHeadToReal();
                let cell = Global.myMaze.getCellsByType(LR.MazeItemType.PLAYER_START);
                if (cell != null && cell.length > 0) {
                  this._myPlayerLocomotion._myPlayerTransformManager.teleportPosition(cell[0].myCellPosition, null, true);
                  if (Global.myMaze.getCellsByType(LR.MazeItemType.BIG_TREE) != null && Global.myMaze.getCellsByType(LR.MazeItemType.BIG_TREE).length > 0) {
                    let rotationQuat = Global.lookBigTreeAligned(this._myPlayerLocomotion._myPlayerTransformManager.getPosition());
                    this._myPlayerLocomotion._myPlayerTransformManager.setRotationQuat(rotationQuat);
                  }
                  Global.myPlayer.resetReal(true, false, false, true);
                  Global.myPlayer.resetHeadToReal();
                }
              }
            } else {
              _myTotalRaycasts = 0;
              this._myPlayerLocomotion.update(dt);
            }
          } else {
            this._myPlayerLocomotion._myPlayerHeadManager.update(dt);
          }
        },
        onActivate() {
          if (this._myPlayerLocomotion != null) {
            this._myPlayerLocomotion.setIdle(false);
          }
        },
        onDeactivate() {
          if (this._myPlayerLocomotion != null) {
            this._myPlayerLocomotion.setIdle(true);
          }
        }
      });
      CollisionCheckGlobal = null;
    }
  });

  // js/locomotion/teleport/player_locomotion_teleport_parable.js
  var require_player_locomotion_teleport_parable = __commonJS({
    "js/locomotion/teleport/player_locomotion_teleport_parable.js"() {
      PlayerLocomotionTeleportParable = class PlayerLocomotionTeleportParable {
        constructor() {
          this._myStartPosition = PP.vec3_create();
          this._myForward = PP.vec3_create();
          this._myUp = PP.vec3_create();
          this._mySpeed = 0;
          this._myGravity = 0;
          this._myStepLength = 0;
        }
        setStartPosition(startPosition) {
          this._myStartPosition.vec3_copy(startPosition);
        }
        setForward(forward) {
          this._myForward.vec3_copy(forward);
        }
        setUp(up) {
          this._myUp.vec3_copy(up);
        }
        setSpeed(speed) {
          this._mySpeed = speed;
        }
        setGravity(gravity) {
          this._myGravity = gravity;
        }
        setStepLength(stepLength) {
          this._myStepLength = stepLength;
        }
        getPosition(positionIndex, outPosition = PP.vec3_create()) {
        }
        getDistance(positionIndex) {
        }
        getPositionIndexByDistance(distance4) {
        }
        getPositionByDistance(distance4, outPosition = PP.vec3_create()) {
        }
        getDistanceOverFlatDistance(flatDistance, maxParableDistance) {
        }
        getFlatDistanceOverDistance(distance4) {
        }
      };
      PlayerLocomotionTeleportParable.prototype.getPosition = function() {
        let forwardPosition = PP.vec3_create();
        let upPosition = PP.vec3_create();
        return function getPosition(positionIndex, outPosition = PP.vec3_create()) {
          let deltaTimePerStep = this._myStepLength / this._mySpeed;
          let elapsedTime = deltaTimePerStep * positionIndex;
          forwardPosition = this._myForward.vec3_scale(this._mySpeed * elapsedTime, forwardPosition);
          forwardPosition = forwardPosition.vec3_add(this._myStartPosition, forwardPosition);
          upPosition = this._myUp.vec3_scale(this._myGravity * elapsedTime * elapsedTime / 2, upPosition);
          outPosition = forwardPosition.vec3_add(upPosition, outPosition);
          return outPosition;
        };
      }();
      PlayerLocomotionTeleportParable.prototype.getDistance = function() {
        let currentPosition = PP.vec3_create();
        let prevPosition = PP.vec3_create();
        return function getDistance(positionIndex) {
          let distance4 = 0;
          prevPosition.vec3_copy(this._myStartPosition);
          for (let i = 1; i <= positionIndex; i++) {
            currentPosition = this.getPosition(i, currentPosition);
            distance4 += currentPosition.vec3_distance(prevPosition);
            prevPosition.vec3_copy(currentPosition);
          }
          return distance4;
        };
      }();
      PlayerLocomotionTeleportParable.prototype.getPositionIndexByDistance = function() {
        let currentPosition = PP.vec3_create();
        let prevPosition = PP.vec3_create();
        return function getPositionIndexByDistance(distance4) {
          let currentDistance = 0;
          let currentIndex = 0;
          prevPosition = this.getPosition(currentIndex, prevPosition);
          while (currentDistance < distance4) {
            currentPosition = this.getPosition(currentIndex + 1, currentPosition);
            currentDistance += currentPosition.vec3_distance(prevPosition);
            currentIndex++;
            prevPosition.vec3_copy(currentPosition);
          }
          return Math.max(0, currentIndex - 1);
        };
      }();
      PlayerLocomotionTeleportParable.prototype.getPositionByDistance = function() {
        let currentPosition = PP.vec3_create();
        let prevPosition = PP.vec3_create();
        let prevToCurrent = PP.vec3_create();
        return function getPositionIndexByDistance(distance4, outPosition = PP.vec3_create()) {
          let currentDistance = 0;
          let currentIndex = 0;
          let found = false;
          prevPosition = this.getPosition(currentIndex, prevPosition);
          while (!found) {
            currentPosition = this.getPosition(currentIndex + 1, currentPosition);
            currentDistance += currentPosition.vec3_distance(prevPosition);
            currentIndex++;
            if (currentDistance > distance4) {
              let lengthToRemove = currentDistance - distance4;
              prevToCurrent = currentPosition.vec3_sub(prevPosition, prevToCurrent);
              let lengthToAdd = prevToCurrent.vec3_length() - lengthToRemove;
              prevToCurrent.vec3_normalize(prevToCurrent);
              outPosition = prevPosition.vec3_add(prevToCurrent.vec3_scale(lengthToAdd, outPosition), outPosition);
              found = true;
            }
            prevPosition.vec3_copy(currentPosition);
          }
          return outPosition;
        };
      }();
      PlayerLocomotionTeleportParable.prototype.getDistanceOverFlatDistance = function() {
        let currentPosition = PP.vec3_create();
        let flatCurrentPosition = PP.vec3_create();
        let flatStartPosition = PP.vec3_create();
        let prevPosition = PP.vec3_create();
        let prevToCurrent = PP.vec3_create();
        let startToCurrentFlat = PP.vec3_create();
        return function getDistanceOverFlatDistance(flatDistance, maxParableDistance) {
          if (flatDistance < 1e-5) {
            return 0;
          }
          let currentDistance = 0;
          let currentIndex = 0;
          flatStartPosition = this._myStartPosition.vec3_removeComponentAlongAxis(this._myUp, flatStartPosition);
          prevPosition = this.getPosition(currentIndex, prevPosition);
          let distanceOverFlatDistance = 0;
          while (currentDistance <= maxParableDistance) {
            currentPosition = this.getPosition(currentIndex + 1, currentPosition);
            currentDistance += currentPosition.vec3_distance(prevPosition);
            currentIndex++;
            flatCurrentPosition = currentPosition.vec3_removeComponentAlongAxis(this._myUp, flatCurrentPosition);
            startToCurrentFlat = flatCurrentPosition.vec3_sub(flatStartPosition, startToCurrentFlat);
            let currentFlatDistance = startToCurrentFlat.vec3_length();
            if (currentFlatDistance >= flatDistance) {
              let flatDifference = currentFlatDistance - flatDistance;
              prevToCurrent = currentPosition.vec3_sub(prevPosition, prevToCurrent);
              let angleWithFlat = prevToCurrent.vec3_angleRadians(startToCurrentFlat);
              let cos = Math.cos(angleWithFlat);
              let lengthToRemove = prevToCurrent.vec3_length();
              if (cos != 0) {
                lengthToRemove = flatDifference / Math.cos(angleWithFlat);
              }
              distanceOverFlatDistance = currentDistance - lengthToRemove;
              break;
            } else {
              distanceOverFlatDistance = currentDistance;
            }
            prevPosition.vec3_copy(currentPosition);
          }
          return Math.min(maxParableDistance, distanceOverFlatDistance);
        };
      }();
      PlayerLocomotionTeleportParable.prototype.getFlatDistanceOverDistance = function() {
        let positionByDistance = PP.vec3_create();
        let flatPositionByDistance = PP.vec3_create();
        let flatStartPosition = PP.vec3_create();
        return function getFlatDistanceOverDistance(distance4) {
          positionByDistance = this.getPositionByDistance(distance4, positionByDistance);
          flatPositionByDistance = positionByDistance.vec3_removeComponentAlongAxis(this._myUp, flatPositionByDistance);
          flatStartPosition = this._myStartPosition.vec3_removeComponentAlongAxis(this._myUp, flatStartPosition);
          return flatStartPosition.vec3_distance(flatPositionByDistance);
        };
      }();
    }
  });

  // js/locomotion/teleport/player_locomotion_teleport_state.js
  var require_player_locomotion_teleport_state = __commonJS({
    "js/locomotion/teleport/player_locomotion_teleport_state.js"() {
      PlayerLocomotionTeleportState = class PlayerLocomotionTeleportState extends PP.State {
        constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
          super();
          this._myLocomotionRuntimeParams = locomotionRuntimeParams;
          this._myTeleportParams = teleportParams;
          this._myTeleportRuntimeParams = teleportRuntimeParams;
          this._myTeleportAsMovementFailed = false;
        }
      };
      PlayerLocomotionTeleportState.prototype._checkTeleport = function() {
        return function _checkTeleport(teleportPosition, feetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams = null) {
          CollisionCheckGlobal.teleport(teleportPosition, feetTransformQuat, this._myTeleportParams.myCollisionCheckParams, collisionRuntimeParams);
          if (checkTeleportCollisionRuntimeParams != null) {
            checkTeleportCollisionRuntimeParams.copy(collisionRuntimeParams);
          }
        };
      }();
      PlayerLocomotionTeleportState.prototype._checkTeleportAsMovement = function() {
        let checkTeleportMovementCollisionRuntimeParams = new CollisionRuntimeParams();
        let feetRotationQuat = PP.quat_create();
        let feetPosition = PP.vec3_create();
        let feetUp = PP.vec3_create();
        let teleportFeetForward = PP.vec3_create();
        let teleportFeetRotationQuat = PP.quat_create();
        let teleportFeetTransformQuat = PP.quat2_create();
        let currentFeetPosition = PP.vec3_create();
        let fixedTeleportPosition = PP.vec3_create();
        let teleportMovement = PP.vec3_create();
        let extraVerticalMovement = PP.vec3_create();
        let movementToTeleportPosition = PP.vec3_create();
        let movementFeetTransformQuat = PP.quat2_create();
        return function _checkTeleportAsMovement(teleportPosition, feetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams) {
          feetPosition = feetTransformQuat.quat2_getPosition(feetPosition);
          feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
          feetUp = feetRotationQuat.quat_getUp(feetUp);
          teleportFeetForward = teleportPosition.vec3_sub(feetPosition, teleportFeetForward).vec3_removeComponentAlongAxis(feetUp, teleportFeetForward);
          teleportFeetForward.vec3_normalize(teleportFeetForward);
          if (teleportFeetForward.vec3_isZero(1e-5)) {
            teleportFeetForward = feetRotationQuat.quat_getForward(teleportFeetForward);
          }
          teleportFeetRotationQuat.quat_setUp(feetUp, teleportFeetForward);
          teleportFeetTransformQuat.quat2_setPositionRotationQuat(feetPosition, teleportFeetRotationQuat);
          this._checkTeleport(teleportPosition, teleportFeetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams);
          if (!collisionRuntimeParams.myTeleportCanceled) {
            let teleportMovementValid = false;
            checkTeleportMovementCollisionRuntimeParams.copy(collisionRuntimeParams);
            fixedTeleportPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
            currentFeetPosition.vec3_copy(feetPosition);
            for (let i = 0; i < this._myTeleportParams.myTeleportAsMovementMaxSteps; i++) {
              teleportMovement = fixedTeleportPosition.vec3_sub(currentFeetPosition, teleportMovement);
              if (this._myTeleportParams.myTeleportAsMovementRemoveVerticalMovement) {
                teleportMovement = teleportMovement.vec3_removeComponentAlongAxis(feetUp, teleportMovement);
              }
              if (this._myTeleportParams.myTeleportAsMovementExtraVerticalMovementPerMeter != 0) {
                let meters = teleportMovement.vec3_length();
                let extraVerticalMovementValue = meters * this._myTeleportParams.myTeleportAsMovementExtraVerticalMovementPerMeter;
                extraVerticalMovement = feetUp.vec3_scale(extraVerticalMovementValue, extraVerticalMovement);
                teleportMovement = teleportMovement.vec3_add(extraVerticalMovement, teleportMovement);
              }
              movementFeetTransformQuat.quat2_setPositionRotationQuat(currentFeetPosition, feetRotationQuat);
              CollisionCheckGlobal.move(teleportMovement, movementFeetTransformQuat, this._myTeleportParams.myCollisionCheckParams, checkTeleportMovementCollisionRuntimeParams);
              if (!checkTeleportMovementCollisionRuntimeParams.myHorizontalMovementCanceled && !checkTeleportMovementCollisionRuntimeParams.myVerticalMovementCanceled) {
                movementToTeleportPosition = fixedTeleportPosition.vec3_sub(checkTeleportMovementCollisionRuntimeParams.myNewPosition, movementToTeleportPosition);
                if (movementToTeleportPosition.vec3_length() < this._myTeleportParams.myTeleportAsMovementMaxDistanceFromTeleportPosition + 1e-5) {
                  teleportMovementValid = true;
                  break;
                } else {
                  teleportMovement.vec3_copy(movementToTeleportPosition);
                  currentFeetPosition.vec3_copy(checkTeleportMovementCollisionRuntimeParams.myNewPosition);
                }
              } else {
                break;
              }
            }
            if (!teleportMovementValid) {
              collisionRuntimeParams.myTeleportCanceled = true;
            }
            this._myTeleportAsMovementFailed = !teleportMovementValid;
          }
        };
      }();
      PlayerLocomotionTeleportState.prototype._teleportToPosition = function() {
        let playerUp = PP.vec3_create();
        let feetTransformQuat = PP.quat2_create();
        let newFeetTransformQuat = PP.quat2_create();
        let newFeetRotationQuat = PP.quat_create();
        let teleportRotation = PP.quat_create();
        return function _teleportToPosition(teleportPosition, rotationOnUp, collisionRuntimeParams, forceTeleport = false) {
          this._myTeleportAsMovementFailed = false;
          playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
          feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
          newFeetRotationQuat = feetTransformQuat.quat2_getRotationQuat(newFeetRotationQuat);
          if (rotationOnUp != 0) {
            newFeetRotationQuat = newFeetRotationQuat.quat_rotateAxis(rotationOnUp, playerUp, newFeetRotationQuat);
          }
          newFeetTransformQuat.quat2_setPositionRotationQuat(teleportPosition, newFeetRotationQuat);
          if (PP.myGamepads[PP.InputUtils.getOppositeHandedness(this._myTeleportParams.myHandedness)].getButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
            CollisionCheckGlobal.positionCheck(true, newFeetTransformQuat, this._myTeleportParams.myCollisionCheckParams, collisionRuntimeParams);
            this._myTeleportParams.myPlayerHeadManager.teleportPositionFeet(teleportPosition);
            if (rotationOnUp != 0) {
              teleportRotation.quat_fromAxis(rotationOnUp, playerUp);
              this._myTeleportParams.myPlayerHeadManager.rotateFeetQuat(teleportRotation);
            }
          } else {
            this._myTeleportParams.myPlayerTransformManager.teleportTransformQuat(newFeetTransformQuat, collisionRuntimeParams, forceTeleport);
          }
        };
      }();
    }
  });

  // js/locomotion/teleport/player_locomotion_teleport_detection_visualizer.js
  var require_player_locomotion_teleport_detection_visualizer = __commonJS({
    "js/locomotion/teleport/player_locomotion_teleport_detection_visualizer.js"() {
      PlayerLocomotionTeleportDetectionVisualizerParams = class PlayerLocomotionTeleportDetectionVisualizerParams {
        constructor() {
          this.myTeleportParableValidMaterial = null;
          this.myTeleportParableInvalidMaterial = null;
          this.myTeleportPositionObject = null;
          this.myTeleportParableLineEndOffset = 0.05;
          this.myTeleportParableMinVerticalDistanceToShowVerticalLine = 0.6;
          this.myTeleportParablePositionUpOffset = 0.05;
          this.myTeleportParablePositionVisualAlignOnSurface = true;
          this.myVisualTeleportPositionLerpActive = true;
          this.myVisualTeleportPositionLerpFactor = 10;
          this.myVisualTeleportPositionMinDistanceToResetLerp = 5e-3;
          this.myVisualTeleportPositionMinDistanceToLerp = 0.15;
          this.myVisualTeleportPositionMaxDistanceToLerp = 5;
          this.myVisualTeleportPositionMinDistanceToCloseLerpFactor = 0.02;
          this.myVisualTeleportPositionCloseLerpFactor = 30;
          this.myVisualTeleportPositionMinAngleDistanceToResetLerp = 0.1;
          this.myVisualTeleportPositionMinAngleDistanceToLerp = 1;
          this.myVisualTeleportPositionMaxAngleDistanceToLerp = 180;
        }
      };
      PlayerLocomotionTeleportDetectionVisualizer = class PlayerLocomotionTeleportDetectionVisualizer {
        constructor(teleportParams, teleportRuntimeParams, detectionRuntimeParams) {
          this._myDetectionRuntimeParams = detectionRuntimeParams;
          this._myTeleportParams = teleportParams;
          this._myTeleportRuntimeParams = teleportRuntimeParams;
          this._myVisualTeleportTransformQuatReset = true;
          this._myVisualTeleportTransformQuat = PP.quat2_create();
          this._myVisualTeleportTransformPositionLerping = false;
          this._myVisualTeleportTransformRotationLerping = false;
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Teleport Min Distance Lerp", this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToLerp, 1, 3, 0));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Teleport Max Distance Lerp", this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxDistanceToLerp, 1, 3, 0));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Teleport Min Angle Distance Lerp", this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToLerp, 10, 3, 0));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Teleport Max Angle Distance Lerp", this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxAngleDistanceToLerp, 10, 3, 0));
          this._setupVisuals();
        }
        start() {
        }
        end() {
          this._myVisualTeleportTransformQuatReset = true;
          this._myVisualTeleportTransformPositionLerping = false;
          this._myVisualTeleportTransformRotationLerping = false;
          this._hideTeleportPosition();
        }
        update(dt) {
          this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToLerp = PP.myEasyTuneVariables.get("Teleport Min Distance Lerp");
          this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxDistanceToLerp = PP.myEasyTuneVariables.get("Teleport Max Distance Lerp");
          this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToLerp = PP.myEasyTuneVariables.get("Teleport Min Angle Distance Lerp");
          this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxAngleDistanceToLerp = PP.myEasyTuneVariables.get("Teleport Max Angle Distance Lerp");
          if (this._myDetectionRuntimeParams.myTeleportDetectionValid) {
            this._showTeleportPosition(dt);
          } else {
            this._myVisualTeleportTransformQuatReset = true;
            this._myVisualTeleportTransformPositionLerping = false;
            this._myVisualTeleportTransformRotationLerping = false;
            this._hideTeleportPosition();
          }
        }
        _showTeleportPosition(dt) {
          this._showTeleportParable(dt);
        }
        _hideTeleportPosition() {
          for (let visualLine of this._myValidVisualLines) {
            visualLine.setVisible(false);
          }
          for (let visualLine of this._myInvalidVisualLines) {
            visualLine.setVisible(false);
          }
          this._myValidVisualPoint.setVisible(false);
          this._myInvalidVisualPoint.setVisible(false);
          this._myValidVisualVerticalLine.setVisible(false);
          this._myValidVisualTeleportPositionTorus.setVisible(false);
          this._myValidVisualTeleportPositionTorusInner.setVisible(false);
          if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
            this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
          }
        }
        _addVisualLines(amount) {
          for (let i = 0; i < amount; i++) {
            {
              let visualParams = new PP.VisualLineParams();
              if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
                visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial;
              } else {
                visualParams.myMaterial = this._myTeleportParableValidMaterial;
              }
              this._myValidVisualLines.push(new PP.VisualLine(visualParams));
            }
            {
              let visualParams = new PP.VisualLineParams();
              if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
                visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableInvalidMaterial;
              } else {
                visualParams.myMaterial = this._myTeleportParableInvalidMaterial;
              }
              this._myInvalidVisualLines.push(new PP.VisualLine(visualParams));
            }
          }
        }
      };
      PlayerLocomotionTeleportDetectionVisualizer.prototype._setupVisuals = function() {
        let innerTorusPosition = PP.vec3_create();
        return function _setupVisuals() {
          this._myTeleportParableValidMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
          this._myTeleportParableValidMaterial.color = PP.vec4_create(190 / 255, 20 / 255, 60 / 255, 1);
          this._myTeleportParableInvalidMaterial = PP.myDefaultResources.myMaterials.myFlatOpaque.clone();
          this._myTeleportParableInvalidMaterial.color = PP.vec4_create(225 / 255, 175 / 255, 55 / 255, 1);
          this._myValidVisualLines = [];
          this._myInvalidVisualLines = [];
          this._addVisualLines(30);
          {
            let visualParams = new PP.VisualPointParams();
            if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
              visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial;
            } else {
              visualParams.myMaterial = this._myTeleportParableValidMaterial;
            }
            this._myValidVisualPoint = new PP.VisualPoint(visualParams);
          }
          {
            let visualParams = new PP.VisualPointParams();
            if (this._myTeleportParams.myVisualizerParams.myTeleportParableInvalidMaterial != null) {
              visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableInvalidMaterial;
            } else {
              visualParams.myMaterial = this._myTeleportParableInvalidMaterial;
            }
            this._myInvalidVisualPoint = new PP.VisualPoint(visualParams);
          }
          {
            let visualParams = new PP.VisualLineParams();
            if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
              visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial;
            } else {
              visualParams.myMaterial = this._myTeleportParableValidMaterial;
            }
            this._myValidVisualVerticalLine = new PP.VisualLine(visualParams);
          }
          this._myVisualTeleportPositionObject = PP.myVisualData.myRootObject.pp_addObject();
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Teleport Torus Radius", 0.175, 0.1, 3));
          PP.myEasyTuneVariables.add(new PP.EasyTuneInt("Teleport Torus Segments", 24, 1));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Teleport Torus Thickness", 0.02, 0.1, 3));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Teleport Torus Inner Radius", 0.04, 0.1, 3));
          {
            let visualParams = new PP.VisualTorusParams();
            visualParams.myRadius = PP.myEasyTuneVariables.get("Teleport Torus Radius");
            visualParams.mySegmentsAmount = PP.myEasyTuneVariables.get("Teleport Torus Segments");
            visualParams.mySegmentThickness = PP.myEasyTuneVariables.get("Teleport Torus Thickness");
            if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
              visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial;
            } else {
              visualParams.myMaterial = this._myTeleportParableValidMaterial;
            }
            visualParams.myParent = this._myVisualTeleportPositionObject;
            visualParams.myIsLocal = true;
            this._myValidVisualTeleportPositionTorus = new PP.VisualTorus(visualParams);
          }
          {
            let visualParams = new PP.VisualTorusParams();
            visualParams.myRadius = PP.myEasyTuneVariables.get("Teleport Torus Inner Radius");
            visualParams.mySegmentsAmount = PP.myEasyTuneVariables.get("Teleport Torus Segments");
            visualParams.mySegmentThickness = PP.myEasyTuneVariables.get("Teleport Torus Thickness");
            if (this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial != null) {
              visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportParableValidMaterial;
            } else {
              visualParams.myMaterial = this._myTeleportParableValidMaterial;
            }
            visualParams.myParent = this._myVisualTeleportPositionObject;
            visualParams.myIsLocal = true;
            let visualTorusParams = this._myValidVisualTeleportPositionTorus.getParams();
            let innerTorusCenter = (visualTorusParams.myRadius - visualTorusParams.mySegmentThickness / 2) / 2;
            innerTorusPosition.vec3_set(0, 0, innerTorusCenter);
            visualParams.myTransform.mat4_setPosition(innerTorusPosition);
            this._myValidVisualTeleportPositionTorusInner = new PP.VisualTorus(visualParams);
          }
          if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
            this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setParent(this._myVisualTeleportPositionObject);
            this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_resetTransformLocal();
            this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
          }
          this._hideTeleportPosition();
        };
      }();
      PlayerLocomotionTeleportDetectionVisualizer.prototype._showTeleportParable = function() {
        let currentPosition = PP.vec3_create();
        let nextPosition = PP.vec3_create();
        let playerUp = PP.vec3_create();
        let upDifference = PP.vec3_create();
        return function _showTeleportParable(dt) {
          let showParableDistance = Math.max(this._myDetectionRuntimeParams.myParableDistance - this._myTeleportParams.myVisualizerParams.myTeleportParableLineEndOffset);
          let lastParableIndex = this._myDetectionRuntimeParams.myParable.getPositionIndexByDistance(showParableDistance);
          let lastParableIndexDistance = this._myDetectionRuntimeParams.myParable.getDistance(lastParableIndex);
          if (lastParableIndex + 1 > this._myValidVisualLines.length) {
            this._addVisualLines(lastParableIndex + 1, this._myValidVisualLines.length);
          }
          const usedVisualLines = [];
          for (let i = 0; i <= lastParableIndex; i++) {
            currentPosition = this._myDetectionRuntimeParams.myParable.getPosition(i, currentPosition);
            nextPosition = this._myDetectionRuntimeParams.myParable.getPosition(i + 1, nextPosition);
            let visuaLine = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myValidVisualLines[i] : this._myInvalidVisualLines[i];
            usedVisualLines.push(visuaLine);
            let currentVisualLineParams = visuaLine.getParams();
            if (i == lastParableIndex) {
              let stepLength = Math.max(0, showParableDistance - lastParableIndexDistance);
              nextPosition = nextPosition.vec3_sub(currentPosition, nextPosition).vec3_normalize(nextPosition);
              nextPosition = currentPosition.vec3_add(nextPosition.vec3_scale(stepLength, nextPosition), nextPosition);
            }
            currentVisualLineParams.setStartEnd(currentPosition, nextPosition);
            currentVisualLineParams.myThickness = 5e-3;
            visuaLine.paramsUpdated();
            visuaLine.setVisible(true);
            if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugShowActive) {
              PP.myDebugVisualManager.drawPoint(0, currentPosition, PP.vec4_create(1, 0, 0, 1), 0.01);
            }
          }
          for (let visualLine of this._myValidVisualLines) {
            if (usedVisualLines.indexOf(visualLine) == -1) {
              visualLine.setVisible(false);
            }
          }
          for (let visualLine of this._myInvalidVisualLines) {
            if (usedVisualLines.indexOf(visualLine) == -1) {
              visualLine.setVisible(false);
            }
          }
          let visualPoint = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myValidVisualPoint : this._myInvalidVisualPoint;
          let visualPointParams = visualPoint.getParams();
          visualPointParams.myPosition.vec3_copy(nextPosition);
          visualPointParams.myRadius = 0.01;
          visualPoint.paramsUpdated();
          visualPoint.setVisible(true);
          let unusedVisualPoint = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myInvalidVisualPoint : this._myValidVisualPoint;
          unusedVisualPoint.setVisible(false);
          if (this._myDetectionRuntimeParams.myTeleportPositionValid) {
            playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
            upDifference = nextPosition.vec3_sub(this._myTeleportRuntimeParams.myTeleportPosition, upDifference).vec3_componentAlongAxis(playerUp, upDifference);
            let upDistance = upDifference.vec3_length();
            if (upDistance >= this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine) {
              let lineLength = Math.min(upDistance - this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine, this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine);
              let visualLineParams = this._myValidVisualVerticalLine.getParams();
              visualLineParams.myStart.vec3_copy(nextPosition);
              visualLineParams.myDirection = playerUp.vec3_negate(visualLineParams.myDirection);
              visualLineParams.myLength = lineLength;
              visualLineParams.myThickness = 5e-3;
              this._myValidVisualVerticalLine.paramsUpdated();
              this._myValidVisualVerticalLine.setVisible(true);
            } else {
              this._myValidVisualVerticalLine.setVisible(false);
            }
            this._showTeleportParablePosition(dt);
          } else {
            this._myValidVisualTeleportPositionTorus.setVisible(false);
            this._myValidVisualTeleportPositionTorusInner.setVisible(false);
            this._myValidVisualVerticalLine.setVisible(false);
            if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
              this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
            }
            this._myVisualTeleportTransformQuatReset = true;
            this._myVisualTeleportTransformPositionLerping = false;
            this._myVisualTeleportTransformRotationLerping = false;
          }
        };
      }();
      PlayerLocomotionTeleportDetectionVisualizer.prototype._showTeleportParablePosition = function() {
        let playerUp = PP.vec3_create();
        let feetTransformQuat = PP.quat2_create();
        let feetRotationQuat = PP.quat_create();
        let visualPosition = PP.vec3_create();
        let visualForward = PP.vec3_create();
        let visualRotationQuat = PP.quat_create();
        let currentVisualTeleportTransformQuat = PP.quat2_create();
        let currentVisualTeleportPosition = PP.vec3_create();
        let currentVisualTeleportRotationQuat = PP.quat_create();
        let differenceRotationQuat = PP.quat_create();
        return function _showTeleportParablePosition(dt) {
          playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
          feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
          feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
          feetRotationQuat = feetRotationQuat.quat_rotateAxis(this._myTeleportRuntimeParams.myTeleportRotationOnUp, playerUp, feetRotationQuat);
          visualForward = feetRotationQuat.quat_getForward(visualForward);
          visualPosition = this._myTeleportRuntimeParams.myTeleportPosition.vec3_add(playerUp.vec3_scale(this._myTeleportParams.myVisualizerParams.myTeleportParablePositionUpOffset, visualPosition), visualPosition);
          if (this._myTeleportParams.myVisualizerParams.myTeleportParablePositionVisualAlignOnSurface) {
            visualRotationQuat.quat_setUp(this._myDetectionRuntimeParams.myTeleportSurfaceNormal, visualForward);
          } else {
            visualRotationQuat.quat_setUp(playerUp, visualForward);
          }
          this._myVisualTeleportTransformQuat.quat2_setPositionRotationQuat(visualPosition, visualRotationQuat);
          if (this._myVisualTeleportTransformQuatReset || !this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpActive) {
            this._myVisualTeleportPositionObject.pp_setTransformQuat(this._myVisualTeleportTransformQuat);
            this._myVisualTeleportTransformQuatReset = false;
          } else {
            currentVisualTeleportTransformQuat = this._myVisualTeleportPositionObject.pp_getTransformQuat(currentVisualTeleportTransformQuat);
            currentVisualTeleportPosition = currentVisualTeleportTransformQuat.quat2_getPosition(currentVisualTeleportPosition);
            currentVisualTeleportRotationQuat = currentVisualTeleportTransformQuat.quat2_getRotationQuat(currentVisualTeleportRotationQuat);
            currentVisualTeleportRotationQuat.quat_rotationToQuat(visualRotationQuat, differenceRotationQuat);
            let positionDistance = currentVisualTeleportPosition.vec3_distance(visualPosition);
            let rotationAngleDistance = differenceRotationQuat.quat_getAngle();
            if ((!this._myVisualTeleportTransformPositionLerping || positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToResetLerp) && (positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToLerp || positionDistance > this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxDistanceToLerp)) {
              this._myVisualTeleportTransformPositionLerping = false;
              currentVisualTeleportPosition.vec3_copy(visualPosition);
            } else {
              this._myVisualTeleportTransformPositionLerping = true;
              let interpolationValue = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpFactor * dt;
              if (positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToCloseLerpFactor) {
                interpolationValue = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionCloseLerpFactor * dt;
              }
              currentVisualTeleportPosition.vec3_lerp(visualPosition, interpolationValue, currentVisualTeleportPosition);
            }
            if ((!this._myVisualTeleportTransformRotationLerping || rotationAngleDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToResetLerp) && (rotationAngleDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToLerp || positionDistance > this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxAngleDistanceToLerp)) {
              this._myVisualTeleportTransformRotationLerping = false;
              currentVisualTeleportRotationQuat.quat_copy(visualRotationQuat);
            } else {
              let interpolationValue = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpFactor * dt;
              this._myVisualTeleportTransformRotationLerping = true;
              currentVisualTeleportRotationQuat.quat_slerp(visualRotationQuat, interpolationValue, currentVisualTeleportRotationQuat);
            }
            currentVisualTeleportTransformQuat.quat2_setPositionRotationQuat(currentVisualTeleportPosition, currentVisualTeleportRotationQuat);
            this._myVisualTeleportPositionObject.pp_setTransformQuat(currentVisualTeleportTransformQuat);
          }
          {
            let visualParams = this._myValidVisualTeleportPositionTorus.getParams();
            visualParams.myRadius = PP.myEasyTuneVariables.get("Teleport Torus Radius");
            visualParams.mySegmentsAmount = PP.myEasyTuneVariables.get("Teleport Torus Segments");
            visualParams.mySegmentThickness = PP.myEasyTuneVariables.get("Teleport Torus Thickness");
            this._myValidVisualTeleportPositionTorus.paramsUpdated();
          }
          {
            let visualParams = this._myValidVisualTeleportPositionTorusInner.getParams();
            visualParams.myRadius = PP.myEasyTuneVariables.get("Teleport Torus Inner Radius");
            visualParams.mySegmentsAmount = PP.myEasyTuneVariables.get("Teleport Torus Segments");
            visualParams.mySegmentThickness = PP.myEasyTuneVariables.get("Teleport Torus Thickness");
            this._myValidVisualTeleportPositionTorusInner.paramsUpdated();
          }
          if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject == null) {
            this._myValidVisualTeleportPositionTorus.setVisible(true);
            this._myValidVisualTeleportPositionTorusInner.setVisible(true);
          } else {
            this._myValidVisualTeleportPositionTorus.setVisible(false);
            this._myValidVisualTeleportPositionTorusInner.setVisible(false);
            this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(true);
          }
          if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugShowActive) {
            PP.myDebugVisualManager.drawPoint(0, this._myTeleportRuntimeParams.myTeleportPosition, PP.vec4_create(0, 0, 1, 1), 0.02);
          }
        };
      }();
    }
  });

  // js/locomotion/teleport/player_locomotion_teleport_detection_state.js
  var require_player_locomotion_teleport_detection_state = __commonJS({
    "js/locomotion/teleport/player_locomotion_teleport_detection_state.js"() {
      PlayerLocomotionTeleportDetectionParams = class PlayerLocomotionTeleportDetectionParams {
        constructor() {
          this.myMaxDistance = 0;
          this.myMaxHeightDifference = 0;
          this.myGroundAngleToIgnoreUpward = 0;
          this.myMustBeOnGround = false;
          this.myTeleportBlockLayerFlags = new PP.PhysicsLayerFlags();
          this.myTeleportFloorLayerFlags = new PP.PhysicsLayerFlags();
          this.myParableForwardMinAngleToBeValidUp = 30;
          this.myParableForwardMinAngleToBeValidDown = 0;
          this.myTeleportParableStartReferenceObject = null;
          this.myTeleportParableStartPositionOffset = PP.vec3_create(0, -0.04, 0.08);
          this.myTeleportParableStartRotationOffset = PP.vec3_create(30, 0, 0);
          this.myTeleportParableSpeed = 15;
          this.myTeleportParableGravity = -30;
          this.myTeleportParableStepLength = 0.25;
          this.myRotationOnUpMinStickIntensity = 0.5;
          this.myRotationOnUpActive = false;
          this.myTeleportFeetPositionMustBeVisible = false;
          this.myTeleportHeadPositionMustBeVisible = false;
          this.myTeleportHeadOrFeetPositionMustBeVisible = false;
          this.myVisibilityCheckRadius = 0.05;
          this.myVisibilityCheckFeetPositionVerticalOffset = 0.1;
          this.myVisibilityCheckDistanceFromHitThreshold = 0.1;
          this.myVisibilityCheckCircumferenceSliceAmount = 6;
          this.myVisibilityCheckCircumferenceStepAmount = 1;
          this.myVisibilityCheckCircumferenceRotationPerStep = 30;
          this.myVisibilityBlockLayerFlags = new PP.PhysicsLayerFlags();
        }
      };
      PlayerLocomotionTeleportDetectionRuntimeParams = class PlayerLocomotionTeleportDetectionRuntimeParams {
        constructor() {
          this.myTeleportDetectionValid = false;
          this.myTeleportPositionValid = false;
          this.myTeleportSurfaceNormal = PP.vec3_create();
          this.myParable = new PlayerLocomotionTeleportParable();
        }
      };
      PlayerLocomotionTeleportDetectionState = class PlayerLocomotionTeleportDetectionState extends PlayerLocomotionTeleportState {
        constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
          super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
          this._myDetectionRuntimeParams = new PlayerLocomotionTeleportDetectionRuntimeParams();
          this._myVisualizer = new PlayerLocomotionTeleportDetectionVisualizer(this._myTeleportParams, this._myTeleportRuntimeParams, this._myDetectionRuntimeParams);
          this._myTeleportRotationOnUpNext = 0;
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Parable Steps", this._myTeleportParams.myDetectionParams.myTeleportParableStepLength, 1, 3, 0.01));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Parable Gravity", this._myTeleportParams.myDetectionParams.myTeleportParableGravity, 10, 3));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Parable Speed", this._myTeleportParams.myDetectionParams.myTeleportParableSpeed, 10, 3, 0));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Teleport Max Distance", this._myTeleportParams.myDetectionParams.myMaxDistance, 10, 3, 0));
        }
        start() {
          this._myLocomotionRuntimeParams.myIsTeleportDetecting = true;
          this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
          this._myTeleportRotationOnUpNext = 0;
          this._myDetectionRuntimeParams.myParable.setSpeed(this._myTeleportParams.myDetectionParams.myTeleportParableSpeed);
          this._myDetectionRuntimeParams.myParable.setGravity(this._myTeleportParams.myDetectionParams.myTeleportParableGravity);
          this._myDetectionRuntimeParams.myParable.setStepLength(this._myTeleportParams.myDetectionParams.myTeleportParableStepLength);
          Global.myPlayer.resetReal(true, false, false);
          Global.myPlayer.resetHeadToReal();
          this._myVisualizer.start();
        }
        end() {
          this._myLocomotionRuntimeParams.myIsTeleportDetecting = false;
          this._myVisualizer.end();
        }
        update(dt, fsm) {
          this._detectTeleportPosition();
          this._myVisualizer.update(dt);
          if (this._confirmTeleport()) {
            if (this._myDetectionRuntimeParams.myTeleportPositionValid) {
              fsm.perform("teleport");
            } else {
              fsm.perform("cancel");
            }
          } else if (this._cancelTeleport()) {
            fsm.perform("cancel");
          }
        }
        _confirmTeleport() {
          let confirmTeleport = false;
          if (!PP.XRUtils.isSessionActive()) {
            if (PP.myMouse.isInsideView()) {
              confirmTeleport = PP.myMouse.isButtonPressEnd(PP.MouseButtonID.MIDDLE);
            }
          } else {
            let axes = PP.myGamepads[this._myTeleportParams.myHandedness].getAxesInfo().getAxes();
            if (axes.vec2_length() <= this._myTeleportParams.myStickIdleThreshold) {
              confirmTeleport = true;
            }
          }
          return confirmTeleport;
        }
        _cancelTeleport() {
          let cancelTeleport = false;
          if (!PP.XRUtils.isSessionActive()) {
            cancelTeleport = PP.myMouse.isButtonPressEnd(PP.MouseButtonID.RIGHT) || !PP.myMouse.isInsideView();
          } else {
            cancelTeleport = PP.myGamepads[this._myTeleportParams.myHandedness].getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressed();
          }
          if (Global.myCancelTeleport > 0) {
            Global.myCancelTeleport = 0;
            cancelTeleport = true;
          }
          return cancelTeleport;
        }
        _detectTeleportPosition() {
          this._myDetectionRuntimeParams.myParable.setSpeed(PP.myEasyTuneVariables.get("Parable Speed"));
          this._myDetectionRuntimeParams.myParable.setGravity(PP.myEasyTuneVariables.get("Parable Gravity"));
          this._myDetectionRuntimeParams.myParable.setStepLength(PP.myEasyTuneVariables.get("Parable Steps"));
          this._myTeleportParams.myDetectionParams.myMaxDistance = Global.mySetup.myLocomotionSetup.myTeleportDistance;
          if (PP.XRUtils.isSessionActive()) {
            this._detectTeleportRotationVR();
            this._detectTeleportPositionVR();
          } else {
            this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
            this._myTeleportRotationOnUpNext = 0;
            this._detectTeleportPositionNonVR();
          }
        }
      };
      PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionNonVR = function() {
        let mousePosition = PP.vec3_create();
        let mouseDirection = PP.vec3_create();
        let playerUp = PP.vec3_create();
        return function _detectTeleportPositionNonVR(dt) {
          this._myDetectionRuntimeParams.myTeleportPositionValid = false;
          this._myDetectionRuntimeParams.myTeleportDetectionValid = true;
          playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
          PP.myMouse.getOriginWorld(mousePosition);
          PP.myMouse.getDirectionWorld(mouseDirection);
          this._detectTeleportPositionParable(mousePosition, mouseDirection, playerUp);
        };
      }();
      PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionVR = function() {
        let teleportStartTransformLocal = PP.quat2_create();
        let teleportStartTransformWorld = PP.quat2_create();
        let teleportStartPosition = PP.vec3_create();
        let teleportDirection = PP.vec3_create();
        let playerUp = PP.vec3_create();
        let playerUpNegate = PP.vec3_create();
        return function _detectTeleportPositionVR(dt) {
          this._myDetectionRuntimeParams.myTeleportPositionValid = false;
          this._myDetectionRuntimeParams.myTeleportDetectionValid = false;
          if (this._myTeleportParams.myDetectionParams.myTeleportParableStartReferenceObject == null) {
            let referenceObject = PP.myPlayerObjects.myHands[this._myTeleportParams.myHandedness];
            teleportStartTransformLocal.quat2_setPositionRotationDegrees(this._myTeleportParams.myDetectionParams.myTeleportParableStartPositionOffset, this._myTeleportParams.myDetectionParams.myTeleportParableStartRotationOffset);
            teleportStartTransformWorld = referenceObject.pp_convertTransformObjectToWorldQuat(teleportStartTransformLocal, teleportStartTransformWorld);
          } else {
            let referenceObject = this._myTeleportParams.myDetectionParams.myTeleportParableStartReferenceObject;
            referenceObject.pp_getTransformQuat(teleportStartTransformWorld);
          }
          teleportStartPosition = teleportStartTransformWorld.quat2_getPosition(teleportStartPosition);
          teleportDirection = teleportStartTransformWorld.quat2_getForward(teleportDirection);
          playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
          playerUpNegate = playerUp.vec3_negate(playerUpNegate);
          if (teleportDirection.vec3_angle(playerUp) >= this._myTeleportParams.myDetectionParams.myParableForwardMinAngleToBeValidUp && teleportDirection.vec3_angle(playerUpNegate) >= this._myTeleportParams.myDetectionParams.myParableForwardMinAngleToBeValidDown) {
            this._myDetectionRuntimeParams.myTeleportDetectionValid = true;
          }
          if (this._myDetectionRuntimeParams.myTeleportDetectionValid) {
            this._detectTeleportPositionParable(teleportStartPosition, teleportDirection, playerUp);
          }
        };
      }();
      PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionParable = function() {
        let parablePosition = PP.vec3_create();
        let prevParablePosition = PP.vec3_create();
        let parableFinalPosition = PP.vec3_create();
        let raycastSetup = new PP.RaycastSetup();
        let raycastResult = new PP.RaycastResults();
        let parableHitPosition = PP.vec3_create();
        let parableHitNormal = PP.vec3_create();
        let verticalHitOrigin = PP.vec3_create();
        let verticalHitDirection = PP.vec3_create();
        let flatTeleportHorizontalHitNormal = PP.vec3_create();
        let flatParableHitNormal = PP.vec3_create();
        let flatParableDirectionNegate = PP.vec3_create();
        let teleportCollisionRuntimeParams = new CollisionRuntimeParams();
        let objectsEqualCallback = (first, second) => first.pp_equals(second);
        return function _detectTeleportPositionParable(startPosition, direction, up) {
          this._myDetectionRuntimeParams.myParable.setStartPosition(startPosition);
          this._myDetectionRuntimeParams.myParable.setForward(direction);
          this._myDetectionRuntimeParams.myParable.setUp(up);
          let currentPositionIndex = 1;
          let positionFlatDistance = 0;
          let positionParableDistance = 0;
          prevParablePosition = this._myDetectionRuntimeParams.myParable.getPosition(currentPositionIndex - 1, prevParablePosition);
          raycastSetup.myIgnoreHitsInsideCollision = true;
          raycastSetup.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myTeleportBlockLayerFlags.getMask());
          raycastSetup.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
          for (let objectToIgnore of this._myTeleportParams.myCollisionCheckParams.myVerticalObjectsToIgnore) {
            raycastSetup.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
          }
          let maxParableDistance = this._myTeleportParams.myDetectionParams.myMaxDistance * 2;
          do {
            parablePosition = this._myDetectionRuntimeParams.myParable.getPosition(currentPositionIndex, parablePosition);
            raycastSetup.myOrigin.vec3_copy(prevParablePosition);
            raycastSetup.myDirection = parablePosition.vec3_sub(prevParablePosition, raycastSetup.myDirection);
            raycastSetup.myDistance = raycastSetup.myDirection.vec3_length();
            raycastSetup.myDirection.vec3_normalize(raycastSetup.myDirection);
            raycastResult = PP.PhysicsUtils.raycast(raycastSetup, raycastResult);
            if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
              PP.myDebugVisualManager.drawRaycast(0, raycastResult);
            }
            prevParablePosition.vec3_copy(parablePosition);
            positionFlatDistance = parablePosition.vec3_sub(startPosition, parablePosition).vec3_removeComponentAlongAxis(up, parablePosition).vec3_length();
            positionParableDistance = this._myDetectionRuntimeParams.myParable.getDistance(currentPositionIndex);
            currentPositionIndex++;
          } while (positionFlatDistance <= this._myTeleportParams.myDetectionParams.myMaxDistance && positionParableDistance <= maxParableDistance && !raycastResult.isColliding());
          let maxParableDistanceOverFlatDistance = this._myDetectionRuntimeParams.myParable.getDistanceOverFlatDistance(this._myTeleportParams.myDetectionParams.myMaxDistance, maxParableDistance);
          let fixedPositionParableDistance = positionParableDistance;
          if (positionParableDistance > maxParableDistanceOverFlatDistance || positionParableDistance > maxParableDistance) {
            fixedPositionParableDistance = Math.min(maxParableDistanceOverFlatDistance, maxParableDistance);
          }
          this._myDetectionRuntimeParams.myParableDistance = fixedPositionParableDistance;
          let hitCollisionValid = false;
          let bottomCheckMaxLength = 100;
          if (raycastResult.isColliding()) {
            let hit = raycastResult.myHits.pp_first();
            let hitParableDistance = positionParableDistance - (raycastSetup.myDistance - hit.myDistance);
            if (hitParableDistance <= fixedPositionParableDistance) {
              hitCollisionValid = true;
              this._myDetectionRuntimeParams.myParableDistance = hitParableDistance;
              teleportCollisionRuntimeParams.reset();
              this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
              this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
              this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
              parableHitPosition.vec3_copy(hit.myPosition);
              parableHitNormal.vec3_copy(hit.myNormal);
              if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
                verticalHitOrigin = hit.myPosition.vec3_add(hit.myNormal.vec3_scale(0.01, verticalHitOrigin), verticalHitOrigin);
                verticalHitDirection = up.vec3_negate(verticalHitDirection);
                raycastSetup.myOrigin.vec3_copy(verticalHitOrigin);
                raycastSetup.myDirection.vec3_copy(verticalHitDirection);
                raycastSetup.myDistance = bottomCheckMaxLength;
                raycastResult = PP.PhysicsUtils.raycast(raycastSetup, raycastResult);
                if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
                  PP.myDebugVisualManager.drawRaycast(0, raycastResult);
                }
                if (raycastResult.isColliding()) {
                  let hit2 = raycastResult.myHits.pp_first();
                  teleportCollisionRuntimeParams.reset();
                  this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                  this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                  this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                  if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed && teleportCollisionRuntimeParams.myTeleportCanceled && teleportCollisionRuntimeParams.myIsCollidingHorizontally) {
                    flatTeleportHorizontalHitNormal = teleportCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatTeleportHorizontalHitNormal);
                    if (!flatTeleportHorizontalHitNormal.vec3_isZero(1e-5)) {
                      flatTeleportHorizontalHitNormal.vec3_normalize(flatTeleportHorizontalHitNormal);
                      let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                      raycastSetup.myOrigin = verticalHitOrigin.vec3_add(flatTeleportHorizontalHitNormal.vec3_scale(backwardStep, raycastSetup.myOrigin), raycastSetup.myOrigin);
                      raycastSetup.myDirection.vec3_copy(verticalHitDirection);
                      raycastSetup.myDistance = bottomCheckMaxLength;
                      raycastResult = PP.PhysicsUtils.raycast(raycastSetup, raycastResult);
                      if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
                        PP.myDebugVisualManager.drawPoint(0, raycastSetup.myOrigin, PP.vec4_create(0, 0, 0, 1), 0.03);
                        PP.myDebugVisualManager.drawRaycast(0, raycastResult);
                      }
                      if (raycastResult.isColliding()) {
                        let hit3 = raycastResult.myHits.pp_first();
                        teleportCollisionRuntimeParams.reset();
                        this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                        this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                        this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                      }
                    }
                  } else {
                  }
                  if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
                    flatParableHitNormal = parableHitNormal.vec3_removeComponentAlongAxis(up, flatParableHitNormal);
                    if (!flatParableHitNormal.vec3_isZero(1e-5)) {
                      flatParableHitNormal.vec3_normalize(flatParableHitNormal);
                      let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                      raycastSetup.myOrigin = verticalHitOrigin.vec3_add(flatParableHitNormal.vec3_scale(backwardStep, raycastSetup.myOrigin), raycastSetup.myOrigin);
                      raycastSetup.myDirection.vec3_copy(verticalHitDirection);
                      raycastSetup.myDistance = bottomCheckMaxLength;
                      raycastResult = PP.PhysicsUtils.raycast(raycastSetup, raycastResult);
                      if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
                        PP.myDebugVisualManager.drawPoint(0, raycastSetup.myOrigin, PP.vec4_create(0, 0, 0, 1), 0.03);
                        PP.myDebugVisualManager.drawRaycast(0, raycastResult);
                      }
                      if (raycastResult.isColliding()) {
                        let hit3 = raycastResult.myHits.pp_first();
                        teleportCollisionRuntimeParams.reset();
                        this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                        this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                        this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                      }
                    }
                  } else {
                  }
                  if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
                    flatParableDirectionNegate = direction.vec3_negate(flatParableDirectionNegate).vec3_removeComponentAlongAxis(up, flatParableDirectionNegate).vec3_normalize(flatParableDirectionNegate);
                    if (!flatParableDirectionNegate.vec3_isZero(1e-5)) {
                      flatParableDirectionNegate.vec3_normalize(flatParableDirectionNegate);
                      let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                      raycastSetup.myOrigin = verticalHitOrigin.vec3_add(flatParableDirectionNegate.vec3_scale(backwardStep, raycastSetup.myOrigin), raycastSetup.myOrigin);
                      raycastSetup.myDirection.vec3_copy(verticalHitDirection);
                      raycastSetup.myDistance = bottomCheckMaxLength;
                      raycastResult = PP.PhysicsUtils.raycast(raycastSetup, raycastResult);
                      if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
                        PP.myDebugVisualManager.drawPoint(0, raycastSetup.myOrigin, PP.vec4_create(0, 0, 0, 1), 0.03);
                        PP.myDebugVisualManager.drawRaycast(0, raycastResult);
                      }
                      if (raycastResult.isColliding()) {
                        let hit3 = raycastResult.myHits.pp_first();
                        teleportCollisionRuntimeParams.reset();
                        this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                        this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                        this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                      }
                    }
                  } else {
                  }
                }
              } else {
              }
            }
          }
          if (!hitCollisionValid) {
            parableFinalPosition = this._myDetectionRuntimeParams.myParable.getPositionByDistance(this._myDetectionRuntimeParams.myParableDistance, parableFinalPosition);
            verticalHitOrigin.vec3_copy(parableFinalPosition);
            verticalHitDirection = up.vec3_negate(verticalHitDirection);
            raycastSetup.myOrigin.vec3_copy(verticalHitOrigin);
            raycastSetup.myDirection.vec3_copy(verticalHitDirection);
            raycastSetup.myDistance = bottomCheckMaxLength;
            raycastResult = PP.PhysicsUtils.raycast(raycastSetup, raycastResult);
            if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
              PP.myDebugVisualManager.drawRaycast(0, raycastResult);
            }
            if (raycastResult.isColliding()) {
              let hit = raycastResult.myHits.pp_first();
              teleportCollisionRuntimeParams.reset();
              this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
              this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
              this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
              if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed && teleportCollisionRuntimeParams.myTeleportCanceled && teleportCollisionRuntimeParams.myIsCollidingHorizontally) {
                flatTeleportHorizontalHitNormal = teleportCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatTeleportHorizontalHitNormal);
                if (!flatTeleportHorizontalHitNormal.vec3_isZero(1e-5)) {
                  flatTeleportHorizontalHitNormal.vec3_normalize(flatTeleportHorizontalHitNormal);
                  let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                  raycastSetup.myOrigin = verticalHitOrigin.vec3_add(flatTeleportHorizontalHitNormal.vec3_scale(backwardStep, raycastSetup.myOrigin), raycastSetup.myOrigin);
                  raycastSetup.myDirection.vec3_copy(verticalHitDirection);
                  raycastSetup.myDistance = bottomCheckMaxLength;
                  raycastResult = PP.PhysicsUtils.raycast(raycastSetup, raycastResult);
                  if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
                    PP.myDebugVisualManager.drawPoint(0, raycastSetup.myOrigin, PP.vec4_create(0, 0, 0, 1), 0.03);
                    PP.myDebugVisualManager.drawRaycast(0, raycastResult);
                  }
                  if (raycastResult.isColliding()) {
                    let hit2 = raycastResult.myHits.pp_first();
                    teleportCollisionRuntimeParams.reset();
                    this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                    this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                    this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                  }
                }
              }
              if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
                flatParableDirectionNegate = direction.vec3_negate(flatParableDirectionNegate).vec3_removeComponentAlongAxis(up, flatParableDirectionNegate).vec3_normalize(flatParableDirectionNegate);
                if (!flatParableDirectionNegate.vec3_isZero(1e-5)) {
                  flatParableDirectionNegate.vec3_normalize(flatParableDirectionNegate);
                  let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                  raycastSetup.myOrigin = verticalHitOrigin.vec3_add(flatParableDirectionNegate.vec3_scale(backwardStep, raycastSetup.myOrigin), raycastSetup.myOrigin);
                  raycastSetup.myDirection.vec3_copy(verticalHitDirection);
                  raycastSetup.myDistance = bottomCheckMaxLength;
                  raycastResult = PP.PhysicsUtils.raycast(raycastSetup, raycastResult);
                  if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugDetectActive) {
                    PP.myDebugVisualManager.drawPoint(0, raycastSetup.myOrigin, PP.vec4_create(0, 0, 0, 1), 0.03);
                    PP.myDebugVisualManager.drawRaycast(0, raycastResult);
                  }
                  if (raycastResult.isColliding()) {
                    let hit2 = raycastResult.myHits.pp_first();
                    teleportCollisionRuntimeParams.reset();
                    this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                    this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                    this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                  }
                }
              }
            }
          }
        };
      }();
      PlayerLocomotionTeleportDetectionState.prototype._detectTeleportRotationVR = function() {
        let axesVec3 = PP.vec3_create();
        let axesForward = PP.vec3_create(0, 0, 1);
        let axesUp = PP.vec3_create(0, 1, 0);
        return function _detectTeleportRotationVR(dt) {
          let axes = PP.myGamepads[this._myTeleportParams.myHandedness].getAxesInfo().getAxes();
          if (axes.vec2_length() > this._myTeleportParams.myDetectionParams.myRotationOnUpMinStickIntensity) {
            this._myTeleportRuntimeParams.myTeleportRotationOnUp = this._myTeleportRotationOnUpNext;
            axesVec3.vec3_set(axes[0], 0, axes[1]);
            this._myTeleportRotationOnUpNext = axesVec3.vec3_angleSigned(axesForward, axesUp);
          }
          if (!this._myTeleportParams.myDetectionParams.myRotationOnUpActive) {
            this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
            this._myTeleportRotationOnUpNext = 0;
          }
        };
      }();
      PlayerLocomotionTeleportDetectionState.prototype._isTeleportHitValid = function() {
        let raycastSetup = new PP.RaycastSetup();
        let raycastResult = new PP.RaycastResults();
        let playerUp = PP.vec3_create();
        return function _isTeleportHitValid(hit, rotationOnUp, checkTeleportCollisionRuntimeParams) {
          let isValid = false;
          this._myTeleportAsMovementFailed = false;
          if (hit.isValid() && !hit.myIsInsideCollision) {
            playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
            let hitValidEvenWhenNotConcordant = true;
            if (hitValidEvenWhenNotConcordant || hit.myNormal.vec3_isConcordant(playerUp)) {
              raycastSetup.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
              raycastSetup.myIgnoreHitsInsideCollision = true;
              raycastSetup.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myTeleportFloorLayerFlags.getMask());
              let distanceToCheck = 0.01;
              raycastSetup.myOrigin = hit.myPosition.vec3_add(hit.myNormal.vec3_scale(distanceToCheck, raycastSetup.myOrigin), raycastSetup.myOrigin);
              raycastSetup.myDirection = hit.myNormal.vec3_negate(raycastSetup.myDirection);
              raycastSetup.myDistance = distanceToCheck * 1.25;
              raycastSetup.myDirection.vec3_normalize(raycastSetup.myDirection);
              raycastResult = PP.PhysicsUtils.raycast(raycastSetup, raycastResult);
              if (raycastResult.isColliding()) {
                let floorHit = raycastResult.myHits.pp_first();
                if (floorHit.myObject.pp_equals(hit.myObject)) {
                  isValid = this._isTeleportPositionValid(hit.myPosition, rotationOnUp, checkTeleportCollisionRuntimeParams);
                }
              }
            }
          }
          return isValid;
        };
      }();
      PlayerLocomotionTeleportDetectionState.prototype._isTeleportPositionValid = function() {
        let playerUp = PP.vec3_create();
        let feetTransformQuat = PP.quat2_create();
        let feetRotationQuat = PP.quat_create();
        let feetPosition = PP.vec3_create();
        let differenceOnUpVector = PP.vec3_create();
        let teleportCheckCollisionRuntimeParams = new CollisionRuntimeParams();
        return function _isTeleportPositionValid(teleportPosition, rotationOnUp, checkTeleportCollisionRuntimeParams) {
          let isValid = false;
          let positionVisible = this._isTeleportPositionVisible(teleportPosition);
          if (positionVisible) {
            playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
            feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
            feetPosition = feetTransformQuat.quat2_getPosition(feetPosition);
            if (rotationOnUp != 0) {
              feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
              feetRotationQuat = feetRotationQuat.quat_rotateAxis(rotationOnUp, playerUp, feetRotationQuat);
              feetTransformQuat.quat2_setPositionRotationQuat(feetPosition, feetRotationQuat);
            }
            let differenceOnUp = teleportPosition.vec3_sub(feetPosition, differenceOnUpVector).vec3_componentAlongAxis(playerUp, differenceOnUpVector).vec3_length();
            if (differenceOnUp < this._myTeleportParams.myDetectionParams.myMaxHeightDifference + 1e-5) {
              let teleportCheckValid = false;
              teleportCheckCollisionRuntimeParams.copy(this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
              if (!this._myTeleportParams.myPerformTeleportAsMovement) {
                this._checkTeleport(teleportPosition, feetTransformQuat, teleportCheckCollisionRuntimeParams, checkTeleportCollisionRuntimeParams);
              } else {
                this._checkTeleportAsMovement(teleportPosition, feetTransformQuat, teleportCheckCollisionRuntimeParams, checkTeleportCollisionRuntimeParams);
              }
              if (!teleportCheckCollisionRuntimeParams.myTeleportCanceled) {
                teleportCheckValid = true;
              }
              if (teleportCheckValid && (!this._myTeleportParams.myDetectionParams.myMustBeOnGround || teleportCheckCollisionRuntimeParams.myIsOnGround)) {
                let groundAngleValid = true;
                let isTeleportingUpward = teleportCheckCollisionRuntimeParams.myNewPosition.vec3_isFartherAlongAxis(feetPosition, playerUp);
                if (isTeleportingUpward) {
                  groundAngleValid = teleportCheckCollisionRuntimeParams.myGroundAngle < this._myTeleportParams.myDetectionParams.myGroundAngleToIgnoreUpward + 1e-4;
                }
                if (groundAngleValid) {
                  isValid = true;
                }
              }
            }
          }
          return isValid;
        };
      }();
    }
  });

  // js/locomotion/teleport/player_locomotion_teleport_detection_state_visibility.js
  var require_player_locomotion_teleport_detection_state_visibility = __commonJS({
    "js/locomotion/teleport/player_locomotion_teleport_detection_state_visibility.js"() {
      PlayerLocomotionTeleportDetectionState.prototype._isTeleportPositionVisible = function() {
        let playerUp = PP.vec3_create();
        let offsetFeetTeleportPosition = PP.vec3_create();
        let headTeleportPosition = PP.vec3_create();
        return function _isTeleportPositionVisible(teleportPosition) {
          let isVisible = true;
          if (this._myTeleportParams.myDetectionParams.myTeleportFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible) {
            playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
            let isHeadVisible = false;
            let isFeetVisible = false;
            if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadPositionMustBeVisible) {
              let headheight = this._myTeleportParams.myPlayerHeadManager.getHeightHead();
              headTeleportPosition = teleportPosition.vec3_add(playerUp.vec3_scale(headheight, headTeleportPosition), headTeleportPosition);
              isHeadVisible = this._isPositionVisible(headTeleportPosition);
            } else {
              isHeadVisible = true;
            }
            if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible && isHeadVisible) {
              isFeetVisible = true;
            } else {
              if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportFeetPositionMustBeVisible && isHeadVisible) {
                offsetFeetTeleportPosition = teleportPosition.vec3_add(playerUp.vec3_scale(this._myTeleportParams.myDetectionParams.myVisibilityCheckFeetPositionVerticalOffset, offsetFeetTeleportPosition), offsetFeetTeleportPosition);
                isFeetVisible = this._isPositionVisible(offsetFeetTeleportPosition);
              } else {
                isFeetVisible = true;
              }
            }
            isVisible = isHeadVisible && isFeetVisible;
          }
          return isVisible;
        };
      }();
      PlayerLocomotionTeleportDetectionState.prototype._isPositionVisible = function() {
        let playerUp = PP.vec3_create();
        let standardUp = PP.vec3_create(0, 1, 0);
        let standardForward = PP.vec3_create(0, 0, 1);
        let referenceUp = PP.vec3_create();
        let headPosition = PP.vec3_create();
        let direction = PP.vec3_create();
        let fixedRight = PP.vec3_create();
        let fixedForward = PP.vec3_create();
        let fixedUp = PP.vec3_create();
        let raycastEndPosition = PP.vec3_create();
        let raycastSetup = new PP.RaycastSetup();
        let raycastResult = new PP.RaycastResults();
        let objectsEqualCallback = (first, second) => first.pp_equals(second);
        return function _isPositionVisible(position) {
          let isVisible = true;
          playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
          let currentHead = this._myTeleportParams.myPlayerHeadManager.getHead();
          headPosition = currentHead.pp_getPosition(headPosition);
          direction = position.vec3_sub(headPosition, direction).vec3_normalize(direction);
          referenceUp.vec3_copy(standardUp);
          if (direction.vec3_angle(standardUp) < 1e-4) {
            referenceUp.vec3_copy(standardForward);
          }
          fixedRight = direction.vec3_cross(referenceUp, fixedRight);
          fixedUp = fixedRight.vec3_cross(direction, fixedUp);
          fixedForward.vec3_copy(direction);
          fixedUp.vec3_normalize(fixedUp);
          fixedForward.vec3_normalize(fixedForward);
          let checkPositions = this._getVisibilityCheckPositions(headPosition, fixedUp, fixedForward);
          let distance4 = headPosition.vec3_distance(position);
          for (let checkPosition of checkPositions) {
            raycastSetup.myOrigin.vec3_copy(checkPosition);
            raycastSetup.myDirection.vec3_copy(fixedForward);
            raycastSetup.myDistance = distance4;
            raycastSetup.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myVisibilityBlockLayerFlags.getMask());
            raycastSetup.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
            for (let objectToIgnore of this._myTeleportParams.myCollisionCheckParams.myVerticalObjectsToIgnore) {
              raycastSetup.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
            }
            raycastSetup.myIgnoreHitsInsideCollision = true;
            raycastResult = PP.PhysicsUtils.raycast(raycastSetup, raycastResult);
            if (this._myTeleportParams.myDebugActive && this._myTeleportParams.myDebugVisibilityActive) {
              PP.myDebugVisualManager.drawRaycast(0, raycastResult);
            }
            if (raycastResult.isColliding()) {
              raycastEndPosition = checkPosition.vec3_add(fixedForward.vec3_scale(distance4, raycastEndPosition), raycastEndPosition);
              let hit = raycastResult.myHits.pp_first();
              if (this._myTeleportParams.myDetectionParams.myVisibilityCheckDistanceFromHitThreshold == 0 || hit.myPosition.vec3_distance(raycastEndPosition) > this._myTeleportParams.myDetectionParams.myVisibilityCheckDistanceFromHitThreshold + 1e-5) {
                isVisible = false;
                break;
              }
            }
          }
          return isVisible;
        };
      }();
      PlayerLocomotionTeleportDetectionState.prototype._getVisibilityCheckPositions = function() {
        let checkPositions = [];
        let cachedCheckPositions = [];
        let currentCachedCheckPositionIndex = 0;
        let _localGetCachedCheckPosition = function() {
          let item = null;
          while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
            cachedCheckPositions.push(PP.vec3_create());
          }
          item = cachedCheckPositions[currentCachedCheckPositionIndex];
          currentCachedCheckPositionIndex++;
          return item;
        };
        let currentDirection = PP.vec3_create();
        return function _getVisibilityCheckPositions(position, up, forward) {
          checkPositions.length = 0;
          currentCachedCheckPositionIndex = 0;
          {
            let tempCheckPosition = _localGetCachedCheckPosition();
            tempCheckPosition.vec3_copy(position);
            checkPositions.push(tempCheckPosition);
          }
          let radiusStep = this._myTeleportParams.myDetectionParams.myVisibilityCheckRadius / this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceStepAmount;
          let sliceAngle = 360 / this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceSliceAmount;
          let currentStepRotation = 0;
          for (let i = 0; i < this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceStepAmount; i++) {
            let currentRadius = radiusStep * (i + 1);
            currentDirection = up.vec3_rotateAxis(currentStepRotation, forward, currentDirection);
            for (let j = 0; j < this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceSliceAmount; j++) {
              let tempCheckPosition = _localGetCachedCheckPosition();
              let sliceDirection = currentDirection.vec3_rotateAxis(sliceAngle * j, forward, tempCheckPosition);
              checkPositions.push(position.vec3_add(sliceDirection.vec3_scale(currentRadius, sliceDirection), sliceDirection));
            }
            currentStepRotation += this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceRotationPerStep;
          }
          return checkPositions;
        };
      }();
    }
  });

  // js/locomotion/teleport/player_locomotion_teleport_teleport_state.js
  var require_player_locomotion_teleport_teleport_state = __commonJS({
    "js/locomotion/teleport/player_locomotion_teleport_teleport_state.js"() {
      PlayerLocomotionTeleportTeleportType = {
        INSTANT: 0,
        BLINK: 1,
        SHIFT: 2
      };
      PlayerLocomotionTeleportTeleportParams = class PlayerLocomotionTeleportTeleportParams {
        constructor() {
          this.myTeleportType = PlayerLocomotionTeleportTeleportType.SHIFT;
          this.myBlinkFadeOutSeconds = 0.1;
          this.myBlinkFadeInSeconds = 0.1;
          this.myBlinkWaitSeconds = 0.1;
          this.myBlinkSphereColor = PP.vec3_create();
          this.myBlinkSphereScale = 0.1;
          this.myShiftMovementSeconds = 0.15;
          this.myShiftMovementSecondsMultiplierOverDistanceFunction = null;
          this.myShiftMovementEasingFunction = PP.EasingFunction.easeInOut;
          this.myShiftRotateSeconds = 1;
          this.myShiftRotateSecondsMultiplierOverAngleFunction = null;
          this.myShiftRotateEasingFunction = PP.EasingFunction.easeOut;
          this.myShiftRotateStartAfterMovementPercentage = 0.7;
          this.myShiftRotateSecondsMultiplierOverAngleFunction = function(angle3) {
            return PP.EasingFunction.easeOut(angle3 / 180);
          };
        }
      };
      PlayerLocomotionTeleportTeleportState = class PlayerLocomotionTeleportTeleportState extends PlayerLocomotionTeleportState {
        constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
          super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
          this._myFSM = new PP.FSM();
          this._myFSM.addState("init");
          this._myFSM.addState("idle");
          this._myBlinkState = new PlayerLocomotionTeleportTeleportBlinkState(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
          this._myShiftState = new PlayerLocomotionTeleportTeleportShiftState(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
          this._myFSM.addState("instant_teleport", this._instantUpdate.bind(this));
          this._myFSM.addState("blink_teleport", this._myBlinkState);
          this._myFSM.addState("shift_teleport", this._myShiftState);
          this._myFSM.addTransition("init", "idle", "start");
          this._myFSM.addTransition("idle", "instant_teleport", "start_instant");
          this._myFSM.addTransition("idle", "blink_teleport", "start_blink");
          this._myFSM.addTransition("idle", "shift_teleport", "start_shift");
          this._myFSM.addTransition("instant_teleport", "idle", "done", this._teleportDone.bind(this));
          this._myFSM.addTransition("blink_teleport", "idle", "done", this._teleportDone.bind(this));
          this._myFSM.addTransition("shift_teleport", "idle", "done", this._teleportDone.bind(this));
          this._myFSM.addTransition("idle", "idle", "stop");
          this._myFSM.addTransition("instant_teleport", "idle", "stop", this._instantStop.bind(this));
          this._myFSM.addTransition("blink_teleport", "idle", "stop");
          this._myFSM.addTransition("shift_teleport", "idle", "stop");
          this._myFSM.init("init");
          this._myFSM.perform("start");
        }
        start(fsm) {
          this._myParentFSM = fsm;
          switch (this._myTeleportParams.myTeleportParams.myTeleportType) {
            case PlayerLocomotionTeleportTeleportType.INSTANT:
              this._myFSM.perform("start_instant");
              break;
            case PlayerLocomotionTeleportTeleportType.BLINK:
              this._myFSM.perform("start_blink");
              break;
            case PlayerLocomotionTeleportTeleportType.SHIFT:
              this._myFSM.perform("start_shift");
              break;
            default:
              this._myFSM.perform("start_instant");
          }
        }
        end() {
        }
        update(dt, fsm) {
          this._myFSM.update(dt);
        }
        completeTeleport() {
          this._myFSM.perform("stop");
          this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
        }
        _instantUpdate(dt, fsm) {
          this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
          this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
          fsm.perform("done");
        }
        _instantStop(fsm) {
          this._instantUpdate(0, fsm);
        }
        _teleportDone() {
          Global.myPlayer.resetReal(true, false, false);
          Global.myPlayer.resetHeadToReal();
          this._myParentFSM.performDelayed("done");
        }
      };
    }
  });

  // js/locomotion/teleport/player_locomotion_teleport_teleport_blink_state.js
  var require_player_locomotion_teleport_teleport_blink_state = __commonJS({
    "js/locomotion/teleport/player_locomotion_teleport_teleport_blink_state.js"() {
      PlayerLocomotionTeleportTeleportBlinkState = class PlayerLocomotionTeleportTeleportBlinkState extends PlayerLocomotionTeleportState {
        constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
          super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
          this._myBlinkSphere = WL.scene.addObject(null);
          this._myBlinkSphereMeshComponent = this._myBlinkSphere.pp_addComponent("mesh");
          this._myBlinkSphereMeshComponent.mesh = PP.myDefaultResources.myMeshes.myInvertedSphere;
          this._myBlinkSphereMeshComponent.material = PP.myDefaultResources.myMaterials.myFlatTransparentNoDepth.clone();
          this._myBlinkSphereMaterialColor = [
            this._myTeleportParams.myTeleportParams.myBlinkSphereColor[0] / 255,
            this._myTeleportParams.myTeleportParams.myBlinkSphereColor[1] / 255,
            this._myTeleportParams.myTeleportParams.myBlinkSphereColor[2] / 255,
            0
          ];
          this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
          this._myBlinkSphere.pp_resetTransformLocal();
          this._myBlinkSphere.pp_setScaleLocal(this._myTeleportParams.myTeleportParams.myBlinkSphereScale);
          this._myBlinkSphere.pp_setActive(false);
          this._myFSM = new PP.FSM();
          this._myFSM.addState("init");
          this._myFSM.addState("idle");
          this._myFSM.addState("fade_out", this._fadeOutUpdate.bind(this));
          this._myFSM.addState("wait", new PP.TimerState(this._myTeleportParams.myTeleportParams.myBlinkWaitSeconds, "done"));
          this._myFSM.addState("fade_in", this._fadeInUpdate.bind(this));
          this._myFSM.addTransition("init", "idle", "start");
          this._myFSM.addTransition("idle", "fade_out", "teleport", this._startFadeOut.bind(this));
          this._myFSM.addTransition("fade_out", "wait", "done", this._teleport.bind(this));
          this._myFSM.addTransition("wait", "fade_in", "done", this._startFadeIn.bind(this));
          this._myFSM.addTransition("fade_in", "idle", "done", this._teleportDone.bind(this));
          this._myFSM.addTransition("idle", "idle", "stop");
          this._myFSM.addTransition("fade_out", "idle", "stop", this._stop.bind(this, true));
          this._myFSM.addTransition("wait", "idle", "stop", this._stop.bind(this, false));
          this._myFSM.addTransition("fade_in", "idle", "stop", this._stop.bind(this, false));
          this._myFSM.init("init");
          this._myFSM.perform("start");
          this._myFadeInTimer = new PP.Timer(this._myTeleportParams.myTeleportParams.myBlinkFadeInSeconds);
          this._myFadeOutTimer = new PP.Timer(this._myTeleportParams.myTeleportParams.myBlinkFadeOutSeconds);
          this._myFadeOutAlphaOverTime = new PP.NumberOverValue(0, 1, 0, 1);
          this._myFadeInAlphaOverTime = new PP.NumberOverValue(1, 0, 0, 1);
        }
        start(fsm) {
          this._myParentFSM = fsm;
          this._myFSM.perform("teleport");
        }
        end() {
          this._myBlinkSphere.pp_setActive(false);
          this._myBlinkSphere.pp_setParent(null, false);
          this._myFSM.perform("stop");
        }
        update(dt, fsm) {
          this._myBlinkSphere.pp_setParent(this._myTeleportParams.myPlayerHeadManager.getHead(), false);
          this._myFSM.update(dt);
        }
        _startFadeOut() {
          this._myFadeOutTimer.start();
          this._myBlinkSphereMaterialColor[3] = 0;
          this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
          this._myBlinkSphere.pp_setActive(true);
        }
        _startFadeIn() {
          this._myFadeInTimer.start();
        }
        _fadeOutUpdate(dt, fsm) {
          this._myFadeOutTimer.update(dt);
          let alpha = this._myFadeOutAlphaOverTime.get(this._myFadeOutTimer.getPercentage());
          this._myBlinkSphereMaterialColor[3] = alpha;
          this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
          if (this._myFadeOutTimer.isDone()) {
            fsm.perform("done");
          }
        }
        _fadeInUpdate(dt, fsm) {
          this._myFadeInTimer.update(dt);
          let alpha = this._myFadeInAlphaOverTime.get(this._myFadeInTimer.getPercentage());
          this._myBlinkSphereMaterialColor[3] = alpha;
          this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
          if (this._myFadeInTimer.isDone()) {
            fsm.perform("done");
          }
        }
        _teleportDone() {
          this._myBlinkSphere.pp_setActive(false);
          this._myParentFSM.performDelayed("done");
        }
        _stop(teleport) {
          this._myBlinkSphere.pp_setActive(false);
          if (teleport) {
            this._teleport();
          }
        }
        _teleport() {
          this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
          this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
        }
      };
    }
  });

  // js/locomotion/teleport/player_locomotion_teleport_teleport_shift_state.js
  var player_locomotion_teleport_teleport_shift_state_exports = {};
  var import_howler8;
  var init_player_locomotion_teleport_teleport_shift_state = __esm({
    "js/locomotion/teleport/player_locomotion_teleport_teleport_shift_state.js"() {
      import_howler8 = __toESM(require_howler());
      PlayerLocomotionTeleportTeleportShiftState = class PlayerLocomotionTeleportTeleportShiftState2 extends PlayerLocomotionTeleportState {
        constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
          super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
          this._myFSM = new PP.FSM();
          this._myFSM.addState("init");
          this._myFSM.addState("idle");
          this._myFSM.addState("shifting", this._shiftingUpdate.bind(this));
          this._myFSM.addTransition("init", "idle", "start");
          this._myFSM.addTransition("idle", "shifting", "teleport", this._startShifting.bind(this));
          this._myFSM.addTransition("shifting", "idle", "done", this._teleportDone.bind(this));
          this._myFSM.addTransition("idle", "idle", "stop");
          this._myFSM.addTransition("shifting", "idle", "stop", this._stop.bind(this));
          this._myFSM.init("init");
          this._myFSM.perform("start");
          this._myShiftMovementTimer = new PP.Timer(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds);
          this._myShiftRotateTimer = new PP.Timer(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds, false);
          this._myFeetStartPosition = new PP.vec3_create();
          this._myCurrentRotationOnUp = 0;
          this._myStartRotationOnUp = 0;
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Shift Movement Seconds", this._myTeleportParams.myTeleportParams.myShiftMovementSeconds, 0.5, 3, 0));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Shift Rotate Seconds", this._myTeleportParams.myTeleportParams.myShiftRotateSeconds, 0.5, 3, 0));
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Shift Rotate Start Percentage", this._myTeleportParams.myTeleportParams.myShiftRotateStartAfterMovementPercentage, 0.5, 3, 0, 1));
          this._mySteps = [];
        }
        start(fsm) {
          this._myParentFSM = fsm;
          this._myFSM.perform("teleport");
        }
        end() {
          this._myFSM.perform("stop");
        }
        update(dt, fsm) {
          this._myTeleportParams.myTeleportParams.myShiftMovementSeconds = PP.myEasyTuneVariables.get("Shift Movement Seconds");
          this._myTeleportParams.myTeleportParams.myShiftRotateSeconds = PP.myEasyTuneVariables.get("Shift Rotate Seconds");
          this._myTeleportParams.myTeleportParams.myShiftRotateStartAfterMovementPercentage = PP.myEasyTuneVariables.get("Shift Rotate Start Percentage");
          this._myFSM.update(dt);
        }
        _startShifting() {
          if (this._mySteps.length == 0) {
            this._mySteps[0] = PP.myAudioManager.createAudioPlayer(AudioID.PASSO_1);
          }
          let player = Math.pp_randomPick(this._mySteps);
          player.setPosition(this._myTeleportRuntimeParams.myTeleportPosition);
          player.setPitch(Math.pp_random(1 - 0.35, 1 + 0.15));
          player.play();
          if (Global.myUnmute) {
            Global.myUnmute = false;
            import_howler8.Howler.mute(false);
          }
          this._myTeleportParams.myPlayerTransformManager.getParams().mySyncPositionDisabled = true;
          this._myLocomotionRuntimeParams.myIsTeleporting = true;
          this._myFeetStartPosition = this._myTeleportParams.myPlayerHeadManager.getPositionFeet(this._myFeetStartPosition);
          this._myShiftMovementTimer.start(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds);
          if (this._myTeleportParams.myTeleportParams.myShiftMovementSecondsMultiplierOverDistanceFunction) {
            let distance4 = this._myTeleportRuntimeParams.myTeleportPosition.vec3_distance(this._myFeetStartPosition);
            let multiplier = this._myTeleportParams.myTeleportParams.myShiftMovementSecondsMultiplierOverDistanceFunction(distance4);
            this._myShiftMovementTimer.start(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds * multiplier);
          }
          this._myShiftRotateTimer.reset(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds);
          if (this._myTeleportParams.myTeleportParams.myShiftRotateSecondsMultiplierOverAngleFunction) {
            let multiplier = this._myTeleportParams.myTeleportParams.myShiftRotateSecondsMultiplierOverAngleFunction(Math.abs(this._myTeleportRuntimeParams.myTeleportRotationOnUp));
            this._myShiftRotateTimer.reset(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds * multiplier);
          }
          this._myStartRotationOnUp = this._myTeleportRuntimeParams.myTeleportRotationOnUp;
          this._myCurrentRotationOnUp = 0;
        }
        _stop() {
          this._teleport();
        }
        _teleportDone() {
          this._teleport();
          this._myParentFSM.performDelayed("done");
        }
        _teleport() {
          this._myTeleportParams.myPlayerTransformManager.getParams().mySyncPositionDisabled = false;
          this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
          this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myStartRotationOnUp - this._myCurrentRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
        }
      };
      PlayerLocomotionTeleportTeleportShiftState.prototype._shiftingUpdate = function() {
        let movementToTeleportFeet = PP.vec3_create();
        let newFeetPosition = PP.vec3_create();
        return function _shiftingUpdate(dt, fsm) {
          this._myShiftMovementTimer.update(dt);
          this._myShiftRotateTimer.update(dt);
          if (this._myShiftRotateTimer.isDone() && this._myShiftMovementTimer.isDone()) {
            fsm.perform("done");
          } else {
            newFeetPosition.vec3_copy(this._myTeleportRuntimeParams.myTeleportPosition);
            if (this._myShiftMovementTimer.isStarted() || this._myShiftMovementTimer.isJustDone()) {
              let interpolationValue = this._myTeleportParams.myTeleportParams.myShiftMovementEasingFunction(this._myShiftMovementTimer.getPercentage());
              if (interpolationValue >= this._myTeleportParams.myTeleportParams.myShiftRotateStartAfterMovementPercentage && !this._myShiftRotateTimer.isStarted()) {
                this._myShiftRotateTimer.start();
                this._myShiftRotateTimer.update(dt);
              }
              movementToTeleportFeet = this._myTeleportRuntimeParams.myTeleportPosition.vec3_sub(this._myFeetStartPosition, movementToTeleportFeet);
              movementToTeleportFeet.vec3_scale(interpolationValue, movementToTeleportFeet);
              newFeetPosition = this._myFeetStartPosition.vec3_add(movementToTeleportFeet, newFeetPosition);
            }
            let rotationOnUp = 0;
            if (this._myShiftRotateTimer.isRunning() || this._myShiftRotateTimer.isJustDone()) {
              let interpolationValue = this._myTeleportParams.myTeleportParams.myShiftRotateEasingFunction(this._myShiftRotateTimer.getPercentage());
              let newCurrentRotationOnUp = this._myStartRotationOnUp * interpolationValue;
              rotationOnUp = newCurrentRotationOnUp - this._myCurrentRotationOnUp;
              this._myCurrentRotationOnUp = newCurrentRotationOnUp;
            }
            this._teleportToPosition(newFeetPosition, rotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams, true);
          }
        };
      }();
      Object.defineProperty(PlayerLocomotionTeleportTeleportShiftState.prototype, "_shiftingUpdate", { enumerable: false });
    }
  });

  // js/locomotion/teleport/player_locomotion_teleport.js
  var require_player_locomotion_teleport2 = __commonJS({
    "js/locomotion/teleport/player_locomotion_teleport.js"() {
      PlayerLocomotionTeleportParams = class PlayerLocomotionTeleportParams {
        constructor() {
          this.myPlayerHeadManager = null;
          this.myCollisionCheckParams = null;
          this.myDetectionParams = new PlayerLocomotionTeleportDetectionParams();
          this.myVisualizerParams = new PlayerLocomotionTeleportDetectionVisualizerParams();
          this.myTeleportParams = new PlayerLocomotionTeleportTeleportParams();
          this.myHandedness = PP.Handedness.LEFT;
          this.myPerformTeleportAsMovement = false;
          this.myTeleportAsMovementMaxDistanceFromTeleportPosition = 1e-3;
          this.myTeleportAsMovementMaxSteps = 2;
          this.myTeleportAsMovementRemoveVerticalMovement = true;
          this.myTeleportAsMovementExtraVerticalMovementPerMeter = 1;
          this.myStickIdleThreshold = 0.1;
          this.myAdjustPositionEveryFrame = false;
          this.myGravityAcceleration = 0;
          this.myDebugActive = false;
          this.myDebugDetectActive = false;
          this.myDebugShowActive = false;
          this.myDebugVisibilityActive = false;
        }
      };
      PlayerLocomotionTeleportRuntimeParams = class PlayerLocomotionTeleportRuntimeParams {
        constructor() {
          this.myTeleportPosition = PP.vec3_create();
          this.myTeleportRotationOnUp = 0;
        }
      };
      PlayerLocomotionTeleport = class PlayerLocomotionTeleport extends PlayerLocomotionMovement {
        constructor(teleportParams, locomotionRuntimeParams) {
          super(locomotionRuntimeParams);
          this._myTeleportParams = teleportParams;
          this._myTeleportRuntimeParams = new PlayerLocomotionTeleportRuntimeParams();
          this._myStickIdleCharge = true;
          this._myGravitySpeed = 0;
          this._myDetectionState = new PlayerLocomotionTeleportDetectionState(this._myTeleportParams, this._myTeleportRuntimeParams, this._myLocomotionRuntimeParams);
          this._myTeleportState = new PlayerLocomotionTeleportTeleportState(this._myTeleportParams, this._myTeleportRuntimeParams, this._myLocomotionRuntimeParams);
          this._myFSM = new PP.FSM();
          this._myFSM.addState("init");
          this._myFSM.addState("idle", this._idleUpdate.bind(this));
          this._myFSM.addState("detect", this._myDetectionState);
          this._myFSM.addState("teleport", this._myTeleportState);
          this._myFSM.addTransition("init", "idle", "start");
          this._myFSM.addTransition("idle", "detect", "detect");
          this._myFSM.addTransition("detect", "teleport", "teleport");
          this._myFSM.addTransition("detect", "idle", "cancel");
          this._myFSM.addTransition("teleport", "idle", "done");
          this._myFSM.addTransition("idle", "idle", "stop");
          this._myFSM.addTransition("detect", "idle", "stop");
          this._myFSM.addTransition("teleport", "idle", "stop", this._completeTeleport.bind(this));
          this._myFSM.init("init");
          this._myFSM.perform("start");
        }
        start() {
          this._myGravitySpeed = 0;
        }
        stop() {
          this._myFSM.perform("stop");
        }
        canStop() {
          return this._myFSM.isInState("idle");
        }
        update(dt) {
          this._myLocomotionRuntimeParams.myTeleportJustPerformed = false;
          this._myFSM.update(dt);
          if (this._myTeleportParams.myAdjustPositionEveryFrame || this._myTeleportParams.myGravityAcceleration != 0) {
            this._applyGravity(dt);
          }
          if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
            this._myLocomotionRuntimeParams.myIsFlying = false;
          }
        }
        _idleUpdate(dt) {
          if (this._startDetecting()) {
            this._myFSM.perform("detect");
          }
        }
        _startDetecting() {
          let startDetecting = false;
          if (!PP.XRUtils.isSessionActive()) {
            startDetecting = PP.myMouse.isButtonPressStart(PP.MouseButtonID.MIDDLE) && PP.myMouse.isTargetingRenderCanvas();
          } else {
            let axes = PP.myGamepads[this._myTeleportParams.myHandedness].getAxesInfo().getAxes();
            if (axes.vec2_length() <= this._myTeleportParams.myStickIdleThreshold) {
              this._myStickIdleCharge = true;
            }
            if (this._myStickIdleCharge && axes[1] >= 0.75) {
              this._myStickIdleCharge = false;
              startDetecting = true;
            }
          }
          return startDetecting;
        }
        _completeTeleport() {
          this._myTeleportState.completeTeleport();
        }
      };
      PlayerLocomotionTeleport.prototype._applyGravity = function() {
        let playerUp = PP.vec3_create();
        let gravityMovement = PP.vec3_create();
        let feetTransformQuat = PP.quat2_create();
        return function _applyGravity(dt) {
          playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
          this._myGravitySpeed += this._myTeleportParams.myGravityAcceleration * dt;
          gravityMovement = playerUp.vec3_scale(this._myGravitySpeed * dt, gravityMovement);
          if (this._myLocomotionRuntimeParams.myIsFlying) {
            gravityMovement.vec3_zero();
          }
          feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
          CollisionCheckGlobal.move(gravityMovement, feetTransformQuat, this._myTeleportParams.myCollisionCheckParams, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
          if (!this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myVerticalMovementCanceled) {
            this._myTeleportParams.myPlayerHeadManager.teleportPositionFeet(this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myNewPosition);
          }
          if (this._myGravitySpeed > 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnCeiling || this._myGravitySpeed < 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
            this._myGravitySpeed = 0;
          }
        };
      }();
    }
  });

  // js/locomotion/cleaned/player_locomotion_cleaned.js
  var require_player_locomotion_cleaned = __commonJS({
    "js/locomotion/cleaned/player_locomotion_cleaned.js"() {
      CleanedPlayerLocomotion = class CleanedPlayerLocomotion {
        constructor(params) {
          this._myParams = params;
          this._myCollisionCheckParamsMovement = new CollisionCheckParams();
          this._setupCollisionCheckParamsMovement();
          this._myCollisionCheckParamsTeleport = null;
          this._setupCollisionCheckParamsTeleport();
          this._myCollisionRuntimeParams = new CollisionRuntimeParams();
          this._myMovementRuntimeParams = new PlayerLocomotionMovementRuntimeParams();
          this._myMovementRuntimeParams.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
          {
            let params2 = new PlayerHeadManagerParams();
            params2.mySessionChangeResyncEnabled = true;
            params2.myBlurEndResyncEnabled = true;
            params2.myBlurEndResyncRotation = true;
            params2.myEnterSessionResyncHeight = false;
            params2.myExitSessionResyncHeight = false;
            params2.myExitSessionResyncVerticalAngle = false;
            params2.myExitSessionRemoveRightTilt = true;
            params2.myExitSessionAdjustMaxVerticalAngle = true;
            params2.myExitSessionMaxVerticalAngle = 90;
            params2.myHeightOffsetVRWithFloor = 0;
            params2.myHeightOffsetVRWithoutFloor = 1.7;
            params2.myHeightOffsetNonVR = 1.7;
            params2.myForeheadExtraHeight = this._myParams.myForeheadExtraHeight;
            params2.myFeetRotationKeepUp = true;
            params2.myDebugActive = false;
            this._myPlayerHeadManager = new PlayerHeadManager(params2);
          }
          {
            let params2 = new PlayerTransformManagerParams();
            params2.myPlayerHeadManager = this._myPlayerHeadManager;
            params2.myMovementCollisionCheckParams = this._myCollisionCheckParamsMovement;
            params2.myTeleportCollisionCheckParams = null;
            params2.myTeleportCollisionCheckParamsCopyFromMovement = true;
            params2.myTeleportCollisionCheckParamsCheck360 = true;
            params2.myHeadCollisionBlockLayerFlags.copy(params2.myMovementCollisionCheckParams.myHorizontalBlockLayerFlags);
            params2.myHeadCollisionBlockLayerFlags.add(params2.myMovementCollisionCheckParams.myVerticalBlockLayerFlags);
            params2.myHeadCollisionObjectsToIgnore.pp_copy(params2.myMovementCollisionCheckParams.myHorizontalObjectsToIgnore);
            let objectsEqualCallback = (first, second) => first.pp_equals(second);
            for (let objectToIgnore of params2.myMovementCollisionCheckParams.myVerticalObjectsToIgnore) {
              params2.myHeadCollisionObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
            }
            params2.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
            params2.myHeadRadius = 0.075;
            params2.myIsMaxDistanceFromRealToSyncEnabled = true;
            params2.myMaxDistanceFromRealToSync = 100;
            params2.myIsFloatingValidIfVerticalMovement = false;
            params2.myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
            params2.myIsFloatingValidIfSteepGround = false;
            params2.myIsFloatingValidIfVerticalMovementAndSteepGround = false;
            params2.myIsFloatingValidIfRealOnGround = false;
            params2.myIsLeaningValidAboveDistance = true;
            params2.myLeaningValidDistance = 2;
            params2.myFloatingSplitCheckEnabled = true;
            params2.myFloatingSplitCheckMaxLength = 0.2;
            params2.myFloatingSplitCheckMaxSteps = 5;
            params2.myRealMovementAllowVerticalAdjustments = false;
            params2.myUpdateRealPositionValid = true;
            params2.myUpdatePositionValid = true;
            params2.myIsBodyCollidingWhenHeightBelowValue = null;
            params2.myIsBodyCollidingWhenHeightAboveValue = null;
            params2.myResetToValidOnEnterSession = true;
            params2.myResetToValidOnExitSession = true;
            params2.myAlwaysResetRealPositionNonVR = true;
            params2.myAlwaysResetRealRotationNonVR = true;
            params2.myAlwaysResetRealHeightNonVR = true;
            params2.myAlwaysResetRealPositionVR = false;
            params2.myAlwaysResetRealRotationVR = false;
            params2.myAlwaysResetRealHeightVR = false;
            params2.myNeverResetRealPositionNonVR = false;
            params2.myNeverResetRealRotationNonVR = true;
            params2.myNeverResetRealHeightNonVR = false;
            params2.myNeverResetRealPositionVR = false;
            params2.myNeverResetRealRotationVR = false;
            params2.myNeverResetRealHeightVR = true;
            params2.myResetRealOnMove = false;
            params2.myDebugActive = false;
            this._myPlayerTransformManager = new CleanedPlayerTransformManager(params2);
            transformManager = this._myPlayerTransformManager;
          }
          {
            let params2 = new PlayerObscureManagerParams();
            params2.myPlayerTransformManager = this._myPlayerTransformManager;
            params2.myObscureObject = null;
            params2.myObscureMaterial = null;
            params2.myObscureRadius = 0.1;
            params2.myObscureFadeOutSeconds = 0.15;
            params2.myObscureFadeInSeconds = 0.15;
            params2.myObscureFadeEasingFunction = PP.EasingFunction.linear;
            params2.myObscureLevelRelativeDistanceEasingFunction = PP.EasingFunction.linear;
            params2.myDistanceToStartObscureWhenBodyColliding = 0.5;
            params2.myDistanceToStartObscureWhenHeadColliding = 0;
            params2.myDistanceToStartObscureWhenFloating = 2220.35;
            params2.myDistanceToStartObscureWhenFar = 0.5;
            params2.myRelativeDistanceToMaxObscureWhenBodyColliding = 0.5;
            params2.myRelativeDistanceToMaxObscureWhenHeadColliding = 0;
            params2.myRelativeDistanceToMaxObscureWhenFloating = 0.5;
            params2.myRelativeDistanceToMaxObscureWhenFar = 0.5;
            this._myPlayerObscureManager = new PlayerObscureManager(params2);
          }
          {
            let params2 = new PlayerLocomotionRotateParams();
            params2.myPlayerHeadManager = this._myPlayerHeadManager;
            params2.myPlayerTransformManager = this._myPlayerTransformManager;
            params2.myMaxRotationSpeed = this._myParams.myMaxRotationSpeed;
            params2.myIsSnapTurn = this._myParams.myIsSnapTurn;
            params2.mySnapTurnOnlyVR = this._myParams.mySnapTurnOnlyVR;
            params2.mySnapTurnAngle = this._myParams.mySnapTurnAngle;
            if (this._myParams.mySnapTurnSpeedDegrees > LocomotionUtils.EPSILON_NUMBER) {
              params2.mySmoothSnapActive = true;
              params2.mySmoothSnapSpeedDegrees = this._myParams.mySnapTurnSpeedDegrees;
            } else {
              params2.mySmoothSnapActive = false;
            }
            params2.myRotationMinStickIntensityThreshold = 0.1;
            params2.mySnapTurnActivateThreshold = 0.5;
            params2.mySnapTurnResetThreshold = 0.4;
            params2.myClampVerticalAngle = true;
            params2.myMaxVerticalAngle = 90;
            this._myPlayerLocomotionRotate = new PlayerLocomotionRotate(params2);
            params2.myHandedness = PP.InputUtils.getOppositeHandedness(this._myParams.myMainHand);
          }
          {
            {
              let params2 = new PlayerLocomotionSmoothParams();
              params2.myPlayerHeadManager = this._myPlayerHeadManager;
              params2.myPlayerTransformManager = this._myPlayerTransformManager;
              params2.myCollisionCheckParams = this._myCollisionCheckParamsMovement;
              params2.myHandedness = this._myParams.myMainHand;
              params2.myMaxSpeed = this._myParams.myMaxSpeed;
              params2.myMovementMinStickIntensityThreshold = 0.1;
              params2.myFlyEnabled = this._myParams.myFlyEnabled;
              params2.myMinAngleToFlyUpNonVR = this._myParams.myMinAngleToFlyUpNonVR;
              params2.myMinAngleToFlyDownNonVR = this._myParams.myMinAngleToFlyDownNonVR;
              params2.myMinAngleToFlyUpVR = this._myParams.myMinAngleToFlyUpVR;
              params2.myMinAngleToFlyDownVR = this._myParams.myMinAngleToFlyDownVR;
              params2.myMinAngleToFlyRight = this._myParams.myMinAngleToFlyRight;
              params2.myGravityAcceleration = -20;
              params2.myVRDirectionReferenceType = this._myParams.myVRDirectionReferenceType;
              params2.myVRDirectionReferenceObject = this._myParams.myVRDirectionReferenceObject;
              this._myPlayerLocomotionSmooth = new CleanedPlayerLocomotionSmooth(params2, this._myMovementRuntimeParams);
            }
            {
              let params2 = new PlayerLocomotionTeleportParams();
              params2.myPlayerHeadManager = this._myPlayerHeadManager;
              params2.myPlayerTransformManager = this._myPlayerTransformManager;
              params2.myCollisionCheckParams = this._myCollisionCheckParamsTeleport;
              params2.myHandedness = this._myParams.myMainHand;
              params2.myDetectionParams.myMaxDistance = 3;
              params2.myDetectionParams.myMaxHeightDifference = 0.5;
              params2.myDetectionParams.myGroundAngleToIgnoreUpward = this._myCollisionCheckParamsMovement.myGroundAngleToIgnore;
              params2.myDetectionParams.myMustBeOnGround = true;
              params2.myDetectionParams.myTeleportBlockLayerFlags.setFlagActive(0, true);
              params2.myDetectionParams.myTeleportBlockLayerFlags.setFlagActive(4, true);
              params2.myDetectionParams.myTeleportBlockLayerFlags.setFlagActive(5, true);
              params2.myDetectionParams.myTeleportFloorLayerFlags.copy(params2.myDetectionParams.myTeleportBlockLayerFlags);
              params2.myDetectionParams.myTeleportFeetPositionMustBeVisible = false;
              params2.myDetectionParams.myTeleportHeadPositionMustBeVisible = false;
              params2.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible = true;
              params2.myDetectionParams.myTeleportParableStartReferenceObject = this._myParams.myTeleportParableStartReferenceObject;
              params2.myDetectionParams.myVisibilityBlockLayerFlags.copy(params2.myDetectionParams.myTeleportBlockLayerFlags);
              params2.myVisualizerParams.myTeleportPositionObject = this._myParams.myTeleportPositionObject;
              params2.myPerformTeleportAsMovement = false;
              params2.myTeleportAsMovementRemoveVerticalMovement = true;
              params2.myTeleportAsMovementExtraVerticalMovementPerMeter = -2;
              params2.myGravityAcceleration = 0;
              params2.myDebugActive = false;
              params2.myDebugDetectActive = true;
              params2.myDebugShowActive = true;
              params2.myDebugVisibilityActive = false;
              this._myPlayerLocomotionTeleport = new PlayerLocomotionTeleport(params2, this._myMovementRuntimeParams);
            }
          }
          this._setupLocomotionMovementFSM();
          this._myIdle = false;
        }
        start() {
          this._fixAlmostUp();
          this._myPlayerHeadManager.start();
          this._myPlayerTransformManager.start();
          this._myPlayerObscureManager.start();
          this._myPlayerLocomotionRotate.start();
          this._myLocomotionMovementFSM.perform("start");
        }
        canStop() {
          let canStop = false;
          if (this._myLocomotionMovementFSM.isInState("smooth") && this._myPlayerLocomotionSmooth.canStop()) {
            canStop = true;
          } else if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
            canStop = true;
          }
          return canStop;
        }
        update(dt) {
          this._myPlayerHeadManager.update(dt);
          this._myPlayerTransformManager.update(dt);
          if (PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressEnd(2)) {
            if (this._myLocomotionMovementFSM.isInState("smooth") && this._myPlayerLocomotionSmooth.canStop()) {
              Global.sendAnalytics("event", "switch_teleport", {
                "value": 1
              });
              this._myLocomotionMovementFSM.perform("next");
            } else if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
              this._myLocomotionMovementFSM.perform("next");
              Global.sendAnalytics("event", "switch_smooth", {
                "value": 1
              });
            }
          }
          if (this._myPlayerHeadManager.isSynced()) {
            this._updateCollisionHeight();
            if (!this._myIdle) {
              this._myPlayerLocomotionRotate.update(dt);
              this._myLocomotionMovementFSM.update(dt);
            }
          }
          this._myPlayerObscureManager.update(dt);
          if (!this._myParams.myFlyEnabled) {
            let maxHeight = 0;
            let position = Global.myPlayer.getPosition();
            if (position[1] > maxHeight) {
              let fixedPosition = position.vec3_clone();
              fixedPosition[1] = maxHeight;
              Global.myPlayer.teleportPosition(fixedPosition, null, true);
            }
          }
          this._myCollisionCheckParamsTeleport.myHorizontalObjectsToIgnore.pp_copy(this._myPlayerTransformManager._myParams.myMovementCollisionCheckParams.myHorizontalObjectsToIgnore);
          this._myCollisionCheckParamsTeleport.myVerticalObjectsToIgnore.pp_copy(this._myPlayerTransformManager._myParams.myMovementCollisionCheckParams.myVerticalObjectsToIgnore);
        }
        setIdle(idle) {
          this._myIdle = idle;
          if (idle) {
            this._myLocomotionMovementFSM.perform("idle");
          } else {
            this._myLocomotionMovementFSM.perform("start");
          }
        }
        _updateCollisionHeight() {
          this._myCollisionCheckParamsMovement.myHeight = this._myPlayerHeadManager.getHeightHead();
          if (this._myCollisionCheckParamsMovement.myHeight <= 1e-6) {
            this._myCollisionCheckParamsMovement.myHeight = 0;
          }
          this._myCollisionCheckParamsTeleport.myHeight = this._myCollisionCheckParamsMovement.myHeight;
        }
        _setupCollisionCheckParamsMovement() {
          let simplifiedParams = new PP.CharacterColliderSetupSimplifiedCreationParams();
          simplifiedParams.myHeight = 1.7;
          simplifiedParams.myRadius = this._myParams.myCharacterRadius;
          simplifiedParams.myAccuracyLevel = PP.CharacterColliderSetupSimplifiedCreationAccuracyLevel.MEDIUM;
          simplifiedParams.myIsPlayer = true;
          simplifiedParams.myCheckOnlyFeet = true;
          simplifiedParams.myAverageSpeed = this._myParams.myMaxSpeed;
          simplifiedParams.myCanFly = false;
          simplifiedParams.myShouldSlideAgainstWall = true;
          simplifiedParams.myCollectGroundInfo = true;
          simplifiedParams.myShouldSnapOnGround = true;
          simplifiedParams.myMaxDistanceToSnapOnGround = 0.3;
          simplifiedParams.myMaxWalkableGroundAngle = 70;
          simplifiedParams.myMaxWalkableGroundStepHeight = 0.3;
          simplifiedParams.myShouldNotFallFromEdges = false;
          simplifiedParams.myHorizontalCheckBlockLayerFlags.setFlagActive(0, true);
          simplifiedParams.myHorizontalCheckBlockLayerFlags.setFlagActive(4, true);
          simplifiedParams.myHorizontalCheckBlockLayerFlags.setFlagActive(5, true);
          let physXComponents = PP.myPlayerObjects.myPlayer.pp_getComponentsHierarchy("physx");
          for (let physXComponent of physXComponents) {
            simplifiedParams.myHorizontalCheckObjectsToIgnore.pp_pushUnique(physXComponent.object, (first, second) => first.pp_equals(second));
          }
          simplifiedParams.myVerticalCheckBlockLayerFlags.copy(simplifiedParams.myHorizontalCheckBlockLayerFlags);
          simplifiedParams.myVerticalCheckObjectsToIgnore.pp_copy(simplifiedParams.myHorizontalCheckObjectsToIgnore);
          simplifiedParams.myHorizontalCheckDebugActive = false;
          simplifiedParams.myVerticalCheckDebugActive = false;
          let colliderSetup = PP.CharacterColliderUtils.createCharacterColliderSetupSimplified(simplifiedParams);
          colliderSetup.myVerticalCheckSetup.myVerticalPositionCheckEnabled = false;
          colliderSetup.myVerticalCheckSetup.myVerticalCheckCircumferenceSlices = 3;
          this._myCollisionCheckParamsMovement = PP.CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(colliderSetup, this._myCollisionCheckParamsMovement);
        }
        _setupCollisionCheckParamsTeleport() {
          this._myCollisionCheckParamsTeleport = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myCollisionCheckParamsMovement);
          this._myCollisionCheckParamsTeleport.myGroundAngleToIgnore = 61;
          this._myCollisionCheckParamsTeleport.myTeleportMustBeOnIgnorableGroundAngle = true;
          this._myCollisionCheckParamsTeleport.myTeleportMustBeOnGround = true;
        }
        _fixAlmostUp() {
          let defaultUp = PP.vec3_create(0, 1, 0);
          let angleWithDefaultUp = PP.myPlayerObjects.myPlayer.pp_getUp().vec3_angle(defaultUp);
          if (angleWithDefaultUp < 1) {
            let forward = PP.myPlayerObjects.myPlayer.pp_getForward();
            let flatForward = forward.vec3_clone();
            flatForward[1] = 0;
            let defaultForward = PP.vec3_create(0, 0, 1);
            let angleWithDefaultForward = defaultForward.vec3_angleSigned(flatForward, defaultUp);
            PP.myPlayerObjects.myPlayer.pp_resetRotation();
            PP.myPlayerObjects.myPlayer.pp_rotateAxis(angleWithDefaultForward, defaultUp);
          }
        }
        _setupLocomotionMovementFSM() {
          this._myLocomotionMovementFSM = new PP.FSM();
          this._myLocomotionMovementFSM.addState("init");
          this._myLocomotionMovementFSM.addState("smooth", (dt) => this._myPlayerLocomotionSmooth.update(dt));
          this._myLocomotionMovementFSM.addState("teleport", (dt) => this._myPlayerLocomotionTeleport.update(dt));
          this._myLocomotionMovementFSM.addState("idleSmooth");
          this._myLocomotionMovementFSM.addState("idleTeleport");
          this._myLocomotionMovementFSM.addTransition("init", "smooth", "start", function() {
            this._myPlayerLocomotionSmooth.start();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("smooth", "teleport", "next", function() {
            this._myPlayerLocomotionSmooth.stop();
            this._myPlayerLocomotionTeleport.start();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("teleport", "smooth", "next", function() {
            this._myPlayerLocomotionTeleport.stop();
            this._myPlayerLocomotionSmooth.start();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("smooth", "idleSmooth", "idle", function() {
            this._myPlayerLocomotionSmooth.stop();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("teleport", "idleTeleport", "idle", function() {
            this._myPlayerLocomotionTeleport.stop();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("idleSmooth", "smooth", "start", function() {
            this._myPlayerLocomotionSmooth.start();
          }.bind(this));
          this._myLocomotionMovementFSM.addTransition("idleTeleport", "teleport", "start", function() {
            this._myPlayerLocomotionTeleport.start();
          }.bind(this));
          this._myLocomotionMovementFSM.init("init");
        }
      };
    }
  });

  // js/locomotion/cleaned/player_locomotion_smooth_cleaned.js
  var player_locomotion_smooth_cleaned_exports = {};
  var import_howler9;
  var init_player_locomotion_smooth_cleaned = __esm({
    "js/locomotion/cleaned/player_locomotion_smooth_cleaned.js"() {
      import_howler9 = __toESM(require_howler());
      CleanedPlayerLocomotionSmooth = class CleanedPlayerLocomotionSmooth2 extends PlayerLocomotionMovement {
        constructor(params, locomotionRuntimeParams) {
          super(locomotionRuntimeParams);
          this._myParams = params;
          this._myDirectionReference = PP.myPlayerObjects.myHead;
          this._myStickIdleTimer = new PP.Timer(0.25, false);
          let directionConverterNonVRParams = new PP.Direction2DTo3DConverterParams();
          directionConverterNonVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled;
          directionConverterNonVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled;
          directionConverterNonVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpNonVR;
          directionConverterNonVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownNonVR;
          directionConverterNonVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
          directionConverterNonVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
          directionConverterNonVRParams.myInvertForwardWhenUpsideDown = true;
          let directionConverterVRParams = new PP.Direction2DTo3DConverterParams();
          directionConverterVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled;
          directionConverterVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled;
          directionConverterVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpVR;
          directionConverterVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownVR;
          directionConverterVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
          directionConverterVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
          directionConverterVRParams.myInvertForwardWhenUpsideDown = true;
          this._myDirectionConverterNonVR = new PP.Direction2DTo3DConverter(directionConverterNonVRParams);
          this._myDirectionConverterVR = new PP.Direction2DTo3DConverter(directionConverterVRParams);
          this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
          if (Global.myFromAbove) {
            this._myLocomotionRuntimeParams.myIsFlying = true;
          }
          this._myGravitySpeed = 0;
          if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
          this._myStepDelay = 0.8;
          this._myStepTimer = new PP.Timer(this._myStepDelay);
          let delay = this._myStepDelay / 5;
          this._myStepTimer.start(Math.max(0, Math.pp_random(delay - 0.1, delay + 0.05)));
          this._StepRemove = false;
          this._mySteps = [];
          this.stepCounter = 0;
          this._myNonVRPlayingTimer = new PP.Timer(30);
          this._myTimeMoving = 0;
          this._myTimeMovingStep = [1, 2, 3, 5, 10, 20, 30, 60];
          this._myTimeMovingStepIndex = 0;
        }
        update(dt) {
        }
      };
      CleanedPlayerLocomotionSmooth.prototype.update = function() {
        let playerUp = PP.vec3_create();
        let headMovement = PP.vec3_create();
        let direction = PP.vec3_create();
        let directionOnUp = PP.vec3_create();
        let verticalMovement = PP.vec3_create();
        let feetTransformQuat = PP.quat2_create();
        let directionReferenceTransformQuat = PP.quat2_create();
        return function update(dt) {
          this._myParams.myMaxSpeed = Global.mySetup.myLocomotionSetup.mySpeed;
          playerUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
          headMovement.vec3_zero();
          let axes = PP.myGamepads[this._myParams.myHandedness].getAxesInfo().getAxes();
          axes[0] = Math.abs(axes[0]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[0] : 0;
          axes[1] = Math.abs(axes[1]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[1] : 0;
          let horizontalMovement = false;
          let speedUsed = 0;
          if (!axes.vec2_isZero()) {
            this._myStickIdleTimer.start();
            direction = this._myCurrentDirectionConverter.convertTransformQuat(axes, this._myDirectionReference.pp_getTransformQuat(directionReferenceTransformQuat), playerUp, direction);
            if (!direction.vec3_isZero()) {
              this._myLocomotionRuntimeParams.myIsFlying = this._myLocomotionRuntimeParams.myIsFlying || direction.vec3_componentAlongAxis(playerUp, directionOnUp).vec3_length() > 1e-6;
              if (!this._myLocomotionRuntimeParams.myIsFlying) {
                direction = direction.vec3_removeComponentAlongAxis(playerUp, direction);
              }
              let movementIntensity = axes.vec2_length();
              let speed = Math.pp_lerp(0, this._myParams.myMaxSpeed, movementIntensity);
              if (this._myParams.myFlyEnabled && PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.SELECT).isPressed()) {
                speed = 20;
                if (!Global.myDebugMoveUsed) {
                  Global.myDebugMoveUsed = true;
                  Global.sendAnalytics("event", "debug_movement_used", {
                    "value": 1
                  });
                }
              }
              headMovement = direction.vec3_scale(speed * dt, headMovement);
              horizontalMovement = true;
              speedUsed = speed;
            }
          } else {
            if (this._myStickIdleTimer.isRunning()) {
              this._myStickIdleTimer.update(dt);
              if (this._myStickIdleTimer.isDone()) {
                this._myCurrentDirectionConverter.resetFly();
              }
            }
          }
          if (this._myParams.myFlyEnabled) {
            if (PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).isPressed()) {
              if (!Global.myDebugFlyUsed) {
                Global.myDebugFlyUsed = true;
                Global.sendAnalytics("event", "debug_fly_used", {
                  "value": 1
                });
              }
              let speed = Math.pp_lerp(0, this._myParams.myMaxSpeed, 1);
              if (this._myParams.myFlyEnabled && PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.SELECT).isPressed()) {
                speed = 20;
              }
              verticalMovement = playerUp.vec3_scale(speed * dt, verticalMovement);
              headMovement = headMovement.vec3_add(verticalMovement, headMovement);
              this._myLocomotionRuntimeParams.myIsFlying = true;
            } else if (PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
              let speed = Math.pp_lerp(0, this._myParams.myMaxSpeed, 1);
              if (this._myParams.myFlyEnabled && PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.SELECT).isPressed()) {
                speed = 20;
              }
              verticalMovement = playerUp.vec3_scale(-speed * dt, verticalMovement);
              headMovement = headMovement.vec3_add(verticalMovement, headMovement);
              this._myLocomotionRuntimeParams.myIsFlying = true;
            }
            if (PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON).isPressEnd(2)) {
              this._myLocomotionRuntimeParams.myIsFlying = false;
            }
          }
          let ignoreMoveThroughCollisionShortcut = true;
          if (ignoreMoveThroughCollisionShortcut || !PP.myGamepads[this._myParams.myHandedness].getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressed()) {
            if (!this._myLocomotionRuntimeParams.myIsFlying) {
              this._myGravitySpeed += this._myParams.myGravityAcceleration * dt;
              verticalMovement = playerUp.vec3_scale(this._myGravitySpeed * dt, verticalMovement);
              headMovement = headMovement.vec3_add(verticalMovement, headMovement);
            }
            feetTransformQuat = this._myParams.myPlayerTransformManager.getTransformQuat(feetTransformQuat);
            globalDT = dt;
            this._myParams.myPlayerTransformManager.move(headMovement, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
            if (horizontalMovement) {
              this._myParams.myPlayerTransformManager.resetReal(true, false, false);
              Global.myPlayer.resetHeadToReal();
            }
            if (horizontalMovement && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myFixedMovement.vec3_length() > 1e-5) {
              this._myTimeMoving += dt;
              if (this._myTimeMovingStepIndex < this._myTimeMovingStep.length && this._myTimeMoving > this._myTimeMovingStep[this._myTimeMovingStepIndex] * 60) {
                Global.sendAnalytics("event", "moving_for_" + this._myTimeMovingStep[this._myTimeMovingStepIndex] + "_minutes_" + (Global.mySessionStarted ? "vr" : "non_vr"), {
                  "value": 1
                });
                this._myTimeMovingStepIndex++;
              }
              if (this._myNonVRPlayingTimer.isRunning()) {
                this._myNonVRPlayingTimer.update(dt);
                if (this._myNonVRPlayingTimer.isDone()) {
                  if (!Global.mySessionStarted) {
                    Global.sendAnalytics("event", "moving_non_vr", {
                      "value": 1
                    });
                  }
                }
              }
              this._myStepTimer.update(dt);
              if (this._myStepTimer.isDone()) {
                this._StepRemove = true;
                let delay = Math.pp_lerp(this._myStepDelay * 2, this._myStepDelay, speedUsed / this._myParams.myMaxSpeed);
                this._myStepTimer.start(Math.pp_random(delay - 0.1, delay + 0.05));
                if (this._mySteps.length == 0) {
                  this._mySteps[0] = PP.myAudioManager.createAudioPlayer(AudioID.PASSO_1);
                }
                this.stepCounter = this.stepCounter + 1;
                this.stepCounter = this.stepCounter % this._mySteps.length;
                let player = this._mySteps[this.stepCounter];
                player = Math.pp_randomPick(this._mySteps);
                let horizontalDirection = this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis([0, 1, 0]).vec3_normalize();
                player.setPosition(this._myParams.myPlayerTransformManager.getPosition().vec3_add(horizontalDirection.vec3_scale(0.2)));
                player.setPitch(Math.pp_random(1 - 0.35, 1 + 0.15));
                player.play();
              }
              if (Global.myUnmute) {
                Global.myUnmute = false;
                import_howler9.Howler.mute(false);
              }
            } else {
              if (this._StepRemove) {
                this._myStepTimer.update(dt);
                if (this._myStepTimer.isDone()) {
                  this._StepRemove = false;
                  let delay = this._myStepDelay / 5;
                  this._myStepTimer.start(Math.max(0, Math.pp_random(delay - 0.1, delay + 0.05)));
                }
              }
            }
            if (this._myGravitySpeed > 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnCeiling || this._myGravitySpeed < 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
              this._myGravitySpeed = 0;
            }
          }
          if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
            this._myLocomotionRuntimeParams.myIsFlying = false;
            this._myCurrentDirectionConverter.resetFly();
          }
        };
      }();
      globalDT = 0;
      CleanedPlayerLocomotionSmooth.prototype._onXRSessionStart = function() {
        return function _onXRSessionStart(session) {
          switch (this._myParams.myVRDirectionReferenceType) {
            case 0:
              this._myDirectionReference = PP.myPlayerObjects.myHead;
              break;
            case 1:
              this._myDirectionReference = PP.myPlayerObjects.myHands[this._myParams.myHandedness];
              break;
            case 2:
              this._myDirectionReference = this._myParams.myVRDirectionReferenceObject;
              break;
          }
          this._myCurrentDirectionConverter = this._myDirectionConverterVR;
          this._myCurrentDirectionConverter.resetFly();
        };
      }();
      CleanedPlayerLocomotionSmooth.prototype._onXRSessionEnd = function() {
        return function _onXRSessionEnd(session) {
          this._myDirectionReference = PP.myPlayerObjects.myHead;
          this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
          this._myCurrentDirectionConverter.resetFly();
        };
      }();
      Object.defineProperty(CleanedPlayerLocomotionSmooth.prototype, "update", { enumerable: false });
      Object.defineProperty(CleanedPlayerLocomotionSmooth.prototype, "_onXRSessionStart", { enumerable: false });
      Object.defineProperty(CleanedPlayerLocomotionSmooth.prototype, "_onXRSessionEnd", { enumerable: false });
    }
  });

  // js/locomotion/cleaned/player_transform_manager_cleaned.js
  var require_player_transform_manager_cleaned = __commonJS({
    "js/locomotion/cleaned/player_transform_manager_cleaned.js"() {
      CleanedPlayerTransformManager = class CleanedPlayerTransformManager {
        constructor(params) {
          this._myParams = params;
          this._myRealMovementCollisionCheckParams = null;
          this._generateRealMovementParamsFromMovementParams();
          this._myCollisionRuntimeParams = new CollisionRuntimeParams();
          this._myRealCollisionRuntimeParams = new CollisionRuntimeParams();
          if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
            this._generateTeleportParamsFromMovementParams();
          }
          this._myHeadCollisionCheckParams = null;
          this._setupHeadCollisionCheckParams();
          this._myValidPosition = PP.vec3_create();
          this._myValidRotationQuat = new PP.quat_create();
          this._myValidHeight = 0;
          this._myValidPositionHead = PP.vec3_create();
          this._myIsBodyColliding = false;
          this._myIsHeadColliding = false;
          this._myIsLeaning = false;
          this._myIsHopping = false;
          this._myIsFar = false;
          this._myLastValidMovementDirection = PP.vec3_create();
          this._myIsRealPositionValid = false;
          this._myIsPositionValid = false;
          this._myResetRealOnSynced = false;
        }
        start() {
          this.resetToReal(true);
          if (WL.xrSession) {
            this._onXRSessionStart(true, WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this, false));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
        }
        // update should be before to check the new valid transform and if the head new transform is fine
        // then update movements, so that they will use the proper transform
        // pre/post update?
        // for sliding if previous frame no horizontal movement then reset sliding on pre update
        // in generale capire come fare per risolvere i problemi quando c' un move solo verticale che sputtana i dati dello sliding precedente
        // che servono per far slidare bene anche dopo, magari un flag per dire non aggiornare le cose relative al movimento orizzontale
        // o un move check solo verticale
        update(dt) {
        }
        move(movement, outCollisionRuntimeParams = null, forceMove = false) {
        }
        teleportPosition(position, outCollisionRuntimeParams = null, forceTeleport = false) {
        }
        teleportTransformQuat(transformQuat3, outCollisionRuntimeParams = null, forceTeleport = false) {
        }
        rotateQuat(rotationQuat) {
        }
        setRotationQuat(rotationQuat) {
        }
        setHeight(height, forceSet = false) {
        }
        getPlayer() {
          return this._myParams.myPlayerHeadManager.getPlayer();
        }
        getHead() {
          return this._myParams.myPlayerHeadManager.getHead();
        }
        getTransformQuat(outTransformQuat = PP.quat2_create()) {
          return outTransformQuat.quat2_setPositionRotationQuat(this.getPosition(), this.getRotationQuat());
        }
        getPosition(outPosition = PP.vec3_create()) {
          return outPosition.vec3_copy(this._myValidPosition);
        }
        getRotationQuat(outRotation = PP.quat_create()) {
          return outRotation.quat_copy(this._myValidRotationQuat);
        }
        getPositionHead(outPosition = PP.vec3_create()) {
          return outPosition.vec3_copy(this._myValidPositionHead);
        }
        getTransformHeadQuat(outTransformQuat = PP.quat2_create()) {
          return outTransformQuat.quat2_setPositionRotationQuat(this.getPositionHead(), this.getRotationQuat());
        }
        getHeight() {
          return this._myValidHeight;
        }
        getTransformRealQuat(outTransformQuat = PP.quat2_create()) {
          return this.getPlayerHeadManager().getTransformFeetQuat(outTransformQuat);
        }
        getTransformHeadRealQuat(outTransformQuat = PP.quat2_create()) {
          return this.getPlayerHeadManager().getTransformHeadQuat(outTransformQuat);
        }
        getPositionReal(outPosition = PP.vec3_create()) {
          return this.getPlayerHeadManager().getPositionFeet(outPosition);
        }
        getPositionHeadReal(outPosition = PP.vec3_create()) {
          return this.getPlayerHeadManager().getPositionHead(outPosition);
        }
        getRotationRealQuat(outRotation = PP.quat_create()) {
          return this.getPlayerHeadManager().getRotationFeetQuat(outRotation);
        }
        getHeightReal() {
          return this._myParams.myPlayerHeadManager.getHeightHead();
        }
        isSynced(syncFlagMap = null) {
          let isBodyColliding = this.isBodyColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING));
          let isHeadColliding = this.isHeadColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING));
          let isFar = this.isFar() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FAR));
          let isFloating = this.isFloating() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING));
          return !isBodyColliding && !isHeadColliding && !isFar && !isFloating;
        }
        resetReal(resetPosition = true, resetRotation = true, resetHeight = true, updateRealFlags = false) {
        }
        updateReal() {
          this._updateReal(0, false);
        }
        resetToReal(updateRealFlags = false) {
          this._myValidPosition = this.getPositionReal(this._myValidPosition);
          this._myValidPositionHead = this.getPositionHeadReal(this._myValidPositionHead);
          this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
          this._myValidHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
          if (updateRealFlags) {
            this._updateReal(0, false);
          }
        }
        resetHeadToReal() {
          this._myValidPositionHead = this.getPositionHeadReal(this._myValidPositionHead);
        }
        isBodyColliding() {
          return this._myIsBodyColliding;
        }
        isHeadColliding() {
          return this._myIsHeadColliding;
        }
        isFloating() {
          return this.isLeaning() || this.isHopping();
        }
        isLeaning() {
          return this._myIsLeaning;
        }
        isHopping() {
          return this._myIsHopping;
        }
        isFar() {
          return this._myIsFar;
        }
        getDistanceToReal() {
        }
        getDistanceToRealHead() {
        }
        getPlayerHeadManager() {
          return this._myParams.myPlayerHeadManager;
        }
        getParams() {
          return this._myParams;
        }
        getMovementCollisionCheckParams() {
          return this._myParams.myMovementCollisionCheckParams;
        }
        getTeleportCollisionCheckParams() {
          return this._myParams.myTeleportCollisionCheckParams;
        }
        collisionCheckParamsUpdated() {
          if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
            this._generateTeleportParamsFromMovementParams();
          }
          this._generateRealMovementParamsFromMovementParams();
        }
        isPositionValid() {
          return this._myIsPositionValid;
        }
        isRealPositionValid() {
          return this._myIsRealPositionValid;
        }
        getCollisionRuntimeParams() {
          return this._myCollisionRuntimeParams;
        }
        getRealCollisionRuntimeParams() {
          return this._myRealCollisionRuntimeParams;
        }
        _updateCollisionHeight() {
          let validHeight = this.getHeight();
          let realHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
          this._myParams.myMovementCollisionCheckParams.myHeight = validHeight;
          this._myParams.myTeleportCollisionCheckParams.myHeight = validHeight;
          this._myRealMovementCollisionCheckParams.myHeight = realHeight;
        }
        _setupHeadCollisionCheckParams() {
          this._myHeadCollisionCheckParams = new CollisionCheckParams();
          let params = this._myHeadCollisionCheckParams;
          params.myRadius = this._myParams.myHeadRadius;
          params.myDistanceFromFeetToIgnore = 0;
          params.myDistanceFromHeadToIgnore = 0;
          params.mySplitMovementEnabled = true;
          params.mySplitMovementMaxLength = 0.5;
          params.mySplitMovementMaxStepsEnabled = true;
          params.mySplitMovementMaxSteps = 2;
          params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
          params.mySplitMovementStopWhenVerticalMovementCanceled = true;
          params.myHorizontalMovementCheckEnabled = true;
          params.myHorizontalMovementRadialStepAmount = 1;
          params.myHorizontalMovementCheckDiagonalOutward = true;
          params.myHorizontalMovementCheckDiagonalInward = true;
          params.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = true;
          params.myHorizontalMovementCheckVerticalDiagonalUpwardInward = true;
          params.myHorizontalPositionCheckEnabled = true;
          params.myHalfConeAngle = 180;
          params.myHalfConeSliceAmount = 3;
          params.myCheckConeBorder = true;
          params.myCheckConeRay = true;
          params.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = false;
          params.myHorizontalPositionCheckVerticalDirectionType = 0;
          params.myHeight = params.myRadius;
          params.myPositionOffsetLocal.vec3_set(0, 0.05, 0);
          params.myCheckHeight = true;
          params.myCheckHeightVerticalMovement = true;
          params.myCheckHeightVerticalPosition = true;
          params.myHeightCheckStepAmountMovement = 1;
          params.myHeightCheckStepAmountPosition = 1;
          params.myCheckHeightTopMovement = true;
          params.myCheckHeightTopPosition = true;
          params.myCheckVerticalStraight = true;
          params.myCheckVerticalFixedForwardEnabled = true;
          params.myCheckVerticalFixedForward = PP.vec3_create(0, 0, 1);
          params.myCheckHorizontalFixedForwardEnabled = true;
          params.myCheckHorizontalFixedForward = PP.vec3_create(0, 0, 1);
          params.myVerticalMovementCheckEnabled = true;
          params.myVerticalPositionCheckEnabled = true;
          params.myGroundCircumferenceAddCenter = true;
          params.myGroundCircumferenceSliceAmount = 6;
          params.myGroundCircumferenceStepAmount = 2;
          params.myGroundCircumferenceRotationPerStep = 30;
          params.myFeetRadius = params.myRadius;
          params.myHorizontalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
          params.myHorizontalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
          params.myVerticalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
          params.myVerticalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
          params.myDebugActive = false;
          params.myDebugHorizontalMovementActive = true;
          params.myDebugHorizontalPositionActive = false;
          params.myDebugVerticalMovementActive = false;
          params.myDebugVerticalPositionActive = false;
          params.myDebugSlidingActive = false;
          params.myDebugGroundInfoActive = false;
          params.myDebugCeilingInfoActive = false;
          params.myDebugRuntimeParamsActive = false;
          params.myDebugMovementActive = false;
        }
        _generateTeleportParamsFromMovementParams() {
          if (this._myParams.myTeleportCollisionCheckParams == null) {
            this._myParams.myTeleportCollisionCheckParams = new CollisionCheckParams();
          }
          if (this._myParams.myTeleportCollisionCheckParamsCheck360) {
            this._myParams.myTeleportCollisionCheckParams = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myParams.myMovementCollisionCheckParams, this._myParams.myTeleportCollisionCheckParams);
          } else {
            this._myParams.myTeleportCollisionCheckParams.copy(this._myParams.myMovementCollisionCheckParams);
          }
        }
        _generateRealMovementParamsFromMovementParams() {
          if (this._myRealMovementCollisionCheckParams == null) {
            this._myRealMovementCollisionCheckParams = new CollisionCheckParams();
          }
          let params = this._myRealMovementCollisionCheckParams;
          params.copy(this._myParams.myMovementCollisionCheckParams);
          params.mySplitMovementEnabled = true;
          params.mySplitMovementMaxLength = 0.5;
          params.mySplitMovementMaxStepsEnabled = true;
          params.mySplitMovementMaxSteps = 2;
          params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
          params.mySplitMovementStopWhenVerticalMovementCanceled = true;
          params.mySlidingEnabled = false;
          if (!this._myParams.myRealMovementAllowVerticalAdjustments) {
            params.mySnapOnGroundEnabled = false;
            params.mySnapOnCeilingEnabled = false;
            params.myGroundPopOutEnabled = false;
            params.myCeilingPopOutEnabled = false;
            params.myAdjustVerticalMovementWithGroundAngleDownhill = false;
            params.myAdjustVerticalMovementWithGroundAngleUphill = false;
            params.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
            params.myAdjustVerticalMovementWithCeilingAngleUphill = false;
            params.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
            params.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
            params.myVerticalMovementReduceEnabled = false;
          }
          params.myIsOnGroundIfInsideHit = true;
          params.myDebugActive = false;
          params.myDebugHorizontalMovementActive = false;
          params.myDebugHorizontalPositionActive = false;
          params.myDebugVerticalMovementActive = false;
          params.myDebugVerticalPositionActive = false;
          params.myDebugSlidingActive = false;
          params.myDebugGroundInfoActive = true;
          params.myDebugCeilingInfoActive = true;
          params.myDebugRuntimeParamsActive = false;
          params.myDebugMovementActive = false;
        }
        _onXRSessionStart(manualStart, session) {
          if (this._myParams.myResetToValidOnEnterSession) {
            this._myResetRealOnSynced = true;
          }
        }
        _onXRSessionEnd() {
          if (this._myParams.myResetToValidOnExitSession) {
            this._myResetRealOnSynced = true;
          }
        }
        _debugUpdate(dt) {
          PP.myDebugVisualManager.drawPoint(0, this._myValidPosition, PP.vec4_create(1, 0, 0, 1), 0.05);
          PP.myDebugVisualManager.drawLineEnd(0, this._myValidPosition, this.getPositionReal(), PP.vec4_create(1, 0, 0, 1), 0.05);
          PP.myDebugVisualManager.drawLine(0, this._myValidPosition, this._myValidRotationQuat.quat_getForward(), 0.15, PP.vec4_create(0, 1, 0, 1), 0.025);
          PP.myDebugVisualManager.drawPoint(0, this._myValidPositionHead, PP.vec4_create(1, 1, 0, 1), 0.05);
        }
      };
      CleanedPlayerTransformManager.prototype.getDistanceToReal = function() {
        let realPosition = PP.vec3_create();
        return function getDistanceToReal() {
          realPosition = this.getPositionReal(realPosition);
          return realPosition.vec3_distance(this.getPosition());
        };
      }();
      CleanedPlayerTransformManager.prototype.getDistanceToRealHead = function() {
        let realPosition = PP.vec3_create();
        return function getDistanceToRealHead() {
          realPosition = this.getPositionHeadReal(realPosition);
          return realPosition.vec3_distance(this.getPositionHead());
        };
      }();
      CleanedPlayerTransformManager.prototype.resetReal = function() {
        let realUp = PP.vec3_create();
        let validUp = PP.vec3_create();
        let position = PP.vec3_create();
        let rotationQuat = PP.quat_create();
        return function resetReal(resetPosition = true, resetRotation = true, resetHeight = true, updateRealFlags = false) {
          let playerHeadManager = this.getPlayerHeadManager();
          if (resetPosition) {
            playerHeadManager.teleportPositionFeet(this.getPosition(position));
          }
          realUp = this.getPlayerHeadManager().getRotationFeetQuat(rotationQuat).quat_getUp(realUp);
          validUp = this.getRotationQuat(rotationQuat).quat_getUp(validUp);
          if (resetRotation || realUp.vec3_angle(validUp) > Math.PP_EPSILON_DEGREES && this._myParams.myResetRealResetRotationIfUpChanged) {
            playerHeadManager.setRotationFeetQuat(this.getRotationQuat(rotationQuat), false);
          }
          if (resetHeight) {
            playerHeadManager.setHeight(this.getHeight(), true);
          }
          if (updateRealFlags) {
            this._updateReal(0, false);
          }
        };
      }();
      CleanedPlayerTransformManager.prototype.update = function() {
        let transformQuat3 = PP.quat2_create();
        let collisionRuntimeParams = new CollisionRuntimeParams();
        let transformUp = PP.vec3_create();
        let horizontalDirection = PP.vec3_create();
        let rotationQuat = PP.quat_create();
        return function update(dt) {
          this._myHeadCollisionCheckParams.myHorizontalObjectsToIgnore.pp_copy(this._myParams.myMovementCollisionCheckParams.myHorizontalObjectsToIgnore);
          this._myHeadCollisionCheckParams.myVerticalObjectsToIgnore.pp_copy(this._myParams.myMovementCollisionCheckParams.myVerticalObjectsToIgnore);
          this._myRealMovementCollisionCheckParams.myHorizontalObjectsToIgnore.pp_copy(this._myParams.myMovementCollisionCheckParams.myHorizontalObjectsToIgnore);
          this._myRealMovementCollisionCheckParams.myVerticalObjectsToIgnore.pp_copy(this._myParams.myMovementCollisionCheckParams.myVerticalObjectsToIgnore);
          this._myParams.myTeleportCollisionCheckParams.myHorizontalObjectsToIgnore.pp_copy(this._myParams.myMovementCollisionCheckParams.myHorizontalObjectsToIgnore);
          this._myParams.myTeleportCollisionCheckParams.myVerticalObjectsToIgnore.pp_copy(this._myParams.myMovementCollisionCheckParams.myVerticalObjectsToIgnore);
          if (this._myResetRealOnSynced) {
            if (this.getPlayerHeadManager().isSynced()) {
              this._myResetRealOnSynced = false;
              if (PP.XRUtils.isSessionActive()) {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionVR,
                  !this._myParams.myNeverResetRealRotationVR,
                  !this._myParams.myNeverResetRealHeightVR,
                  false
                );
              } else {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionNonVR,
                  !this._myParams.myNeverResetRealRotationNonVR,
                  !this._myParams.myNeverResetRealHeightNonVR && false,
                  false
                );
              }
            }
          }
          this._updateReal(dt);
          let updatePositionValidEnabled = false;
          if (updatePositionValidEnabled && this._myParams.myUpdatePositionValid) {
            transformQuat3 = this.getTransformQuat(transformQuat3);
            transformUp = transformQuat3.quat2_getUp(transformUp);
            rotationQuat = transformQuat3.quat2_getRotationQuat(rotationQuat);
            horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
            if (!horizontalDirection.vec3_isZero(1e-5)) {
              horizontalDirection.vec3_normalize(horizontalDirection);
              rotationQuat.quat_setForward(horizontalDirection);
              transformQuat3.quat2_setRotationQuat(rotationQuat);
            }
            let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugActive;
            this._myParams.myMovementCollisionCheckParams.myDebugActive = false;
            CollisionCheckGlobal.positionCheck(true, transformQuat3, this._myParams.myMovementCollisionCheckParams, collisionRuntimeParams);
            this._myParams.myMovementCollisionCheckParams.myDebugActive = debugBackup;
            this._myIsPositionValid = collisionRuntimeParams.myIsPositionOk;
          }
          if (this._myParams.myDebugActive) {
            this._debugUpdate(dt);
          }
        };
      }();
      CleanedPlayerTransformManager.prototype._updateReal = function() {
        let movementToCheck = PP.vec3_create();
        let position = PP.vec3_create();
        let positionReal = PP.vec3_create();
        let transformQuat3 = PP.quat2_create();
        let collisionRuntimeParams = new CollisionRuntimeParams();
        let newPosition = PP.vec3_create();
        let newPositionHead = PP.vec3_create();
        let movementStep = PP.vec3_create();
        let currentMovementStep = PP.vec3_create();
        let transformUp = PP.vec3_create();
        let verticalMovement = PP.vec3_create();
        let movementChecked = PP.vec3_create();
        let newFeetPosition = PP.vec3_create();
        let floatingTransformQuat = PP.quat2_create();
        let horizontalDirection = PP.vec3_create();
        let rotationQuat = PP.quat_create();
        return function _updateReal(dt, resetRealEnabled = true) {
          if (this.getPlayerHeadManager().isSynced()) {
            this._myIsBodyColliding = false;
            this._myIsHeadColliding = false;
            this._myIsLeaning = false;
            this._myIsHopping = false;
            this._myIsFar = false;
            this._generateRealMovementParamsFromMovementParams();
            this._updateCollisionHeight();
            movementToCheck = this.getPositionReal(positionReal).vec3_sub(this.getPosition(position), movementToCheck);
            if (movementToCheck.vec3_length() > 1e-4) {
              this._myLastValidMovementDirection = movementToCheck.vec3_normalize(this._myLastValidMovementDirection);
            }
            if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FAR)) {
              if (this._myParams.myIsMaxDistanceFromRealToSyncEnabled && movementToCheck.vec3_length() > this._myParams.myMaxDistanceFromRealToSync) {
                this._myIsFar = true;
              } else if (this._myParams.myIsFarExtraCheckCallback != null && this._myParams.myIsFarExtraCheckCallback(this)) {
                this._myIsFar = true;
              }
            }
            collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
            collisionRuntimeParams.myIsOnGround = true;
            transformQuat3 = this.getTransformQuat(transformQuat3);
            newPosition.vec3_copy(this._myValidPosition);
            if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING)) {
              CollisionCheckGlobal.move(movementToCheck, transformQuat3, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
              if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
                if (Math.pp_clamp(
                  this._myRealMovementCollisionCheckParams.myHeight,
                  this._myParams.myIsBodyCollidingWhenHeightBelowValue,
                  this._myParams.myIsBodyCollidingWhenHeightAboveValue
                ) != this._myRealMovementCollisionCheckParams.myHeight) {
                  this._myIsBodyColliding = true;
                } else {
                  if (this._myParams.myIsBodyCollidingExtraCheckCallback != null && this._myParams.myIsBodyCollidingExtraCheckCallback(this)) {
                    this._myIsBodyColliding = true;
                  } else {
                    this._myIsBodyColliding = false;
                    newPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
                  }
                }
              } else {
                this._myIsBodyColliding = true;
              }
            }
            let updateFloatingEnabled = false;
            if (updateFloatingEnabled && this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING)) {
              if (!this._myIsBodyColliding) {
                movementToCheck = newPosition.vec3_sub(position, movementToCheck);
              } else {
                movementToCheck = positionReal.vec3_sub(position, movementToCheck);
              }
              collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
              floatingTransformQuat.quat2_setPositionRotationQuat(this._myValidPosition, this._myValidRotationQuat);
              CollisionCheckGlobal.updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
              if (collisionRuntimeParams.myIsOnGround) {
                transformUp = transformQuat3.quat2_getUp(transformUp);
                verticalMovement = movementToCheck.vec3_componentAlongAxis(transformUp);
                let isVertical = !verticalMovement.vec3_isZero(1e-5);
                if (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovement) {
                  let movementStepAmount = 1;
                  movementStep.vec3_copy(movementToCheck);
                  if (!movementToCheck.vec3_isZero(1e-5) && this._myParams.myFloatingSplitCheckEnabled) {
                    let equalStepLength = movementToCheck.vec3_length() / this._myParams.myFloatingSplitCheckMaxSteps;
                    if (!this._myParams.myFloatingSplitCheckStepEqualLength || equalStepLength < this._myParams.myFloatingSplitCheckStepEqualLengthMinLength) {
                      let maxLength = this._myParams.myFloatingSplitCheckStepEqualLength ? this._myParams.myFloatingSplitCheckStepEqualLengthMinLength : this._myParams.myFloatingSplitCheckMaxLength;
                      movementStepAmount = Math.ceil(movementToCheck.vec3_length() / maxLength);
                      if (movementStepAmount > 1) {
                        movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(maxLength, movementStep);
                        movementStepAmount = this._myParams.myFloatingSplitCheckMaxSteps != null ? Math.min(movementStepAmount, this._myParams.myFloatingSplitCheckMaxSteps) : movementStepAmount;
                      }
                      movementStepAmount = Math.max(1, movementStepAmount);
                      if (movementStepAmount == 1) {
                        movementStep.vec3_copy(movementToCheck);
                      }
                    } else {
                      movementStepAmount = this._myParams.myFloatingSplitCheckMaxSteps;
                      if (movementStepAmount > 1) {
                        movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(equalStepLength, movementStep);
                      }
                    }
                  }
                  let isOnValidGroundAngle = collisionRuntimeParams.myGroundAngle <= this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4;
                  movementChecked.vec3_zero();
                  newFeetPosition.vec3_copy(this._myValidPosition);
                  collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
                  let atLeastOneNotOnGround = false;
                  let isOneOnGroundBetweenNoGround = false;
                  let isLastOnGround = false;
                  let isOneOnSteepGround = false;
                  for (let i = 0; i < movementStepAmount; i++) {
                    if (movementStepAmount == 1 || i != movementStepAmount - 1) {
                      currentMovementStep.vec3_copy(movementStep);
                    } else {
                      currentMovementStep = movementToCheck.vec3_sub(movementChecked, currentMovementStep);
                    }
                    newFeetPosition = newFeetPosition.vec3_add(currentMovementStep, newFeetPosition);
                    floatingTransformQuat.quat2_setPositionRotationQuat(newFeetPosition, this._myValidRotationQuat);
                    collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
                    CollisionCheckGlobal.updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
                    movementChecked = movementChecked.vec3_add(currentMovementStep, movementChecked);
                    if (!collisionRuntimeParams.myIsOnGround) {
                      atLeastOneNotOnGround = true;
                    } else {
                      if (collisionRuntimeParams.myGroundAngle > this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4) {
                        isOneOnSteepGround = true;
                      }
                      if (atLeastOneNotOnGround) {
                        isOneOnGroundBetweenNoGround = true;
                      }
                      if (i == movementStepAmount - 1) {
                        isLastOnGround = true;
                      }
                    }
                  }
                  let isFloatingOnSteepGroundFail = isOneOnSteepGround && isOnValidGroundAngle && !this._myParams.myIsFloatingValidIfSteepGround && (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovementAndSteepGround);
                  if (atLeastOneNotOnGround || isFloatingOnSteepGroundFail) {
                    if (isOneOnGroundBetweenNoGround) {
                      this._myIsHopping = true;
                    } else {
                      this._myIsLeaning = true;
                    }
                  } else {
                    this._myIsLeaning = false;
                    this._myIsHopping = false;
                    if (this._myParams.myIsLeaningExtraCheckCallback != null && this._myParams.myIsLeaningExtraCheckCallback(this)) {
                      this._myIsLeaning = true;
                    } else if (this._myParams.myIsHoppingExtraCheckCallback != null && this._myParams.myIsHoppingExtraCheckCallback(this)) {
                      this._myIsHopping = true;
                    }
                  }
                  if (this._myIsLeaning) {
                    let distance4 = movementToCheck.vec3_length();
                    if (this._myParams.myIsLeaningValidAboveDistance && distance4 > this._myParams.myLeaningValidDistance) {
                      this._myIsLeaning = false;
                    }
                  }
                  if (this._myIsLeaning || this._myIsHopping) {
                    if (isLastOnGround && this._myParams.myIsFloatingValidIfRealOnGround) {
                      this._myIsLeaning = false;
                      this._myIsHopping = false;
                    } else if (isLastOnGround && isVertical && this._myParams.myIsFloatingValidIfVerticalMovementAndRealOnGround) {
                      this._myIsLeaning = false;
                      this._myIsHopping = false;
                    }
                  }
                }
              }
            }
            movementToCheck = this.getPositionHeadReal(positionReal).vec3_sub(this.getPositionHead(position), movementToCheck);
            collisionRuntimeParams.reset();
            transformQuat3 = this.getTransformHeadQuat(transformQuat3);
            newPositionHead.vec3_copy(this._myValidPositionHead);
            if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING)) {
              CollisionCheckGlobal.move(movementToCheck, transformQuat3, this._myHeadCollisionCheckParams, collisionRuntimeParams);
              if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
                this._myIsHeadColliding = false;
                newPositionHead.vec3_copy(collisionRuntimeParams.myNewPosition);
              } else {
                this._myIsHeadColliding = true;
              }
            }
            if (this.isSynced(this._myParams.mySyncPositionFlagMap) && !this._myParams.mySyncPositionDisabled) {
              this._myValidPosition.vec3_copy(newPosition);
            }
            if (this.isSynced(this._myParams.mySyncPositionHeadFlagMap)) {
              this._myValidPositionHead = this.getPositionHeadReal(newPositionHead);
            }
            let alwaysSyncRotation = true;
            if (alwaysSyncRotation || this.isSynced(this._myParams.mySyncRotationFlagMap)) {
              this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
            }
            let alwaysSyncHeight = true;
            if (alwaysSyncHeight || this.isSynced(this._myParams.mySyncHeightFlagMap)) {
              this._myValidHeight = this._myRealMovementCollisionCheckParams.myHeight;
              this._updateCollisionHeight();
            }
            let updateRealPositionValidEnabled = false;
            if (updateRealPositionValidEnabled && this._myParams.myUpdateRealPositionValid) {
              transformQuat3 = this.getTransformRealQuat(transformQuat3);
              transformUp = transformQuat3.quat2_getUp(transformUp);
              rotationQuat = transformQuat3.quat2_getRotationQuat(rotationQuat);
              horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
              if (!horizontalDirection.vec3_isZero(1e-5)) {
                horizontalDirection.vec3_normalize(horizontalDirection);
                rotationQuat.quat_setForward(horizontalDirection);
                transformQuat3.quat2_setRotationQuat(rotationQuat);
              }
              let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugActive;
              this._myParams.myMovementCollisionCheckParams.myDebugActive = false;
              CollisionCheckGlobal.positionCheck(true, transformQuat3, this._myParams.myMovementCollisionCheckParams, this._myRealCollisionRuntimeParams);
              this._myIsRealPositionValid = this._myRealCollisionRuntimeParams.myIsPositionOk;
              this._myParams.myMovementCollisionCheckParams.myDebugActive = debugBackup;
            }
          }
        };
      }();
      CleanedPlayerTransformManager.prototype.move = function() {
        let transformQuat3 = PP.quat2_create();
        let fixedMovement = PP.vec3_create();
        return function move(movement, outCollisionRuntimeParams = null, forceMove = false) {
          transformQuat3 = this.getTransformQuat(transformQuat3);
          CollisionCheckGlobal.move(movement, transformQuat3, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
          if (outCollisionRuntimeParams != null) {
            outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
          }
          if (!forceMove) {
            fixedMovement.vec3_copy(this._myCollisionRuntimeParams.myFixedMovement);
          } else {
            fixedMovement.vec3_copy(movement);
          }
          if (!fixedMovement.vec3_isZero(1e-5)) {
            this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
            this.getPlayerHeadManager().moveFeet(fixedMovement);
          }
          if (this._myParams.myResetRealOnMove) {
            if (!this.isSynced()) {
              if (PP.XRUtils.isSessionActive()) {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionVR,
                  !this._myParams.myNeverResetRealRotationVR,
                  !this._myParams.myNeverResetRealHeightVR,
                  false
                );
              } else {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionNonVR,
                  !this._myParams.myNeverResetRealRotationNonVR,
                  !this._myParams.myNeverResetRealHeightNonVR,
                  false
                );
              }
            }
          }
        };
      }();
      CleanedPlayerTransformManager.prototype.teleportPosition = function() {
        let teleportTransformQuat = PP.quat2_create();
        return function teleportPosition(teleportPosition, outCollisionRuntimeParams = null, forceTeleport = false) {
          teleportTransformQuat = this.getTransformQuat(teleportTransformQuat);
          teleportTransformQuat.quat2_setPosition(teleportPosition);
          this.teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams, forceTeleport);
        };
      }();
      CleanedPlayerTransformManager.prototype.teleportTransformQuat = function() {
        let currentPosition = PP.vec3_create();
        let teleportPositionVec = PP.vec3_create();
        let teleportRotation = PP.quat_create();
        let rotatedTransformQuat = PP.quat2_create();
        let fixedMovement = PP.vec3_create();
        return function teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
          currentPosition = this.getPosition(currentPosition);
          teleportPositionVec = teleportTransformQuat.quat2_getPosition(teleportPositionVec);
          teleportRotation = teleportTransformQuat.quat2_getRotationQuat(teleportRotation);
          rotatedTransformQuat.quat2_setPositionRotationQuat(currentPosition, teleportRotation);
          CollisionCheckGlobal.teleport(teleportPositionVec, rotatedTransformQuat, this._myParams.myTeleportCollisionCheckParams, this._myCollisionRuntimeParams);
          if (outCollisionRuntimeParams != null) {
            outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
          }
          fixedMovement.vec3_zero();
          if (!forceTeleport) {
            if (!this._myCollisionRuntimeParams.myTeleportCanceled) {
              fixedMovement = this._myCollisionRuntimeParams.myFixedTeleportPosition.vec3_sub(currentPosition, fixedMovement);
              this.getPlayerHeadManager().setRotationFeetQuat(teleportRotation);
            }
          } else {
            fixedMovement = teleportPositionVec.vec3_sub(currentPosition, fixedMovement);
            this.getPlayerHeadManager().setRotationFeetQuat(teleportRotation);
          }
          if (!fixedMovement.vec3_isZero(1e-5)) {
            this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
            this.getPlayerHeadManager().moveFeet(fixedMovement);
          }
          if (this._myParams.myResetRealOnTeleport) {
            if (!this.isSynced()) {
              if (PP.XRUtils.isSessionActive()) {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionVR,
                  !this._myParams.myNeverResetRealRotationVR,
                  !this._myParams.myNeverResetRealHeightVR,
                  false
                );
              } else {
                this.resetReal(
                  !this._myParams.myNeverResetRealPositionNonVR,
                  !this._myParams.myNeverResetRealRotationNonVR,
                  !this._myParams.myNeverResetRealHeightNonVR,
                  false
                );
              }
            }
          }
        };
      }();
      CleanedPlayerTransformManager.prototype.rotateQuat = function() {
        return function rotateQuat(rotationQuat) {
          this._myValidRotationQuat.quat_rotateQuat(rotationQuat, this._myValidRotationQuat);
          this.getPlayerHeadManager().rotateFeetQuat(rotationQuat);
        };
      }();
      CleanedPlayerTransformManager.prototype.setRotationQuat = function() {
        let rotationToPerform = PP.quat_create();
        return function setRotationQuat(rotationQuat) {
          rotationToPerform = this._myValidRotationQuat.quat_rotationToQuat(rotationQuat, rotationToPerform);
          this.rotateQuat(rotationToPerform);
        };
      }();
      CleanedPlayerTransformManager.prototype.setHeight = function() {
        let transformQuat3 = PP.quat2_create();
        return function setHeight(height, forceSet = false) {
          let fixedHeight = Math.pp_clamp(height, this._myParams.myMinHeight, this._myParams.myMaxHeight);
          let previousHeight = this.getHeight();
          this._myValidHeight = fixedHeight;
          this._updateCollisionHeight();
          transformQuat3 = this.getTransformQuat(transformQuat3);
          CollisionCheckGlobal.positionCheck(true, transformQuat3, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
          if (this._myCollisionRuntimeParams.myIsPositionOk || forceSet) {
            this.getPlayerHeadManager().setHeight(this.getHeight(), true);
          } else {
            this._myValidHeight = previousHeight;
          }
          this._updateCollisionHeight();
        };
      }();
    }
  });

  // js/labyroots/labyroots_gateway.js
  var require_labyroots_gateway = __commonJS({
    "js/labyroots/labyroots_gateway.js"() {
      WL.registerComponent("labyroots-gateway", {
        _myFromAbove: { type: WL.Type.Bool, default: false }
      }, {
        init: function() {
          Global.myAnalyticsEnabled = true;
          Global.sendAnalytics("event", "game_init_started", {
            "value": 1
          });
          PP.CAUtils.initializeSDK();
          Global.myFromAbove = this._myFromAbove;
          Global.mySaveManager = new PP.SaveManager("labyroots");
          Global.mySaveManager.setDelaySavesCommit(false);
          this._myVRButtonVisibilityUpdated = false;
          this._myVRButtonDisabledOpacityUpdated = false;
          this._myVRButtonUsabilityUpdated = false;
          this._myXRButtonsContainer = document.getElementById("xr-buttons-container");
          this._myVRButton = document.getElementById("vr-button");
          this._myDesiredFrameRate = null;
          this._mySetDesiredFrameRateMaxAttempts = 10;
          if (window.location != null && window.location.host != null) {
            Global.myIsLocalhost = window.location.host == "localhost:8080";
          }
          Global.myAnalyticsEnabled = !Global.myIsLocalhost;
          this._myGestureStartEventListener = function(event) {
            event.preventDefault();
          };
          document.addEventListener("gesturestart", this._myGestureStartEventListener);
        },
        start: function() {
          this._myLoadSetupDone = false;
          this._loadSetup();
          this._myFirstUpdate = true;
          this._myVeryFirstUpdate = true;
          this._myReadyCounter = 10;
          if (WL.xrSession) {
            this._onXRSessionStart(WL.xrSession);
          }
          WL.onXRSessionStart.push(this._onXRSessionStart.bind(this));
          WL.onXRSessionEnd.push(this._onXRSessionEnd.bind(this));
          this._myButtonPressed = false;
          PP.CAUtils.setDummyServer(new LR.LRCADummyServer());
          PP.CAUtils.setUseDummyServerOnSDKMissing(true);
          PP.CAUtils.setUseDummyServerOnError(true);
          this._myTimePlayingVR = 0;
          this._myTimePlayingVRStep = [1, 2, 3, 5, 10, 20, 30, 60];
          this._myTimePlayingVRStepIndex = 0;
        },
        update: function(dt) {
          if (this._myVeryFirstUpdate) {
            this._myVeryFirstUpdate = false;
            if (this._myVRButton != null) {
              this._myVRButton.style.setProperty("display", "block");
            }
          } else {
            if (!this._myVRButtonUsabilityUpdated) {
              this._updateVRButtonVisibility();
            }
          }
          if (WL.xrSession != null && WL.xrSession.updateTargetFrameRate != null && this._myDesiredFrameRate != null && WL.xrSession.frameRate != this._myDesiredFrameRate) {
            try {
              WL.xrSession.updateTargetFrameRate(this._myDesiredFrameRate).catch(function() {
                if (this._mySetDesiredFrameRateMaxAttempts > 0) {
                  this._mySetDesiredFrameRateMaxAttempts--;
                } else {
                  this._myDesiredFrameRate = null;
                }
              }.bind(this));
            } catch (error) {
              if (this._mySetDesiredFrameRateMaxAttempts > 0) {
                this._mySetDesiredFrameRateMaxAttempts--;
              } else {
                this._myDesiredFrameRate = null;
              }
            }
          }
          if (!this._myLoadSetupDone) {
            return;
          }
          Global.mySaveManager.update(dt);
          if (this._myFirstUpdate) {
            this._myFirstUpdate = false;
            let gameplayItems = WL.scene.pp_getObjectByName("Gameplay Items");
            if (gameplayItems != null) {
              let fruits = gameplayItems.pp_getObjectByName("Fruits");
              let fruit1 = fruits.pp_getObjectByName("" + LR.MazeItemType.HUMAN_TREE_1).pp_getChildren()[0];
              let fruit2 = fruits.pp_getObjectByName("" + LR.MazeItemType.HUMAN_TREE_2).pp_getChildren()[0];
              let fruit3 = fruits.pp_getObjectByName("" + LR.MazeItemType.HUMAN_TREE_3).pp_getChildren()[0];
              let fruit4 = fruits.pp_getObjectByName("" + LR.MazeItemType.HUMAN_TREE_4).pp_getChildren()[0];
              Global.myFruits[LR.MazeItemType.HUMAN_TREE_1] = fruit1;
              Global.myFruits[LR.MazeItemType.HUMAN_TREE_2] = fruit2;
              Global.myFruits[LR.MazeItemType.HUMAN_TREE_3] = fruit3;
              Global.myFruits[LR.MazeItemType.HUMAN_TREE_4] = fruit4;
              Global.myAxeProto = gameplayItems.pp_getObjectByName("Axe");
              Global.myAxe = Global.myAxeProto;
              Global.myFollowAxe = gameplayItems.pp_getObjectByName("Follow Axe");
            }
            let mazeItems = WL.scene.pp_getObjectByName("Maze Items");
            if (mazeItems != null) {
              let tree1 = mazeItems.pp_getObjectByName("" + LR.MazeItemType.HUMAN_TREE_1).pp_getChildren()[0];
              let tree2 = mazeItems.pp_getObjectByName("" + LR.MazeItemType.HUMAN_TREE_2).pp_getChildren()[0];
              let tree3 = mazeItems.pp_getObjectByName("" + LR.MazeItemType.HUMAN_TREE_3).pp_getChildren()[0];
              let tree4 = mazeItems.pp_getObjectByName("" + LR.MazeItemType.HUMAN_TREE_4).pp_getChildren()[0];
              Global.myTrees[LR.MazeItemType.HUMAN_TREE_1] = tree1;
              Global.myTrees[LR.MazeItemType.HUMAN_TREE_2] = tree2;
              Global.myTrees[LR.MazeItemType.HUMAN_TREE_3] = tree3;
              Global.myTrees[LR.MazeItemType.HUMAN_TREE_4] = tree4;
            }
            Global.myMaze.buildMaze();
          } else if (this._myReadyCounter > 0) {
            this._myReadyCounter--;
            if (this._myReadyCounter == 0) {
              Global.sendAnalytics("event", "game_init_ended", {
                "value": 1
              });
              Global.myStoryReady = true;
            }
          }
          if (Global.mySessionStarted) {
            if (!this._myButtonPressed) {
              if (PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.SELECT).isPressEnd() || PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.SQUEEZE).isPressEnd() || PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.SELECT).isPressEnd() || PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.SQUEEZE).isPressEnd()) {
                this._myButtonPressed = true;
                Global.sendAnalytics("event", "button_pressed", {
                  "value": 1
                });
              }
            }
          }
          if (Global.myReady) {
            if (PP.XRUtils.isSessionActive()) {
              this._myTimePlayingVR += dt;
              if (this._myTimePlayingVRStepIndex < this._myTimePlayingVRStep.length && this._myTimePlayingVR > this._myTimePlayingVRStep[this._myTimePlayingVRStepIndex] * 60) {
                Global.sendAnalytics("event", "playing_for_" + this._myTimePlayingVRStep[this._myTimePlayingVRStepIndex] + "_minutes_vr", {
                  "value": 1
                });
                this._myTimePlayingVRStepIndex++;
              }
            }
          }
          if (Global.myElementToClick != null) {
            Global.myElementToClickCounter--;
            if (Global.myElementToClickCounter <= 0) {
              Global.myElementToClickCounter = 0;
              let elementToClick = Global.myElementToClick;
              Global.myElementToClick = null;
              try {
                elementToClick.click();
                document.body.removeChild(elementToClick);
              } catch (error) {
              }
            }
          }
        },
        _loadSetup() {
          loadFileJSON("./setup.json", (data) => {
            Global.mySetup = data;
            this._loadMaze();
            this._myLoadSetupDone = true;
          });
        },
        _loadMaze() {
          Global.myMaze = new LR.Maze(Global.mySetup.myMazeSetup, this.object);
        },
        _updateVRButtonVisibility() {
          if (this._myVRButton != null) {
            if (!this._myVRButtonVisibilityUpdated) {
              this._myVRButton.style.setProperty("transform", "scale(1)");
              this._myVRButtonVisibilityUpdated = true;
            }
            if (!this._myVRButtonUsabilityUpdated) {
              if (WL.vrSupported != null && WL.vrSupported) {
                this._myVRButton.style.setProperty("opacity", "1");
                this._myVRButton.style.setProperty("pointer-events", "all");
                this._myVRButtonUsabilityUpdated = true;
              } else if (!this._myVRButtonDisabledOpacityUpdated) {
                this._myVRButton.style.setProperty("opacity", "0.5");
                this._myVRButtonDisabledOpacityUpdated = true;
              }
            }
          } else {
            this._myVRButtonUsabilityUpdated = true;
          }
        },
        _onXRSessionStart(session) {
          if (this._myXRButtonsContainer != null) {
            this._myXRButtonsContainer.style.setProperty("display", "none");
          }
          this._myDesiredFrameRate = null;
          this._mySetDesiredFrameRateMaxAttempts = 10;
          if (session.supportedFrameRates != null) {
            let desiredFrameRate = 72;
            let bestFrameRate = null;
            for (let supportedFrameRate of session.supportedFrameRates) {
              if (supportedFrameRate == desiredFrameRate) {
                bestFrameRate = desiredFrameRate;
                break;
              } else if (bestFrameRate == null) {
                bestFrameRate = supportedFrameRate;
              } else if (supportedFrameRate > desiredFrameRate && (supportedFrameRate < bestFrameRate || bestFrameRate < desiredFrameRate)) {
                bestFrameRate = supportedFrameRate;
              } else if (supportedFrameRate < desiredFrameRate && supportedFrameRate > bestFrameRate) {
                bestFrameRate = supportedFrameRate;
              }
            }
            this._myDesiredFrameRate = bestFrameRate;
          }
          if (session.updateTargetFrameRate != null && this._myDesiredFrameRate != null) {
            try {
              session.updateTargetFrameRate(this._myDesiredFrameRate);
            } catch (error) {
            }
          }
          Global.sendAnalytics("event", "enter_vr", {
            "value": 1
          });
          let isFirstEnterVR = Global.mySaveManager.load("is_first_enter_vr", true);
          if (isFirstEnterVR) {
            Global.sendAnalytics("event", "enter_vr_first_time", {
              "value": 1
            });
          }
          Global.mySaveManager.save("is_first_enter_vr", false);
          Global.mySessionStarted = true;
        },
        _onXRSessionEnd() {
          if (this._myXRButtonsContainer != null) {
            this._myXRButtonsContainer.style.removeProperty("display");
          }
          this._myDesiredFrameRate = null;
        }
      });
      Global = {
        mySetup: {},
        myMaze: null,
        myPlayer: null,
        myStoryReady: false,
        myReady: false,
        myStage: 0,
        myRoots: null,
        myAxe: null,
        myTrees: [],
        myFruits: [],
        myAxeProto: null,
        myFollowAxe: null,
        myFromAbove: false,
        myAnalyticsEnabled: false,
        myIsLocalhost: false,
        myElementToClick: null,
        myElementToClickCounter: 0,
        myAudioMangia: null
      };
      Global.mySessionStarted = false;
      Global.sendAnalytics = function sendAnalytics(eventType, eventName, eventValue) {
        try {
          if (Global.myAnalyticsEnabled) {
            if (window.gtag != null) {
              window.gtag(eventType, eventName, eventValue);
            }
          }
        } catch (error) {
        }
      };
      LR = {};
    }
  });

  // js/labyroots/json/file_manager.js
  var require_file_manager = __commonJS({
    "js/labyroots/json/file_manager.js"() {
      downloadFileText = function(filename, text) {
        const blob = new Blob([text], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        let element = document.createElement("a");
        element.href = url;
        element.download = filename;
        element.style.display = "none";
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
        return true;
      };
      downloadFileJSON = function(filename, object) {
        let json = null;
        try {
          json = JSON.stringify(object);
        } catch (error) {
        }
        if (json != null) {
          return downloadFileText(filename, json);
        }
        return false;
      };
      loadFileText = function(filepath, loadCallback, errorCallback) {
        loadFile("text", filepath, loadCallback, errorCallback);
      };
      loadFileJSON = function(filepath, loadCallback, errorCallback) {
        loadFile("json", filepath, loadCallback, errorCallback);
      };
      loadFile = function(responseBodyConversionFunction, filepath, loadCallback, errorCallback) {
        fetch(filepath).then(
          function(response) {
            if (response.ok) {
              response[responseBodyConversionFunction]().then(
                function(data) {
                  if (loadCallback) {
                    loadCallback(data);
                  }
                },
                function(response2) {
                  if (errorCallback != null) {
                    errorCallback(response2);
                  }
                }
              );
            } else {
              if (errorCallback != null) {
                errorCallback(response);
              }
            }
          },
          function(response) {
            if (errorCallback != null) {
              errorCallback(response);
            }
          }
        );
      };
    }
  });

  // js/labyroots/maze/maze.js
  var require_maze = __commonJS({
    "js/labyroots/maze/maze.js"() {
      Global.mySecretWall = null;
      Global.myIsWeddingTime = false;
      Global.myIsMazeverseTime = false;
      LR.Maze = class Maze {
        constructor(mazeSetup, parent) {
          this._myDefaultCellSize = 2;
          this._myCellSize = mazeSetup.myCellSize;
          this._myCells = [];
          this._myTopLeftPosition = PP.vec3_create();
          this._myMazeObjectsParent = parent.pp_addObject();
          this.createCells(mazeSetup);
          this._myCellCoordinates = [0, 0];
        }
        createCells(mazeSetup) {
          let isWedding = Global.isWedding();
          let isMazeverse = Global.isMazeverse();
          this._myGridToUse = mazeSetup.myGrid;
          Global.myIsWeddingTime = false;
          Global.myIsMazeverseTime = false;
          Global.myWinMazeverse = Global.mySaveManager.load("win_mazeverse", false);
          if (isMazeverse) {
            this._myGridToUse = Global.createMazeverseMaze();
            if (this._myGridToUse == null) {
              this._myGridToUse = mazeSetup.myGrid;
              Global.sendAnalytics("event", "mazeverse_maze_failed", {
                "value": 1
              });
            } else {
              Global.myIsMazeverseTime = true;
              Global.sendAnalytics("event", "is_mazeverse_maze", {
                "value": 1
              });
              if (!Global.myWinMazeverse) {
                Global.sendAnalytics("event", "is_mazeverse_maze_no_win", {
                  "value": 1
                });
              }
            }
          } else if (isWedding) {
            this._myGridToUse = mazeSetup.mySecretGrid;
            Global.myIsWeddingTime = true;
            Global.sendAnalytics("event", "is_wedding_maze", {
              "value": 1
            });
          } else {
            Global.sendAnalytics("event", "is_normal_maze", {
              "value": 1
            });
          }
          this._myTopLeftPosition = this.computeTopLeftPosition(mazeSetup);
          let grid = this._myGridToUse;
          for (let i = 0; i < grid.length; i++) {
            let row = grid[i];
            this._myCells[i] = [];
            for (let j = 0; j < row.length; j++) {
              let value = row[j];
              let intValue = parseInt(value);
              let mazeItemType = intValue;
              let fruits = 0;
              if (intValue >= 50) {
                mazeItemType = Math.floor(intValue / 10) * 10;
                fruits = intValue % 10;
              }
              let cell = new LR.MazeCell();
              cell.myCellCoordinates.vec2_set(i, j);
              cell.myCellSize = this._myCellSize;
              cell.myStaticMazeItemType = mazeItemType;
              cell.myFruits = fruits;
              cell.myCellPosition.vec3_copy(this._myTopLeftPosition);
              cell.myCellPosition.vec3_add([-(this._myCellSize / 2 + j * this._myCellSize), 0, -(this._myCellSize / 2 + i * this._myCellSize)], cell.myCellPosition);
              this._myCells[i][j] = cell;
            }
          }
        }
        computeTopLeftPosition(mazeSetup) {
          let row = this._myGridToUse.length;
          let column = this._myGridToUse[0].length;
          let width = column * this._myCellSize;
          let depth = row * this._myCellSize;
          let leftPosition = Math.floor(width / 2);
          leftPosition += leftPosition % 2;
          let topPosition = Math.floor(depth / 2);
          topPosition += topPosition % 2;
          return [leftPosition, 0, topPosition];
        }
        buildMaze() {
          this._myMazeItems = WL.scene.pp_getObjectByName("Maze Items");
          let cellCoordinatesList = [];
          for (let i = 0; i < this._myCells.length; i++) {
            let row = this._myCells[i];
            for (let j = 0; j < row.length; j++) {
              cellCoordinatesList.push([i, j]);
            }
          }
          let currentRow = Math.floor(this._myCells.length / 2);
          let currentColumn = Math.floor(this._myCells[0].length / 2);
          let found = false;
          for (let i = 0; i < this._myCells.length && !found; i++) {
            let row = this._myCells[i];
            for (let j = 0; j < row.length; j++) {
              let cell = row[j];
              if (cell.myStaticMazeItemType == LR.MazeItemType.BUILD_CELL) {
                currentRow = cell.myCellCoordinates[0];
                currentColumn = cell.myCellCoordinates[1];
                break;
              }
            }
          }
          let rowToAdd = 1;
          let currentRowToAdd = 1;
          let columnToAdd = 1;
          let currentColumnToAdd = 1;
          let cellCoordinatesListSpiral = [];
          let useRow = false;
          while (cellCoordinatesListSpiral.length < cellCoordinatesList.length) {
            cellCoordinatesListSpiral.pp_pushUnique([currentRow, currentColumn], (first, second) => first[0] == second[0] && first[1] == second[1]);
            if (useRow) {
              currentRow += Math.pp_sign(currentRowToAdd) * 1;
              let clampedCurrentRow = Math.pp_clamp(currentRow, 0, this._myCells.length - 1);
              if (clampedCurrentRow != currentRow) {
                currentRowToAdd -= Math.pp_sign(currentRowToAdd) * 1;
              }
              rowToAdd--;
              if (rowToAdd == 0) {
                useRow = false;
                currentRowToAdd += Math.pp_sign(currentRowToAdd) * 1;
                currentRowToAdd *= -1;
                rowToAdd = Math.abs(currentRowToAdd);
              }
            } else {
              currentColumn += Math.pp_sign(currentColumnToAdd) * 1;
              let clampedCurrentColumn = Math.pp_clamp(currentColumn, 0, this._myCells[0].length - 1);
              if (clampedCurrentColumn != currentColumn) {
                currentColumnToAdd -= Math.pp_sign(currentColumnToAdd) * 1;
              }
              columnToAdd--;
              if (columnToAdd == 0) {
                useRow = true;
                currentColumnToAdd += Math.pp_sign(currentColumnToAdd) * 1;
                currentColumnToAdd *= -1;
                columnToAdd = Math.abs(currentColumnToAdd);
              }
            }
            currentRow = Math.pp_clamp(currentRow, 0, this._myCells.length - 1);
            currentColumn = Math.pp_clamp(currentColumn, 0, this._myCells[0].length - 1);
          }
          let cellCoordinatesToBuildLater = [];
          for (let i = 0; i < cellCoordinatesListSpiral.length; i++) {
            if (i % 2 == 0) {
              this.buildCell(this._myCells[cellCoordinatesListSpiral[i][0]][cellCoordinatesListSpiral[i][1]]);
            } else {
              cellCoordinatesToBuildLater.unshift(cellCoordinatesListSpiral[i]);
            }
          }
          for (let cellCoordinates of cellCoordinatesToBuildLater) {
            this.buildCell(this._myCells[cellCoordinates[0]][cellCoordinates[1]]);
          }
        }
        getCellByPosition(position) {
          let cellCoordinates = this.convertCellPositionToCellCoordinates(position);
          let cell = null;
          if (this._myCells[cellCoordinates[0]] != null) {
            cell = this._myCells[cellCoordinates[0]][cellCoordinates[1]];
          }
          return cell;
        }
        getCellNextToPositionEmpty(position) {
          let cellCoordinates = this.convertCellPositionToCellCoordinates(position);
          let close = [];
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              if (!(i == 1 && j == 1)) {
                let row = cellCoordinates[0] - 1 + i;
                let column = cellCoordinates[1] - 1 + j;
                if (row >= 0 && row < this._myCells.length) {
                  if (column >= 0 && column < this._myCells[row].length) {
                    let currentCell = this._myCells[row][column];
                    if (currentCell.myStaticMazeItemType == LR.MazeItemType.NONE || currentCell.myStaticMazeItemType == LR.MazeItemType.HUMAN_TREE_0 || currentCell.myStaticMazeItemType == LR.MazeItemType.HUMAN_TREE_1 || currentCell.myStaticMazeItemType == LR.MazeItemType.HUMAN_TREE_2 || currentCell.myStaticMazeItemType == LR.MazeItemType.HUMAN_TREE_3 || currentCell.myStaticMazeItemType == LR.MazeItemType.CREDITS || currentCell.myStaticMazeItemType == LR.MazeItemType.SECRET_CODES || currentCell.myStaticMazeItemType == LR.MazeItemType.ZESTY || currentCell.myStaticMazeItemType == LR.MazeItemType.SECRET_ZONE_CHECK || currentCell.myStaticMazeItemType == LR.MazeItemType.LEADERBOARD_TOP_10 || currentCell.myStaticMazeItemType == LR.MazeItemType.LEADERBOARD_AROUND_U || currentCell.myStaticMazeItemType == LR.MazeItemType.BUILD_CELL) {
                      close.push(currentCell);
                    }
                  }
                }
              }
            }
          }
          return close;
        }
        convertCellPositionToCellCoordinates(position) {
          let cellCoordinates = this._myCellCoordinates.vec3_zero();
          let positionTopLeft = position.vec3_sub(this._myTopLeftPosition);
          cellCoordinates[0] = Math.max(0, -(Math.floor(positionTopLeft[2] / this._myCellSize) + 1));
          cellCoordinates[1] = Math.max(0, -(Math.floor(positionTopLeft[0] / this._myCellSize) + 1));
          return cellCoordinates;
        }
        convertCellCoordinatesToCellPosition(cellCoordinates) {
          let position = [-(this._myCellSize / 2 + cellCoordinates[1] * this._myCellSize), 0, -(this._myCellSize / 2 + cellCoordinates[0] * this._myCellSize)];
          return position;
        }
        getCellsByType(itemType) {
          let cells = [];
          for (let i = 0; i < this._myCells.length; i++) {
            let row = this._myCells[i];
            for (let j = 0; j < row.length; j++) {
              if (row[j].myStaticMazeItemType == itemType) {
                cells.push(row[j]);
              }
            }
          }
          return cells;
        }
        buildCell(cell) {
          if (cell.myStaticMazeItemType != LR.MazeItemType.NONE) {
            let cellType = cell.myStaticMazeItemType;
            if (cellType == LR.MazeItemType.HUMAN_TREE_0) {
              let types = [];
              types.push(Global.myPerfectFruit);
              for (let i = 0; i < Global.mySetup.myTreeSetup.myPerfectTreeRatio; i++) {
                types.push(Global.myGoodFruit);
                types.push(Global.myBadFruit);
              }
              cellType = Math.pp_randomPick(types);
            }
            let cellItems = this._myMazeItems.pp_getObjectByNameChildren("" + cellType);
            if (cellItems != null) {
              let randomChild = Math.pp_randomPick(cellItems.pp_getChildren());
              if (randomChild != null) {
                let oldChildPosition = randomChild.pp_getPosition();
                randomChild.pp_setPosition(cell.myCellPosition);
                let objectToSpawn = randomChild.pp_clone();
                objectToSpawn.pp_setActive(true);
                objectToSpawn.pp_setParent(this._myMazeObjectsParent);
                cell.myObject = objectToSpawn;
                randomChild.pp_setPosition(oldChildPosition);
                if (cell.myFruits > 0) {
                  let tree = objectToSpawn.pp_getComponent("human-tree");
                  if (tree != null) {
                    tree.spawnFruits(cell.myFruits);
                  }
                }
                if (cell.myStaticMazeItemType == LR.MazeItemType.BIG_TREE_FIRST_ROOT) {
                  Global.myAxeParent = objectToSpawn.pp_getComponent("billboard-player").object;
                  Global.myAxe.pp_setParent(objectToSpawn.pp_getComponent("billboard-player").object);
                  let axeComponent = Global.myAxe.pp_getComponent("axe");
                  if (axeComponent != null) {
                    axeComponent.setStartTransforms(cell.myCellPosition);
                  }
                  Global.myAxeCell = cell;
                }
                if (cellType == LR.MazeItemType.SECRET_WALL) {
                  Global.mySecretWall = objectToSpawn;
                }
              }
            }
          }
        }
      };
      Global.myAxeCell = null;
      Global.myAxeParent = null;
      LR.MazeCell = class MazeCell {
        constructor() {
          this.myCellCoordinates = PP.vec2_create();
          this.myCellPosition = PP.vec3_create();
          this.myCellSize = 0;
          this.myHorizontalDirection = PP.vec3_create(0, 0, 1);
          this.myUpDirection = PP.vec3_create(0, 0, 1);
          this.myStaticMazeItemType = LR.MazeItemType.NONE;
          this.myFruits = 0;
          this.myObject = null;
          this._myVector = [0, 0, 0];
        }
        getRandomPositionOnCell() {
          let randomDistance = Math.pp_random(0, this.myCellSize / 2);
          let randomAngle = Math.pp_random(0, 360);
          let randomDirection = this.myHorizontalDirection.vec3_rotateAxis(randomAngle, PP.vec3_create(0, 1, 0), this._myVector);
          randomDirection.vec3_scale(randomDistance, randomDirection);
          let randomPosition = this.myCellPosition.vec3_add(randomDirection, randomDirection);
          return randomPosition;
        }
      };
      Global.isWedding = function() {
        let isWedding = Global.mySaveManager.load("is_wedding", false);
        if (!isWedding) {
          try {
            let urlSearchParams = new URL(window.location).searchParams;
            if (urlSearchParams != null && urlSearchParams.get("wedding") == "true") {
              isWedding = true;
            }
          } catch (error) {
          }
        }
        return isWedding;
      };
      Global.isMazeverse = function() {
        let isMazeverse = Global.mySaveManager.load("is_mazeverse", false);
        if (!isMazeverse) {
          try {
            let urlSearchParams = new URL(window.location).searchParams;
            if (urlSearchParams != null && urlSearchParams.get("mazeverse") == "true") {
              isMazeverse = true;
            }
          } catch (error) {
          }
        }
        return isMazeverse && !Global.isWedding();
      };
    }
  });

  // js/labyroots/maze/maze_item_type.js
  var require_maze_item_type = __commonJS({
    "js/labyroots/maze/maze_item_type.js"() {
      LR.MazeItemType = {
        NONE: 0,
        NO_HUMAN_TREE: 1,
        CREDITS: 2,
        SECRET_CODES: 3,
        ZESTY: 4,
        SECRET_WALL: 5,
        SECRET_ZONE_CHECK: 6,
        LEADERBOARD_TOP_10: 7,
        LEADERBOARD_AROUND_U: 8,
        BUILD_CELL: 9,
        PLAYER_START: 10,
        PLAYER_RESPAWN: 11,
        WONDERMELON: 12,
        BIG_TREE: 20,
        BIG_TREE_HEART: 21,
        BIG_TREE_ROOT: 22,
        BIG_TREE_WALL_HORIZONTAL: 23,
        BIG_TREE_WALL_VERTICAL: 24,
        BIG_TREE_FIRST_ROOT: 25,
        ROCK_WALL_HORIZONTAL: 30,
        ROCK_WALL_VERTICAL: 31,
        ROCK_WALL_TOP_LEFT: 32,
        ROCK_WALL_TOP_RIGHT: 33,
        ROCK_WALL_BOTTOM_LEFT: 34,
        ROCK_WALL_BOTTOM_RIGHT: 35,
        ROCK_WALL_T_UP: 36,
        ROCK_WALL_T_RIGHT: 37,
        ROCK_WALL_T_DOWN: 38,
        ROCK_WALL_T_LEFT: 39,
        ROCK_WALL_CROSS: 40,
        HUMAN_TREE_0: 50,
        HUMAN_TREE_1: 60,
        HUMAN_TREE_2: 70,
        HUMAN_TREE_3: 80,
        HUMAN_TREE_4: 90
      };
    }
  });

  // js/labyroots/maze/mazeverse_maze.js
  var require_mazeverse_maze = __commonJS({
    "js/labyroots/maze/mazeverse_maze.js"() {
      LR.CreateWallsResults = class CreateWallsResults {
        constructor() {
          this.myFreeCells = [];
          this.myWallCells = [];
          this.myDoors = [];
          this.myNoDoors = false;
          this.myBigTreeRoom = null;
          this.myBigTreeRoomSize = null;
          this.myPlayerRoom = null;
          this.myPlayerRoomSize = null;
          this.myWoodsRoom = null;
          this.myWoodsRoomSize = null;
        }
        reset() {
          this.myNoDoors = false;
          this.myFreeCells = [];
          this.myWallCells = [];
          this.myDoors = [];
          this.myBigTreeRoom = null;
          this.myPlayerRoom = null;
          this.myWoodsRoom = null;
        }
      };
      Global.cellCoordinatesEqual = function(first, second) {
        return first[0] == second[0] && first[1] == second[1];
      };
      Global.doorsEqual = function(first, second) {
        let equal = true;
        if (first.length != second.length) {
          equal = false;
        } else {
          for (let i = 0; i < first.length; i++) {
            if (first[i] != second[i]) {
              equal = false;
              break;
            }
          }
        }
        return equal;
      };
      Global.createMazeverseMaze = function() {
        let maxAttempts = 10;
        let maze = null;
        while (maxAttempts > 0 && maze == null) {
          maxAttempts--;
          try {
            maze = Global.initializeMaze();
            let createWallsResults = new LR.CreateWallsResults();
            let createWallsMaxAttempts = 100;
            let returnedCreateWallsResults = null;
            Global.chooseSpecialRoomSetups(createWallsResults);
            do {
              Global.emptyMaze(maze);
              createWallsMaxAttempts--;
              createWallsResults.reset();
              returnedCreateWallsResults = Global.createWalls(maze, createWallsResults);
              if (returnedCreateWallsResults == null) {
                if (Global.myFromAbove) {
                  console.error("Create Walls Failed:", 100 - createWallsMaxAttempts);
                }
              }
            } while (returnedCreateWallsResults == null && createWallsMaxAttempts > 0);
            createWallsResults = returnedCreateWallsResults;
            if (createWallsResults == null) {
              throw "Create Wall Failed";
            }
            let addElementsResult = false;
            let addElementsMaxAttempts = 100;
            let mazeClone = [];
            for (let i = 0; i < maze.length; i++) {
              mazeClone[i] = [];
              let row = maze[i];
              for (let j = 0; j < row.length; j++) {
                mazeClone[i][j] = maze[i][j];
              }
            }
            do {
              for (let i = 0; i < mazeClone.length; i++) {
                let row = mazeClone[i];
                for (let j = 0; j < row.length; j++) {
                  maze[i][j] = mazeClone[i][j];
                }
              }
              addElementsMaxAttempts--;
              addElementsResult = Global.addElementsToMaze(maze, createWallsResults);
              if (!addElementsResult) {
                if (Global.myFromAbove) {
                  console.error("Add Elements Failed:", 100 - addElementsMaxAttempts);
                }
              }
            } while (!addElementsResult && addElementsMaxAttempts > 0);
            if (!addElementsResult) {
              throw "Add Elements Failed";
            }
            Global.adjustMazeWalls(maze);
          } catch (error) {
            if (Global.myFromAbove) {
              console.error("FAIL - Attempt:", 10 - maxAttempts, "- Error:", error);
            }
            maze = null;
          }
        }
        return maze;
      };
      Global.initializeMaze = function() {
        let maze = [];
        let rowMax = Math.pp_randomPick(26, 30);
        let columnMax = Math.pp_randomPick(26, 30);
        if (!Global.myWinMazeverse) {
          rowMax = 26;
          columnMax = 26;
        }
        let rowMin = Math.pp_randomPick(20, 21);
        let columnMin = Math.pp_randomPick(20, 21);
        let rows = Math.pp_randomInt(rowMin, rowMax);
        let columns = Math.pp_randomInt(columnMin, columnMax);
        for (let i = 0; i < rows; i++) {
          maze[i] = [];
          for (let j = 0; j < columns; j++) {
            maze[i][j] = LR.MazeItemType.NONE;
          }
        }
        if (Global.myFromAbove) {
          console.error("Size: [", rows, ",", columns, "]");
        }
        return maze;
      };
      Global.emptyMaze = function(maze) {
        for (let i = 0; i < maze.length; i++) {
          let row = maze[i];
          for (let j = 0; j < row.length; j++) {
            maze[i][j] = LR.MazeItemType.NONE;
          }
        }
      };
      Global.convertMazeToString = function(maze) {
        for (let i = 0; i < maze.length; i++) {
          let row = maze[i];
          for (let j = 0; j < row.length; j++) {
            maze[i][j] = row[j].toString();
            if (maze[i][j].length < 2) {
              maze[i][j] = "0" + maze[i][j];
            }
          }
        }
      };
      Global.lookPlayerAligned = function(position) {
        let rotationQuat = PP.quat_create();
        let cell = Global.myMaze.getCellsByType(LR.MazeItemType.PLAYER_START);
        if (cell != null && cell.length > 0) {
          let cellPosition = cell[0].myCellPosition;
          let direction = cellPosition.vec3_sub(position).vec3_removeComponentAlongAxis([0, 1, 0]);
          if (!direction.vec3_isZero(1e-5)) {
            direction.vec3_normalize(direction);
            if (Math.abs(direction[0]) > Math.abs(direction[2])) {
              direction = [1 * Math.pp_sign(direction[0]), 0, 0];
            } else {
              direction = [0, 0, 1 * Math.pp_sign(direction[2])];
            }
            direction.vec3_normalize(direction);
          }
          rotationQuat.quat_setUp([0, 1, 0], direction);
        }
        return rotationQuat;
      };
      Global.lookBigTreeAligned = function(position) {
        let rotationQuat = PP.quat_create();
        let cell = Global.myMaze.getCellsByType(LR.MazeItemType.BIG_TREE);
        if (cell != null && cell.length > 0) {
          let cellPosition = cell[0].myCellPosition;
          let direction = cellPosition.vec3_sub(position).vec3_removeComponentAlongAxis([0, 1, 0]);
          if (!direction.vec3_isZero(1e-5)) {
            direction.vec3_normalize(direction);
            if (Math.abs(direction[0]) > Math.abs(direction[2])) {
              direction = [1 * Math.pp_sign(direction[0]), 0, 0];
            } else {
              direction = [0, 0, 1 * Math.pp_sign(direction[2])];
            }
            direction.vec3_normalize(direction);
          }
          rotationQuat.quat_setUp([0, 1, 0], direction);
        }
        return rotationQuat;
      };
    }
  });

  // js/labyroots/maze/mazeverse_create_walls.js
  var require_mazeverse_create_walls = __commonJS({
    "js/labyroots/maze/mazeverse_create_walls.js"() {
      Global.createWalls = function(maze, createWallsResults) {
        for (let i = 1; i < maze.length - 1; i++) {
          let row = maze[i];
          for (let j = 1; j < row.length - 1; j++) {
            createWallsResults.myFreeCells.pp_pushUnique([i, j], Global.cellCoordinatesEqual);
          }
        }
        for (let i = 0; i < maze.length; i++) {
          let row = maze[i];
          for (let j = 0; j < row.length; j++) {
            if (i < 1 || i > maze.length - 2 || j < 1 || j > row.length - 2) {
              maze[i][j] = LR.MazeItemType.ROCK_WALL_HORIZONTAL;
            }
          }
        }
        let rooms = [[[1, 1], [maze.length - 2, maze[0].length - 2], Math.pp_randomInt(0, 1)]];
        while (rooms.length > 0) {
          let room = Math.pp_randomPick(rooms);
          rooms.pp_removeEqual(room);
          if (!Global.useAsSpecialRoom(room, createWallsResults)) {
            if (!Global.skipRoom(room, createWallsResults)) {
              let start = room[0];
              let end = room[1];
              let usedRow = room[1];
              let wall = null;
              let useRow = false;
              let maxAttempts = 100;
              while (wall == null && maxAttempts > 0) {
                maxAttempts--;
                let wallAttempt = [[], []];
                let rowColumnDiff = start[1] - start[0] - (end[1] - end[0]);
                if (rowColumnDiff < 0) {
                  useRow = Math.pp_randomInt(0, Math.ceil(Math.abs(rowColumnDiff) / (usedRow ? 0.5 : 2))) == 0;
                } else if (rowColumnDiff > 0) {
                  useRow = Math.pp_randomInt(0, Math.ceil(rowColumnDiff / (usedRow ? 2 : 0.5))) != 0;
                } else {
                  if (usedRow) {
                    useRow = Math.pp_randomInt(0, 2) == 0;
                  } else {
                    useRow = Math.pp_randomInt(0, 2) != 0;
                  }
                }
                if (useRow) {
                  let difference = end[0] - start[0];
                  let extraDistance = Math.floor(difference / 4);
                  let extraDistanceMultiplier = Math.pp_randomPick(1, 1, 1, 1, 0.5, 0.5, 0);
                  extraDistance = Math.ceil(extraDistance * extraDistanceMultiplier);
                  let startFixed = start[0] + 1 + extraDistance;
                  let endFixed = end[0] - 1 - extraDistance;
                  if (endFixed - startFixed >= 0) {
                    wallAttempt[0][0] = Math.pp_randomInt(startFixed, endFixed);
                    wallAttempt[0][1] = start[1];
                    wallAttempt[1][0] = wallAttempt[0][0];
                    wallAttempt[1][1] = end[1];
                    if (maze[wallAttempt[0][0]][wallAttempt[0][1] - 1] == LR.MazeItemType.ROCK_WALL_HORIZONTAL && maze[wallAttempt[1][0]][wallAttempt[1][1] + 1] == LR.MazeItemType.ROCK_WALL_HORIZONTAL) {
                      wall = wallAttempt;
                    }
                  }
                } else {
                  let difference = end[1] - start[1];
                  let extraDistance = Math.floor(difference / 4);
                  let extraDistanceMultiplier = Math.pp_randomPick(1, 1, 1, 1, 0.5, 0.5, 0);
                  extraDistance = Math.round(extraDistance * extraDistanceMultiplier);
                  let startFixed = start[1] + 1 + extraDistance;
                  let endFixed = end[1] - 1 - extraDistance;
                  if (endFixed - startFixed >= 0) {
                    wallAttempt[0][1] = Math.pp_randomInt(startFixed, endFixed);
                    wallAttempt[0][0] = start[0];
                    wallAttempt[1][1] = wallAttempt[0][1];
                    wallAttempt[1][0] = end[0];
                    if (maze[wallAttempt[0][0] - 1][wallAttempt[0][1]] == LR.MazeItemType.ROCK_WALL_HORIZONTAL && maze[wallAttempt[1][0] + 1][wallAttempt[1][1]] == LR.MazeItemType.ROCK_WALL_HORIZONTAL) {
                      wall = wallAttempt;
                    }
                  }
                }
                if (wall != null) {
                  if (wall[1][0] - wall[0][0] < 1 && wall[1][1] - wall[0][1] < 1) {
                    wall = null;
                  }
                }
              }
              if (wall != null) {
                let wallCells = [];
                if (useRow) {
                  let rowStart = wall[0][0];
                  let columnStart = wall[0][1];
                  for (let i = 0; i <= wall[1][1] - wall[0][1]; i++) {
                    wallCells.push([rowStart, columnStart + i]);
                  }
                } else {
                  let rowStart = wall[0][0];
                  let columnStart = wall[0][1];
                  for (let i = 0; i <= wall[1][0] - wall[0][0]; i++) {
                    wallCells.push([rowStart + i, columnStart]);
                  }
                }
                for (let wallCell of wallCells) {
                  createWallsResults.myWallCells.pp_pushUnique(wallCell, Global.cellCoordinatesEqual);
                  createWallsResults.myFreeCells.pp_removeEqual(wallCell, Global.cellCoordinatesEqual);
                  maze[wallCell[0]][wallCell[1]] = LR.MazeItemType.ROCK_WALL_HORIZONTAL;
                }
                if (useRow) {
                  let upRoom = [[start[0], start[1]], [wall[0][0] - 1, end[1]], useRow];
                  let bottomRoom = [[wall[0][0] + 1, start[1]], [end[0], end[1]], useRow];
                  rooms.push(upRoom);
                  rooms.push(bottomRoom);
                } else {
                  let leftRoom = [[start[0], start[1]], [end[0], wall[0][1] - 1], useRow];
                  let rightRoom = [[start[0], wall[0][1] + 1], [end[0], end[1]], useRow];
                  rooms.push(leftRoom);
                  rooms.push(rightRoom);
                }
                if (!Global.addDoorToWall(wallCells, useRow, maze, createWallsResults)) {
                  if (Global.myFromAbove) {
                    console.error("CAN'T CREATE DOOR");
                  }
                  return null;
                }
              } else {
              }
            }
          }
        }
        if (Math.pp_randomInt(0, 9) != 0) {
          Global.addExtraDoors(maze, createWallsResults);
        }
        let reachable = Global.checkFreeCellsReachable(maze, createWallsResults, false);
        if (!reachable) {
          if (Global.myFromAbove) {
            console.error("NOT REACHABLE");
          }
          return null;
        }
        if (createWallsResults.myBigTreeRoomSize != null && createWallsResults.myBigTreeRoom == null || createWallsResults.myPlayerRoomSize != null && createWallsResults.myPlayerRoom == null || createWallsResults.myWoodsRoomSize != null && createWallsResults.myWoodsRoom == null) {
          if (Global.myFromAbove) {
            console.error("SPECIAL ROOMS FAILURE");
          }
          return null;
        }
        if (createWallsResults.myFreeCells.length < 50) {
          if (Global.myFromAbove) {
            console.error("TOO FEW FREE CELLS");
          }
          return null;
        }
        return createWallsResults;
      };
      Global.skipRoom = function(room, createWallsResults) {
        let skipRoom = false;
        let start = room[0];
        let end = room[1];
        if (end[0] - start[0] <= 0 || end[1] - start[1] <= 0) {
          skipRoom = true;
        } else if (end[0] - start[0] <= 1 && end[1] - start[1] <= 1) {
          skipRoom = true;
        }
        return skipRoom;
      };
      Global.useAsSpecialRoom = function(room, createWallsResults) {
        let used = false;
        let rows = room[1][0] - room[0][0] + 1;
        let columns = room[1][1] - room[0][1] + 1;
        if (createWallsResults.myBigTreeRoomSize != null && createWallsResults.myBigTreeRoom == null) {
          if (rows == createWallsResults.myBigTreeRoomSize[0] && columns == createWallsResults.myBigTreeRoomSize[1] || rows == createWallsResults.myBigTreeRoomSize[1] && columns == createWallsResults.myBigTreeRoomSize[0]) {
            createWallsResults.myBigTreeRoom = room;
            used = true;
          }
        }
        if (!used) {
          if (createWallsResults.myPlayerRoomSize != null && createWallsResults.myPlayerRoom == null) {
            if (rows == createWallsResults.myPlayerRoomSize[0] && columns == createWallsResults.myPlayerRoomSize[1] || rows == createWallsResults.myPlayerRoomSize[1] && columns == createWallsResults.myPlayerRoomSize[0]) {
              createWallsResults.myPlayerRoom = room;
              used = true;
            }
          }
        }
        if (!used) {
          if (createWallsResults.myWoodsRoomSize != null && createWallsResults.myWoodsRoom == null) {
            if (rows == createWallsResults.myWoodsRoomSize[0] && columns == createWallsResults.myWoodsRoomSize[1] || rows == createWallsResults.myWoodsRoomSize[1] && columns == createWallsResults.myWoodsRoomSize[0]) {
              createWallsResults.myWoodsRoom = room;
              used = true;
            }
          }
        }
        return used;
      };
      Global.adjustMazeWalls = function(maze) {
        for (let i = 0; i < maze.length; i++) {
          let row = maze[i];
          for (let j = 0; j < row.length; j++) {
            let item = row[j];
            if (item >= LR.MazeItemType.ROCK_WALL_HORIZONTAL && item <= LR.MazeItemType.ROCK_WALL_CROSS) {
              let left = Global.isWallType(j == 0 ? LR.MazeItemType.NONE : row[j - 1], true);
              let right = Global.isWallType(j == row.length - 1 ? LR.MazeItemType.NONE : row[j + 1], true);
              let up = Global.isWallType(i == 0 ? LR.MazeItemType.NONE : maze[i - 1][j], true);
              let bottom = Global.isWallType(i == maze.length - 1 ? LR.MazeItemType.NONE : maze[i + 1][j], true);
              if (left && right && !up && !bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_HORIZONTAL;
              } else if (!left && !right && up && bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_VERTICAL;
              } else if (left && !right && up && bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_T_LEFT;
              } else if (!left && right && up && bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_T_RIGHT;
              } else if (left && right && !up && bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_T_DOWN;
              } else if (left && right && up && !bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_T_UP;
              } else if (left && !right && up && !bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_BOTTOM_LEFT;
              } else if (left && !right && !up && bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_TOP_LEFT;
              } else if (!left && right && !up && bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_TOP_RIGHT;
              } else if (!left && right && up && !bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_BOTTOM_RIGHT;
              } else if (!left && right && !up && !bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_HORIZONTAL;
              } else if (left && !right && !up && !bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_HORIZONTAL;
              } else if (!left && !right && up && !bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_VERTICAL;
              } else if (!left && !right && !up && bottom) {
                row[j] = LR.MazeItemType.ROCK_WALL_VERTICAL;
              } else {
                row[j] = LR.MazeItemType.ROCK_WALL_CROSS;
              }
            }
          }
        }
      };
      Global.checkFreeCellsReachable = function(maze, createWallsResults, rootWallsBlock = false) {
        let freeCellsReachable = true;
        let startCell = Math.pp_randomPick(createWallsResults.myFreeCells);
        let reachableCells = Global.getReachableCells(startCell, maze, rootWallsBlock);
        if (reachableCells.length != createWallsResults.myFreeCells.length) {
          freeCellsReachable = false;
        } else {
          for (let reachableCell of reachableCells) {
            if (!createWallsResults.myFreeCells.pp_hasEqual(reachableCell, Global.cellCoordinatesEqual)) {
              freeCellsReachable = false;
              break;
            }
          }
        }
        return freeCellsReachable;
      };
      Global.getReachableCells = function(startCell, maze, rootWallsBlock = false) {
        let reachableCells = [];
        let cellsToExplore = [];
        cellsToExplore.push(startCell);
        let exploredCells = [];
        while (cellsToExplore.length > 0) {
          let currentCell = cellsToExplore.shift();
          reachableCells.pp_pushUnique(currentCell, Global.cellCoordinatesEqual);
          exploredCells.pp_pushUnique(currentCell, Global.cellCoordinatesEqual);
          let neighborCells = [];
          neighborCells.push([currentCell[0] + 1, currentCell[1]]);
          neighborCells.push([currentCell[0], currentCell[1] + 1]);
          neighborCells.push([currentCell[0] - 1, currentCell[1]]);
          neighborCells.push([currentCell[0], currentCell[1] - 1]);
          for (let neighborCell of neighborCells) {
            if (!exploredCells.pp_hasEqual(neighborCell, Global.cellCoordinatesEqual)) {
              if (neighborCell[0] >= 0 && neighborCell[0] <= maze.length - 1) {
                if (neighborCell[1] >= 0 && neighborCell[1] <= maze[0].length - 1) {
                  let mazeCell = maze[neighborCell[0]][neighborCell[1]];
                  if (mazeCell < LR.MazeItemType.ROCK_WALL_HORIZONTAL || mazeCell > LR.MazeItemType.ROCK_WALL_CROSS) {
                    if (!rootWallsBlock || mazeCell != LR.MazeItemType.BIG_TREE_WALL_HORIZONTAL && mazeCell != LR.MazeItemType.BIG_TREE_WALL_VERTICAL) {
                      cellsToExplore.pp_pushUnique(neighborCell, Global.cellCoordinatesEqual);
                    }
                  }
                }
              }
            }
          }
        }
        return reachableCells;
      };
      Global.isWallType = function(type, rootWallIsWall = false) {
        let isWallType = false;
        if (type >= LR.MazeItemType.ROCK_WALL_HORIZONTAL && type <= LR.MazeItemType.ROCK_WALL_CROSS) {
          isWallType = true;
        } else if (rootWallIsWall) {
          if (type == LR.MazeItemType.BIG_TREE_WALL_HORIZONTAL || type == LR.MazeItemType.BIG_TREE_WALL_VERTICAL) {
            isWallType = true;
          }
        }
        return isWallType;
      };
      Global.addDoorToWall = function(wallCells, useRow, maze, createWallsResults) {
        let door = null;
        let maxAttempts = 100;
        let amountChance = [];
        let chance1 = Math.max(Math.ceil(49 / wallCells.length), 3);
        for (let i = 0; i < chance1; i++) {
          amountChance.push(1);
        }
        amountChance.push(2, 2, 2, 3);
        while (door == null && maxAttempts > 0) {
          maxAttempts--;
          let doorCell = Math.pp_randomPick(wallCells);
          let amount = Math.pp_randomPick(amountChance);
          door = Global.addDoorToMaze(doorCell, amount, maze);
        }
        if (door != null) {
          Global.addDoorToResults(door, maze, createWallsResults);
        }
        return door != null;
      };
      Global.addExtraDoors = function(maze, createWallsResults) {
        let doorsAmount = createWallsResults.myDoors.length;
        let extraDoors = Math.pp_randomInt(Math.round(doorsAmount * 1), Math.round(doorsAmount * 1.25));
        extraDoors = Math.round(doorsAmount / Math.pp_random(4, 6));
        if (Math.pp_randomInt(0, 9) == 0) {
          createWallsResults.myNoDoors = true;
          extraDoors = extraDoors * 1e3;
        }
        let maxRetry = extraDoors * 100;
        for (let i = 0; i < extraDoors; i++) {
          let doorCell = Math.pp_randomPick(createWallsResults.myWallCells);
          if (doorCell != null) {
            let amount = Math.pp_randomPick(1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3);
            let door = Global.addDoorToMaze(doorCell, amount, maze);
            if (door != null) {
              Global.addDoorToResults(door, maze, createWallsResults, true);
            }
            if (door == null && maxRetry > 0) {
              maxRetry--;
              i--;
            }
          }
        }
      };
      Global.addDoorToResults = function(door, maze, createWallsResults, isExtra) {
        for (let i = 1; i < door.length; i++) {
          let doorCell = door[i];
          if (isExtra) {
            maze[doorCell[0]][doorCell[1]] = LR.MazeItemType.NONE;
          } else {
            maze[doorCell[0]][doorCell[1]] = LR.MazeItemType.NONE;
          }
          createWallsResults.myWallCells.pp_removeEqual(doorCell, Global.cellCoordinatesEqual);
          createWallsResults.myFreeCells.pp_pushUnique(doorCell, Global.cellCoordinatesEqual);
        }
        createWallsResults.myDoors.pp_pushUnique(door, Global.doorsEqual);
      };
      Global.addDoorToMaze = function(doorCell, amount, maze) {
        let doorDirection = Global.getDoorDirection(doorCell, maze);
        if (doorDirection == null) {
          return null;
        }
        let door = [doorDirection];
        let doorCellsToReturn = [];
        let doorCellsVisited = [];
        let doorCells = [];
        doorCells.push(doorCell);
        while (doorCells.length > 0 && amount > 0) {
          let currentCell = Math.pp_randomPick(doorCells);
          doorCellsVisited.pp_pushUnique(currentCell, Global.cellCoordinatesEqual);
          doorCells.pp_removeEqual(currentCell, Global.cellCoordinatesEqual);
          let currentCellDirection = Global.getDoorDirection(currentCell, maze);
          if (currentCellDirection == doorDirection) {
            let backupMazeCell = maze[currentCell[0]][currentCell[1]];
            maze[currentCell[0]][currentCell[1]] = LR.MazeItemType.NONE;
            let isOk = true;
            if (doorDirection) {
              let leftIsAlone = Global.isAloneWall([currentCell[0], currentCell[1] - 1], maze);
              let rightIsAlone = Global.isAloneWall([currentCell[0], currentCell[1] + 1], maze);
              if (leftIsAlone || rightIsAlone) {
                isOk = false;
              }
            } else {
              let upIsAlone = Global.isAloneWall([currentCell[0] - 1, currentCell[1]], maze);
              let bottomIsAlone = Global.isAloneWall([currentCell[0] + 1, currentCell[1]], maze);
              if (upIsAlone || bottomIsAlone) {
                isOk = false;
              }
            }
            maze[currentCell[0]][currentCell[1]] = backupMazeCell;
            if (isOk) {
              amount--;
              doorCellsToReturn.pp_pushUnique(currentCell, Global.cellCoordinatesEqual);
              if (doorDirection) {
                doorCells.pp_pushUnique([currentCell[0], currentCell[1] - 1], Global.cellCoordinatesEqual);
                doorCells.pp_pushUnique([currentCell[0], currentCell[1] + 1], Global.cellCoordinatesEqual);
              } else {
                doorCells.pp_pushUnique([currentCell[0] - 1, currentCell[1]], Global.cellCoordinatesEqual);
                doorCells.pp_pushUnique([currentCell[0] + 1, currentCell[1]], Global.cellCoordinatesEqual);
              }
              for (let doorCellVisited of doorCellsVisited) {
                doorCells.pp_removeEqual(doorCellVisited, Global.cellCoordinatesEqual);
              }
            }
          }
        }
        for (let doorCellToReturn of doorCellsToReturn) {
          door.push(doorCellToReturn);
        }
        return door.length > 1 ? door : null;
      };
      Global.getDoorDirection = function(doorCell, maze) {
        let doorDirection = null;
        let left = Global.isWallType(doorCell[1] == 0 ? LR.MazeItemType.NONE : maze[doorCell[0]][doorCell[1] - 1]);
        let right = Global.isWallType(doorCell[1] == maze[0].length - 1 ? LR.MazeItemType.NONE : maze[doorCell[0]][doorCell[1] + 1]);
        let up = Global.isWallType(doorCell[0] == 0 ? LR.MazeItemType.NONE : maze[doorCell[0] - 1][doorCell[1]]);
        let bottom = Global.isWallType(doorCell[0] == maze.length - 1 ? LR.MazeItemType.NONE : maze[doorCell[0] + 1][doorCell[1]]);
        if (left && right && !up && !bottom) {
          doorDirection = true;
        } else if (!left && !right && up && bottom) {
          doorDirection = false;
        }
        return doorDirection;
      };
      Global.isAloneWall = function(wallCell, maze) {
        let isAlone = true;
        let left = Global.isWallType(wallCell[1] == 0 ? LR.MazeItemType.NONE : maze[wallCell[0]][wallCell[1] - 1]);
        let right = Global.isWallType(wallCell[1] == maze[0].length - 1 ? LR.MazeItemType.NONE : maze[wallCell[0]][wallCell[1] + 1]);
        let up = Global.isWallType(wallCell[0] == 0 ? LR.MazeItemType.NONE : maze[wallCell[0] - 1][wallCell[1]]);
        let bottom = Global.isWallType(wallCell[0] == maze.length - 1 ? LR.MazeItemType.NONE : maze[wallCell[0] + 1][wallCell[1]]);
        if (left || right || up || bottom) {
          isAlone = false;
        } else if (!Global.isWallType(maze[wallCell[0]][wallCell[1]])) {
          isAlone = false;
        }
        return isAlone;
      };
      Global.chooseSpecialRoomSetups = function(createWallsResults) {
        let bigTreeSize = [0, 0];
        {
          let randomSizes = [Math.pp_randomInt(3, 5), Math.pp_randomInt(3, 4)];
          let first = Math.pp_randomInt(0, 1);
          bigTreeSize[0] = randomSizes[first];
          bigTreeSize[1] = randomSizes[(first + 1) % 2];
          createWallsResults.myBigTreeRoomSize = bigTreeSize;
        }
        let createPlayerRoom = Math.pp_randomInt(0, 4) != 0;
        if (createPlayerRoom || !Global.myWinMazeverse) {
          createWallsResults.myPlayerRoomSize = [Math.pp_randomInt(3, 4), Math.pp_randomInt(3, 4)];
        }
        let specialRoom = Math.pp_randomInt(0, 2) == 0;
        if (specialRoom) {
          createWallsResults.myWoodsRoomSize = [Math.pp_randomInt(3, 5), Math.pp_randomInt(3, 5)];
        }
      };
    }
  });

  // js/labyroots/maze/mazeverse_add_elements.js
  var require_mazeverse_add_elements = __commonJS({
    "js/labyroots/maze/mazeverse_add_elements.js"() {
      LR.AddElemenstResults = class AddElemenstResults {
        constructor() {
          this.myRootsMustBeFar = false;
          this.myTreesMustBeFar = false;
          this.myRootsToAdd = 3;
          this.myAllElements = [];
          this.myElementsFar = [];
          this.myRootsFar = [];
          this.myTreesFar = [];
          this.myTreesFar = [];
          this.myZestiesFar = [];
          this.myPlayer = [0, 0];
          this.myFirstRoot = [0, 0];
        }
      };
      Global.addElementsToMaze = function(maze, createWallsResults) {
        let freeCells = createWallsResults.myFreeCells.pp_clone();
        let doors = createWallsResults.myDoors.pp_clone();
        let addElementsResults = new LR.AddElemenstResults();
        addElementsResults.myRootsMustBeFar = Math.pp_randomInt(0, 4) != 0;
        addElementsResults.myTreesMustBeFar = Math.pp_randomInt(0, 4) != 0;
        if (createWallsResults.myWoodsRoom != null) {
          Global.addWoods(maze, createWallsResults, freeCells, addElementsResults);
        }
        Global.addBigTree(maze, createWallsResults, freeCells, addElementsResults);
        let firstRootAdded = Global.addPlayer(maze, createWallsResults, freeCells, addElementsResults);
        if (!firstRootAdded) {
          Global.addFirstRoot(maze, createWallsResults, freeCells, addElementsResults);
        }
        if (Math.pp_randomInt(0, 9) != 0 && (!createWallsResults.myNoDoors || Math.pp_randomInt(0, 2) != 0)) {
          Global.addRootWalls(maze, createWallsResults, freeCells, doors, addElementsResults);
        }
        Global.addRoots(maze, createWallsResults, freeCells, addElementsResults);
        Global.addTrees(maze, createWallsResults, freeCells, addElementsResults);
        Global.addZesties(maze, createWallsResults, freeCells, addElementsResults);
        Global.addWondermelon(maze, createWallsResults, freeCells, addElementsResults);
        let everythingReachable = Global.isEverythingReachable(maze, addElementsResults);
        return everythingReachable;
      };
      Global.addBigTree = function(maze, createWallsResults, freeCells, addElementsResults) {
        let room = createWallsResults.myBigTreeRoom;
        let start = room[0];
        let end = room[1];
        let rowStart = start[0] + 1;
        let rowEnd = end[0] - 1;
        let columnStart = start[1] + 1;
        let columnEnd = end[1] - 1;
        let bigTreePosition = [Math.pp_randomInt(rowStart, rowEnd), Math.pp_randomInt(columnStart, columnEnd)];
        maze[bigTreePosition[0]][bigTreePosition[1]] = LR.MazeItemType.BIG_TREE;
        if (!freeCells.pp_hasEqual(bigTreePosition, Global.cellCoordinatesEqual)) {
        }
        freeCells.pp_removeEqual(bigTreePosition, Global.cellCoordinatesEqual);
        freeCells.pp_removeEqual([bigTreePosition[0] - 1, bigTreePosition[1]], Global.cellCoordinatesEqual);
        freeCells.pp_removeEqual([bigTreePosition[0] + 1, bigTreePosition[1]], Global.cellCoordinatesEqual);
        freeCells.pp_removeEqual([bigTreePosition[0], bigTreePosition[1] - 1], Global.cellCoordinatesEqual);
        freeCells.pp_removeEqual([bigTreePosition[0], bigTreePosition[1] + 1], Global.cellCoordinatesEqual);
        addElementsResults.myAllElements.push(bigTreePosition);
        addElementsResults.myElementsFar.push(bigTreePosition);
        addElementsResults.myRootsFar.push(bigTreePosition);
      };
      Global.addPlayer = function(maze, createWallsResults, freeCells, addElementsResults) {
        let firstRootAdded = false;
        if (createWallsResults.myPlayerRoom != null) {
          firstRootAdded = true;
          let room = createWallsResults.myPlayerRoom;
          let start = room[0];
          let end = room[1];
          let rowStart = start[0];
          let rowEnd = end[0];
          let columnStart = start[1];
          let columnEnd = end[1];
          let playerPosition = [Math.pp_randomInt(rowStart, rowEnd), Math.pp_randomInt(columnStart, columnEnd)];
          maze[playerPosition[0]][playerPosition[1]] = LR.MazeItemType.PLAYER_START;
          if (!freeCells.pp_hasEqual(playerPosition, Global.cellCoordinatesEqual)) {
          }
          freeCells.pp_removeEqual(playerPosition, Global.cellCoordinatesEqual);
          addElementsResults.myAllElements.push(playerPosition);
          addElementsResults.myElementsFar.push(playerPosition);
          addElementsResults.myPlayer.pp_copy(playerPosition);
          addElementsResults.myRootsFar.push(playerPosition);
          let firstRootPosition = [0, 0];
          let found = false;
          while (!found) {
            firstRootPosition = [Math.pp_randomInt(rowStart, rowEnd), Math.pp_randomInt(columnStart, columnEnd)];
            if (freeCells.pp_hasEqual(firstRootPosition, Global.cellCoordinatesEqual)) {
              found = true;
            }
          }
          maze[firstRootPosition[0]][firstRootPosition[1]] = LR.MazeItemType.BIG_TREE_FIRST_ROOT;
          freeCells.pp_removeEqual(firstRootPosition, Global.cellCoordinatesEqual);
          addElementsResults.myAllElements.push(firstRootPosition);
          addElementsResults.myElementsFar.push(firstRootPosition);
          addElementsResults.myFirstRoot.pp_copy(firstRootPosition);
          addElementsResults.myRootsFar.push(firstRootPosition);
        } else {
          let playerPosition = Math.pp_randomPick(freeCells);
          freeCells.pp_removeEqual(playerPosition, Global.cellCoordinatesEqual);
          maze[playerPosition[0]][playerPosition[1]] = LR.MazeItemType.PLAYER_START;
          addElementsResults.myAllElements.push(playerPosition);
          addElementsResults.myElementsFar.push(playerPosition);
          addElementsResults.myPlayer.pp_copy(playerPosition);
          addElementsResults.myRootsFar.push(playerPosition);
        }
        return firstRootAdded;
      };
      Global.addFirstRoot = function(maze, createWallsResults, freeCells, addElementsResults) {
        let far = addElementsResults.myRootsMustBeFar;
        let firstRootPosition = Math.pp_randomPick(freeCells);
        let farDistance = 3;
        let isFar = Global.isFarFromAll(firstRootPosition, addElementsResults.myRootsFar, maze, farDistance);
        let maxAttempts = 100;
        while (far && !isFar && maxAttempts > 0) {
          maxAttempts--;
          firstRootPosition = Math.pp_randomPick(freeCells);
          isFar = Global.isFarFromAll(firstRootPosition, addElementsResults.myRootsFar, maze, farDistance);
          if (!isFar && maxAttempts == 0 && farDistance == 3) {
            farDistance = 4;
            maxAttempts = 50;
          }
        }
        maze[firstRootPosition[0]][firstRootPosition[1]] = LR.MazeItemType.BIG_TREE_FIRST_ROOT;
        freeCells.pp_removeEqual(firstRootPosition, Global.cellCoordinatesEqual);
        addElementsResults.myAllElements.push(firstRootPosition);
        addElementsResults.myElementsFar.push(firstRootPosition);
        addElementsResults.myFirstRoot.pp_copy(firstRootPosition);
        addElementsResults.myRootsFar.push(firstRootPosition);
      };
      Global.addRootWalls = function(maze, createWallsResults, freeCells, doors, addElementsResults) {
        let rootWallsToAdd = Math.round(createWallsResults.myDoors.length * Math.pp_random(0.2, 0.4));
        let allowOneBigRootWall = false;
        if (Math.pp_randomInt(0, 9) == 0) {
          allowOneBigRootWall = true;
        }
        let blockedDoors = 0;
        let doorsLength = doors.length;
        while (rootWallsToAdd > 0) {
          rootWallsToAdd--;
          let maxAttempts = 100;
          while (maxAttempts > 0 && doors.length > 0) {
            maxAttempts--;
            let randomDoorIndex = Math.pp_randomInt(0, doors.length - 1);
            let randomDoor = doors[randomDoorIndex];
            doors.pp_removeIndex(randomDoorIndex);
            if (randomDoor.length < 5) {
              if (Global.isDoorFree(randomDoor, freeCells)) {
                if (Global.isDoorLimited(randomDoor, maze)) {
                  if (!Global.isDoorBlockingPlayer(addElementsResults.myPlayer, addElementsResults.myFirstRoot, randomDoor, maze)) {
                    if (randomDoor.length == 2) {
                      let doorCell = randomDoor[1];
                      maze[doorCell[0]][doorCell[1]] = randomDoor[0] ? LR.MazeItemType.BIG_TREE_WALL_HORIZONTAL : LR.MazeItemType.BIG_TREE_WALL_VERTICAL;
                      freeCells.pp_removeEqual(doorCell, Global.cellCoordinatesEqual);
                      addElementsResults.myAllElements.push(doorCell);
                    } else if (randomDoor.length == 3) {
                      let doorCellIndex = Math.pp_randomInt(0, 1);
                      let doorCell = randomDoor[doorCellIndex + 1];
                      maze[doorCell[0]][doorCell[1]] = randomDoor[0] ? LR.MazeItemType.BIG_TREE_WALL_HORIZONTAL : LR.MazeItemType.BIG_TREE_WALL_VERTICAL;
                      freeCells.pp_removeEqual(doorCell, Global.cellCoordinatesEqual);
                      addElementsResults.myAllElements.push(doorCell);
                      let wallCellIndex = (doorCellIndex + 1) % 2;
                      let wallCell = randomDoor[wallCellIndex + 1];
                      if (!allowOneBigRootWall) {
                        maze[wallCell[0]][wallCell[1]] = LR.MazeItemType.ROCK_WALL_HORIZONTAL;
                      } else {
                        allowOneBigRootWall = false;
                        maze[wallCell[0]][wallCell[1]] = randomDoor[0] ? LR.MazeItemType.BIG_TREE_WALL_HORIZONTAL : LR.MazeItemType.BIG_TREE_WALL_VERTICAL;
                      }
                      freeCells.pp_removeEqual(wallCell, Global.cellCoordinatesEqual);
                    } else if (randomDoor.length == 4) {
                      let indexes = [1, 2, 3];
                      let middleDoorIndex = Global.getMiddleDoorIndex(randomDoor);
                      let wallCellIndex = middleDoorIndex;
                      let wallCell = randomDoor[wallCellIndex];
                      if (!allowOneBigRootWall) {
                        maze[wallCell[0]][wallCell[1]] = LR.MazeItemType.ROCK_WALL_HORIZONTAL;
                      } else {
                        allowOneBigRootWall = false;
                        maze[wallCell[0]][wallCell[1]] = randomDoor[0] ? LR.MazeItemType.BIG_TREE_WALL_HORIZONTAL : LR.MazeItemType.BIG_TREE_WALL_VERTICAL;
                      }
                      freeCells.pp_removeEqual(wallCell, Global.cellCoordinatesEqual);
                      indexes.pp_removeEqual(middleDoorIndex);
                      for (let i = 0; i < indexes.length; i++) {
                        let doorCellIndex = indexes[i];
                        let doorCell = randomDoor[doorCellIndex];
                        maze[doorCell[0]][doorCell[1]] = randomDoor[0] ? LR.MazeItemType.BIG_TREE_WALL_HORIZONTAL : LR.MazeItemType.BIG_TREE_WALL_VERTICAL;
                        freeCells.pp_removeEqual(doorCell, Global.cellCoordinatesEqual);
                        addElementsResults.myAllElements.push(doorCell);
                      }
                    } else {
                    }
                    break;
                  } else {
                    blockedDoors++;
                    if (blockedDoors > doorsLength - 4) {
                    }
                  }
                } else {
                }
              } else {
              }
            }
          }
        }
      };
      Global.addWoods = function(maze, createWallsResults, freeCells, addElementsResults) {
        let addRoot = Math.pp_randomInt(0, 2) != 0;
        let room = createWallsResults.myWoodsRoom;
        let start = room[0];
        let end = room[1];
        let roomCells = [];
        for (let row = start[0]; row <= end[0]; row++) {
          for (let column = start[1]; column <= end[1]; column++) {
            roomCells.push([row, column]);
          }
        }
        if (addRoot) {
          let rootPosition = Math.pp_randomPick(roomCells);
          roomCells.pp_removeEqual(rootPosition, Global.cellCoordinatesEqual);
          if (!freeCells.pp_hasEqual(rootPosition, Global.cellCoordinatesEqual)) {
          }
          freeCells.pp_removeEqual(rootPosition, Global.cellCoordinatesEqual);
          maze[rootPosition[0]][rootPosition[1]] = LR.MazeItemType.BIG_TREE_ROOT;
          addElementsResults.myAllElements.push(rootPosition);
          addElementsResults.myElementsFar.push(rootPosition);
          addElementsResults.myRootsFar.push(rootPosition);
          addElementsResults.myRootsToAdd--;
        }
        while (roomCells.length > 0) {
          let treePosition = Math.pp_randomPick(roomCells);
          roomCells.pp_removeEqual(treePosition, Global.cellCoordinatesEqual);
          if (!freeCells.pp_hasEqual(treePosition, Global.cellCoordinatesEqual)) {
          }
          freeCells.pp_removeEqual(treePosition, Global.cellCoordinatesEqual);
          maze[treePosition[0]][treePosition[1]] = LR.MazeItemType.HUMAN_TREE_0 + 7;
          addElementsResults.myAllElements.push(treePosition);
          addElementsResults.myElementsFar.push(treePosition);
        }
      };
      Global.addRoots = function(maze, createWallsResults, freeCells, addElementsResults) {
        let far = addElementsResults.myRootsMustBeFar;
        let rootsToAdd = addElementsResults.myRootsToAdd;
        for (let i = 0; i < rootsToAdd; i++) {
          let rootPosition = Math.pp_randomPick(freeCells);
          let farDistance = 3;
          let isFar = Global.isFarFromAll(rootPosition, addElementsResults.myRootsFar, maze, farDistance);
          let maxAttempts = 100;
          while (far && !isFar && maxAttempts > 0) {
            maxAttempts--;
            rootPosition = Math.pp_randomPick(freeCells);
            isFar = Global.isFarFromAll(rootPosition, addElementsResults.myRootsFar, maze, farDistance);
            if (!isFar && maxAttempts == 0 && farDistance == 3) {
              farDistance = 4;
              maxAttempts = 50;
            }
          }
          maze[rootPosition[0]][rootPosition[1]] = LR.MazeItemType.BIG_TREE_ROOT;
          freeCells.pp_removeEqual(rootPosition, Global.cellCoordinatesEqual);
          addElementsResults.myAllElements.push(rootPosition);
          addElementsResults.myElementsFar.push(rootPosition);
          addElementsResults.myRootsFar.push(rootPosition);
        }
      };
      Global.addTrees = function(maze, createWallsResults, freeCells, addElementsResults) {
        let far = addElementsResults.myTreesFar;
        let extra = 0;
        if (maze.length * maze[0].length > 700) {
          extra = 2;
        } else if (maze.length * maze[0].length > 550) {
          extra = 1;
        }
        let treesToAdd = Math.pp_randomInt(4 + extra, 8 + extra);
        if (Math.pp_randomInt(0, 9) == 0) {
          treesToAdd = 0;
        }
        for (let i = 0; i < treesToAdd; i++) {
          let treePosition = Math.pp_randomPick(freeCells);
          let farDistance = 3;
          let isFar = Global.isFarFromAll(treePosition, addElementsResults.myTreesFar, maze, farDistance);
          let maxAttempts = 100;
          while (far && !isFar && maxAttempts > 0) {
            maxAttempts--;
            treePosition = Math.pp_randomPick(freeCells);
            isFar = Global.isFarFromAll(treePosition, addElementsResults.myTreesFar, maze, farDistance);
            if (!isFar && maxAttempts == 0 && farDistance == 3) {
              farDistance = 4;
              maxAttempts = 50;
            }
          }
          maze[treePosition[0]][treePosition[1]] = LR.MazeItemType.HUMAN_TREE_0 + 7;
          freeCells.pp_removeEqual(treePosition, Global.cellCoordinatesEqual);
          addElementsResults.myAllElements.push(treePosition);
          addElementsResults.myElementsFar.push(treePosition);
          addElementsResults.myTreesFar.push(treePosition);
        }
      };
      Global.addZesties = function(maze, createWallsResults, freeCells, addElementsResults) {
        let far = true;
        let zestyMax = [1, 1, 1, 2];
        if (maze.length * maze[0].length > 700) {
          zestyMax = [1, 2];
        } else if (maze.length * maze[0].length > 550) {
          zestyMax = [1, 1, 2];
        }
        let zestiesToAdd = Math.pp_randomPick(zestyMax);
        if (Math.pp_randomInt(0, 9) == 0) {
          zestiesToAdd = 0;
        }
        for (let i = 0; i < zestiesToAdd; i++) {
          let zestyPosition = Math.pp_randomPick(freeCells);
          let farDistance = 3;
          let isFar = Global.isFarFromAll(zestyPosition, addElementsResults.myZestiesFar, maze, farDistance);
          let maxAttempts = 100;
          while (far && !isFar && maxAttempts > 0) {
            maxAttempts--;
            zestyPosition = Math.pp_randomPick(freeCells);
            isFar = Global.isFarFromAll(zestyPosition, addElementsResults.myZestiesFar, maze, farDistance);
            if (!isFar && maxAttempts == 0 && farDistance == 3) {
              farDistance = 4;
              maxAttempts = 50;
            }
          }
          maze[zestyPosition[0]][zestyPosition[1]] = LR.MazeItemType.ZESTY;
          freeCells.pp_removeEqual(zestyPosition, Global.cellCoordinatesEqual);
          addElementsResults.myAllElements.push(zestyPosition);
          addElementsResults.myElementsFar.push(zestyPosition);
          addElementsResults.myZestiesFar.push(zestyPosition);
        }
      };
      Global.addWondermelon = function(maze, createWallsResults, freeCells, addElementsResults) {
        let wondermelonPosition = Math.pp_randomPick(freeCells);
        maze[wondermelonPosition[0]][wondermelonPosition[1]] = LR.MazeItemType.WONDERMELON;
        freeCells.pp_removeEqual(wondermelonPosition, Global.cellCoordinatesEqual);
        addElementsResults.myAllElements.push(wondermelonPosition);
        addElementsResults.myElementsFar.push(wondermelonPosition);
        addElementsResults.myZestiesFar.push(wondermelonPosition);
      };
      Global.isDoorFree = function isDoorFree(door, freeCells) {
        let isDoorFree2 = true;
        for (let i = 1; i < door.length; i++) {
          let doorCell = door[i];
          if (!freeCells.pp_hasEqual(doorCell)) {
            isDoorFree2 = false;
            break;
          }
        }
        return isDoorFree2;
      };
      Global.isDoorLimited = function isDoorLimited(door, maze) {
        let isDoorLimited2 = true;
        if (door[0]) {
          let min4 = Number.MAX_VALUE;
          let max4 = -Number.MAX_VALUE;
          for (let i = 1; i < door.length; i++) {
            let doorCell = door[i];
            min4 = Math.min(min4, doorCell[1]);
            max4 = Math.max(max4, doorCell[1]);
          }
          isDoorLimited2 = Global.isWallType(maze[door[1][0]][min4 - 1]) && Global.isWallType(maze[door[1][0]][max4 + 1]);
        } else {
          let min4 = Number.MAX_VALUE;
          let max4 = -Number.MAX_VALUE;
          for (let i = 1; i < door.length; i++) {
            let doorCell = door[i];
            min4 = Math.min(min4, doorCell[0]);
            max4 = Math.max(max4, doorCell[0]);
          }
          isDoorLimited2 = Global.isWallType(maze[min4 - 1][door[1][1]]) && Global.isWallType(maze[max4 + 1][door[1][1]]);
        }
        return isDoorLimited2;
      };
      Global.isDoorBlockingPlayer = function isDoorBlockingPlayer(player, firstRoot, randomDoor, maze) {
        let mazeClone = [];
        for (let i = 0; i < maze.length; i++) {
          mazeClone[i] = [];
          let row = maze[i];
          for (let j = 0; j < row.length; j++) {
            mazeClone[i][j] = maze[i][j];
          }
        }
        for (let i = 1; i < randomDoor.length; i++) {
          let doorCell = randomDoor[i];
          mazeClone[doorCell[0]][doorCell[1]] = randomDoor[0] ? LR.MazeItemType.BIG_TREE_WALL_HORIZONTAL : LR.MazeItemType.BIG_TREE_WALL_VERTICAL;
        }
        let reachableCells = Global.getReachableCells(player, mazeClone, true);
        return !reachableCells.pp_hasEqual(firstRoot, Global.cellCoordinatesEqual);
      };
      Global.isEverythingReachable = function isEverythingReachable(maze, addElementsResult) {
        let reachableCells = Global.getReachableCells(addElementsResult.myPlayer, maze, false);
        let allElements = addElementsResult.myAllElements.pp_clone();
        for (let reachableCell of reachableCells) {
          allElements.pp_removeEqual(reachableCell, Global.cellCoordinatesEqual);
        }
        return allElements.length == 0;
      };
      Global.isFarFromAll = function isFarFromAll(cell, otherCells, maze, far = 3) {
        let farFromAll = true;
        for (let otherCell of otherCells) {
          if (!Global.isFar(cell, otherCell, maze, far)) {
            farFromAll = false;
            break;
          }
        }
        return farFromAll;
      };
      Global.isFar = function isFar(first, second, maze, far = 3) {
        return Global.distanceBetweenCellPositions(first, second) > Math.max(maze.length, maze[0].length) / far;
      };
      Global.distanceBetweenCellPositions = function distanceBetweenCellPositions(first, second) {
        return Math.max(Math.abs(first[0] - second[0]), Math.abs(first[1] - second[1]));
      };
      Global.getMiddleDoorIndex = function getMiddleDoorIndex(door) {
        let middleIndex = -1;
        let direction = door[0];
        for (let i = 0; i < 3; i++) {
          let currentDoor = door[1 + i];
          let previousPos = [currentDoor[0], currentDoor[1] - 1];
          let nextPos = [currentDoor[0], currentDoor[1] + 1];
          if (!direction) {
            previousPos = [currentDoor[0] - 1, currentDoor[1]];
            nextPos = [currentDoor[0] + 1, currentDoor[1]];
          }
          let previousFound = false;
          let nextFound = false;
          for (let j = 0; j < 3; j++) {
            let doorToCheck = door[1 + j];
            if (doorToCheck[0] == previousPos[0] && doorToCheck[1] == previousPos[1]) {
              previousFound = true;
            }
            if (doorToCheck[0] == nextPos[0] && doorToCheck[1] == nextPos[1]) {
              nextFound = true;
            }
          }
          if (previousFound && nextFound) {
            middleIndex = 1 + i;
            break;
          }
        }
        if (middleIndex == -1) {
          middleIndex = 1;
          if (Global.myFromAbove) {
            console.error("ERROR MIDDLE INDEX NOT FOUND");
          }
        }
        return middleIndex;
      };
    }
  });

  // js/labyroots/cauldron/billboard_player.js
  var require_billboard_player = __commonJS({
    "js/labyroots/cauldron/billboard_player.js"() {
      WL.registerComponent("billboard-player", {
        _myKeepUp: { type: WL.Type.Bool, default: false }
      }, {
        init() {
        },
        start() {
          this._myUp = [0, 1, 0];
          this._myPosition = PP.vec3_create();
        },
        update(dt) {
          let playerPosition = PP.myPlayerObjects.myHead.pp_getPosition();
          let directionToPlayer = playerPosition.vec3_sub(this.object.pp_getPosition(this._myPosition), this._myPosition);
          if (!directionToPlayer.vec3_isZero(1e-4)) {
            if (this._myKeepUp) {
              this.object.pp_setUp(this._myUp, directionToPlayer);
            } else {
              this.object.pp_setForward(directionToPlayer, this._myUp);
            }
          }
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          clonedComponent._myKeepUp = this._myKeepUp;
          return clonedComponent;
        }
      });
    }
  });

  // js/labyroots/cauldron/story.js
  var require_story = __commonJS({
    "js/labyroots/cauldron/story.js"() {
      WL.registerComponent("story", {
        _myOnlyVR: { type: WL.Type.Bool, default: true }
      }, {
        init: function() {
        },
        start: function() {
          this._myStarted = false;
          this._myResetPhysx = true;
          this._myResetActive = false;
          this._myTimer2 = new PP.Timer(4);
          this._myTimer = new PP.Timer(30);
          this._myTimerSkipFirstTime = new PP.Timer(10);
          this._myTimerSkipFirstTimeVR = new PP.Timer(5);
          this._mySteps = [];
          this._myStepDelay = 0.8;
          this._myStepTimer = new PP.Timer(0.1);
          let delay = Math.pp_lerp(this._myStepDelay * 2, this._myStepDelay, 0.75);
          this._myStepTimer.start(Math.pp_random(delay - 0.1, delay + 0.05));
          this._mySkip = false;
          this._myCanSkip = false;
          this._mySessionActive = false;
          this._myPhysXResetCompleted = false;
        },
        update: function(dt) {
          if (Global.myReady)
            return;
          if (PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).myMultiplePressEndCount >= 2 || PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON).myMultiplePressEndCount >= 2 || PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.TOP_BUTTON).myMultiplePressEndCount >= 2 || PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.BOTTOM_BUTTON).myMultiplePressEndCount >= 2 || PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.SELECT).myMultiplePressEndCount >= 2 || PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.SQUEEZE).myMultiplePressEndCount >= 2 || PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.SELECT).myMultiplePressEndCount >= 2 || PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.SQUEEZE).myMultiplePressEndCount >= 2) {
            if (this._myCanSkip) {
              this._mySkip = true;
            }
          }
          if (!this._myStarted) {
            if (Global.myStoryReady) {
              if (PP.XRUtils.isSessionActive() || !this._myOnlyVR) {
                let currentVersion = "2.2.1";
                console.log("Game Version:", currentVersion);
                this._myStarted = true;
                this._myCanSkip = Global.mySaveManager.load("can_skip", false);
                if (Global.myIsWeddingTime || Global.myIsMazeverseTime) {
                  if (Global.myFromAbove) {
                    this._myTimer.start(0);
                  } else {
                    this._myTimer.start(8);
                  }
                  this._myCanSkip = true;
                }
                if (Global.myIsMazeverseTime) {
                  Global.mySky.pp_rotateAxis(Math.pp_randomInt(0, 360), [0, 1, 0]);
                  Global.myLights.pp_rotateAxis(Math.pp_randomInt(0, 360), [0, 1, 0]);
                }
                Global.mySaveManager.save("is_wedding", false);
                this._mySessionActive = PP.XRUtils.isSessionActive();
              }
            }
          } else {
            if (this._mySteps.length == 0) {
              this._mySteps[0] = PP.myAudioManager.createAudioPlayer(AudioID.PASSO_1);
            }
            if (this._myResetActive) {
              this._myResetActive = false;
              let physxs = WL.scene.pp_getComponents("physx");
              for (let physx of physxs) {
                physx.active = true;
              }
              this._myPhysXResetCompleted = true;
            }
            if (this._myResetPhysx) {
              this._myResetPhysx = false;
              this._myResetActive = true;
              let physxs = WL.scene.pp_getComponents("physx");
              for (let physx of physxs) {
                if (physx.backupExtents != null) {
                  physx.extents = physx.backupExtents;
                  physx.backupExtents = null;
                }
                physx.active = false;
              }
            }
            this._myStepTimer.update(dt);
            if (this._myStepTimer.isDone()) {
              let delay = Math.pp_lerp(this._myStepDelay * 2, this._myStepDelay, 0.75);
              this._myStepTimer.start(Math.pp_random(delay - 0.1, delay + 0.05));
              let player = this._mySteps[0];
              player.setPosition(Global.myPlayer.getPositionReal());
              player.setPitch(Math.pp_random(1 - 0.35, 1 + 0.15));
              player.play();
            }
            this._myTimer.update(dt);
            this._myTimer2.update(dt);
            if (!this._mySessionActive && PP.XRUtils.isSessionActive()) {
              this._mySessionActive = true;
              if (this._myTimer.getTimeLeft() < 6) {
                this._myTimer.start(6);
              }
            }
            this._myTimerSkipFirstTime.update(dt);
            if (this._myTimerSkipFirstTime.isJustDone()) {
              this._myCanSkip = true;
            }
            if (PP.XRUtils.isSessionActive()) {
              this._myTimerSkipFirstTimeVR.update(dt);
              if (this._myTimerSkipFirstTimeVR.isJustDone()) {
                this._myCanSkip = true;
              }
            }
            if (this._myPhysXResetCompleted) {
              if (this._myTimer.isDone() || this._myCanSkip && this._myTimer2.isDone() && this._mySkip) {
                if (this._mySkip && this._myTimer2.isDone() && this._myCanSkip) {
                  Global.sendAnalytics("event", "intro_skipped", {
                    "value": 1
                  });
                  if (this._myTimerSkipFirstTime.isDone()) {
                    Global.sendAnalytics("event", "intro_skipped_late", {
                      "value": 1
                    });
                  }
                } else {
                  Global.sendAnalytics("event", "intro_watched", {
                    "value": 1
                  });
                }
                Global.sendAnalytics("event", "intro_done", {
                  "value": 1
                });
                PP.CAUtils.getUser(function(user) {
                  if (user != null && user.displayName != null && user.displayName.length != null && user.displayName.length > 0) {
                    Global.sendAnalytics("event", "playing_signed_in", {
                      "value": 1
                    });
                  }
                }, null, false);
                this._myTimer.reset();
                this._myTimer2.reset();
                Global.myAxe.pp_setActive(true);
                Global.myFollowAxe.pp_setActive(true);
                Global.myReady = true;
                Global.mySaveManager.save("can_skip", true);
                Global.myMusicPlayer = PP.myAudioManager.createAudioPlayer(AudioID.MUSIC);
                Global.myMusicPlayer.play();
              }
            }
          }
        }
      });
      Global.myMusicPlayer = null;
    }
  });

  // js/labyroots/cauldron/audio_load.js
  var require_audio_load = __commonJS({
    "js/labyroots/cauldron/audio_load.js"() {
      WL.registerComponent("audio-load", {}, {
        init() {
        },
        start() {
          this._myStarted = false;
        },
        update(dt) {
          if (!this._myStarted) {
            if (Global.myStoryReady) {
              this._myStarted = true;
              this.prepareSFXSetups();
              Global.myAudioMangia = PP.myAudioManager.createAudioPlayer(AudioID.MANGIA_FRUTTO);
            }
          }
        },
        prepareSFXSetups() {
          let manager = PP.myAudioManager;
          {
            let audioSetup = new PP.AudioSetup("assets/audio/music/creepy_music.mp3");
            audioSetup.myLoop = true;
            audioSetup.mySpatial = false;
            audioSetup.myVolume = 0.1;
            manager.addAudioSetup(AudioID.MUSIC, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Lamento albero 1.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 1;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.LAMENTO_UMANO_1, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Lamento albero 2.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 1;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.LAMENTO_UMANO_2, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Lamento albero 3.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 1;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.LAMENTO_UMANO_3, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Lamento albero 1.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 1.5;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.LAMENTO_UMANO_1_MORTE, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Lamento albero 2.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 1.5;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.LAMENTO_UMANO_2_MORTE, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Lamento albero 3.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 1.5;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.LAMENTO_UMANO_3_MORTE, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Lamento albero 1.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 2.5;
            audioSetup.myReferenceDistance = 2;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.LAMENTO_1, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Lamento albero 2.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 2.5;
            audioSetup.myReferenceDistance = 2;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.LAMENTO_2, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Lamento albero 3.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 2.5;
            audioSetup.myReferenceDistance = 2;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.LAMENTO_3, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Ascia su muro di radici.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 2.5;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.COLPO_FINALE, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Attacco ascia alberi 1.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 2;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.COLPO_NORMALE_1, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Attacco ascia alberi 2.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 2;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.COLPO_NORMALE_2, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Mangiare frutto 1.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 3;
            audioSetup.myPool = 10;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.MANGIA_FRUTTO, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Passi nel verde 3.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 2;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.PRENDI_FRUTTO, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Passi nel verde 3.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 2;
            audioSetup.myReferenceDistance = 2;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.TREE_UMANO_SPAWN, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Passi nel verde 1.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 1.5;
            audioSetup.myReferenceDistance = 1.25;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.PASSO_1, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Passi nel verde 2.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 0.75;
            audioSetup.myReferenceDistance = 1.5;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.PASSO_2, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Passi nel verde 3.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 0.75;
            audioSetup.myReferenceDistance = 1.5;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.PASSO_3, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Attacco ascia alberi 2.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 0.75;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.HEAL, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Attacco ascia alberi 2.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 0.75;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.HEAL2, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Colpo spada su pietra 1.mp3");
            audioSetup.myRate = 0.25;
            audioSetup.myVolume = 1;
            audioSetup.myReferenceDistance = 2;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.SECRET_WALL_OPEN, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Colpo spada su pietra 1.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 2;
            audioSetup.myReferenceDistance = 0.3;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.INVINCIBLE, audioSetup);
          }
          {
            let audioSetup = new PP.AudioSetup("assets/audio/sfx/Attacco ascia alberi 2.mp3");
            audioSetup.myRate = 1;
            audioSetup.myVolume = 0.5;
            audioSetup.myReferenceDistance = 1;
            audioSetup.myPreventPlayWhenAudioContextNotRunning = true;
            manager.addAudioSetup(AudioID.BIG_TREE_DIE_HIT, audioSetup);
          }
        }
      });
      AudioID = {
        MUSIC: 0,
        LAMENTO_1: 1,
        LAMENTO_2: 2,
        LAMENTO_3: 3,
        COLPO_FINALE: 4,
        COLPO_NORMALE_1: 5,
        COLPO_NORMALE_2: 6,
        MANGIA_FRUTTO: 7,
        PRENDI_FRUTTO: 8,
        PASSO_1: 10,
        PASSO_2: 11,
        PASSO_3: 12,
        HEAL: 13,
        HEAL2: 14,
        LAMENTO_UMANO_1: 15,
        LAMENTO_UMANO_2: 16,
        LAMENTO_UMANO_3: 17,
        LAMENTO_UMANO_1_MORTE: 18,
        LAMENTO_UMANO_2_MORTE: 19,
        LAMENTO_UMANO_3_MORTE: 20,
        TREE_UMANO_SPAWN: 21,
        SECRET_WALL_OPEN: 22,
        BIG_TREE_DIE_HIT: 23,
        INVINCIBLE: 24
      };
    }
  });

  // js/labyroots/cauldron/deactivate_on_story.js
  var require_deactivate_on_story = __commonJS({
    "js/labyroots/cauldron/deactivate_on_story.js"() {
      WL.registerComponent("deactivate-on-story", {}, {
        init: function() {
        },
        start: function() {
        },
        update: function(dt) {
          if (Global.myReady) {
            this.object.pp_setActive(false);
          }
        }
      });
    }
  });

  // js/labyroots/cauldron/open_ggj.js
  var open_ggj_exports = {};
  var import_howler10;
  var init_open_ggj = __esm({
    "js/labyroots/cauldron/open_ggj.js"() {
      import_howler10 = __toESM(require_howler());
      WL.registerComponent("open-ggj", {}, {
        init: function() {
        },
        start: function() {
          this._myChange = 0;
          this._myEnd = 0;
          this._myHit = 3;
        },
        update: function(dt) {
          if (this._myEnd > 0) {
            this._myEnd--;
            if (this._myEnd == 0) {
              this._myChange = 1;
              Global.myUnmute = true;
              import_howler10.Howler.mute(true);
              if (Global.myAxe != null && Global.myAxe._myGrabbable != null) {
                Global.myAxe._myGrabbable.release();
              }
            }
          }
          if (this._myEnd == 0 && this._myChange > 0) {
            this._myChange--;
            if (this._myChange == 0) {
              let onSuccess = function() {
                Global.myUnmute = true;
                import_howler10.Howler.mute(true);
                if (Global.myAxe != null && Global.myAxe._myGrabbable != null) {
                  Global.myAxe._myGrabbable.release();
                }
                Global.sendAnalytics("event", "open_ggj_success", {
                  "value": 1
                });
              }.bind(this);
              PP.XRUtils.openLink("https://globalgamejam.org/2023/games/labyroots-4", true, true, true, true, onSuccess);
            }
          }
        },
        hit() {
          if (this._myHit == 0) {
            this._myHit = 3;
          }
          this._myHit--;
          return true;
        },
        open() {
          this._myEnd = 90;
          this._myChange = 1;
          Global.sendAnalytics("event", "open_ggj", {
            "value": 1
          });
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          return clonedComponent;
        }
      });
    }
  });

  // js/labyroots/cauldron/open_github.js
  var open_github_exports = {};
  var import_howler11;
  var init_open_github = __esm({
    "js/labyroots/cauldron/open_github.js"() {
      import_howler11 = __toESM(require_howler());
      WL.registerComponent("open-github", {}, {
        init: function() {
        },
        start: function() {
          this._myChange = 0;
          this._myEnd = 0;
          this._myHit = 3;
        },
        update: function(dt) {
          if (this._myEnd > 0) {
            this._myEnd--;
            if (this._myEnd == 0) {
              this._myChange = 1;
              Global.myUnmute = true;
              import_howler11.Howler.mute(true);
              if (Global.myAxe != null && Global.myAxe._myGrabbable != null) {
                Global.myAxe._myGrabbable.release();
              }
            }
          }
          if (this._myEnd == 0 && this._myChange > 0) {
            this._myChange--;
            if (this._myChange == 0) {
              let onSuccess = function() {
                Global.myUnmute = true;
                import_howler11.Howler.mute(true);
                if (Global.myAxe != null && Global.myAxe._myGrabbable != null) {
                  Global.myAxe._myGrabbable.release();
                }
                Global.sendAnalytics("event", "open_github_success", {
                  "value": 1
                });
              }.bind(this);
              PP.XRUtils.openLink("https://github.com/signorpipo/labyroots", true, true, true, true, onSuccess);
            }
          }
        },
        hit() {
          if (this._myHit == 0) {
            this._myHit = 3;
          }
          this._myHit--;
          return true;
        },
        open() {
          this._myEnd = 60;
          this._myChange = 1;
          Global.sendAnalytics("event", "open_github", {
            "value": 1
          });
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          return clonedComponent;
        }
      });
    }
  });

  // js/labyroots/cauldron/open_zesty.js
  var open_zesty_exports = {};
  var import_howler12;
  var init_open_zesty = __esm({
    "js/labyroots/cauldron/open_zesty.js"() {
      import_howler12 = __toESM(require_howler());
      WL.registerComponent("open-zesty", {}, {
        init: function() {
        },
        start: function() {
          this._myChange = 0;
          this._myEnd = 0;
          this._myHit = 3;
        },
        update: function(dt) {
          if (this._myEnd > 0) {
            this._myEnd--;
            if (this._myEnd == 0) {
              this._myChange = 1;
              Global.myUnmute = true;
              import_howler12.Howler.mute(true);
              if (Global.myAxe != null && Global.myAxe._myGrabbable != null) {
                Global.myAxe._myGrabbable.release();
              }
            }
          }
          if (this._myEnd == 0 && this._myChange > 0) {
            this._myChange--;
            if (this._myChange == 0) {
              this.openZestyUrl();
            }
          }
        },
        hit() {
          if (this._myHit == 0) {
            this._myHit = 3;
          }
          this._myHit--;
          return true;
        },
        open() {
          this._myEnd = 90;
          this._myChange = 1;
          Global.sendAnalytics("event", "open_zesty", {
            "value": 1
          });
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          return clonedComponent;
        },
        result(result) {
        },
        openZestyUrl() {
          try {
            let zesty = WL.scene.pp_getComponent("zesty-banner");
            if (zesty != null) {
              Global.myZestyComponent = zesty;
              let onSuccess = function() {
                Global.myUnmute = true;
                import_howler12.Howler.mute(true);
                if (Global.myAxe != null && Global.myAxe._myGrabbable != null) {
                  Global.myAxe._myGrabbable.release();
                }
                Global.sendAnalytics("event", "open_zesty_success", {
                  "value": 1
                });
              }.bind(this);
              if (zesty.banner != null && zesty.banner.url != null) {
                let onZestySuccess = function() {
                  onSuccess();
                  try {
                    zesty.executeClick();
                  } catch (error) {
                  }
                }.bind(this);
                PP.XRUtils.openLink(zesty.banner.url, true, true, true, true, onZestySuccess);
              } else {
                PP.XRUtils.openLink("https://www.zesty.market", true, true, true, true, onSuccess);
              }
            }
          } catch (error) {
          }
        }
      });
      Global.myZestyComponent = null;
    }
  });

  // js/labyroots/cauldron/zesty-wonderland-sdk-compat.js
  var require_zesty_wonderland_sdk_compat = __commonJS({
    "js/labyroots/cauldron/zesty-wonderland-sdk-compat.js"() {
      (() => {
        var Vt = Object.create;
        var Ee = Object.defineProperty;
        var Kt = Object.getOwnPropertyDescriptor;
        var Xt = Object.getOwnPropertyNames;
        var Gt = Object.getPrototypeOf, Qt = Object.prototype.hasOwnProperty;
        var l = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
        var Zt = (t, e, r, i) => {
          if (e && typeof e == "object" || typeof e == "function")
            for (let n of Xt(e))
              !Qt.call(t, n) && n !== r && Ee(t, n, { get: () => e[n], enumerable: !(i = Kt(e, n)) || i.enumerable });
          return t;
        };
        var xe = (t, e, r) => (r = t != null ? Vt(Gt(t)) : {}, Zt(e || !t || !t.__esModule ? Ee(r, "default", { value: t, enumerable: true }) : r, t));
        var V = l((un, Oe) => {
          "use strict";
          Oe.exports = function(e, r) {
            return function() {
              for (var n = new Array(arguments.length), s = 0; s < n.length; s++)
                n[s] = arguments[s];
              return e.apply(r, n);
            };
          };
        });
        var f = l((cn, Ae) => {
          "use strict";
          var Yt = V(), X = Object.prototype.toString, G = function(t) {
            return function(e) {
              var r = X.call(e);
              return t[r] || (t[r] = r.slice(8, -1).toLowerCase());
            };
          }(/* @__PURE__ */ Object.create(null));
          function C(t) {
            return t = t.toLowerCase(), function(r) {
              return G(r) === t;
            };
          }
          function Q(t) {
            return Array.isArray(t);
          }
          function U(t) {
            return typeof t > "u";
          }
          function er(t) {
            return t !== null && !U(t) && t.constructor !== null && !U(t.constructor) && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t);
          }
          var Re = C("ArrayBuffer");
          function tr(t) {
            var e;
            return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && Re(t.buffer), e;
          }
          function rr(t) {
            return typeof t == "string";
          }
          function nr(t) {
            return typeof t == "number";
          }
          function Ce(t) {
            return t !== null && typeof t == "object";
          }
          function D(t) {
            if (G(t) !== "object")
              return false;
            var e = Object.getPrototypeOf(t);
            return e === null || e === Object.prototype;
          }
          var ir = C("Date"), sr = C("File"), ar = C("Blob"), or = C("FileList");
          function Z(t) {
            return X.call(t) === "[object Function]";
          }
          function ur(t) {
            return Ce(t) && Z(t.pipe);
          }
          function cr(t) {
            var e = "[object FormData]";
            return t && (typeof FormData == "function" && t instanceof FormData || X.call(t) === e || Z(t.toString) && t.toString() === e);
          }
          var lr = C("URLSearchParams");
          function dr(t) {
            return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
          }
          function fr() {
            return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? false : typeof window < "u" && typeof document < "u";
          }
          function Y(t, e) {
            if (!(t === null || typeof t > "u"))
              if (typeof t != "object" && (t = [t]), Q(t))
                for (var r = 0, i = t.length; r < i; r++)
                  e.call(null, t[r], r, t);
              else
                for (var n in t)
                  Object.prototype.hasOwnProperty.call(t, n) && e.call(null, t[n], n, t);
          }
          function K() {
            var t = {};
            function e(n, s) {
              D(t[s]) && D(n) ? t[s] = K(t[s], n) : D(n) ? t[s] = K({}, n) : Q(n) ? t[s] = n.slice() : t[s] = n;
            }
            for (var r = 0, i = arguments.length; r < i; r++)
              Y(arguments[r], e);
            return t;
          }
          function pr(t, e, r) {
            return Y(e, function(n, s) {
              r && typeof n == "function" ? t[s] = Yt(n, r) : t[s] = n;
            }), t;
          }
          function hr(t) {
            return t.charCodeAt(0) === 65279 && (t = t.slice(1)), t;
          }
          function mr(t, e, r, i) {
            t.prototype = Object.create(e.prototype, i), t.prototype.constructor = t, r && Object.assign(t.prototype, r);
          }
          function yr(t, e, r) {
            var i, n, s, a = {};
            e = e || {};
            do {
              for (i = Object.getOwnPropertyNames(t), n = i.length; n-- > 0; )
                s = i[n], a[s] || (e[s] = t[s], a[s] = true);
              t = Object.getPrototypeOf(t);
            } while (t && (!r || r(t, e)) && t !== Object.prototype);
            return e;
          }
          function vr(t, e, r) {
            t = String(t), (r === void 0 || r > t.length) && (r = t.length), r -= e.length;
            var i = t.indexOf(e, r);
            return i !== -1 && i === r;
          }
          function wr(t) {
            if (!t)
              return null;
            var e = t.length;
            if (U(e))
              return null;
            for (var r = new Array(e); e-- > 0; )
              r[e] = t[e];
            return r;
          }
          var gr = function(t) {
            return function(e) {
              return t && e instanceof t;
            };
          }(typeof Uint8Array < "u" && Object.getPrototypeOf(Uint8Array));
          Ae.exports = { isArray: Q, isArrayBuffer: Re, isBuffer: er, isFormData: cr, isArrayBufferView: tr, isString: rr, isNumber: nr, isObject: Ce, isPlainObject: D, isUndefined: U, isDate: ir, isFile: sr, isBlob: ar, isFunction: Z, isStream: ur, isURLSearchParams: lr, isStandardBrowserEnv: fr, forEach: Y, merge: K, extend: pr, trim: dr, stripBOM: hr, inherits: mr, toFlatObject: yr, kindOf: G, kindOfTest: C, endsWith: vr, toArray: wr, isTypedArray: gr, isFileList: or };
        });
        var ee = l((ln2, qe) => {
          "use strict";
          var S = f();
          function Te(t) {
            return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
          }
          qe.exports = function(e, r, i) {
            if (!r)
              return e;
            var n;
            if (i)
              n = i(r);
            else if (S.isURLSearchParams(r))
              n = r.toString();
            else {
              var s = [];
              S.forEach(r, function(c, h) {
                c === null || typeof c > "u" || (S.isArray(c) ? h = h + "[]" : c = [c], S.forEach(c, function(d) {
                  S.isDate(d) ? d = d.toISOString() : S.isObject(d) && (d = JSON.stringify(d)), s.push(Te(h) + "=" + Te(d));
                }));
              }), n = s.join("&");
            }
            if (n) {
              var a = e.indexOf("#");
              a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + n;
            }
            return e;
          };
        });
        var Ne = l((dn, Se) => {
          "use strict";
          var br = f();
          function j() {
            this.handlers = [];
          }
          j.prototype.use = function(e, r, i) {
            return this.handlers.push({ fulfilled: e, rejected: r, synchronous: i ? i.synchronous : false, runWhen: i ? i.runWhen : null }), this.handlers.length - 1;
          };
          j.prototype.eject = function(e) {
            this.handlers[e] && (this.handlers[e] = null);
          };
          j.prototype.forEach = function(e) {
            br.forEach(this.handlers, function(i) {
              i !== null && e(i);
            });
          };
          Se.exports = j;
        });
        var Pe = l((fn, ke) => {
          "use strict";
          var Er = f();
          ke.exports = function(e, r) {
            Er.forEach(e, function(n, s) {
              s !== r && s.toUpperCase() === r.toUpperCase() && (e[r] = n, delete e[s]);
            });
          };
        });
        var A = l((pn, De) => {
          "use strict";
          var _e = f();
          function N(t, e, r, i, n) {
            Error.call(this), this.message = t, this.name = "AxiosError", e && (this.code = e), r && (this.config = r), i && (this.request = i), n && (this.response = n);
          }
          _e.inherits(N, Error, { toJSON: function() {
            return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null };
          } });
          var Le = N.prototype, Be = {};
          ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(t) {
            Be[t] = { value: t };
          });
          Object.defineProperties(N, Be);
          Object.defineProperty(Le, "isAxiosError", { value: true });
          N.from = function(t, e, r, i, n, s) {
            var a = Object.create(Le);
            return _e.toFlatObject(t, a, function(c) {
              return c !== Error.prototype;
            }), N.call(a, t.message, e, r, i, n), a.name = t.name, s && Object.assign(a, s), a;
          };
          De.exports = N;
        });
        var te = l((hn, Ue) => {
          "use strict";
          Ue.exports = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false };
        });
        var re = l((mn, je) => {
          "use strict";
          var b = f();
          function xr(t, e) {
            e = e || new FormData();
            var r = [];
            function i(s) {
              return s === null ? "" : b.isDate(s) ? s.toISOString() : b.isArrayBuffer(s) || b.isTypedArray(s) ? typeof Blob == "function" ? new Blob([s]) : Buffer.from(s) : s;
            }
            function n(s, a) {
              if (b.isPlainObject(s) || b.isArray(s)) {
                if (r.indexOf(s) !== -1)
                  throw Error("Circular reference detected in " + a);
                r.push(s), b.forEach(s, function(c, h) {
                  if (!b.isUndefined(c)) {
                    var o = a ? a + "." + h : h, d;
                    if (c && !a && typeof c == "object") {
                      if (b.endsWith(h, "{}"))
                        c = JSON.stringify(c);
                      else if (b.endsWith(h, "[]") && (d = b.toArray(c))) {
                        d.forEach(function(v) {
                          !b.isUndefined(v) && e.append(o, i(v));
                        });
                        return;
                      }
                    }
                    n(c, o);
                  }
                }), r.pop();
              } else
                e.append(a, i(s));
            }
            return n(t), e;
          }
          je.exports = xr;
        });
        var Ie = l((yn, Fe) => {
          "use strict";
          var ne = A();
          Fe.exports = function(e, r, i) {
            var n = i.config.validateStatus;
            !i.status || !n || n(i.status) ? e(i) : r(new ne("Request failed with status code " + i.status, [ne.ERR_BAD_REQUEST, ne.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4], i.config, i.request, i));
          };
        });
        var Me = l((vn, ze) => {
          "use strict";
          var F = f();
          ze.exports = F.isStandardBrowserEnv() ? function() {
            return { write: function(r, i, n, s, a, u) {
              var c = [];
              c.push(r + "=" + encodeURIComponent(i)), F.isNumber(n) && c.push("expires=" + new Date(n).toGMTString()), F.isString(s) && c.push("path=" + s), F.isString(a) && c.push("domain=" + a), u === true && c.push("secure"), document.cookie = c.join("; ");
            }, read: function(r) {
              var i = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
              return i ? decodeURIComponent(i[3]) : null;
            }, remove: function(r) {
              this.write(r, "", Date.now() - 864e5);
            } };
          }() : function() {
            return { write: function() {
            }, read: function() {
              return null;
            }, remove: function() {
            } };
          }();
        });
        var We = l((wn, $e) => {
          "use strict";
          $e.exports = function(e) {
            return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
          };
        });
        var Je = l((gn, He) => {
          "use strict";
          He.exports = function(e, r) {
            return r ? e.replace(/\/+$/, "") + "/" + r.replace(/^\/+/, "") : e;
          };
        });
        var ie = l((bn, Ve) => {
          "use strict";
          var Or = We(), Rr = Je();
          Ve.exports = function(e, r) {
            return e && !Or(r) ? Rr(e, r) : r;
          };
        });
        var Xe = l((En, Ke) => {
          "use strict";
          var se = f(), Cr = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
          Ke.exports = function(e) {
            var r = {}, i, n, s;
            return e && se.forEach(e.split(`
`), function(u) {
              if (s = u.indexOf(":"), i = se.trim(u.substr(0, s)).toLowerCase(), n = se.trim(u.substr(s + 1)), i) {
                if (r[i] && Cr.indexOf(i) >= 0)
                  return;
                i === "set-cookie" ? r[i] = (r[i] ? r[i] : []).concat([n]) : r[i] = r[i] ? r[i] + ", " + n : n;
              }
            }), r;
          };
        });
        var Ze = l((xn, Qe) => {
          "use strict";
          var Ge = f();
          Qe.exports = Ge.isStandardBrowserEnv() ? function() {
            var e = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a"), i;
            function n(s) {
              var a = s;
              return e && (r.setAttribute("href", a), a = r.href), r.setAttribute("href", a), { href: r.href, protocol: r.protocol ? r.protocol.replace(/:$/, "") : "", host: r.host, search: r.search ? r.search.replace(/^\?/, "") : "", hash: r.hash ? r.hash.replace(/^#/, "") : "", hostname: r.hostname, port: r.port, pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname };
            }
            return i = n(window.location.href), function(a) {
              var u = Ge.isString(a) ? n(a) : a;
              return u.protocol === i.protocol && u.host === i.host;
            };
          }() : function() {
            return function() {
              return true;
            };
          }();
        });
        var L = l((On, et) => {
          "use strict";
          var ae = A(), Ar = f();
          function Ye(t) {
            ae.call(this, t ?? "canceled", ae.ERR_CANCELED), this.name = "CanceledError";
          }
          Ar.inherits(Ye, ae, { __CANCEL__: true });
          et.exports = Ye;
        });
        var rt = l((Rn, tt) => {
          "use strict";
          tt.exports = function(e) {
            var r = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
            return r && r[1] || "";
          };
        });
        var oe = l((Cn, nt) => {
          "use strict";
          var B = f(), Tr = Ie(), qr = Me(), Sr = ee(), Nr = ie(), kr = Xe(), Pr = Ze(), _r = te(), E = A(), Lr = L(), Br = rt();
          nt.exports = function(e) {
            return new Promise(function(i, n) {
              var s = e.data, a = e.headers, u = e.responseType, c;
              function h() {
                e.cancelToken && e.cancelToken.unsubscribe(c), e.signal && e.signal.removeEventListener("abort", c);
              }
              B.isFormData(s) && B.isStandardBrowserEnv() && delete a["Content-Type"];
              var o = new XMLHttpRequest();
              if (e.auth) {
                var d = e.auth.username || "", v = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
                a.Authorization = "Basic " + btoa(d + ":" + v);
              }
              var m = Nr(e.baseURL, e.url);
              o.open(e.method.toUpperCase(), Sr(m, e.params, e.paramsSerializer), true), o.timeout = e.timeout;
              function ge() {
                if (o) {
                  var g = "getAllResponseHeaders" in o ? kr(o.getAllResponseHeaders()) : null, q = !u || u === "text" || u === "json" ? o.responseText : o.response, R = { data: q, status: o.status, statusText: o.statusText, headers: g, config: e, request: o };
                  Tr(function(J) {
                    i(J), h();
                  }, function(J) {
                    n(J), h();
                  }, R), o = null;
                }
              }
              if ("onloadend" in o ? o.onloadend = ge : o.onreadystatechange = function() {
                !o || o.readyState !== 4 || o.status === 0 && !(o.responseURL && o.responseURL.indexOf("file:") === 0) || setTimeout(ge);
              }, o.onabort = function() {
                o && (n(new E("Request aborted", E.ECONNABORTED, e, o)), o = null);
              }, o.onerror = function() {
                n(new E("Network Error", E.ERR_NETWORK, e, o, o)), o = null;
              }, o.ontimeout = function() {
                var q = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded", R = e.transitional || _r;
                e.timeoutErrorMessage && (q = e.timeoutErrorMessage), n(new E(q, R.clarifyTimeoutError ? E.ETIMEDOUT : E.ECONNABORTED, e, o)), o = null;
              }, B.isStandardBrowserEnv()) {
                var be = (e.withCredentials || Pr(m)) && e.xsrfCookieName ? qr.read(e.xsrfCookieName) : void 0;
                be && (a[e.xsrfHeaderName] = be);
              }
              "setRequestHeader" in o && B.forEach(a, function(q, R) {
                typeof s > "u" && R.toLowerCase() === "content-type" ? delete a[R] : o.setRequestHeader(R, q);
              }), B.isUndefined(e.withCredentials) || (o.withCredentials = !!e.withCredentials), u && u !== "json" && (o.responseType = e.responseType), typeof e.onDownloadProgress == "function" && o.addEventListener("progress", e.onDownloadProgress), typeof e.onUploadProgress == "function" && o.upload && o.upload.addEventListener("progress", e.onUploadProgress), (e.cancelToken || e.signal) && (c = function(g) {
                o && (n(!g || g && g.type ? new Lr() : g), o.abort(), o = null);
              }, e.cancelToken && e.cancelToken.subscribe(c), e.signal && (e.signal.aborted ? c() : e.signal.addEventListener("abort", c))), s || (s = null);
              var H = Br(m);
              if (H && ["http", "https", "file"].indexOf(H) === -1) {
                n(new E("Unsupported protocol " + H + ":", E.ERR_BAD_REQUEST, e));
                return;
              }
              o.send(s);
            });
          };
        });
        var st = l((An, it) => {
          it.exports = null;
        });
        var z = l((Tn, ct) => {
          "use strict";
          var p = f(), at = Pe(), ot = A(), Dr = te(), Ur = re(), jr = { "Content-Type": "application/x-www-form-urlencoded" };
          function ut(t, e) {
            !p.isUndefined(t) && p.isUndefined(t["Content-Type"]) && (t["Content-Type"] = e);
          }
          function Fr() {
            var t;
            return typeof XMLHttpRequest < "u" ? t = oe() : typeof process < "u" && Object.prototype.toString.call(process) === "[object process]" && (t = oe()), t;
          }
          function Ir(t, e, r) {
            if (p.isString(t))
              try {
                return (e || JSON.parse)(t), p.trim(t);
              } catch (i) {
                if (i.name !== "SyntaxError")
                  throw i;
              }
            return (r || JSON.stringify)(t);
          }
          var I = { transitional: Dr, adapter: Fr(), transformRequest: [function(e, r) {
            if (at(r, "Accept"), at(r, "Content-Type"), p.isFormData(e) || p.isArrayBuffer(e) || p.isBuffer(e) || p.isStream(e) || p.isFile(e) || p.isBlob(e))
              return e;
            if (p.isArrayBufferView(e))
              return e.buffer;
            if (p.isURLSearchParams(e))
              return ut(r, "application/x-www-form-urlencoded;charset=utf-8"), e.toString();
            var i = p.isObject(e), n = r && r["Content-Type"], s;
            if ((s = p.isFileList(e)) || i && n === "multipart/form-data") {
              var a = this.env && this.env.FormData;
              return Ur(s ? { "files[]": e } : e, a && new a());
            } else if (i || n === "application/json")
              return ut(r, "application/json"), Ir(e);
            return e;
          }], transformResponse: [function(e) {
            var r = this.transitional || I.transitional, i = r && r.silentJSONParsing, n = r && r.forcedJSONParsing, s = !i && this.responseType === "json";
            if (s || n && p.isString(e) && e.length)
              try {
                return JSON.parse(e);
              } catch (a) {
                if (s)
                  throw a.name === "SyntaxError" ? ot.from(a, ot.ERR_BAD_RESPONSE, this, null, this.response) : a;
              }
            return e;
          }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: st() }, validateStatus: function(e) {
            return e >= 200 && e < 300;
          }, headers: { common: { Accept: "application/json, text/plain, */*" } } };
          p.forEach(["delete", "get", "head"], function(e) {
            I.headers[e] = {};
          });
          p.forEach(["post", "put", "patch"], function(e) {
            I.headers[e] = p.merge(jr);
          });
          ct.exports = I;
        });
        var dt = l((qn, lt) => {
          "use strict";
          var zr = f(), Mr = z();
          lt.exports = function(e, r, i) {
            var n = this || Mr;
            return zr.forEach(i, function(a) {
              e = a.call(n, e, r);
            }), e;
          };
        });
        var ue = l((Sn, ft) => {
          "use strict";
          ft.exports = function(e) {
            return !!(e && e.__CANCEL__);
          };
        });
        var mt = l((Nn, ht) => {
          "use strict";
          var pt = f(), ce = dt(), $r = ue(), Wr = z(), Hr = L();
          function le(t) {
            if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
              throw new Hr();
          }
          ht.exports = function(e) {
            le(e), e.headers = e.headers || {}, e.data = ce.call(e, e.data, e.headers, e.transformRequest), e.headers = pt.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers), pt.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(n) {
              delete e.headers[n];
            });
            var r = e.adapter || Wr.adapter;
            return r(e).then(function(n) {
              return le(e), n.data = ce.call(e, n.data, n.headers, e.transformResponse), n;
            }, function(n) {
              return $r(n) || (le(e), n && n.response && (n.response.data = ce.call(e, n.response.data, n.response.headers, e.transformResponse))), Promise.reject(n);
            });
          };
        });
        var de = l((kn, yt) => {
          "use strict";
          var w = f();
          yt.exports = function(e, r) {
            r = r || {};
            var i = {};
            function n(o, d) {
              return w.isPlainObject(o) && w.isPlainObject(d) ? w.merge(o, d) : w.isPlainObject(d) ? w.merge({}, d) : w.isArray(d) ? d.slice() : d;
            }
            function s(o) {
              if (w.isUndefined(r[o])) {
                if (!w.isUndefined(e[o]))
                  return n(void 0, e[o]);
              } else
                return n(e[o], r[o]);
            }
            function a(o) {
              if (!w.isUndefined(r[o]))
                return n(void 0, r[o]);
            }
            function u(o) {
              if (w.isUndefined(r[o])) {
                if (!w.isUndefined(e[o]))
                  return n(void 0, e[o]);
              } else
                return n(void 0, r[o]);
            }
            function c(o) {
              if (o in r)
                return n(e[o], r[o]);
              if (o in e)
                return n(void 0, e[o]);
            }
            var h = { url: a, method: a, data: a, baseURL: u, transformRequest: u, transformResponse: u, paramsSerializer: u, timeout: u, timeoutMessage: u, withCredentials: u, adapter: u, responseType: u, xsrfCookieName: u, xsrfHeaderName: u, onUploadProgress: u, onDownloadProgress: u, decompress: u, maxContentLength: u, maxBodyLength: u, beforeRedirect: u, transport: u, httpAgent: u, httpsAgent: u, cancelToken: u, socketPath: u, responseEncoding: u, validateStatus: c };
            return w.forEach(Object.keys(e).concat(Object.keys(r)), function(d) {
              var v = h[d] || s, m = v(d);
              w.isUndefined(m) && v !== c || (i[d] = m);
            }), i;
          };
        });
        var fe = l((Pn, vt) => {
          vt.exports = { version: "0.27.2" };
        });
        var bt = l((_n, gt) => {
          "use strict";
          var Jr = fe().version, O = A(), pe = {};
          ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(t, e) {
            pe[t] = function(i) {
              return typeof i === t || "a" + (e < 1 ? "n " : " ") + t;
            };
          });
          var wt = {};
          pe.transitional = function(e, r, i) {
            function n(s, a) {
              return "[Axios v" + Jr + "] Transitional option '" + s + "'" + a + (i ? ". " + i : "");
            }
            return function(s, a, u) {
              if (e === false)
                throw new O(n(a, " has been removed" + (r ? " in " + r : "")), O.ERR_DEPRECATED);
              return r && !wt[a] && (wt[a] = true, console.warn(n(a, " has been deprecated since v" + r + " and will be removed in the near future"))), e ? e(s, a, u) : true;
            };
          };
          function Vr(t, e, r) {
            if (typeof t != "object")
              throw new O("options must be an object", O.ERR_BAD_OPTION_VALUE);
            for (var i = Object.keys(t), n = i.length; n-- > 0; ) {
              var s = i[n], a = e[s];
              if (a) {
                var u = t[s], c = u === void 0 || a(u, s, t);
                if (c !== true)
                  throw new O("option " + s + " must be " + c, O.ERR_BAD_OPTION_VALUE);
                continue;
              }
              if (r !== true)
                throw new O("Unknown option " + s, O.ERR_BAD_OPTION);
            }
          }
          gt.exports = { assertOptions: Vr, validators: pe };
        });
        var At = l((Ln, Ct) => {
          "use strict";
          var Ot = f(), Kr = ee(), Et = Ne(), xt = mt(), M = de(), Xr = ie(), Rt = bt(), k = Rt.validators;
          function P(t) {
            this.defaults = t, this.interceptors = { request: new Et(), response: new Et() };
          }
          P.prototype.request = function(e, r) {
            typeof e == "string" ? (r = r || {}, r.url = e) : r = e || {}, r = M(this.defaults, r), r.method ? r.method = r.method.toLowerCase() : this.defaults.method ? r.method = this.defaults.method.toLowerCase() : r.method = "get";
            var i = r.transitional;
            i !== void 0 && Rt.assertOptions(i, { silentJSONParsing: k.transitional(k.boolean), forcedJSONParsing: k.transitional(k.boolean), clarifyTimeoutError: k.transitional(k.boolean) }, false);
            var n = [], s = true;
            this.interceptors.request.forEach(function(m) {
              typeof m.runWhen == "function" && m.runWhen(r) === false || (s = s && m.synchronous, n.unshift(m.fulfilled, m.rejected));
            });
            var a = [];
            this.interceptors.response.forEach(function(m) {
              a.push(m.fulfilled, m.rejected);
            });
            var u;
            if (!s) {
              var c = [xt, void 0];
              for (Array.prototype.unshift.apply(c, n), c = c.concat(a), u = Promise.resolve(r); c.length; )
                u = u.then(c.shift(), c.shift());
              return u;
            }
            for (var h = r; n.length; ) {
              var o = n.shift(), d = n.shift();
              try {
                h = o(h);
              } catch (v) {
                d(v);
                break;
              }
            }
            try {
              u = xt(h);
            } catch (v) {
              return Promise.reject(v);
            }
            for (; a.length; )
              u = u.then(a.shift(), a.shift());
            return u;
          };
          P.prototype.getUri = function(e) {
            e = M(this.defaults, e);
            var r = Xr(e.baseURL, e.url);
            return Kr(r, e.params, e.paramsSerializer);
          };
          Ot.forEach(["delete", "get", "head", "options"], function(e) {
            P.prototype[e] = function(r, i) {
              return this.request(M(i || {}, { method: e, url: r, data: (i || {}).data }));
            };
          });
          Ot.forEach(["post", "put", "patch"], function(e) {
            function r(i) {
              return function(s, a, u) {
                return this.request(M(u || {}, { method: e, headers: i ? { "Content-Type": "multipart/form-data" } : {}, url: s, data: a }));
              };
            }
            P.prototype[e] = r(), P.prototype[e + "Form"] = r(true);
          });
          Ct.exports = P;
        });
        var qt = l((Bn, Tt) => {
          "use strict";
          var Gr = L();
          function _(t) {
            if (typeof t != "function")
              throw new TypeError("executor must be a function.");
            var e;
            this.promise = new Promise(function(n) {
              e = n;
            });
            var r = this;
            this.promise.then(function(i) {
              if (r._listeners) {
                var n, s = r._listeners.length;
                for (n = 0; n < s; n++)
                  r._listeners[n](i);
                r._listeners = null;
              }
            }), this.promise.then = function(i) {
              var n, s = new Promise(function(a) {
                r.subscribe(a), n = a;
              }).then(i);
              return s.cancel = function() {
                r.unsubscribe(n);
              }, s;
            }, t(function(n) {
              r.reason || (r.reason = new Gr(n), e(r.reason));
            });
          }
          _.prototype.throwIfRequested = function() {
            if (this.reason)
              throw this.reason;
          };
          _.prototype.subscribe = function(e) {
            if (this.reason) {
              e(this.reason);
              return;
            }
            this._listeners ? this._listeners.push(e) : this._listeners = [e];
          };
          _.prototype.unsubscribe = function(e) {
            if (this._listeners) {
              var r = this._listeners.indexOf(e);
              r !== -1 && this._listeners.splice(r, 1);
            }
          };
          _.source = function() {
            var e, r = new _(function(n) {
              e = n;
            });
            return { token: r, cancel: e };
          };
          Tt.exports = _;
        });
        var Nt = l((Dn, St) => {
          "use strict";
          St.exports = function(e) {
            return function(i) {
              return e.apply(null, i);
            };
          };
        });
        var Pt = l((Un, kt) => {
          "use strict";
          var Qr = f();
          kt.exports = function(e) {
            return Qr.isObject(e) && e.isAxiosError === true;
          };
        });
        var Bt = l((jn, he) => {
          "use strict";
          var _t = f(), Zr = V(), $ = At(), Yr = de(), en = z();
          function Lt(t) {
            var e = new $(t), r = Zr($.prototype.request, e);
            return _t.extend(r, $.prototype, e), _t.extend(r, e), r.create = function(n) {
              return Lt(Yr(t, n));
            }, r;
          }
          var y = Lt(en);
          y.Axios = $;
          y.CanceledError = L();
          y.CancelToken = qt();
          y.isCancel = ue();
          y.VERSION = fe().version;
          y.toFormData = re();
          y.AxiosError = A();
          y.Cancel = y.CanceledError;
          y.all = function(e) {
            return Promise.all(e);
          };
          y.spread = Nt();
          y.isAxiosError = Pt();
          he.exports = y;
          he.exports.default = y;
        });
        var me = l((Fn, Dt) => {
          Dt.exports = Bt();
        });
        var W = xe(me(), 1);
        var x = "https://zesty-storage-prod.s3.amazonaws.com/images/zesty", T = { tall: { width: 0.75, height: 1, style: { standard: `${x}/zesty-banner-tall.png`, minimal: `${x}/zesty-banner-tall-minimal.png`, transparent: `${x}/zesty-banner-tall-transparent.png` } }, wide: { width: 4, height: 1, style: { standard: `${x}/zesty-banner-wide.png`, minimal: `${x}/zesty-banner-wide-minimal.png`, transparent: `${x}/zesty-banner-wide-transparent.png` } }, square: { width: 1, height: 1, style: { standard: `${x}/zesty-banner-square.png`, minimal: `${x}/zesty-banner-square-minimal.png`, transparent: `${x}/zesty-banner-square-transparent.png` } } }, Ut = "square";
        var tn = xe(me(), 1);
        var ye = () => {
          let t = window.XRHand != null && window.XRMediaBinding != null, e = navigator.userAgent.includes("OculusBrowser"), r = t && e ? "Full" : t || e ? "Partial" : "None";
          return { match: r !== "None", confidence: r };
        }, ve = () => {
          let t = window.mozInnerScreenX != null && window.speechSynthesis == null, e = navigator.userAgent.includes("Mobile VR") && !navigator.userAgent.includes("OculusBrowser"), r = t && e ? "Full" : t || e ? "Partial" : "None";
          return { match: r !== "None", confidence: r };
        }, jt = async () => {
          let t = navigator.xr && await navigator.xr.isSessionSupported("immersive-vr") && await navigator.xr.isSessionSupported("immersive-ar"), e = navigator.userAgent.includes("Pico Neo 3 Link"), r = t && e ? "Full" : t || e ? "Partial" : "None";
          return { match: r !== "None", confidence: r };
        }, Ft = () => {
          let t = navigator.maxTouchPoints === 0 || navigator.msMaxTouchPoints === 0, e = !navigator.userAgent.includes("Android") && !navigator.userAgent.includes("Mobile"), r = t && e ? "Full" : t || e ? "Partial" : "None";
          return { match: r !== "None", confidence: r };
        }, we = async () => {
          let t = { platform: "", confidence: "" };
          return ye().match ? t = { platform: "Oculus", confidence: ye().confidence } : ve().match ? t = { platform: "Wolvic", confidence: ve().confidence } : await jt().match ? t = { platform: "Pico", confidence: await jt().confidence } : Ft().match ? t = { platform: "Desktop", confidence: Ft().confidence } : t = { platform: "Unknown", confidence: "None" }, t;
        }, It = (t) => {
          if (t) {
            if (ye().match) {
              if (t.includes("https://www.oculus.com/experiences/quest/")) {
                setTimeout(() => {
                  window.open(t, "_blank");
                }, 1e3);
                return;
              }
            } else if (ve().match) {
              let e = document.createElement("div"), r = document.createElement("div"), i = document.createElement("p"), n = document.createElement("button"), s = document.createElement("button");
              e.style.backgroundColor = "rgb(0, 0, 0, 0.75)", e.style.color = "white", e.style.textAlign = "center", e.style.position = "fixed", e.style.top = "50%", e.style.left = "50%", e.style.padding = "5%", e.style.borderRadius = "5%", e.style.transform = "translate(-50%, -50%)", i.innerHTML = `<b>This billboard leads to ${t}. Continue?</b>`, n.innerText = "Move cursor back into window.", n.style.width = "100vw", n.style.height = "100vh", n.onmouseenter = () => {
                n.style.width = "auto", n.style.height = "auto", n.innerText = "Yes";
              }, n.onclick = () => {
                window.open(t, "_blank"), e.remove();
              }, s.innerText = "No", s.onclick = () => {
                e.remove();
              }, e.append(r), r.append(i), r.append(n), r.append(s), document.body.append(e);
              return;
            }
            window.open(t, "_blank");
          }
        };
        var zt = "https://beacon2.zesty.market/zgraphql", rn = "https://api.zesty.market/api";
        var Mt = async (t, e = "tall", r = "standard") => {
          try {
            let i = encodeURI(window.top.location.href).replace(/\/$/, ""), n = await W.default.get(`${rn}/ad?ad_unit_id=${t}&url=${i}`);
            return n.data ? n.data : { Ads: [{ asset_url: T[e].style[r], cta_url: "https://www.zesty.market" }], CampaignId: "TestCampaign" };
          } catch {
            return console.warn("Could not retrieve an active campaign banner. Retrieving default banner."), { Ads: [{ asset_url: T[e].style[r], cta_url: "https://www.zesty.market" }], CampaignId: "TestCampaign" };
          }
        }, $t = async (t, e = null) => {
          let { platform: r, confidence: i } = await we();
          try {
            await W.default.post(zt, { query: `mutation { increment(eventType: visits, spaceId: "${t}", campaignId: "${e}", platform: { name: ${r}, confidence: ${i} }) { message } }` }, { headers: { "Content-Type": "application/json" } });
          } catch (n) {
            console.log("Failed to emit onload event", n.message);
          }
        }, Wt = async (t, e = null) => {
          let { platform: r, confidence: i } = await we();
          try {
            await W.default.post(zt, { query: `mutation { increment(eventType: clicks, spaceId: "${t}", campaignId: "${e}", platform: { name: ${r}, confidence: ${i} }) { message } }` }, { headers: { "Content-Type": "application/json" } });
          } catch (n) {
            console.log("Failed to emit onclick event", n.message);
          }
        };
        var Ht = "2.2.0";
        console.log(`Zesty SDK Version: ${Ht} (compatibility)`);
        var sn = "https://cdn.zesty.xyz/sdk/zesty-formats.js", an = "https://cdn.zesty.xyz/sdk/zesty-networking.js";
        WL.registerComponent("zesty-banner", { adUnit: { type: WL.Type.String }, format: { type: WL.Type.Enum, values: Object.keys(T), default: Ut }, style: { type: WL.Type.Enum, values: ["standard", "minimal", "transparent"], default: "transparent" }, scaleToRatio: { type: WL.Type.Bool, default: true }, textureProperty: { type: WL.Type.String, default: "auto" }, beacon: { type: WL.Type.Bool, default: true }, dynamicFormats: { type: WL.Type.Bool, default: true }, createAutomaticCollision: { type: WL.Type.Bool, default: true }, dynamicNetworking: { type: WL.Type.Bool, default: true } }, { init: function() {
          this.formats = Object.values(T), this.formatKeys = Object.keys(T), this.styleKeys = ["standard", "minimal", "transparent"];
        }, start: function() {
          if (this.mesh = this.object.getComponent("mesh"), !this.mesh)
            throw new Error("'zesty-banner ' missing mesh component");
          if (this.createAutomaticCollision && (this.collision = this.object.getComponent("collision") || this.object.addComponent("collision", { collider: WL.Collider.Box, group: 2 }), this.cursorTarget = this.object.getComponent("cursor-target") || this.object.addComponent("cursor-target"), this.cursorTarget.addClickFunction(this.onClick.bind(this))), this.dynamicFormats) {
            let t = document.createElement("script");
            t.onload = () => {
              this.formatsOverride = zestyFormats.formats;
            }, t.setAttribute("src", sn), t.setAttribute("crossorigin", "anonymous"), document.body.appendChild(t);
          }
          this.dynamicNetworking ? import(an).then((t) => {
            this.zestyNetworking = Object.assign({}, t), this.startLoading();
          }).catch(() => {
            console.error("Failed to dynamically retrieve networking code, falling back to bundled version."), this.dynamicNetworking = null, this.startLoading();
          }) : this.startLoading();
        }, startLoading: function() {
          this.loadBanner(this.adUnit, this.formatKeys[this.format], this.styleKeys[this.style]).then((t) => {
            this.banner = t, this.scaleToRatio && (this.height = this.object.scalingLocal[1], this.object.resetScaling(), this.createAutomaticCollision && (this.collision.extents = [this.formats[this.format].width * this.height, this.height, 0.1]), this.object.scale([this.formats[this.format].width * this.height, this.height, 1]));
            let e = this.mesh.material;
            if (this.textureProperty === "auto") {
              let r = e.pipeline || e.shader;
              if (r === "Phong Opaque Textured Blend")
                e.diffuseTexture = t.texture, e.alphaMaskThreshold = 0.3;
              else if (r === "Flat Opaque Textured")
                e.flatTexture = t.texture, e.alphaMaskThreshold = 0.8;
              else
                throw Error("'zesty-banner ' unable to apply banner texture: unsupported pipeline " + e.shader);
              this.mesh.material = e;
            } else
              this.mesh.material[this.textureProperty] = t.texture;
            this.beacon && (this.dynamicNetworking ? this.zestyNetworking.sendOnLoadMetric(this.adUnit, this.banner.campaignId) : $t(this.adUnit, this.banner.campaignId));
          });
        }, onClick: function() {
          this.banner?.url && (WL.xrSession ? WL.xrSession.end().then(this.executeClick.bind(this)) : this.executeClick());
        }, executeClick: function() {
          this.beacon && (this.dynamicNetworking ? this.zestyNetworking.sendOnClickMetric(this.adUnit, this.banner.campaignId) : Wt(this.adUnit, this.banner.campaignId));
        }, loadBanner: async function(t, e, r) {
          let i = this.dynamicNetworking ? await this.zestyNetworking.fetchCampaignAd(t, e, r) : await Mt(t, e, r), { asset_url: n, cta_url: s } = i.Ads[0];
          return WL.textures.load(n, "").then((a) => ({ texture: a, imageSrc: n, url: s, campaignId: i.CampaignId }));
        } });
      })();
    }
  });

  // js/labyroots/cauldron/set_texture_after_delay.js
  var require_set_texture_after_delay = __commonJS({
    "js/labyroots/cauldron/set_texture_after_delay.js"() {
      WL.registerComponent("set-texture-after-delay", {
        _myToSet: { type: WL.Type.Object }
      }, {
        init: function() {
        },
        start: function() {
          this._myTimer = new PP.Timer(5);
        },
        update: function(dt) {
          if (Global.myStoryReady) {
            if (this._myTimer.isRunning()) {
              this._myTimer.update(dt);
              if (this._myTimer.isDone()) {
                let myMesh = this.object.pp_getComponent("mesh");
                if (myMesh) {
                  let setMesh = this._myToSet.pp_getComponent("mesh");
                  if (setMesh && setMesh.material.diffuseTexture._id == 0 && WL.scene.pp_getComponent("zesty-banner").banner == null) {
                    setMesh.material.diffuseTexture = myMesh.material.diffuseTexture;
                    Global.sendAnalytics("event", "zesty_load_fail", {
                      "value": 1
                    });
                  }
                }
              }
            }
          }
        }
      });
    }
  });

  // js/labyroots/cauldron/secret_zone_check.js
  var require_secret_zone_check = __commonJS({
    "js/labyroots/cauldron/secret_zone_check.js"() {
      WL.registerComponent("secret-zone-check", {}, {
        init: function() {
        },
        start: function() {
          this._myReached = false;
          this._myStarted = false;
          this._myCell = null;
          this._myUp = [0, 1, 0];
          this._myPosition = [0, 1, 0];
        },
        update: function(dt) {
          if (Global.myReady) {
            if (!this._myStarted) {
              this._myStarted = true;
              this._myCell = Global.myMaze.getCellByPosition(this.object.pp_getPosition());
            }
            if (!this._myReached) {
              if (this._myCell != null) {
                let distanceFromPlayer = Global.myPlayer.getPosition(this._myPosition).vec3_removeComponentAlongAxis(this._myUp, this._myPosition).vec3_distance(this._myCell.myCellPosition.vec3_removeComponentAlongAxis(this._myUp));
                if (distanceFromPlayer <= this._myCell.myCellSize) {
                  this._myReached = true;
                  Global.sendAnalytics("event", "enter_secret_zone", {
                    "value": 1
                  });
                }
              }
            }
          }
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          return clonedComponent;
        }
      });
    }
  });

  // js/labyroots/cauldron/display_leaderboard.js
  var require_display_leaderboard = __commonJS({
    "js/labyroots/cauldron/display_leaderboard.js"() {
      WL.registerComponent("display-leaderboard", {
        _myName: { type: WL.Type.String, default: "" },
        _myIsLocal: { type: WL.Type.Bool, default: false }
      }, {
        init: function() {
          this._myCharacterWeightMap = /* @__PURE__ */ new Map();
          this._myCharacterWeightMap.set("W", 1.3);
          this._myCharacterWeightMap.set("m", 1.3);
          this._myCharacterWeightMap.set("@", 1.3);
          this._myCharacterWeightMap.set("#", 1.3);
          this._myCharacterWeightMap.set("M", 1.2);
          this._myCharacterWeightMap.set("D", 1.1);
          this._myCharacterWeightMap.set("G", 1.1);
          this._myCharacterWeightMap.set("O", 1.1);
          this._myCharacterWeightMap.set("Q", 1.1);
          this._myCharacterWeightMap.set("w", 1.1);
          this._myCharacterWeightMap.set("I", 0.75);
          this._myCharacterWeightMap.set("f", 0.75);
          this._myCharacterWeightMap.set("i", 0.75);
          this._myCharacterWeightMap.set("j", 0.75);
          this._myCharacterWeightMap.set("l", 0.75);
          this._myCharacterWeightMap.set("t", 0.75);
          this._myCharacterWeightMap.set(" ", 0.75);
          this._myCharacterWeightMap.set(".", 0.75);
          this._myCharacterWeightMap.set("-", 0.75);
        },
        start: function() {
          this._myStarted = false;
        },
        update: function(dt) {
          if (!this._myStarted) {
            this._myStarted = true;
            this._myNamesTextComponent = this.object.pp_getObjectByName("Names").pp_getComponent("text");
            this._myScoresTextComponent = this.object.pp_getObjectByName("Scores").pp_getComponent("text");
            if (this._myNamesTextComponent != null && this._myScoresTextComponent != null) {
              this._myNamesTextComponent.text = " ";
              this._myNamesTextComponent.text = "";
              this._myScoresTextComponent.text = " ";
              this._myScoresTextComponent.text = "";
            }
            this.updateLeaderboard();
          }
        },
        updateLeaderboard: function() {
          PP.CAUtils.getLeaderboard(this._myName, true, this._myIsLocal, 10, this._onLeaderboardRetrieved.bind(this));
        },
        _onLeaderboardRetrieved(leaderboard) {
          let namesText = "";
          let scoresText = "";
          let maxRankDigit = 0;
          for (let value of leaderboard) {
            if (value != null && value.rank != null && value.displayName != null && value.score != null) {
              let rank = value.rank + 1;
              if (rank.toFixed(0).length > maxRankDigit) {
                maxRankDigit = rank.toFixed(0).length;
              }
            }
          }
          for (let value of leaderboard) {
            if (value != null && value.rank != null && value.displayName != null && value.score != null) {
              let rank = value.rank + 1;
              let fixedRank = rank.toFixed(0);
              while (fixedRank.length < maxRankDigit) {
                fixedRank = "0".concat(fixedRank);
              }
              let clampedDisplayName = this._clampDisplayName(value.displayName);
              namesText = namesText.concat(fixedRank, " - ", clampedDisplayName, "\n\n");
              let convertedScore = this._convertTime(value.score);
              scoresText = scoresText.concat(convertedScore, "\n\n");
            }
          }
          if (this._myNamesTextComponent != null && this._myScoresTextComponent != null) {
            this._myNamesTextComponent.text = namesText;
            this._myScoresTextComponent.text = scoresText;
          }
        },
        _convertTime(score) {
          let time = Math.floor(score / 1e3);
          let hours = Math.floor(time / 3600);
          time -= hours * 3600;
          let minutes = Math.floor(time / 60);
          time -= minutes * 60;
          let seconds = Math.floor(time);
          let secondsText = seconds.toFixed(0).length < 2 ? "0".concat(seconds.toFixed(0)) : seconds.toFixed(0);
          let minutesText = minutes.toFixed(0).length < 2 ? "0".concat(minutes.toFixed(0)) : minutes.toFixed(0);
          let hoursText = hours.toFixed(0).length < 2 ? "0".concat(hours.toFixed(0)) : hours.toFixed(0);
          let convertedTime = hoursText.concat(":", minutesText, ":", secondsText);
          return convertedTime;
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          clonedComponent._myName = this._myName;
          clonedComponent._myIsLocal = this._myIsLocal;
          return clonedComponent;
        },
        _clampDisplayName(displayName) {
          let nameCharactersToShow = 0;
          let currentWeight = 0;
          for (let i = 0; i < displayName.length; i++) {
            let currentCharacter = displayName.charAt(i);
            let characterWeight = this._myCharacterWeightMap.get(currentCharacter);
            characterWeight = characterWeight != null ? characterWeight : 1;
            currentWeight += characterWeight;
            if (currentWeight > 15) {
              break;
            }
            nameCharactersToShow++;
          }
          nameCharactersToShow = Math.min(nameCharactersToShow, displayName.length);
          if (nameCharactersToShow < displayName.length) {
            return displayName.slice(0, nameCharactersToShow) + "...";
          }
          return displayName;
        }
      });
    }
  });

  // js/labyroots/cauldron/lr_ca_dummy_server.js
  var require_lr_ca_dummy_server = __commonJS({
    "js/labyroots/cauldron/lr_ca_dummy_server.js"() {
      LR.LRCADummyServer = class LRCADummyServer {
        constructor() {
        }
        getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null, caError = PP.CAUtils.CAError.NONE) {
          let leaderboard = null;
          let appName = "HeyVR";
          if (PP.CAUtils.isViverse()) {
            appName = "Viverse World";
          }
          if (caError != PP.CAUtils.CAError.CA_SDK_MISSING) {
            if (aroundPlayer && (caError == PP.CAUtils.CAError.USER_NOT_LOGGED_IN || caError == PP.CAUtils.CAError.USER_HAS_NO_SCORE)) {
              leaderboard = [
                { rank: 0, displayName: "Sign In", score: 0 },
                { rank: 1, displayName: "And", score: 0 },
                { rank: 2, displayName: "Play", score: 0 },
                { rank: 3, displayName: "On", score: 0 },
                { rank: 4, displayName: appName, score: 0 },
                { rank: 5, displayName: "To", score: 0 },
                { rank: 6, displayName: "Submit", score: 0 },
                { rank: 7, displayName: "Your", score: 0 },
                { rank: 8, displayName: "Own", score: 0 },
                { rank: 9, displayName: "Score", score: 0 }
              ];
            } else {
              if (PP.CAUtils.isViverse() && caError == PP.CAUtils.CAError.USER_NOT_LOGGED_IN) {
                leaderboard = [
                  { rank: 0, displayName: "Sign In", score: 0 },
                  { rank: 1, displayName: "And", score: 0 },
                  { rank: 2, displayName: "Play", score: 0 },
                  { rank: 3, displayName: "On", score: 0 },
                  { rank: 4, displayName: appName, score: 0 },
                  { rank: 5, displayName: "To", score: 0 },
                  { rank: 6, displayName: "Submit", score: 0 },
                  { rank: 7, displayName: "Your", score: 0 },
                  { rank: 8, displayName: "Own", score: 0 },
                  { rank: 9, displayName: "Score", score: 0 }
                ];
              } else {
                leaderboard = [
                  { rank: 0, displayName: "An", score: 0 },
                  { rank: 1, displayName: "Error", score: 0 },
                  { rank: 2, displayName: "Has", score: 0 },
                  { rank: 3, displayName: "Occurred", score: 0 },
                  { rank: 4, displayName: "While", score: 0 },
                  { rank: 5, displayName: "Trying", score: 0 },
                  { rank: 6, displayName: "To", score: 0 },
                  { rank: 7, displayName: "Retrieve", score: 0 },
                  { rank: 8, displayName: "The", score: 0 },
                  { rank: 9, displayName: "Leaderboard", score: 0 }
                ];
              }
            }
          } else {
            if (aroundPlayer) {
              leaderboard = [
                { rank: 0, displayName: "Sign In", score: 0 },
                { rank: 1, displayName: "And", score: 0 },
                { rank: 2, displayName: "Play", score: 0 },
                { rank: 3, displayName: "On", score: 0 },
                { rank: 4, displayName: appName, score: 0 },
                { rank: 5, displayName: "To", score: 0 },
                { rank: 6, displayName: "Submit", score: 0 },
                { rank: 7, displayName: "Your", score: 0 },
                { rank: 8, displayName: "Own", score: 0 },
                { rank: 9, displayName: "Score", score: 0 }
              ];
            } else {
              leaderboard = [
                { rank: 0, displayName: "The", score: 0 },
                { rank: 1, displayName: "Top 10", score: 0 },
                { rank: 2, displayName: "Leaderboard", score: 0 },
                { rank: 3, displayName: "Is", score: 0 },
                { rank: 4, displayName: "Available", score: 0 },
                { rank: 5, displayName: "Only", score: 0 },
                { rank: 5, displayName: "When", score: 0 },
                { rank: 7, displayName: "Playing", score: 0 },
                { rank: 8, displayName: "On", score: 0 },
                { rank: 9, displayName: appName, score: 0 }
              ];
            }
          }
          while (leaderboard.length > scoresAmount) {
            leaderboard.pop();
          }
          if (onDoneCallback != null) {
            onDoneCallback(leaderboard);
          }
        }
        submitScore(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null, caError = PP.CAUtils.CAError.NONE) {
          if (onDoneCallback != null) {
            onDoneCallback();
          }
        }
        getUser(onDoneCallback = null, onErrorCallback = null, caError = PP.CAUtils.CAError.NONE) {
          let user = {};
          user.displayName = "I Polaretti";
          if (onDoneCallback != null) {
            onDoneCallback(user);
          }
        }
      };
    }
  });

  // js/labyroots/cauldron/activate_if_wedding.js
  var require_activate_if_wedding = __commonJS({
    "js/labyroots/cauldron/activate_if_wedding.js"() {
      WL.registerComponent("activate-if-wedding", {
        _myIsWedding: { type: WL.Type.Bool, default: false },
        _myIsMazeverse: { type: WL.Type.Bool, default: false }
      }, {
        init: function() {
        },
        start: function() {
          this._myDone = false;
        },
        update: function(dt) {
          if (!this._myDone) {
            this._myDone = true;
            let isWedding = Global.isWedding();
            let isMazeverse = Global.isMazeverse();
            if (isMazeverse) {
              if (!this._myIsMazeverse) {
                this.object.pp_setActive(false);
              } else {
                this.object.pp_setActive(true);
              }
            } else if (isWedding) {
              if (!this._myIsWedding) {
                this.object.pp_setActive(false);
              } else {
                this.object.pp_setActive(true);
              }
            } else {
              if (this._myIsWedding || this._myIsMazeverse) {
                this.object.pp_setActive(false);
              } else {
                this.object.pp_setActive(true);
              }
            }
          }
        }
      });
    }
  });

  // js/labyroots/cauldron/deactivate_physx_if_far_from_player.js
  var require_deactivate_physx_if_far_from_player = __commonJS({
    "js/labyroots/cauldron/deactivate_physx_if_far_from_player.js"() {
      WL.registerComponent("deactivate-physx-if-far-from-player", {}, {
        init() {
        },
        start() {
          this._myStartd = false;
          this._myPhysxList = [];
          this._myMaxDistance = 4;
          this._myPosition = PP.vec3_create();
          this._myPlayerPosition = PP.vec3_create();
          this._myActive = false;
        },
        update(dt) {
          if (!this._myStartd) {
            this._myStartd = true;
            this._myPhysxList = this.object.pp_getComponents("physx");
          } else if (this._myActive) {
            let position = this.object.pp_getPosition(this._myPosition);
            let playerPosition = Global.myPlayer.getPosition(this._myPlayerPosition);
            if (position.vec3_distance(playerPosition) > this._myMaxDistance) {
              for (let physx of this._myPhysxList) {
                physx.active = false;
              }
            } else {
              for (let physx of this._myPhysxList) {
                physx.active = true;
              }
            }
          }
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          return clonedComponent;
        }
      });
    }
  });

  // js/labyroots/cauldron/follow_axe.js
  var require_follow_axe = __commonJS({
    "js/labyroots/cauldron/follow_axe.js"() {
      WL.registerComponent("follow-axe", {}, {
        init() {
        },
        start() {
          this._myOffset = [0.13, 0.17, 0];
          this._myPosition = PP.vec3_create();
          this._myTransformQuat = PP.quat2_create();
        },
        update(dt) {
          if (Global.myReady) {
            if (Global.myAxe) {
              let transform = Global.myAxe.pp_getTransformQuat(this._myTransformQuat);
              let position = this._myOffset.vec3_convertPositionToWorldQuat(transform, this._myPosition);
              this.object.pp_setTransformQuat(transform);
              this.object.pp_setPosition(position);
            }
          }
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          return clonedComponent;
        }
      });
    }
  });

  // js/labyroots/cauldron/fix_drifting.js
  var require_fix_drifting = __commonJS({
    "js/labyroots/cauldron/fix_drifting.js"() {
      WL.registerComponent("fix-drifting", {}, {
        init: function() {
        },
        start: function() {
        },
        update: function(dt) {
          this.object.pp_resetPositionLocal();
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          return clonedComponent;
        }
      });
    }
  });

  // js/labyroots/cauldron/show_drifting.js
  var require_show_drifting = __commonJS({
    "js/labyroots/cauldron/show_drifting.js"() {
      WL.registerComponent("show-drifting", {}, {
        init: function() {
        },
        start: function() {
        },
        update: function(dt) {
          this.object.pp_getPosition().vec_error(8);
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          return clonedComponent;
        }
      });
    }
  });

  // js/labyroots/cauldron/increase_floor_tile.js
  var require_increase_floor_tile = __commonJS({
    "js/labyroots/cauldron/increase_floor_tile.js"() {
      WL.registerComponent("increase-floor-tile", {
        _myAmount: { type: WL.Type.Float, default: 1 }
      }, {
        init() {
        },
        start() {
          this._myStarted = false;
        },
        update(dt) {
          if (!this._myStarted) {
          }
        }
      });
    }
  });

  // js/labyroots/cauldron/render_closest_walls_first.js
  var require_render_closest_walls_first = __commonJS({
    "js/labyroots/cauldron/render_closest_walls_first.js"() {
      WL.registerComponent("render-closest-wall-first", {}, {
        init() {
        },
        start() {
          this._myStarted = false;
          this._myWalls = [];
          this._myPlayerPosition = PP.vec3_create();
          this._myFirstPosition = PP.vec3_create();
          this._mySecondPosition = PP.vec3_create();
          this._myUpdateTimer = new PP.Timer(3);
        },
        update(dt) {
          if (Global.myReady) {
            if (!this._myStarted) {
              this._myStarted = true;
              this._myWalls = [];
              for (let i = 0; i < Global.myMaze._myCells.length; i++) {
                let row = Global.myMaze._myCells[i];
                for (let j = 0; j < row.length; j++) {
                  let currentCell = row[j];
                  if (currentCell.myStaticMazeItemType >= LR.MazeItemType.ROCK_WALL_HORIZONTAL && currentCell.myStaticMazeItemType <= LR.MazeItemType.ROCK_WALL_T_LEFT) {
                    let meshes = currentCell.myObject.pp_getComponents("mesh");
                    for (let mesh of meshes) {
                      this._myWalls.push([PP.vec3_create(), mesh.object]);
                    }
                  }
                }
              }
            } else {
              this._myUpdateTimer.update(dt);
              if (this._myUpdateTimer.isDone()) {
                this._myUpdateTimer.start();
                for (let wall of this._myWalls) {
                  wall[1].pp_getPosition(wall[0]);
                }
                Global.myPlayer.getPosition(this._myPlayerPosition);
                this._myWalls.sort(function(first, second) {
                  return first[0].vec3_distance(this._myPlayerPosition) - second[0].vec3_distance(this._myPlayerPosition);
                }.bind(this));
                for (let wall of this._myWalls) {
                  wall[1].pp_setActive(false);
                  wall[1].pp_setActive(true);
                }
              }
            }
          }
        }
      });
    }
  });

  // js/labyroots/cauldron/send_all_events.js
  var require_send_all_events = __commonJS({
    "js/labyroots/cauldron/send_all_events.js"() {
      WL.registerComponent("send-all-events", {}, {
        init: function() {
        },
        start: function() {
          this._myStarted = false;
        },
        update: function(dt) {
          if (!this._myStarted) {
            if (Global.myReady) {
              this._myStarted = true;
              Global.sendAnalytics("event", "button_pressed", {
                "value": 1
              });
              Global.sendAnalytics("event", "enter_vr", {
                "value": 1
              });
              Global.sendAnalytics("event", "open_ggj_success", {
                "value": 1
              });
              Global.sendAnalytics("event", "open_ggj", {
                "value": 1
              });
              Global.sendAnalytics("event", "open_github_success", {
                "value": 1
              });
              Global.sendAnalytics("event", "open_github", {
                "value": 1
              });
              Global.sendAnalytics("event", "open_zesty", {
                "value": 1
              });
              Global.sendAnalytics("event", "open_zesty_success", {
                "value": 1
              });
              Global.sendAnalytics("event", "enter_secret_zone", {
                "value": 1
              });
              Global.sendAnalytics("event", "zesty_load_fail", {
                "value": 1
              });
              Global.sendAnalytics("event", "intro_skipped", {
                "value": 1
              });
              Global.sendAnalytics("event", "intro_watched", {
                "value": 1
              });
              Global.sendAnalytics("event", "playing_signed_in", {
                "value": 1
              });
              Global.sendAnalytics("event", "is_wedding_maze", {
                "value": 1
              });
              Global.sendAnalytics("event", "is_mazeverse_maze", {
                "value": 1
              });
              Global.sendAnalytics("event", "is_normal_maze", {
                "value": 1
              });
              Global.sendAnalytics("event", "collect_axe", {
                "value": 1
              });
              Global.sendAnalytics("event", "collect_axe_after_death", {
                "value": 1
              });
              Global.sendAnalytics("event", "collect_axe_before_death", {
                "value": 1
              });
              Global.sendAnalytics("event", "secret_code_wedding_success", {
                "value": 1
              });
              Global.sendAnalytics("event", "secret_code_human_tree_success", {
                "value": 1
              });
              Global.sendAnalytics("event", "secret_code_human_tree", {
                "value": 1
              });
              Global.sendAnalytics("event", "secret_code_wedding", {
                "value": 1
              });
              Global.sendAnalytics("event", "secret_code_mazeverse", {
                "value": 1
              });
              Global.sendAnalytics("event", "secret_code_mazeverse_success", {
                "value": 1
              });
              Global.sendAnalytics("event", "death", {
                "value": 1
              });
              Global.sendAnalytics("event", "survive_for_seconds", {
                "value": 1
              });
              Global.sendAnalytics("event", "survive_bear_grills", {
                "value": 1
              });
              Global.sendAnalytics("event", "survive_a_lot", {
                "value": 1
              });
              Global.sendAnalytics("event", "survive_more", {
                "value": 1
              });
              Global.sendAnalytics("event", "defeat_mother_tree", {
                "value": 1
              });
              Global.sendAnalytics("event", "defeat_mother_tree_seconds", {
                "value": 1
              });
              Global.sendAnalytics("event", "collect_fruit", {
                "value": 1
              });
              Global.sendAnalytics("event", "eat_fruit", {
                "value": 1
              });
              Global.sendAnalytics("event", "eat_fruit_perfect", {
                "value": 1
              });
              Global.sendAnalytics("event", "eat_fruit_good", {
                "value": 1
              });
              Global.sendAnalytics("event", "eat_fruit_evil", {
                "value": 1
              });
              Global.sendAnalytics("event", "eat_fruit_bad", {
                "value": 1
              });
              Global.sendAnalytics("event", "defeat_human_tree", {
                "value": 1
              });
              Global.sendAnalytics("event", "defeat_bride_tree", {
                "value": 1
              });
              Global.sendAnalytics("event", "defeat_root_wall", {
                "value": 1
              });
              Global.sendAnalytics("event", "defeat_root", {
                "value": 1
              });
              Global.sendAnalytics("event", "switch_teleport", {
                "value": 1
              });
              Global.sendAnalytics("event", "switch_smooth", {
                "value": 1
              });
              Global.sendAnalytics("event", "moving_non_vr", {
                "value": 1
              });
              Global.sendAnalytics("event", "audio_load_error", {
                "value": 1
              });
              Global.sendAnalytics("event", "defeat_root_axe_spawn", {
                "value": 1
              });
              Global.sendAnalytics("event", "defeat_root_normal", {
                "value": 1
              });
              Global.sendAnalytics("event", "mother_tree_hit_invincible", {
                "value": 1
              });
              Global.sendAnalytics("event", "mother_tree_hit", {
                "value": 1
              });
              Global.sendAnalytics("event", "root_hit_normal", {
                "value": 1
              });
              Global.sendAnalytics("event", "root_hit_axe_spawn", {
                "value": 1
              });
              Global.sendAnalytics("event", "root_hit", {
                "value": 1
              });
              Global.sendAnalytics("event", "intro_done", {
                "value": 1
              });
              Global.sendAnalytics("event", "enter_vr_first_time", {
                "value": 1
              });
              let timeMovingSteps = [1, 2, 3, 5, 10, 20, 30, 60];
              for (let timeMovingStep of timeMovingSteps) {
                Global.sendAnalytics("event", "playing_for_" + timeMovingStep + "_minutes_vr", {
                  "value": 1
                });
                Global.sendAnalytics("event", "moving_for_" + timeMovingStep + "_minutes_vr", {
                  "value": 1
                });
                Global.sendAnalytics("event", "moving_for_" + timeMovingStep + "_minutes_non_vr", {
                  "value": 1
                });
              }
              let timeGrabbedSteps = [5, 10, 15, 30];
              for (let timeGrabbedStep of timeGrabbedSteps) {
                Global.sendAnalytics("event", "fruit_grab_for_" + timeGrabbedStep + "_seconds", {
                  "value": 1
                });
              }
              for (let i = 0; i <= 4; i++) {
                Global.sendAnalytics("event", "root_hit_normal_" + i, {
                  "value": 1
                });
                Global.sendAnalytics("event", "root_hit_axe_spawn_" + i, {
                  "value": 1
                });
                Global.sendAnalytics("event", "root_hit_" + i, {
                  "value": 1
                });
                Global.sendAnalytics("event", "defeat_root_axe_spawn_" + i, {
                  "value": 1
                });
                Global.sendAnalytics("event", "defeat_root_normal_" + i, {
                  "value": 1
                });
                Global.sendAnalytics("event", "defeat_root_" + i, {
                  "value": 1
                });
              }
            }
          }
        }
      });
    }
  });

  // js/labyroots/cauldron/sky_setter.js
  var require_sky_setter = __commonJS({
    "js/labyroots/cauldron/sky_setter.js"() {
      WL.registerComponent("sky-setter", {}, {
        init: function() {
        },
        start: function() {
          Global.mySky = this.object;
        },
        update: function(dt) {
        }
      });
      Global.mySky = null;
    }
  });

  // js/labyroots/cauldron/lights_setter.js
  var require_lights_setter = __commonJS({
    "js/labyroots/cauldron/lights_setter.js"() {
      WL.registerComponent("lights-setter", {}, {
        init: function() {
        },
        start: function() {
          Global.myLights = this.object;
        },
        update: function(dt) {
        }
      });
      Global.myLights = null;
    }
  });

  // js/labyroots/cauldron/wondermelon.js
  var wondermelon_exports = {};
  var import_howler13;
  var init_wondermelon = __esm({
    "js/labyroots/cauldron/wondermelon.js"() {
      import_howler13 = __toESM(require_howler());
      WL.registerComponent("wondermelon", {}, {
        start: function() {
          this._myGathered = false;
          this._myUsed = false;
          this._myGrabbable = this.object.pp_getComponent("pp-grabbable");
          this._myIsGrabbed = false;
          this._myStarted = false;
          this._myChange = 0;
          this._myEnd = 0;
          this._myPhysx = this.object.pp_getComponent("physx");
          if (this._myPhysx != null) {
            this._myPhysx.kinematic = true;
            this._myPulseCounter = 90;
          }
          this._myDisable = false;
        },
        update: function(dt) {
          if (!this._myStarted) {
            if (Global.myStoryReady) {
              this.object.pp_translate([0, 0.5, 0]);
              this._myStarted = true;
            }
          } else {
            if (this._myDisable) {
              this._myDisable = false;
              this.object.pp_setActive(false);
              this.active = true;
            }
            if (this._myGrabbable != null) {
              if (this._myGrabbable.isGrabbed()) {
                if (!this._myGathered) {
                  Global.sendAnalytics("event", "collect_wondermelon", {
                    "value": 1
                  });
                }
                this._myGathered = true;
                this._myIsGrabbed = true;
              } else {
                this._myIsGrabbed = false;
              }
            } else {
              this._myGrabbable = this.object.pp_getComponent("pp-grabbable");
            }
            if (Global.myStoryReady) {
              if (this._myPulseCounter > 0) {
                this._myPulseCounter--;
                this._myPhysx.kinematic = false;
                if (this._myPulseCounter == 0) {
                  let maxLinear = 2;
                  let maxAngular = 1;
                  this._myPhysx.linearVelocity = [Math.pp_random(maxLinear / 2, maxLinear) * Math.pp_randomSign(), 1, Math.pp_random(maxLinear / 2, maxLinear) * Math.pp_randomSign()];
                  this._myPhysx.angularVelocity = [Math.pp_random(maxAngular / 2, maxAngular) * Math.pp_randomSign(), Math.pp_random(maxAngular / 2, maxAngular) * Math.pp_randomSign(), Math.pp_random(maxAngular / 2, maxAngular) * Math.pp_randomSign()];
                }
              }
            }
            this._updateOpenLink(dt);
          }
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          return clonedComponent;
        },
        pp_clonePostProcess(clonedComponent) {
          clonedComponent.start();
        },
        activateEffect() {
          if (!this._myUsed && this._myGrabbable != null && this._myGrabbable.isGrabbed()) {
            this._myEnd = 90;
            this._myChange = 1;
            Global.sendAnalytics("event", "open_wondermelon", {
              "value": 1
            });
            this._myUsed = true;
            Global.myAudioMangia.setPitch(Math.pp_random(1.25 - 0.15, 1.25 + 0.05));
            Global.myAudioMangia.play();
            this._myDisable = true;
          }
        },
        _updateOpenLink(dt) {
          if (this._myEnd > 0) {
            this._myEnd--;
            if (this._myEnd == 0) {
              this._myChange = 1;
              Global.myUnmute = true;
              import_howler13.Howler.mute(true);
              if (Global.myAxe != null && Global.myAxe._myGrabbable != null) {
                Global.myAxe._myGrabbable.release();
              }
            }
          }
          if (this._myEnd == 0 && this._myChange > 0) {
            this._myChange--;
            if (this._myChange == 0) {
              let onSuccess = function() {
                Global.myUnmute = true;
                import_howler13.Howler.mute(true);
                if (Global.myAxe != null && Global.myAxe._myGrabbable != null) {
                  Global.myAxe._myGrabbable.release();
                }
                Global.sendAnalytics("event", "open_wondermelon_success", {
                  "value": 1
                });
                this.active = false;
              }.bind(this);
              PP.XRUtils.openLink("https://signorpipo.itch.io", true, true, true, true, onSuccess);
            }
          }
        }
      });
    }
  });

  // js/labyroots/cauldron/spawn_floor.js
  var require_spawn_floor = __commonJS({
    "js/labyroots/cauldron/spawn_floor.js"() {
      WL.registerComponent("spawn-floor", {
        _myOnlyIfFromAbove: { type: WL.Type.Bool, default: false },
        _myFloor: { type: WL.Type.Object },
        _myStartTile: { type: WL.Type.Object }
      }, {
        start: function() {
          if (!this._myOnlyIfFromAbove || Global.myFromAbove) {
            let spawnedFloorObject = this.object.pp_addObject();
            let spawnedTile = this._myStartTile.pp_clone();
            spawnedTile.pp_setParent(spawnedFloorObject);
            this._myFloor.pp_setActive(false);
            for (let i = 0; i < 10; i++) {
              for (let j = 0; j < 10; j++) {
                if (i != 0) {
                  let newTile = spawnedTile.pp_clone();
                  newTile.pp_translate([i * 5, 0, j * -5]);
                  newTile = spawnedTile.pp_clone();
                  newTile.pp_translate([i * -5, 0, j * 5]);
                }
                if (j != 0) {
                  let newTile = spawnedTile.pp_clone();
                  newTile.pp_translate([i * 5, 0, j * 5]);
                  newTile = spawnedTile.pp_clone();
                  newTile.pp_translate([i * -5, 0, j * -5]);
                }
              }
            }
          }
        }
      });
    }
  });

  // js/labyroots/cauldron/hide_if_pose_not_valid.js
  var require_hide_if_pose_not_valid = __commonJS({
    "js/labyroots/cauldron/hide_if_pose_not_valid.js"() {
      WL.registerComponent("hide-if-pose-not-valid", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myHand: { type: WL.Type.Object }
      }, {
        start() {
          this._myGamepad = PP.myGamepads[PP.InputUtils.getHandednessByIndex(this._myHandedness)];
          this._myGrabberHand = this._myHand.pp_getComponent("pp-grabber-hand");
          this.firstUpdate = true;
        },
        update(dt) {
          if (this.firstUpdate) {
            this.firstUpdate = false;
          } else {
            if (this._myGamepad.getHandPose() != null && this._myGamepad.getHandPose().isValid()) {
            } else {
              if (this._myGrabberHand != null) {
                this._myGrabberHand.throw();
              }
            }
          }
        }
      });
    }
  });

  // js/labyroots/player/transformation.js
  var transformation_exports = {};
  var import_howler14;
  var init_transformation = __esm({
    "js/labyroots/player/transformation.js"() {
      import_howler14 = __toESM(require_howler());
      WL.registerComponent("transformation", {}, {
        init: function() {
          Global.myTransformation = this;
        },
        start: function() {
          this._myStarted = false;
          this._myTransformationTimersSetup = null;
          this._myFirstTransformationTimersSetup = null;
          this._myTransformationTimer = new PP.Timer(0);
          Global.myStage = 0;
          this._myLastFreeCell = null;
          this._myLamentoFinalePitch = 1.4;
          this._myObjectToIgnore = [];
          this._myWeddingDelay = 2;
          this._myWeddingTimer = new PP.Timer(this._myWeddingDelay);
          this._myMazeverseTimer = new PP.Timer(this._myWeddingDelay);
          this._myChange = 0;
          this._myEnd = 0;
          this._myTimeAlive = 0;
          this._myStageTotalTime = 0;
          this._myFirstStageTotalTime = 0;
          this._myResetAxePosition = 0;
          this._myRepeatHealSound = 0;
          this._myRepeatHealSoundTimer = new PP.Timer(0.4);
          this._myPosition = [0, 0, 0];
          this._myIsWedding = false;
          this._myIsMazeverse = false;
          this._myIsFirstLive = true;
        },
        update: function(dt) {
          this._secretMazeCodeUpdate(dt);
          Global.myCancelTeleport = Math.max(Global.myCancelTeleport - 1, 0);
          if (!this._myStarted) {
            if (Global.myReady) {
              this._start();
            }
          } else {
            if (this._myRepeatHealSound > 0) {
              this._myRepeatHealSoundTimer.update(dt);
              if (this._myRepeatHealSoundTimer.isDone()) {
                this._myRepeatHealSoundTimer.start();
                this._myRepeatHealSound--;
                PP.myLeftGamepad.pulse(0.35, 0.25);
                PP.myRightGamepad.pulse(0.35, 0.25);
                let player = this._myAudioHeal2;
                player.setPitch(Math.pp_random(1.4 - 0.15, 1.4 + 0.05));
                player.play();
              }
            }
            if (this._myResetAxePosition > 0) {
              this._myResetAxePosition--;
              let axeComponent = Global.myAxe.pp_getComponent("axe");
              if (axeComponent != null) {
                axeComponent.setStartTransforms(Global.myAxeCell.myCellPosition);
              }
            }
            let playerPosition = Global.myPlayer.getPosition(this._myPosition);
            let currentCell = Global.myMaze.getCellByPosition(playerPosition);
            if (currentCell) {
              if (currentCell.myStaticMazeItemType == LR.MazeItemType.NONE || currentCell.myStaticMazeItemType == LR.MazeItemType.HUMAN_TREE_0 || currentCell.myStaticMazeItemType == LR.MazeItemType.HUMAN_TREE_1 || currentCell.myStaticMazeItemType == LR.MazeItemType.HUMAN_TREE_2 || currentCell.myStaticMazeItemType == LR.MazeItemType.HUMAN_TREE_3 || currentCell.myStaticMazeItemType == LR.MazeItemType.CREDITS || currentCell.myStaticMazeItemType == LR.MazeItemType.SECRET_CODES || currentCell.myStaticMazeItemType == LR.MazeItemType.ZESTY || currentCell.myStaticMazeItemType == LR.MazeItemType.SECRET_ZONE_CHECK || currentCell.myStaticMazeItemType == LR.MazeItemType.LEADERBOARD_TOP_10 || currentCell.myStaticMazeItemType == LR.MazeItemType.LEADERBOARD_AROUND_U || currentCell.myStaticMazeItemType == LR.MazeItemType.BUILD_CELL) {
                this._myLastFreeCell = currentCell;
              }
            }
            this._myTimeAlive += dt;
            let currentTransformationTimersSetup = this._myIsFirstLive ? this._myFirstTransformationTimersSetup : this._myTransformationTimersSetup;
            if (!Global.myBigTreeDead || Global.myStage >= currentTransformationTimersSetup.length - 1) {
              this._myTransformationTimer.update(dt);
              if (this._myTransformationTimer.isDone()) {
                if (Global.myStage + 1 >= currentTransformationTimersSetup.length) {
                  Global.myCancelTeleport = 5;
                  if (Global.myPlayerLocomotion.canStop()) {
                    Global.myPlayerLocomotion.setIdle(true);
                    this._nextStage();
                    Global.myPlayerLocomotion.setIdle(false);
                  }
                } else {
                  this._nextStage();
                }
              }
            }
            if (this._myLastFreeCell != null) {
            }
            if (PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressEnd() && PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).myMultiplePressEndCount >= 3) {
              let oldLast = this._myLastFreeCell;
              this._myLastFreeCell = Math.pp_randomPick(Global.myMaze.getCellNextToPositionEmpty(Global.myPlayer.getPosition()));
              if (this._myLastFreeCell != null) {
                this._spawnTree();
                this._myAudioPrendi.setPosition(this._myLastFreeCell.myCellPosition.vec3_add([0, 1, 0]));
                this._myAudioPrendi.setPitch(Math.pp_random(1.25 - 0.15, 1.25 + 0.05));
                this._myAudioPrendi.play();
                Global.sendAnalytics("event", "secret_code_human_tree_success", {
                  "value": 1
                });
              }
              this._myLastFreeCell = oldLast;
              Global.sendAnalytics("event", "secret_code_human_tree", {
                "value": 1
              });
            }
          }
        },
        _start() {
          this._myLamentiFinale = [];
          this._myLamentiFinale[0] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_1);
          this._myLamentiFinale[1] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_2);
          this._myLamentiFinale[2] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_3);
          this._myLamenti = [];
          this._myLamenti[0] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_UMANO_1);
          this._myLamenti[1] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_UMANO_2);
          this._myLamenti[2] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_UMANO_3);
          this._myLamentiMorte = [];
          this._myLamentiMorte[0] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_UMANO_1_MORTE);
          this._myLamentiMorte[1] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_UMANO_2_MORTE);
          this._myLamentiMorte[2] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_UMANO_3_MORTE);
          this._myAudioPrendi = PP.myAudioManager.createAudioPlayer(AudioID.TREE_UMANO_SPAWN);
          this._myAudioHeal = PP.myAudioManager.createAudioPlayer(AudioID.HEAL);
          this._myAudioHeal2 = PP.myAudioManager.createAudioPlayer(AudioID.HEAL2);
          this._myStarted = true;
          this._myTransformationTimersSetup = Global.mySetup.myPlayerSetup.myTransformationTimers;
          this._myFirstTransformationTimersSetup = Global.mySetup.myPlayerSetup.myFirstTransformationTimers;
          if (Global.myIsMazeverseTime) {
            this._myTransformationTimersSetup = Global.mySetup.myPlayerSetup.myMazeverseTransformationTimers;
            this._myFirstTransformationTimersSetup = Global.mySetup.myPlayerSetup.myMazeverseTransformationTimers;
          }
          if (Global.myFromAbove) {
            this._myTransformationTimersSetup[0] = 1e6;
            this._myFirstTransformationTimersSetup[0] = 1e6;
          }
          for (let timer of this._myTransformationTimersSetup) {
            this._myStageTotalTime += timer;
          }
          for (let timer of this._myFirstTransformationTimersSetup) {
            this._myFirstStageTotalTime += timer;
          }
          this._resetTransformation();
          this._myObjectToIgnore.pp_copy(Global.myPlayer.getMovementCollisionCheckParams().myHorizontalObjectsToIgnore);
          let physXComponents = Global.myAxe.pp_getComponentsHierarchy("physx");
          for (let physXComponent of physXComponents) {
            Global.myPlayer.getMovementCollisionCheckParams().myHorizontalObjectsToIgnore.pp_pushUnique(physXComponent.object, (first, second) => first.pp_equals(second));
          }
          Global.myPlayer.getMovementCollisionCheckParams().myVerticalObjectsToIgnore.pp_copy(Global.myPlayer.getMovementCollisionCheckParams().myHorizontalObjectsToIgnore);
          let rotationQuat = [0, 0, 0].vec3_degreesToQuat();
          Global.myPlayer.setRotationQuat(rotationQuat);
          if (Global.myMaze.getCellsByType(LR.MazeItemType.BIG_TREE) != null && Global.myMaze.getCellsByType(LR.MazeItemType.BIG_TREE).length > 0) {
            rotationQuat = Global.lookBigTreeAligned(Global.myPlayer.getPosition());
            Global.myPlayer.setRotationQuat(rotationQuat);
          }
          if (Global.myFromAbove) {
            Global.myPlayer.teleportPosition([0, 40, 0], null, true);
            Global.myPlayer.resetReal(true, false, false, true);
            Global.myPlayer.resetHeadToReal();
            Global.myPlayer.getPlayerHeadManager().setRotationHeadQuat(rotationQuat.quat_setForward([0, -1, 0]));
          }
        },
        _resetTransformation() {
          Global.myStage = 0;
          let currentTransformationTimersSetup = this._myIsFirstLive ? this._myFirstTransformationTimersSetup : this._myTransformationTimersSetup;
          this._myTransformationTimer.start(currentTransformationTimersSetup[Global.myStage]);
        },
        _nextStage(noSound = false, eat = false, full = false) {
          Global.myStage = Math.max(Global.myStage + 1, 0);
          let dead = false;
          let currentTransformationTimersSetup = this._myIsFirstLive ? this._myFirstTransformationTimersSetup : this._myTransformationTimersSetup;
          if (Global.myStage >= currentTransformationTimersSetup.length) {
            PP.myLeftGamepad.pulse(0.5, 0.5);
            PP.myRightGamepad.pulse(0.5, 0.5);
            this._death();
            dead = true;
          } else {
            this._myTransformationTimer.start(currentTransformationTimersSetup[Global.myStage]);
            if (!noSound && (eat && !full)) {
              PP.myLeftGamepad.pulse(0.35, 0.25);
              PP.myRightGamepad.pulse(0.35, 0.25);
            }
            if (!noSound && (!eat || full)) {
              PP.myLeftGamepad.pulse(0.5, 0.5);
              PP.myRightGamepad.pulse(0.5, 0.5);
            }
          }
          if (!noSound) {
            let player = Math.pp_randomPick(this._myLamenti);
            player.setPitch(Math.pp_random(1 - 0.15, 1 + 0.05));
            if (full) {
              player = Math.pp_randomPick(this._myLamentiMorte);
              player.setPitch(Math.pp_random(0.75 - 0.15, 0.75 + 0.05));
            }
            if (dead) {
              player = Math.pp_randomPick(this._myLamentiFinale);
              player.setPitch(Math.pp_random(this._myLamentoFinalePitch - 0.15, this._myLamentoFinalePitch + 0.05));
            }
            player.play();
          }
        },
        _death() {
          let currentStageTotalTime = this._myIsFirstLive ? this._myFirstStageTotalTime : this._myStageTotalTime;
          Global.myDeadOnce = true;
          this._myIsFirstLive = false;
          Global.sendAnalytics("event", "death", {
            "value": 1
          });
          Global.sendAnalytics("event", "survive_for_seconds", {
            "value": Math.round(this._myTimeAlive)
          });
          if (this._myTimeAlive > currentStageTotalTime * 3) {
            Global.sendAnalytics("event", "survive_bear_grills", {
              "value": 1
            });
          } else if (this._myTimeAlive > currentStageTotalTime * 2) {
            Global.sendAnalytics("event", "survive_a_lot", {
              "value": 1
            });
          } else if (this._myTimeAlive > currentStageTotalTime * 1.1) {
            Global.sendAnalytics("event", "survive_more", {
              "value": 1
            });
          }
          this._myTimeAlive = 0;
          this._spawnTree();
          let cell = Global.myMaze.getCellsByType(LR.MazeItemType.PLAYER_START);
          if (cell != null && cell.length > 0) {
            Global.myPlayer.teleportPosition(cell[0].myCellPosition, null, true);
            let rotationQuat = [0, 0, 0].vec3_degreesToQuat();
            Global.myPlayer.setRotationQuat(rotationQuat);
            if (Global.myMaze.getCellsByType(LR.MazeItemType.BIG_TREE) != null && Global.myMaze.getCellsByType(LR.MazeItemType.BIG_TREE).length > 0) {
              rotationQuat = Global.lookBigTreeAligned(Global.myPlayer.getPosition());
              Global.myPlayer.setRotationQuat(rotationQuat);
            }
            PP.myPlayerObjects.myNonVRCamera.pp_setUp([0, 1, 0]);
            Global.myPlayer.resetReal(true, false, false, true);
            Global.myPlayer.resetHeadToReal();
          }
          if (Global.myAxe != null) {
            let physx = Global.myAxe.pp_getComponentSelf("physx");
            let grabbable = Global.myAxe.pp_getComponentSelf("pp-grabbable");
            grabbable.release();
            physx.kinematic = true;
            Global.myAxe.pp_setParent(Global.myAxeParent);
            this._myResetAxePosition = 2;
            let physXComponents = Global.myAxe.pp_getComponentsHierarchy("physx");
            Global.myPlayer.getMovementCollisionCheckParams().myHorizontalObjectsToIgnore.pp_copy(this._myObjectToIgnore);
            for (let physXComponent of physXComponents) {
              Global.myPlayer.getMovementCollisionCheckParams().myHorizontalObjectsToIgnore.pp_pushUnique(physXComponent.object, (first, second) => first.pp_equals(second));
            }
            Global.myPlayer.getMovementCollisionCheckParams().myVerticalObjectsToIgnore.pp_copy(Global.myPlayer.getMovementCollisionCheckParams().myHorizontalObjectsToIgnore);
          }
          this._myLastFreeCell = null;
          this._resetTransformation();
          let grabbers = WL.scene.pp_getComponents("pp-grabber-hand");
          for (let grabber of grabbers) {
            grabber.throw();
          }
        },
        _spawnTree() {
          if (this._myLastFreeCell != null) {
            let positionTree = this._myLastFreeCell.getRandomPositionOnCell();
            let types = [];
            types.push(Global.myPerfectFruit);
            for (let i = 0; i < Global.mySetup.myTreeSetup.myPerfectTreeRatio; i++) {
              types.push(Global.myGoodFruit);
              types.push(Global.myBadFruit);
            }
            let randomType = Math.pp_randomPick(types);
            let tree = Global.myTrees[randomType].pp_clone();
            tree.pp_setPosition(positionTree);
            tree.pp_getComponent("human-tree").spawnFruits(Math.pp_randomInt(Global.mySetup.myTreeSetup.myMinHumanFruits, Global.mySetup.myTreeSetup.myMaxHumanFruits));
            tree.pp_setActive(true);
          }
        },
        addStage(full = false) {
          let currentTransformationTimersSetup = this._myIsFirstLive ? this._myFirstTransformationTimersSetup : this._myTransformationTimersSetup;
          if (Global.myStage < currentTransformationTimersSetup.length - 1) {
            if (full) {
              Global.myStage = Math.max(0, currentTransformationTimersSetup.length - 2);
              this._nextStage(false, true, true);
            } else {
              this._nextStage(false, true);
            }
          }
        },
        removeStage(full = false) {
          if (Global.myStage >= 0) {
            if (full) {
              Global.myStage = -1;
              this._nextStage(true, true);
              let player = this._myAudioHeal2;
              player.setPitch(Math.pp_random(1.4 - 0.15, 1.4 + 0.05));
              player.play();
              PP.myLeftGamepad.pulse(0.35, 0.25);
              PP.myRightGamepad.pulse(0.35, 0.25);
              this._myRepeatHealSound = 2;
              this._myRepeatHealSoundTimer.start();
            } else {
              Global.myStage = Math.max(-1, Global.myStage - 2);
              this._nextStage(true, true);
              let player = this._myAudioHeal;
              player.setPitch(Math.pp_random(1 - 0.15, 1 + 0.05));
              player.play();
              PP.myLeftGamepad.pulse(0.35, 0.25);
              PP.myRightGamepad.pulse(0.35, 0.25);
            }
          }
        },
        _secretMazeCodeUpdate(dt) {
          if (Global.myUnmute && PP.XRUtils.isSessionActive()) {
            Global.myUnmute = false;
            import_howler14.Howler.mute(false);
          }
          if (this._myEnd > 0) {
            this._myEnd--;
            if (this._myEnd == 0) {
              this._myChange = 1;
              Global.myUnmute = true;
              import_howler14.Howler.mute(true);
              if (Global.myAxe != null && Global.myAxe._myGrabbable != null) {
                Global.myAxe._myGrabbable.release();
              }
            }
          }
          if (this._myEnd == 0 && this._myChange > 0) {
            this._myChange--;
            if (this._myChange == 0) {
              let url = window.location.origin;
              if (window.location != window.parent.location) {
                url = "https://heyvr.io/arcade/games/labyroots";
                if (window.location.ancestorOrigins != null && window.location.ancestorOrigins.length > 0) {
                  let ancestorOrigin = window.location.ancestorOrigins[0];
                  if (ancestorOrigin.includes("itch.io")) {
                    url = "https://signorpipo.itch.io/labyroots";
                  } else if (ancestorOrigin.includes("heyvr.io")) {
                    url = "https://heyvr.io/arcade/games/labyroots";
                  }
                }
              } else {
                if (this._myIsWedding) {
                  url = url + "/?wedding=true";
                } else if (this._myIsMazeverse) {
                  if (!Global.myIsMazeverseTime) {
                    url = url + "/?mazeverse=true";
                  }
                }
              }
              let onSuccess = function() {
                Global.myUnmute = true;
                import_howler14.Howler.mute(true);
                if (Global.myAxe != null && Global.myAxe._myGrabbable != null) {
                  Global.myAxe._myGrabbable.release();
                }
                if (this._myIsWedding) {
                  Global.sendAnalytics("event", "secret_code_wedding_success", {
                    "value": 1
                  });
                } else if (this._myIsMazeverse) {
                  Global.sendAnalytics("event", "secret_code_mazeverse_success", {
                    "value": 1
                  });
                }
              }.bind(this);
              PP.XRUtils.openLink(url, true, true, true, true, onSuccess);
            }
          }
          if (this._myChange == 0 && PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressed() && PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressed()) {
            if (this._myMazeverseTimer.isRunning()) {
              this._myMazeverseTimer.update(dt);
              if (this._myMazeverseTimer.isDone()) {
                Global.sendAnalytics("event", "secret_code_mazeverse", {
                  "value": 1
                });
                Global.mySaveManager.save("is_mazeverse", !Global.myIsMazeverseTime);
                this._myEnd = 1;
                this._myChange = 1;
                this._myIsWedding = false;
                this._myIsMazeverse = true;
              }
            }
          } else {
            this._myMazeverseTimer.start();
          }
          if (this._myChange == 0 && !PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressed() && PP.myLeftGamepad.getButtonInfo(PP.GamepadButtonID.THUMBSTICK).isPressed() && PP.myRightGamepad.getButtonInfo(PP.GamepadButtonID.SELECT).isPressed()) {
            if (this._myWeddingTimer.isRunning()) {
              this._myWeddingTimer.update(dt);
              if (this._myWeddingTimer.isDone()) {
                Global.sendAnalytics("event", "secret_code_wedding", {
                  "value": 1
                });
                Global.mySaveManager.save("is_wedding", true);
                this._myEnd = 1;
                this._myChange = 1;
                this._myIsMazeverse = false;
                this._myIsWedding = true;
              }
            }
          } else {
            this._myWeddingTimer.start();
          }
        }
      });
      Global.myUnmute = false;
      Global.myExitSession = false;
      Global.myDeadOnce = false;
      Global.myWindowOpenResult = false;
      Global.windowOpen = function(urlString, successCallback, errorCallback) {
        let result = true;
        let element = document.createElement("a");
        element.style.display = "none";
        document.body.appendChild(element);
        element.addEventListener("click", function() {
          let result2 = window.open(urlString, "_blank");
          if (result2 != null) {
            if (successCallback != null) {
              successCallback();
            }
            setTimeout(function() {
              if (WL.xrSession) {
                WL.xrSession.end();
              }
            }, 500);
          } else {
            if (errorCallback != null) {
              errorCallback();
            }
          }
        });
        element.click();
        document.body.removeChild(element);
        return result;
      };
      Global.myDebugMoveUsed = false;
      Global.myDebugFlyUsed = false;
    }
  });

  // js/labyroots/player/stage_switch.js
  var require_stage_switch = __commonJS({
    "js/labyroots/player/stage_switch.js"() {
      WL.registerComponent("stage-switch", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myOnlyVR: { type: WL.Type.Bool, default: false },
        _myStage1: { type: WL.Type.Object },
        _myStage2: { type: WL.Type.Object },
        _myStage3: { type: WL.Type.Object },
        _myStage4: { type: WL.Type.Object },
        _myStage5: { type: WL.Type.Object },
        _myStage6: { type: WL.Type.Object }
      }, {
        init: function() {
        },
        start: function() {
          if (this._myHandedness == PP.HandednessIndex.LEFT) {
            this._myGamepad = PP.myLeftGamepad;
          } else {
            this._myGamepad = PP.myRightGamepad;
          }
          this._myStages = [];
          this._myStages[0] = this._myStage1;
          this._myStages[1] = this._myStage2;
          this._myStages[2] = this._myStage3;
          this._myStages[3] = this._myStage4;
          this._myStages[4] = this._myStage5;
          this._myStages[5] = this._myStage6;
          for (let stage of this._myStages) {
            if (stage != null) {
              stage.pp_setActive(false);
            }
          }
          this._myCurrentStage = -1;
        },
        update: function(dt) {
          if (!this._myOnlyVR || PP.XRUtils.isSessionActive() && this._myGamepad.getHandPose() != null && this._myGamepad.getHandPose().isValid()) {
            if (Global.myReady) {
              if (Global.myStage != this._myCurrentStage) {
                this.setStageActive(Global.myStage);
              }
            } else {
              this._myCurrentStage = -1;
              for (let stage of this._myStages) {
                if (stage != null) {
                  stage.pp_setActive(false);
                }
              }
            }
          } else {
            this._myCurrentStage = -1;
            for (let stage of this._myStages) {
              if (stage != null) {
                stage.pp_setActive(false);
              }
            }
          }
        },
        setStageActive(index) {
          for (let stage of this._myStages) {
            if (stage != null) {
              stage.pp_setActive(false);
            }
          }
          if (this._myStages[index] != null) {
            this._myStages[index].pp_setActive(true);
          }
          this._myCurrentStage = index;
        }
      });
    }
  });

  // js/labyroots/player/mouth.js
  var require_mouth = __commonJS({
    "js/labyroots/player/mouth.js"() {
      WL.registerComponent("mouth", {}, {
        init: function() {
        },
        start: function() {
          this._myPhysX = this.object.pp_getComponent("physx");
          this._myPhysX.onCollision(this._onCollision.bind(this));
          this._myTimerDestroy = new PP.Timer(0, false);
          this._myFruitToDestroy = [];
        },
        update: function(dt) {
          if (this._myTimerDestroy.isRunning()) {
            this._myTimerDestroy.update(dt);
            if (this._myTimerDestroy.isDone()) {
              for (let object of this._myFruitToDestroy) {
                object.pp_setActive(false);
              }
              this._myFruitToDestroy = [];
            }
          }
        },
        _onCollision(type, physXComponent) {
          if (type == WL.CollisionEventType.Touch || type == WL.CollisionEventType.TriggerTouch) {
            let fruit = physXComponent.object.pp_getComponent("fruit");
            if (fruit != null) {
              if (!fruit._myUsed) {
                fruit.activateEffect();
                if (fruit._myUsed) {
                  this._myFruitToDestroy.push(fruit.object);
                  this._myTimerDestroy.start();
                }
              }
            } else {
              let wondermelon = physXComponent.object.pp_getComponent("wondermelon");
              if (wondermelon != null) {
                if (!wondermelon._myUsed) {
                  wondermelon.activateEffect();
                  if (wondermelon._myUsed) {
                  }
                }
              }
            }
          }
        }
      });
    }
  });

  // js/labyroots/player/swap_grab_hand.js
  var require_swap_grab_hand = __commonJS({
    "js/labyroots/player/swap_grab_hand.js"() {
      WL.registerComponent("swap-grab-hand", {
        _myHandedness: { type: WL.Type.Enum, values: ["left", "right"], default: "left" },
        _myNormalHand: { type: WL.Type.Object },
        _myGrabHand: { type: WL.Type.Object }
      }, {
        init: function() {
        },
        start: function() {
          if (this._myHandedness == PP.HandednessIndex.LEFT) {
            this._myGamepad = PP.myLeftGamepad;
          } else {
            this._myGamepad = PP.myRightGamepad;
          }
        },
        update: function(dt) {
          if (this._myGamepad.getHandPose() == null || !this._myGamepad.getHandPose().isValid()) {
            this._myNormalHand.pp_setActive(false);
            this._myGrabHand.pp_setActive(false);
          } else {
            if (this._myGamepad.getButtonInfo(PP.GamepadButtonID.SQUEEZE).isPressed()) {
              this._myNormalHand.pp_setActive(false);
              this._myGrabHand.pp_setActive(true);
            } else {
              this._myNormalHand.pp_setActive(true);
              this._myGrabHand.pp_setActive(false);
            }
          }
        }
      });
    }
  });

  // js/labyroots/player/axe.js
  var require_axe = __commonJS({
    "js/labyroots/player/axe.js"() {
      WL.registerComponent("axe", {}, {
        init: function() {
          this._myFirstUpdate = true;
          this._myStartTransform = PP.quat2_create();
          this._myRespawnTransform = PP.quat2_create();
          this._myPrevPosition = [0, 0, 0];
          this._myPosition = [0, 0, 0];
          this._mySpeed = 0;
        },
        start: function() {
          this._myIsGrabbed = false;
          this._myLamentoPitch = 1.4;
          this._myInvinciblePitch = 0.85;
          this._myColpoFinalePitch = 1.25;
          this._myCollected = false;
          this._myStarted = false;
          PP.myEasyTuneVariables.add(new PP.EasyTuneNumber("Pitch", 1, 0.1, 3));
        },
        update: function(dt) {
          if (this._myFirstUpdate) {
            this._myFirstUpdate = false;
            this._myPhysX = Global.myFollowAxe.pp_getComponent("physx");
            if (this._myPhysX != null) {
              this._myPhysX.onCollision(this._onCollision.bind(this));
            }
            this._myToDestroy = [];
            this._myTimerDestroy = new PP.Timer(0, false);
            this._myGrabbable = this.object.pp_getComponent("pp-grabbable");
          }
          if (!this._myStarted) {
            if (Global.myReady) {
              this._myStarted = true;
              this._myAudioColpi = [];
              this._myAudioColpi[0] = PP.myAudioManager.createAudioPlayer(AudioID.COLPO_NORMALE_1);
              this._myAudioColpi[1] = PP.myAudioManager.createAudioPlayer(AudioID.COLPO_NORMALE_2);
              this._myAudioColpoFinale = PP.myAudioManager.createAudioPlayer(AudioID.COLPO_FINALE);
              this._myLamenti = [];
              this._myLamenti[0] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_1);
              this._myLamenti[1] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_2);
              this._myLamenti[2] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_3);
              this._myInvincible = PP.myAudioManager.createAudioPlayer(AudioID.INVINCIBLE);
            }
          }
          if (this._myTimerDestroy.isRunning()) {
            this._myTimerDestroy.update(dt);
            if (this._myTimerDestroy.isDone()) {
              for (let object of this._myToDestroy) {
                if (object[1]) {
                  let fruits = object[0].pp_getComponent("human-tree")._myFruits;
                  for (let fruit of fruits) {
                    if (!fruit._myGathered) {
                      let fruitFall = true;
                      if (!fruitFall) {
                      } else {
                        fruit.pp_setParent(null);
                        fruit.pp_getComponent("physx").kinematic = false;
                      }
                    }
                  }
                }
                object[0].pp_setActive(false);
              }
              this._myToDestroy = [];
            }
          }
          if (this._myGrabbable != null) {
            if (this._myGrabbable.isGrabbed()) {
              if (!this._myCollected) {
                Global.sendAnalytics("event", "collect_axe", {
                  "value": 1
                });
                if (Global.myDeadOnce) {
                  Global.sendAnalytics("event", "collect_axe_after_death", {
                    "value": 1
                  });
                } else {
                  Global.sendAnalytics("event", "collect_axe_before_death", {
                    "value": 1
                  });
                }
              }
              this._myCollected = true;
              this._myIsGrabbed = true;
            } else {
              this._myIsGrabbed = false;
            }
          }
          let currentPosition = this.object.pp_getPosition(this._myPosition);
          if (Global.myReady) {
            let distance4 = currentPosition.vec3_distance(this._myPrevPosition);
            if (distance4 < 1) {
              this._mySpeed = (this._mySpeed + distance4 / Math.max(dt, 1)) / 2;
            }
          }
          this._myPrevPosition.vec3_copy(currentPosition);
        },
        setStartTransforms(cellPosition) {
          let axePosition = [0, 1.4, 0.2];
          let axeRotation = [45, -55, -15];
          this._myStartTransform.quat2_setPositionRotationQuat(axePosition, axeRotation.vec3_degreesToQuat());
          this._myRespawnTransform = this._myStartTransform;
          this.object.pp_setTransformLocalQuat(this._myStartTransform);
          this.object.pp_rotateAxis(180, [0, 1, 0]);
        },
        resetTransformRespawn() {
          this._myGrabbable.release();
          this._myResetPos = true;
          this.object.pp_setTransformLocalQuat(this._myRespawnTransform);
        },
        _onCollision(type, physXComponent) {
          if (!Global.myReady) {
            return;
          }
          if (this._myGrabbable.isGrabbed() && this._mySpeed >= Global.mySetup.myPlayerSetup.myAxeSpeedToHit) {
            if (type == WL.CollisionEventType.Touch || type == WL.CollisionEventType.TriggerTouch) {
              let root = physXComponent.object.pp_getComponent("root");
              if (root) {
                if (root._myHit > 0) {
                  if (root.hit()) {
                    if (root._myHit == 0) {
                      PP.myLeftGamepad.pulse(0.5, 0.5);
                      PP.myRightGamepad.pulse(0.5, 0.5);
                    } else {
                      this._myGrabbable.getGrabber().pp_getComponent("pp-grabber-hand")._myGamepad.pulse(0.5, 0.25);
                    }
                    let player = this._myAudioColpoFinale;
                    let pitch = 1;
                    if (root._myHit > 0) {
                      if (root._myHit > 1) {
                        player = this._myAudioColpi[1];
                      } else {
                        player = this._myAudioColpi[0];
                      }
                    } else {
                      pitch = this._myColpoFinalePitch;
                    }
                    player.setPosition(this.object.pp_getPosition());
                    player.setPitch(Math.pp_random(pitch - 0.15, pitch + 0.05));
                    player.play();
                    if (root._myHit == 0) {
                      let player2 = Math.pp_randomPick(this._myLamenti);
                      player2.setPosition(root.object.pp_getPosition().vec3_add([0, 2, 0]));
                      player2.setPitch(Math.pp_random(this._myLamentoPitch - 0.15, this._myLamentoPitch + 0.05));
                      player2.play();
                    }
                  }
                } else {
                  this._myGrabbable.getGrabber().pp_getComponent("pp-grabber-hand")._myGamepad.pulse(0.5, 0.25);
                }
              }
              let rootWall = physXComponent.object.pp_getComponent("root-wall");
              if (rootWall) {
                if (rootWall._myHit > 0) {
                  if (rootWall.hit()) {
                    if (rootWall._myHit == 0) {
                      PP.myLeftGamepad.pulse(0.5, 0.5);
                      PP.myRightGamepad.pulse(0.5, 0.5);
                    } else {
                      this._myGrabbable.getGrabber().pp_getComponent("pp-grabber-hand")._myGamepad.pulse(0.5, 0.25);
                    }
                    let player = this._myAudioColpoFinale;
                    let pitch = 1;
                    if (rootWall._myHit > 0) {
                      if (rootWall._myHit > 1) {
                        player = this._myAudioColpi[1];
                      } else {
                        player = this._myAudioColpi[0];
                      }
                    } else {
                      pitch = this._myColpoFinalePitch;
                    }
                    player.setPosition(this.object.pp_getPosition());
                    player.setPitch(Math.pp_random(pitch - 0.15, pitch + 0.05));
                    player.play();
                    if (rootWall._myHit == 0) {
                      let player2 = Math.pp_randomPick(this._myLamenti);
                      player2.setPosition(rootWall.object.pp_getPosition().vec3_add([0, 2, 0]));
                      player2.setPitch(Math.pp_random(this._myLamentoPitch - 0.15, this._myLamentoPitch + 0.05));
                      player2.play();
                    }
                  }
                  if (rootWall._myHit == 0) {
                    this._myToDestroy.push([rootWall.object, false]);
                    this._myTimerDestroy.start();
                  }
                }
              }
              let bigTree = physXComponent.object.pp_getComponent("big-tree");
              if (bigTree) {
                if (bigTree._myHit > 0) {
                  if (bigTree.hit()) {
                    if (bigTree._myHit != 0) {
                      this._myGrabbable.getGrabber().pp_getComponent("pp-grabber-hand")._myGamepad.pulse(0.5, 0.25);
                    }
                    let player = this._myAudioColpoFinale;
                    let pitch = 1;
                    if (bigTree._myHit > 0) {
                      if (bigTree._myHit % 2 == 0) {
                        player = this._myAudioColpi[1];
                      } else {
                        player = this._myAudioColpi[0];
                      }
                    } else {
                      pitch = this._myColpoFinalePitch;
                    }
                    player.setPosition(this.object.pp_getPosition());
                    player.setPitch(Math.pp_random(pitch - 0.15, pitch + 0.05));
                    player.play();
                    if (bigTree._myHit == 0) {
                      let player2 = Math.pp_randomPick(this._myLamenti);
                      player2.setPosition(bigTree.object.pp_getPosition().vec3_add([0, 2, 0]));
                      player2.setPitch(Math.pp_random(this._myLamentoPitch - 0.15, this._myLamentoPitch + 0.05));
                    }
                  } else {
                    this._myGrabbable.getGrabber().pp_getComponent("pp-grabber-hand")._myGamepad.pulse(0.5, 0.25);
                    let player = this._myInvincible;
                    player.setPosition(bigTree.object.pp_getPosition().vec3_add([0, 2, 0]));
                    player.setPitch(Math.pp_random(this._myInvinciblePitch - 0.15, this._myInvinciblePitch + 0.05));
                    player.play();
                  }
                  if (bigTree._myHit == 0) {
                  }
                } else {
                  this._myGrabbable.getGrabber().pp_getComponent("pp-grabber-hand")._myGamepad.pulse(0.5, 0.25);
                }
              }
              let humanTree = physXComponent.object.pp_getComponent("human-tree");
              if (humanTree) {
                if (humanTree._myHit > 0) {
                  if (humanTree.hit()) {
                    if (humanTree._myHit == 0) {
                      PP.myLeftGamepad.pulse(0.5, 0.5);
                      PP.myRightGamepad.pulse(0.5, 0.5);
                    } else {
                      this._myGrabbable.getGrabber().pp_getComponent("pp-grabber-hand")._myGamepad.pulse(0.5, 0.25);
                    }
                    let player = this._myAudioColpoFinale;
                    let pitch = 1;
                    if (humanTree._myHit > 0) {
                      if (humanTree._myHit > 1) {
                        player = this._myAudioColpi[1];
                      } else {
                        player = this._myAudioColpi[0];
                      }
                    } else {
                      pitch = this._myColpoFinalePitch;
                    }
                    player.setPosition(this.object.pp_getPosition());
                    player.setPitch(Math.pp_random(pitch - 0.15, pitch + 0.05));
                    player.play();
                  }
                  if (humanTree._myHit == 0) {
                    let player = Math.pp_randomPick(this._myLamenti);
                    player.setPosition(humanTree.object.pp_getPosition().vec3_add([0, 2, 0]));
                    player.setPitch(Math.pp_random(this._myLamentoPitch - 0.15, this._myLamentoPitch + 0.05));
                    player.play();
                    this._myToDestroy.push([humanTree.object, true]);
                    let manageFruits = false;
                    if (manageFruits) {
                      let fruits = humanTree._myFruits;
                      for (let fruit of fruits) {
                        if (!fruit._myGathered) {
                          let fruitFall = true;
                          if (!fruitFall) {
                            this._myToDestroy.push(fruit);
                          } else {
                            fruit.pp_setParent(null);
                            fruit.pp_getComponent("physx").kinematic = false;
                          }
                        }
                      }
                    }
                    this._myTimerDestroy.start();
                  }
                }
              }
              let openComponents = ["open-ggj", "open-zesty", "open-github"];
              for (let component of openComponents) {
                let openComponent = physXComponent.object.pp_getComponent(component);
                if (openComponent) {
                  if (openComponent.hit()) {
                    if (openComponent._myHit == 0) {
                      PP.myLeftGamepad.pulse(0.5, 0.5);
                      PP.myRightGamepad.pulse(0.5, 0.5);
                    } else {
                      this._myGrabbable.getGrabber().pp_getComponent("pp-grabber-hand")._myGamepad.pulse(0.5, 0.25);
                    }
                    let player = this._myAudioColpoFinale;
                    let pitch = 1;
                    if (openComponent._myHit > 0) {
                      if (openComponent._myHit > 1) {
                        player = this._myAudioColpi[1];
                      } else {
                        player = this._myAudioColpi[0];
                      }
                    } else {
                      pitch = this._myColpoFinalePitch;
                    }
                    player.setPosition(this.object.pp_getPosition());
                    player.setPitch(Math.pp_random(pitch - 0.15, pitch + 0.05));
                    player.play();
                    if (openComponent._myHit == 0) {
                      let player2 = Math.pp_randomPick(this._myLamenti);
                      player2.setPosition(openComponent.object.pp_getPosition().vec3_add([0, 2, 0]));
                      player2.setPitch(Math.pp_random(this._myLamentoPitch - 0.15, this._myLamentoPitch + 0.05));
                      player2.play();
                      openComponent.open();
                    }
                  }
                }
              }
            }
          }
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          clonedComponent._myStartTransform.quat2_copy(this._myStartTransform);
          return clonedComponent;
        }
      });
    }
  });

  // js/labyroots/tree/fruit.js
  var require_fruit = __commonJS({
    "js/labyroots/tree/fruit.js"() {
      WL.registerComponent("fruit", {
        _myType: { type: WL.Type.Int, default: 60 }
      }, {
        init: function() {
          if (Global.myFruitRandomPowers.length == 0) {
            let indexes = [0, 1, 2];
            let firstIndex = LR.MazeItemType.HUMAN_TREE_1;
            while (indexes.length > 0) {
              let random5 = Math.pp_randomPick(indexes);
              indexes.pp_removeEqual(random5);
              Global.myFruitRandomPowers[firstIndex] = Global.myFruitPowers[random5];
              if (random5 == 0) {
                Global.myGoodFruit = firstIndex;
              }
              if (random5 == 1) {
                Global.myBadFruit = firstIndex;
              }
              if (random5 == 2) {
                Global.myPerfectFruit = firstIndex;
              }
              if (random5 == 3) {
                Global.myEvilFruit = firstIndex;
              }
              firstIndex += 10;
            }
          }
          Global.myFruitRandomPowers[LR.MazeItemType.HUMAN_TREE_4] = Global.myFruitPowers[3];
        },
        start: function() {
          this._myGathered = false;
          this._myUsed = false;
          this._myGrabbable = this.object.pp_getComponent("pp-grabbable");
          this._myIsGrabbed = false;
          this._myTimeGrabbed = 0;
          this._myTimeGrabbedStep = [5, 10, 15, 30];
          this._myTimeGrabbedStepIndex = 0;
          this._myStarted = false;
        },
        update: function(dt) {
          if (!this._myStarted) {
            if (Global.myStoryReady) {
              this._myStarted = true;
            }
          }
          if (this._myGrabbable != null) {
            if (this._myGrabbable.isGrabbed()) {
              if (!this._myGathered) {
                Global.sendAnalytics("event", "collect_fruit", {
                  "value": 1
                });
              }
              this._myGathered = true;
              this._myIsGrabbed = true;
              this._myTimeGrabbed += dt;
              if (this._myTimeGrabbedStepIndex < this._myTimeGrabbedStep.length && this._myTimeGrabbed > this._myTimeGrabbedStep[this._myTimeGrabbedStepIndex]) {
                Global.sendAnalytics("event", "fruit_grab_for_" + this._myTimeGrabbedStep[this._myTimeGrabbedStepIndex] + "_seconds", {
                  "value": 1
                });
                this._myTimeGrabbedStepIndex++;
              }
            } else {
              this._myIsGrabbed = false;
            }
          } else {
            this._myGrabbable = this.object.pp_getComponent("pp-grabbable");
          }
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          clonedComponent._myType = this._myType;
          return clonedComponent;
        },
        pp_clonePostProcess(clonedComponent) {
          clonedComponent.start();
        },
        activateEffect() {
          if (!this._myUsed && this._myGrabbable != null && this._myGrabbable.isGrabbed()) {
            Global.sendAnalytics("event", "eat_fruit", {
              "value": 1
            });
            Global.myFruitRandomPowers[this._myType]();
            this._myUsed = true;
            Global.myAudioMangia.setPitch(Math.pp_random(1.25 - 0.15, 1.25 + 0.05));
            Global.myAudioMangia.play();
          }
        }
      });
      Global.myFruitRandomPowers = [];
      decreaseStage = function(full) {
        if (full) {
          Global.sendAnalytics("event", "eat_fruit_perfect", {
            "value": 1
          });
        } else {
          Global.sendAnalytics("event", "eat_fruit_good", {
            "value": 1
          });
        }
        Global.myTransformation.removeStage(full);
      };
      increaseStage = function(full) {
        if (full) {
          Global.sendAnalytics("event", "eat_fruit_evil", {
            "value": 1
          });
        } else {
          Global.sendAnalytics("event", "eat_fruit_bad", {
            "value": 1
          });
        }
        Global.myTransformation.addStage(full);
      };
      Global.myFruitPowers = [];
      Global.myFruitPowers[0] = decreaseStage.bind(null, false);
      Global.myFruitPowers[1] = increaseStage.bind(null, false);
      Global.myFruitPowers[2] = decreaseStage.bind(null, true);
      Global.myFruitPowers[3] = increaseStage.bind(null, true);
      Global.myGoodFruit = null;
      Global.myBadFruit = null;
      Global.myPerfectFruit = null;
      Global.myEvilFruit = null;
    }
  });

  // js/labyroots/tree/root.js
  var require_root = __commonJS({
    "js/labyroots/tree/root.js"() {
      WL.registerComponent("root", {
        _myNormal: { type: WL.Type.Object },
        _myHurt: { type: WL.Type.Object },
        _myDead: { type: WL.Type.Object },
        _myAxeSpawnRoot: { type: WL.Type.Bool, default: false }
      }, {
        init: function() {
        },
        start: function() {
          this._myStarted = false;
          this._myHit = 0;
          this._myCurrentPhase = 0;
          this._myPhases = [];
        },
        update: function(dt) {
          if (!this._myStarted) {
            if (Global.myReady) {
              let children = this.object.pp_getChildren();
              for (let i = 0; i < children.length; i++) {
                this._myPhases[parseInt(children[i].pp_getName()) - 1] = children[i];
              }
              for (let phase of this._myPhases) {
                phase.pp_setActive(false);
              }
              this._myStarted = true;
              this._myHit = Global.mySetup.myTreeSetup.myRootHit;
              this._myPhases[0].pp_setActive(true);
            }
          }
        },
        hit() {
          let hitted = false;
          if (this._myHit > 0) {
            this._myHit--;
            hitted = true;
            for (let phase of this._myPhases) {
              phase.pp_setActive(false);
            }
            if (this._myHit == 0) {
              Global.myRootsDefeated += 1;
              this._myPhases[2].pp_setActive(true);
              let tree = WL.scene.pp_getComponent("big-tree");
              if (tree) {
                tree.rootDie();
              }
              Global.sendAnalytics("event", "defeat_root", {
                "value": 1
              });
              Global.sendAnalytics("event", "defeat_root_" + Global.myRootsDefeated, {
                "value": 1
              });
              if (this._myAxeSpawnRoot) {
                Global.sendAnalytics("event", "defeat_root_axe_spawn", {
                  "value": 1
                });
                Global.sendAnalytics("event", "defeat_root_axe_spawn_" + Global.myRootsDefeated, {
                  "value": 1
                });
              } else {
                Global.sendAnalytics("event", "defeat_root_normal", {
                  "value": 1
                });
                Global.sendAnalytics("event", "defeat_root_normal_" + Global.myRootsDefeated, {
                  "value": 1
                });
              }
            } else {
              this._myPhases[1].pp_setActive(true);
              Global.sendAnalytics("event", "root_hit", {
                "value": 1
              });
              let rootHit = Global.myRootsDefeated + 1;
              Global.sendAnalytics("event", "root_hit_" + rootHit, {
                "value": 1
              });
              if (this._myAxeSpawnRoot) {
                Global.sendAnalytics("event", "root_hit_axe_spawn", {
                  "value": 1
                });
                Global.sendAnalytics("event", "root_hit_axe_spawn_" + rootHit, {
                  "value": 1
                });
              } else {
                Global.sendAnalytics("event", "root_hit_normal", {
                  "value": 1
                });
                Global.sendAnalytics("event", "root_hit_normal_" + rootHit, {
                  "value": 1
                });
              }
            }
          }
          return hitted;
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          clonedComponent._myAxeSpawnRoot = this._myAxeSpawnRoot;
          return clonedComponent;
        }
      });
      Global.myRootsDefeated = 0;
    }
  });

  // js/labyroots/tree/root_wall.js
  var require_root_wall = __commonJS({
    "js/labyroots/tree/root_wall.js"() {
      WL.registerComponent("root-wall", {}, {
        init: function() {
        },
        start: function() {
          this._myStarted = false;
          this._myHit = 0;
        },
        update: function(dt) {
          if (!this._myStarted) {
            if (Global.myReady) {
              this._myStarted = true;
              this._myHit = Global.mySetup.myTreeSetup.myRootWallHit;
            }
          }
        },
        hit() {
          let hitted = false;
          if (this._myHit > 0) {
            this._myHit--;
            hitted = true;
            if (this._myHit == 0) {
              Global.sendAnalytics("event", "defeat_root_wall", {
                "value": 1
              });
            }
          }
          return hitted;
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          return clonedComponent;
        }
      });
    }
  });

  // js/labyroots/tree/big_tree.js
  var require_big_tree = __commonJS({
    "js/labyroots/tree/big_tree.js"() {
      Global.myBigTree = null;
      Global.myBigTreeDead = false;
      WL.registerComponent("big-tree", {
        _myPhase1: { type: WL.Type.Object },
        _myPhase2: { type: WL.Type.Object },
        _myPhase3: { type: WL.Type.Object },
        _myPhase4: { type: WL.Type.Object },
        _myPhase5: { type: WL.Type.Object }
      }, {
        init: function() {
        },
        start: function() {
          this._myStarted = false;
          this._myBigTreeRoots = 0;
          this._myHit = 0;
          this._myPhases = [];
          this._myCurrentPhase = 0;
          this._myAvoidIncrement = false;
          Global.myBigTree = this;
          this._myTimeToWin = 0;
        },
        update: function(dt) {
          if (!this._myStarted) {
            if (Global.myReady) {
              this._myBigTreeDie = new LR.BigTreeDie();
              let children = this.object.pp_getChildren();
              for (let i = 0; i < children.length; i++) {
                this._myPhases[parseInt(children[i].pp_getName()) - 1] = children[i];
              }
              for (let phase of this._myPhases) {
                phase.pp_setActive(false);
              }
              this._myStarted = true;
              this._myBigTreeRoots = Global.mySetup.myTreeSetup.myBigTreeRoots;
              this._myHit = Global.mySetup.myTreeSetup.myBigTreeHit;
              this._myPhases[0].pp_setActive(true);
              let rotationQuat = Global.lookPlayerAligned(this.object.pp_getPosition());
              this.object.pp_setRotationQuat(rotationQuat);
            }
          } else if (this._myHit == 0) {
            this._myBigTreeDie.update(dt);
          }
          if (this._myStarted && Global.myReady) {
            if (this._myHit > 0) {
              this._myTimeToWin += dt;
            }
          }
        },
        rootDie() {
          if (this._myBigTreeRoots > 0) {
            this._myBigTreeRoots--;
            for (let phase of this._myPhases) {
              phase.pp_setActive(false);
            }
            this._myCurrentPhase++;
            this._myPhases[Math.floor(this._myCurrentPhase / 2)].pp_setActive(true);
          }
        },
        hit() {
          let hitted = false;
          if (this._myBigTreeRoots == 0) {
            if (!this._myAvoidIncrement) {
              this._myCurrentPhase++;
            }
            if (this._myHit > 0) {
              this._myHit--;
              hitted = true;
              for (let phase of this._myPhases) {
                phase.pp_setActive(false);
              }
              if (this._myHit > 4) {
                this._myPhases[2].pp_setActive(true);
              } else if (this._myHit > 0) {
                this._myPhases[3].pp_setActive(true);
              } else {
                this._myPhases[4].pp_setActive(true);
              }
              this._myAvoidIncrement = true;
              if (this._myHit == 0) {
                Global.myBigTreeDead = true;
                Global.myStage = 0;
                let isFirstWin = !Global.mySaveManager.load("win_normal_maze", false);
                if (isFirstWin && !Global.myIsMazeverseTime) {
                  Global.mySaveManager.save("is_mazeverse", true);
                }
                Global.mySaveManager.save("win", true);
                if (Global.myIsMazeverseTime) {
                  Global.mySaveManager.save("win_mazeverse", true);
                } else {
                  Global.mySaveManager.save("win_normal_maze", true);
                }
                Global.sendAnalytics("event", "defeat_mother_tree", {
                  "value": 1
                });
                if (Global.myIsMazeverseTime) {
                  Global.sendAnalytics("event", "defeat_mother_tree_mazeverse", {
                    "value": 1
                  });
                  if (!Global.myWinMazeverse) {
                    Global.sendAnalytics("event", "defeat_mother_tree_mazeverse_first_time", {
                      "value": 1
                    });
                  }
                } else {
                  Global.sendAnalytics("event", "defeat_mother_tree_normal", {
                    "value": 1
                  });
                }
                Global.sendAnalytics("event", "defeat_mother_tree_seconds", {
                  "value": Math.round(this._myTimeToWin)
                });
                if (!Global.myIsMazeverseTime) {
                  let score = Math.floor(this._myTimeToWin * 1e3);
                  let scoreSubmittedSucceded = false;
                  let scoreStopSubmitting = false;
                  let submitScoreSuccessCallback = function() {
                    if (!scoreSubmittedSucceded) {
                      scoreSubmittedSucceded = true;
                      let leaderboards = WL.scene.pp_getComponents("display-leaderboard");
                      for (let leaderboard of leaderboards) {
                        leaderboard.updateLeaderboard();
                      }
                      Global.sendAnalytics("event", "score_submitted", {
                        "value": 1
                      });
                    }
                  };
                  let submitScoreErrorCallback = function(error) {
                    if (error != null && error.type != PP.CAUtils.CAError.SUBMIT_SCORE_FAILED) {
                      scoreStopSubmitting = true;
                    }
                  };
                  PP.CAUtils.submitScore("labyroots", score, submitScoreSuccessCallback, submitScoreErrorCallback, false);
                  setTimeout(function() {
                    if (!scoreSubmittedSucceded && !scoreStopSubmitting) {
                      PP.CAUtils.submitScore("labyroots", score, submitScoreSuccessCallback, submitScoreErrorCallback, false);
                    }
                  }, 5e3);
                  setTimeout(function() {
                    if (!scoreSubmittedSucceded && !scoreStopSubmitting) {
                      PP.CAUtils.submitScore("labyroots", score, submitScoreSuccessCallback, submitScoreErrorCallback, false);
                    }
                  }, 1e4);
                }
              } else {
                Global.sendAnalytics("event", "mother_tree_hit", {
                  "value": 1
                });
              }
            }
          } else {
            Global.sendAnalytics("event", "mother_tree_hit_invincible", {
              "value": 1
            });
          }
          return hitted;
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          return clonedComponent;
        },
        pp_clonePostProcess(clonedComponent) {
          clonedComponent.start();
        }
      });
    }
  });

  // js/labyroots/tree/human_tree.js
  var require_human_tree = __commonJS({
    "js/labyroots/tree/human_tree.js"() {
      WL.registerComponent("human-tree", {
        _myType: { type: WL.Type.Int, default: 60 }
      }, {
        init: function() {
          this._myPoints = null;
        },
        start: function() {
          this._myStarted = false;
          this._myHit = 0;
          this._myFruits = [];
        },
        update: function(dt) {
          if (!this._myStarted) {
            if (Global.myReady) {
              this._myStarted = true;
              if (this._myType == 90) {
                this._myHit = Global.mySetup.myTreeSetup.myHumanTreeHit * 100;
              } else {
                this._myHit = Global.mySetup.myTreeSetup.myHumanTreeHit;
              }
            }
          }
        },
        pp_clone(targetObject) {
          let clonedComponent = targetObject.pp_addComponent(this.type);
          clonedComponent.active = this.active;
          clonedComponent._myType = this._myType;
          return clonedComponent;
        },
        spawnFruits(fruitAmount) {
          if (this._myPoints == null) {
            this._myPoints = this.object.pp_getChildren();
            this._myPoints.pp_remove((object) => object.pp_getComponent("physx") != null);
          }
          if (fruitAmount == 8) {
            fruitAmount = Math.pp_randomInt(0, this._myPoints.length);
          } else if (fruitAmount == 9) {
            if (this._myType == LR.MazeItemType.HUMAN_TREE_4) {
              fruitAmount = this._myPoints.length;
            } else {
              fruitAmount = Math.pp_randomInt(1, this._myPoints.length);
            }
          } else if (fruitAmount == 7) {
            fruitAmount = Math.pp_randomInt(Global.mySetup.myTreeSetup.myMinHumanFruits, Global.mySetup.myTreeSetup.myMaxHumanFruits);
          }
          let points = this._myPoints.pp_clone();
          while (fruitAmount > 0 && points.length > 0) {
            fruitAmount--;
            let point = Math.pp_randomPick(points);
            points.pp_removeEqual(point);
            let fruit = Global.myFruits[this._myType].pp_clone();
            fruit.pp_setParent(this.object);
            fruit.pp_setTransformLocalQuat(point.pp_getTransformLocalQuat());
            fruit.pp_setActive(true);
            this._myFruits.push(fruit);
          }
        },
        hit() {
          let hitted = false;
          if (this._myHit > 0) {
            this._myHit--;
            hitted = true;
            if (this._myHit == 0) {
              if (this._myType != 90) {
                Global.sendAnalytics("event", "defeat_human_tree", {
                  "value": 1
                });
              } else {
                Global.sendAnalytics("event", "defeat_bride_tree", {
                  "value": 1
                });
                Global.myBigTreeDead = true;
                Global.myStage = 0;
              }
            } else {
              if (this._myType != 90) {
                Global.sendAnalytics("event", "human_tree_hit", {
                  "value": 1
                });
              } else {
                Global.sendAnalytics("event", "bride_tree_hit", {
                  "value": 1
                });
              }
            }
          }
          return hitted;
        },
        pp_clonePostProcess(clonedComponent) {
          clonedComponent.start();
        }
      });
    }
  });

  // js/labyroots/tree/big_tree_die.js
  var require_big_tree_die = __commonJS({
    "js/labyroots/tree/big_tree_die.js"() {
      LR.BigTreeDie = class BigTreeDie {
        constructor() {
          this._myTimer = new PP.Timer(0);
          this._myMaxCounter = 7;
          this._myCounter = this._myMaxCounter;
          this._myLamenti = [];
          this._myLamenti[0] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_1);
          this._myLamenti[1] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_2);
          this._myLamenti[2] = PP.myAudioManager.createAudioPlayer(AudioID.LAMENTO_3);
          this._mySecretWallDie = PP.myAudioManager.createAudioPlayer(AudioID.SECRET_WALL_OPEN);
          this._myAudioColpi = PP.myAudioManager.createAudioPlayer(AudioID.BIG_TREE_DIE_HIT);
          this._myLamentoPitch = 1.4;
        }
        update(dt) {
          let tempoBase = 1;
          if (this._myCounter > 0) {
            this._myTimer.update(dt);
            if (this._myTimer.isDone()) {
              if (this._myCounter > 1) {
                this._myTimer.start(tempoBase);
                let player = Math.pp_randomPick(this._myLamenti);
                let position = Global.myBigTree.object.pp_getPosition().vec3_add([Math.pp_random(-1, 1), Math.pp_random(1.75, 3), 0]);
                player.setPosition(position);
                player.setPitch(Math.pp_random(this._myLamentoPitch - 0.15, this._myLamentoPitch + 0.05));
                player.play();
                if (this._myCounter != this._myMaxCounter) {
                  let playerColpo = this._myAudioColpi;
                  playerColpo.setPosition(position);
                  let pitch = 0.6;
                  playerColpo.setPitch(Math.pp_random(pitch - 0.15, pitch + 0.05));
                }
                PP.myLeftGamepad.pulse(0.5, 0.5);
                PP.myRightGamepad.pulse(0.5, 0.5);
                if (this._myCounter == 2) {
                  this._myTimer.start(tempoBase + 0.5);
                }
              } else if (Global.mySecretWall != null) {
                let wallPosition = Global.mySecretWall.pp_getPosition();
                this._mySecretWallDie.setPosition(wallPosition.vec3_add([0, 1.5, 0]));
                this._mySecretWallDie.play();
                Global.mySecretWall.pp_setActive(false);
                PP.myLeftGamepad.pulse(0.75, 0.75);
                PP.myRightGamepad.pulse(0.75, 0.75);
              }
              this._myCounter--;
            }
          }
        }
      };
    }
  });

  // js/labyroots/test/test.js
  var require_test = __commonJS({
    "js/labyroots/test/test.js"() {
      WL.registerComponent("test", {}, {
        init: function() {
        },
        start: function() {
          this._myState = 3;
          this._myTimer = 15;
        },
        update: function(dt) {
          this._myTimer -= dt;
          if (this._myState == 3 && this._myTimer <= 10) {
            console.log(this._myState + " --> " + --this._myState);
            console.log("10secondi rimanenti");
          } else if (this._myState == 2 && this._myTimer <= 6) {
            console.log(this._myState + " --> " + --this._myState);
            console.log("6secondi rimanenti");
          } else if (this._myState == 1 && this._myTimer <= 3) {
            console.log(this._myState + " --> " + --this._myState);
            console.log("3secondi rimanenti");
          } else if (this._myState == 0 && this._myTimer <= 0) {
            console.log(this._myState + " --> " + --this._myState);
            console.log("Sei un albero");
          }
        }
      });
    }
  });

  // js/bundle.js
  require_thwall_camera();
  require_cursor_target();
  init_cursor();
  require_debug_object();
  require_device_orientation_look();
  require_finger_cursor();
  require_fixed_foveation();
  init_hand_tracking();
  init_hit_test_location();
  init_howler_audio_listener();
  init_howler_audio_source();
  require_image_texture();
  init_mouse_look();
  require_target_framerate();
  init_teleport();
  init_two_joint_ik_solver();
  require_video_texture();
  require_vr_mode_active_switch();
  init_wasd_controls();
  init_wonderleap_ad();
  require_pp();
  init_array_extension();
  init_object_extension();
  require_math_extension();
  require_scene_extension();
  require_clone_component_mod();
  init_cursor_component_mod();
  require_cursor_target_component_mod();
  require_mouse_look_component_mod();
  init_spatial_audio_listener();
  init_audio_manager_component();
  init_audio_manager();
  init_audio_player();
  require_audio_setup();
  init_audio_utils();
  init_mute_everything();
  require_howler_audio_player();
  init_max_physx();
  require_max_visible_triangles();
  require_object_pool_manager();
  require_save_manager();
  require_timer();
  require_clear_console_on_xr_session_start();
  require_set_active();
  require_adjust_hierarchy_physx_scale();
  require_get_player_objects();
  require_get_default_resources();
  require_show_fps();
  require_fsm();
  require_state();
  require_transition();
  require_timer_state();
  require_color_utils();
  require_material_utils();
  require_mesh_utils();
  require_save_utils();
  require_text_utils();
  require_xr_utils();
  require_browser_utils();
  require_physics_utils();
  require_physics_raycast_data();
  require_physics_layer_flags();
  require_physics_collision_collector();
  require_visual_manager();
  require_visual_element_types();
  require_visual_line();
  require_visual_mesh();
  require_visual_point();
  require_visual_arrow();
  require_visual_text();
  require_visual_transform();
  require_visual_raycast();
  require_visual_torus();
  require_visual_manager_component();
  require_debug_manager();
  require_debug_visual_manager();
  require_debug_transform_component();
  require_debug_manager_component();
  require_direction_2D_to_3D_converter();
  require_number_over_value();
  require_player_head_controller();
  require_player_occlusion();
  init_player_head_controller_component();
  init_player_occlusion_component();
  require_collision_params();
  require_collision_check();
  require_collision_movement_check();
  require_collision_teleport_check();
  require_collision_position_check();
  require_horizontal_collision_check();
  require_horizontal_collision_sliding();
  require_horizontal_collision_movement_check();
  require_horizontal_collision_position_check();
  require_vertical_collision_check();
  require_collision_surface_check();
  require_collision_check_bridge();
  require_character_collider_setup();
  require_character_collider_utils();
  require_character_collision_results();
  require_character_collision_system();
  init_character_collision_system_component();
  require_character_controller();
  require_synced_character_controller();
  require_character_controller_utils();
  init_character_controller_component();
  require_player_character_controller();
  require_player_head_character_controller();
  require_player_hand_character_controller();
  init_player_character_controller_component();
  init_player_head_character_controller_component();
  init_player_hand_character_controller_component();
  require_character_controller_utils();
  require_grabbable();
  require_grabber_hand();
  init_global_gravity();
  require_player_locomotion_smooth();
  require_player_locomotion_rotate();
  require_player_locomotion_gravity();
  require_player_locomotion_teleport();
  init_player_locomotion_teleport_component();
  init_player_locomotion_smooth_component();
  init_player_locomotion_rotate_component();
  init_player_locomotion_gravity_component();
  require_ca_utils();
  require_finger_cursor2();
  require_input_types();
  require_input_utils();
  require_keyboard();
  require_mouse();
  require_input_manager();
  require_input_manager_component();
  require_switch_hand_object();
  require_tracked_hand_draw_joint();
  require_tracked_hand_draw_all_joints();
  require_tracked_hand_draw_skin();
  require_gamepad_buttons();
  require_base_gamepad();
  require_universal_gamepad();
  require_gamepad_core();
  require_xr_gamepad_core();
  require_keyboard_gamepad_core();
  require_virtual_gamepad_gamepad_core();
  require_gamepad_mesh_animator();
  require_gamepad_manager();
  require_gamepad_utils();
  require_gamepad_control_scheme();
  require_virtual_gamepad();
  require_virtual_gamepad_component();
  require_virtual_gamepad_params();
  require_virtual_gamepad_virtual_button();
  require_virtual_gamepad_virtual_thumbstick();
  require_virtual_gamepad_icon();
  require_base_pose();
  require_hand_pose();
  require_head_pose();
  require_tracked_hand_joint_pose();
  require_tracked_hand_pose();
  require_set_player_height();
  require_set_hand_local_transform();
  require_set_head_local_transform();
  require_set_vr_head_local_transform();
  require_set_non_vr_head_local_transform();
  require_set_tracked_hand_joint_local_transform();
  require_copy_hand_transform();
  require_copy_head_transform();
  require_copy_player_transform();
  require_copy_player_pivot_transform();
  require_tool_types();
  require_tool_cursor();
  require_console_vr_widget_setup();
  require_console_vr_widget_ui();
  require_console_vr_widget();
  require_console_vr();
  require_console_vr_component();
  require_easy_object_tuner();
  require_easy_light_attenuation();
  require_easy_light_color();
  require_easy_mesh_color();
  require_easy_mesh_ambient_factor();
  require_easy_scale();
  require_easy_set_tune_target_child_number();
  require_easy_set_tune_target_grab();
  require_easy_transform();
  require_easy_tune_base_widget();
  require_easy_tune_base_widget_ui();
  require_easy_tune_base_widget_setup();
  require_easy_tune_bool_array_widget();
  require_easy_tune_bool_array_widget_ui();
  require_easy_tune_bool_array_widget_setup();
  require_easy_tune_bool_array_widget_selector();
  require_easy_tune_none_widget();
  require_easy_tune_none_widget_ui();
  require_easy_tune_none_widget_setup();
  require_easy_tune_number_array_widget();
  require_easy_tune_number_array_widget_ui();
  require_easy_tune_number_array_widget_setup();
  require_easy_tune_number_widget_selector();
  require_easy_tune_transform_widget();
  require_easy_tune_transform_widget_ui();
  require_easy_tune_transform_widget_setup();
  require_easy_tune_widget();
  require_easy_tune_widget_setup();
  require_easy_tune_variables();
  require_easy_tune_variable_types();
  require_easy_tune_globals();
  require_easy_tune_component();
  require_easy_tune_import_variables();
  require_widget_frame_setup();
  require_widget_frame_ui();
  require_widget_frame();
  require_locomotion_utils();
  require_player_head_manager();
  require_player_transform_manager();
  require_player_locomotion_rotate2();
  require_player_locomotion_movement();
  require_player_locomotion_smooth2();
  require_player_obscure_manager();
  require_player_locomotion();
  require_player_locomotion_component();
  require_player_locomotion_teleport_parable();
  require_player_locomotion_teleport_state();
  require_player_locomotion_teleport_detection_visualizer();
  require_player_locomotion_teleport_detection_state();
  require_player_locomotion_teleport_detection_state_visibility();
  require_player_locomotion_teleport_teleport_state();
  require_player_locomotion_teleport_teleport_blink_state();
  init_player_locomotion_teleport_teleport_shift_state();
  require_player_locomotion_teleport2();
  require_player_locomotion_cleaned();
  init_player_locomotion_smooth_cleaned();
  require_player_transform_manager_cleaned();
  require_labyroots_gateway();
  require_file_manager();
  require_maze();
  require_maze_item_type();
  require_mazeverse_maze();
  require_mazeverse_create_walls();
  require_mazeverse_add_elements();
  require_billboard_player();
  require_story();
  require_audio_load();
  require_deactivate_on_story();
  init_open_ggj();
  init_open_github();
  init_open_zesty();
  require_zesty_wonderland_sdk_compat();
  require_set_texture_after_delay();
  require_secret_zone_check();
  require_display_leaderboard();
  require_lr_ca_dummy_server();
  require_activate_if_wedding();
  require_deactivate_physx_if_far_from_player();
  require_follow_axe();
  require_fix_drifting();
  require_show_drifting();
  require_increase_floor_tile();
  require_render_closest_walls_first();
  require_send_all_events();
  require_sky_setter();
  require_lights_setter();
  init_wondermelon();
  require_spawn_floor();
  require_hide_if_pose_not_valid();
  init_transformation();
  require_stage_switch();
  require_mouth();
  require_swap_grab_hand();
  require_axe();
  require_fruit();
  require_root();
  require_root_wall();
  require_big_tree();
  require_human_tree();
  require_big_tree_die();
  require_test();
})();
/*! Bundled license information:

howler/dist/howler.js:
  (*!
   *  howler.js v2.2.4
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
  (*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.4
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
*/
//# sourceMappingURL=labyroots-bundle.js.map
